/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/index";
exports.ids = ["pages/index"];
exports.modules = {

/***/ "./node_modules/@fullcalendar/common/node_modules/tslib/tslib.es6.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@fullcalendar/common/node_modules/tslib/tslib.es6.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0NBQXNDLGtCQUFrQjtBQUNuRiwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlEQUFpRCxPQUFPO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELGNBQWM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ087QUFDUCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixvQ0FBb0M7QUFDckQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE1BQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHNCQUFzQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxrREFBa0QsUUFBUTtBQUMxRCx5Q0FBeUMsUUFBUTtBQUNqRCx5REFBeUQsUUFBUTtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsaUJBQWlCLHVGQUF1RixjQUFjO0FBQ3RILHVCQUF1QixnQ0FBZ0MscUNBQXFDLDJDQUEyQztBQUN2SSw0QkFBNEIsTUFBTSxpQkFBaUIsWUFBWTtBQUMvRCx1QkFBdUI7QUFDdkIsOEJBQThCO0FBQzlCLDZCQUE2QjtBQUM3Qiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUIsNkNBQTZDLFVBQVUsc0RBQXNELGNBQWM7QUFDNUksMEJBQTBCLDZCQUE2QixvQkFBb0IsZ0RBQWdELGtCQUFrQjtBQUM3STtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkdBQTJHLHVGQUF1RixjQUFjO0FBQ2hOLHVCQUF1Qiw4QkFBOEIsZ0RBQWdELHdEQUF3RDtBQUM3Siw2Q0FBNkMsc0NBQXNDLFVBQVUsbUJBQW1CLElBQUk7QUFDcEg7QUFDQTtBQUNPO0FBQ1AsaUNBQWlDLHVDQUF1QyxZQUFZLEtBQUssT0FBTztBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZDQUE2QztBQUM3QztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3R5cGVzY3JpcHQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanM/ZWQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcclxuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XHJcbiAgICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcclxuICAgIH1cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgZGVzYyk7XHJcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgb1trMl0gPSBtW2tdO1xyXG59KTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xyXG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcclxuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xyXG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xyXG4gICAgZm9yICh2YXIgcyA9IDAsIGkgPSAwLCBpbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBpbDsgaSsrKSBzICs9IGFyZ3VtZW50c1tpXS5sZW5ndGg7XHJcbiAgICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXHJcbiAgICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXHJcbiAgICAgICAgICAgIHJba10gPSBhW2pdO1xyXG4gICAgcmV0dXJuIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNHZW5lcmF0b3IodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpZiAoZ1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxyXG4gICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpW25dID0gb1tuXSA/IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ha2VUZW1wbGF0ZU9iamVjdChjb29rZWQsIHJhdykge1xyXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgIHJldHVybiBjb29rZWQ7XHJcbn07XHJcblxyXG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XHJcbn0pIDogZnVuY3Rpb24obywgdikge1xyXG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XHJcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xyXG4gICAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XHJcbiAgICBpZiAocmVjZWl2ZXIgPT09IG51bGwgfHwgKHR5cGVvZiByZWNlaXZlciAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgcmVjZWl2ZXIgIT09IFwiZnVuY3Rpb25cIikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgdXNlICdpbicgb3BlcmF0b3Igb24gbm9uLW9iamVjdFwiKTtcclxuICAgIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/node_modules/tslib/tslib.es6.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/node_modules/tslib/tslib.es6.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL25vZGVfbW9kdWxlcy90c2xpYi90c2xpYi5lczYuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDZDQUE2QyxRQUFRO0FBQ3JEO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0NBQW9DO0FBQ3JEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZCQUE2QixzQkFBc0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELFFBQVE7QUFDMUQseUNBQXlDLFFBQVE7QUFDakQseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGlCQUFpQix1RkFBdUYsY0FBYztBQUN0SCx1QkFBdUIsZ0NBQWdDLHFDQUFxQywyQ0FBMkM7QUFDdkksNEJBQTRCLE1BQU0saUJBQWlCLFlBQVk7QUFDL0QsdUJBQXVCO0FBQ3ZCLDhCQUE4QjtBQUM5Qiw2QkFBNkI7QUFDN0IsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaUJBQWlCLDZDQUE2QyxVQUFVLHNEQUFzRCxjQUFjO0FBQzVJLDBCQUEwQiw2QkFBNkIsb0JBQW9CLGdEQUFnRCxrQkFBa0I7QUFDN0k7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDJHQUEyRyx1RkFBdUYsY0FBYztBQUNoTix1QkFBdUIsOEJBQThCLGdEQUFnRCx3REFBd0Q7QUFDN0osNkNBQTZDLHNDQUFzQyxVQUFVLG1CQUFtQixJQUFJO0FBQ3BIO0FBQ0E7QUFDTztBQUNQLGlDQUFpQyx1Q0FBdUMsWUFBWSxLQUFLLE9BQU87QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2RheWdyaWQvbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5qcz80ZmQ4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xyXG4gICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XHJcbiAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG4gICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XHJcbiAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XHJcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcclxuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XHJcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19wYXJhbShwYXJhbUluZGV4LCBkZWNvcmF0b3IpIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xyXG4gICAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcclxuICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xyXG4gICAgdmFyIGksIHA7XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogbiA9PT0gXCJyZXR1cm5cIiB9IDogZiA/IGYodikgOiB2OyB9IDogZjsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSwgaTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogKG8gPSB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCksIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpKTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShyZXNvbHZlLCByZWplY3QsIGQsIHYpIHsgUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZnVuY3Rpb24odikgeyByZXNvbHZlKHsgdmFsdWU6IHYsIGRvbmU6IGQgfSk7IH0sIHJlamVjdCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xyXG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcclxuICAgIHZhciByZXN1bHQgPSB7fTtcclxuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcclxuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcclxuICAgIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xyXG4gICAgcmV0dXJuIHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgPT09IHN0YXRlIDogc3RhdGUuaGFzKHJlY2VpdmVyKTtcclxufVxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/node_modules/tslib/tslib.es6.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@fullcalendar/react/node_modules/tslib/tslib.es6.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"__assign\": () => (/* binding */ __assign),\n/* harmony export */   \"__asyncDelegator\": () => (/* binding */ __asyncDelegator),\n/* harmony export */   \"__asyncGenerator\": () => (/* binding */ __asyncGenerator),\n/* harmony export */   \"__asyncValues\": () => (/* binding */ __asyncValues),\n/* harmony export */   \"__await\": () => (/* binding */ __await),\n/* harmony export */   \"__awaiter\": () => (/* binding */ __awaiter),\n/* harmony export */   \"__classPrivateFieldGet\": () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   \"__classPrivateFieldIn\": () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   \"__classPrivateFieldSet\": () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   \"__createBinding\": () => (/* binding */ __createBinding),\n/* harmony export */   \"__decorate\": () => (/* binding */ __decorate),\n/* harmony export */   \"__exportStar\": () => (/* binding */ __exportStar),\n/* harmony export */   \"__extends\": () => (/* binding */ __extends),\n/* harmony export */   \"__generator\": () => (/* binding */ __generator),\n/* harmony export */   \"__importDefault\": () => (/* binding */ __importDefault),\n/* harmony export */   \"__importStar\": () => (/* binding */ __importStar),\n/* harmony export */   \"__makeTemplateObject\": () => (/* binding */ __makeTemplateObject),\n/* harmony export */   \"__metadata\": () => (/* binding */ __metadata),\n/* harmony export */   \"__param\": () => (/* binding */ __param),\n/* harmony export */   \"__read\": () => (/* binding */ __read),\n/* harmony export */   \"__rest\": () => (/* binding */ __rest),\n/* harmony export */   \"__spread\": () => (/* binding */ __spread),\n/* harmony export */   \"__spreadArray\": () => (/* binding */ __spreadArray),\n/* harmony export */   \"__spreadArrays\": () => (/* binding */ __spreadArrays),\n/* harmony export */   \"__values\": () => (/* binding */ __values)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nfunction __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ25GLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsaURBQWlELE9BQU87QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsY0FBYztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSw2Q0FBNkMsUUFBUTtBQUNyRDtBQUNBO0FBQ0E7QUFDTztBQUNQLG9DQUFvQztBQUNwQztBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQLGNBQWMsNkJBQTZCLDBCQUEwQixjQUFjLHFCQUFxQjtBQUN4RyxpQkFBaUIsb0RBQW9ELHFFQUFxRSxjQUFjO0FBQ3hKLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDLG1DQUFtQyxTQUFTO0FBQzVDLG1DQUFtQyxXQUFXLFVBQVU7QUFDeEQsMENBQTBDLGNBQWM7QUFDeEQ7QUFDQSw4R0FBOEcsT0FBTztBQUNySCxpRkFBaUYsaUJBQWlCO0FBQ2xHLHlEQUF5RCxnQkFBZ0IsUUFBUTtBQUNqRiwrQ0FBK0MsZ0JBQWdCLGdCQUFnQjtBQUMvRTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0EsVUFBVSxZQUFZLGFBQWEsU0FBUyxVQUFVO0FBQ3RELG9DQUFvQyxTQUFTO0FBQzdDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2QkFBNkIsc0JBQXNCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGtEQUFrRCxRQUFRO0FBQzFELHlDQUF5QyxRQUFRO0FBQ2pELHlEQUF5RCxRQUFRO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxpQkFBaUIsdUZBQXVGLGNBQWM7QUFDdEgsdUJBQXVCLGdDQUFnQyxxQ0FBcUMsMkNBQTJDO0FBQ3ZJLDRCQUE0QixNQUFNLGlCQUFpQixZQUFZO0FBQy9ELHVCQUF1QjtBQUN2Qiw4QkFBOEI7QUFDOUIsNkJBQTZCO0FBQzdCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQixnREFBZ0Qsa0JBQWtCO0FBQzdJO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzPzRiOWYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcclxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XHJcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcclxuICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xyXG4gICAgX19hc3NpZ24gPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uIF9fYXNzaWduKHQpIHtcclxuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcclxuICAgICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApKSB0W3BdID0gc1twXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQsIGtleSkgeyBkZWNvcmF0b3IodGFyZ2V0LCBrZXksIHBhcmFtSW5kZXgpOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QubWV0YWRhdGEgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIFJlZmxlY3QubWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobSwgayk7XHJcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xyXG4gICAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XHJcbiAgICB9XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcclxuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgcCkpIF9fY3JlYXRlQmluZGluZyhvLCBtLCBwKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcclxuICAgIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxyXG4gICAgICAgIGFyID0gYXIuY29uY2F0KF9fcmVhZChhcmd1bWVudHNbaV0pKTtcclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5cygpIHtcclxuICAgIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xyXG4gICAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxyXG4gICAgICAgIGZvciAodmFyIGEgPSBhcmd1bWVudHNbaV0sIGogPSAwLCBqbCA9IGEubGVuZ3RoOyBqIDwgamw7IGorKywgaysrKVxyXG4gICAgICAgICAgICByW2tdID0gYVtqXTtcclxuICAgIHJldHVybiByO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEluKHN0YXRlLCByZWNlaXZlcikge1xyXG4gICAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XHJcbiAgICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/node_modules/tslib/tslib.es6.js\n");

/***/ }),

/***/ "./styles/_app.module.css":
/*!********************************!*\
  !*** ./styles/_app.module.css ***!
  \********************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"flex\": \"_app_flex__G5LVC\",\n\t\"sub\": \"_app_sub__PZGBM\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvX2FwcC5tb2R1bGUuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3N0eWxlcy9fYXBwLm1vZHVsZS5jc3M/NDE0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJmbGV4XCI6IFwiX2FwcF9mbGV4X19HNUxWQ1wiLFxuXHRcInN1YlwiOiBcIl9hcHBfc3ViX19QWkdCTVwiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/_app.module.css\n");

/***/ }),

/***/ "./styles/calendar.module.css":
/*!************************************!*\
  !*** ./styles/calendar.module.css ***!
  \************************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"calendar\": \"calendar_calendar__A0_bd\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvY2FsZW5kYXIubW9kdWxlLmNzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3R5cGVzY3JpcHQtcG9ydGZvbGlvLy4vc3R5bGVzL2NhbGVuZGFyLm1vZHVsZS5jc3M/Nzk0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBFeHBvcnRzXG5tb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJjYWxlbmRhclwiOiBcImNhbGVuZGFyX2NhbGVuZGFyX19BMF9iZFwiXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./styles/calendar.module.css\n");

/***/ }),

/***/ "./styles/friend.module.css":
/*!**********************************!*\
  !*** ./styles/friend.module.css ***!
  \**********************************/
/***/ ((module) => {

eval("// Exports\nmodule.exports = {\n\t\"friend\": \"friend_friend__2SfJz\"\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdHlsZXMvZnJpZW5kLm1vZHVsZS5jc3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3N0eWxlcy9mcmllbmQubW9kdWxlLmNzcz9mZjUzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0ge1xuXHRcImZyaWVuZFwiOiBcImZyaWVuZF9mcmllbmRfXzJTZkp6XCJcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./styles/friend.module.css\n");

/***/ }),

/***/ "./src/Prisma/Friend.tsx":
/*!*******************************!*\
  !*** ./src/Prisma/Friend.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CREATE_FRIEND\": () => (/* binding */ CREATE_FRIEND),\n/* harmony export */   \"DELETE_FRIEND\": () => (/* binding */ DELETE_FRIEND),\n/* harmony export */   \"GET_FRIENDS\": () => (/* binding */ GET_FRIENDS)\n/* harmony export */ });\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @apollo/client */ \"@apollo/client\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_0__);\n\nconst GET_FRIENDS = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  query {\n    friends {\n      id\n      name\n      relation\n    }\n  }\n`;\nconst CREATE_FRIEND = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  mutation FriendCreate($name: String!, $relation: String!) {\n    friendCreate(name: $name, relation: $relation) {\n      userErrors {\n        message\n      }\n      friend {\n        id\n        name\n        relation\n      }\n    }\n  }\n`;\nconst DELETE_FRIEND = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  mutation DeleteFriend($id: Int!) {\n    friendDelete(id: $id) {\n      userErrors {\n        message\n      }\n      friend {\n        id\n        name\n        relation\n      }\n    }\n  }\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUHJpc21hL0ZyaWVuZC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUM7QUFFOUIsTUFBTUMsY0FBY0QsK0NBQUcsQ0FBQzs7Ozs7Ozs7QUFRL0IsQ0FBQyxDQUFDO0FBRUssTUFBTUUsZ0JBQWdCRiwrQ0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7O0FBYWpDLENBQUMsQ0FBQztBQUVLLE1BQU1HLGdCQUFnQkgsK0NBQUcsQ0FBQzs7Ozs7Ozs7Ozs7OztBQWFqQyxDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3NyYy9QcmlzbWEvRnJpZW5kLnRzeD9iMDA5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdxbCB9IGZyb20gXCJAYXBvbGxvL2NsaWVudFwiO1xuXG5leHBvcnQgY29uc3QgR0VUX0ZSSUVORFMgPSBncWxgXG4gIHF1ZXJ5IHtcbiAgICBmcmllbmRzIHtcbiAgICAgIGlkXG4gICAgICBuYW1lXG4gICAgICByZWxhdGlvblxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IENSRUFURV9GUklFTkQgPSBncWxgXG4gIG11dGF0aW9uIEZyaWVuZENyZWF0ZSgkbmFtZTogU3RyaW5nISwgJHJlbGF0aW9uOiBTdHJpbmchKSB7XG4gICAgZnJpZW5kQ3JlYXRlKG5hbWU6ICRuYW1lLCByZWxhdGlvbjogJHJlbGF0aW9uKSB7XG4gICAgICB1c2VyRXJyb3JzIHtcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfVxuICAgICAgZnJpZW5kIHtcbiAgICAgICAgaWRcbiAgICAgICAgbmFtZVxuICAgICAgICByZWxhdGlvblxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcblxuZXhwb3J0IGNvbnN0IERFTEVURV9GUklFTkQgPSBncWxgXG4gIG11dGF0aW9uIERlbGV0ZUZyaWVuZCgkaWQ6IEludCEpIHtcbiAgICBmcmllbmREZWxldGUoaWQ6ICRpZCkge1xuICAgICAgdXNlckVycm9ycyB7XG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH1cbiAgICAgIGZyaWVuZCB7XG4gICAgICAgIGlkXG4gICAgICAgIG5hbWVcbiAgICAgICAgcmVsYXRpb25cbiAgICAgIH1cbiAgICB9XG4gIH1cbmA7XG4iXSwibmFtZXMiOlsiZ3FsIiwiR0VUX0ZSSUVORFMiLCJDUkVBVEVfRlJJRU5EIiwiREVMRVRFX0ZSSUVORCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/Prisma/Friend.tsx\n");

/***/ }),

/***/ "./src/Prisma/Post.tsx":
/*!*****************************!*\
  !*** ./src/Prisma/Post.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"CREATE_POST\": () => (/* binding */ CREATE_POST),\n/* harmony export */   \"DELETE_POST\": () => (/* binding */ DELETE_POST),\n/* harmony export */   \"GET_POSTS\": () => (/* binding */ GET_POSTS),\n/* harmony export */   \"UPDATE_POST\": () => (/* binding */ UPDATE_POST)\n/* harmony export */ });\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @apollo/client */ \"@apollo/client\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_0__);\n\nconst GET_POSTS = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  query {\n    posts {\n      length\n      title\n      content\n      date\n      relation\n    }\n  }\n`;\nconst CREATE_POST = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  mutation CreatePost(\n    $title: String!\n    $date: String!\n    $length: Int!\n    $content: String!\n    $relation: String!\n  ) {\n    postCreate(\n      title: $title\n      date: $date\n      length: $length\n      content: $content\n      relation: $relation\n    ) {\n      userErrors {\n        message\n      }\n      post {\n        title\n        date\n        length\n        content\n        relation\n      }\n    }\n  }\n`;\nconst UPDATE_POST = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  mutation UpdatePost(\n    $lengthId: Int!\n    $title: String\n    $content: String\n    $relation: String\n  ) {\n    postUpdate(\n      lengthId: $lengthId\n      title: $title\n      content: $content\n      relation: $relation\n    ) {\n      userErrors {\n        message\n      }\n      post {\n        content\n        title\n        content\n        date\n        relation\n      }\n    }\n  }\n`;\nconst DELETE_POST = _apollo_client__WEBPACK_IMPORTED_MODULE_0__.gql`\n  mutation PostDelete($lengthId: Int!) {\n    postDelete(lengthId: $lengthId) {\n      userErrors {\n        message\n      }\n      post {\n        length\n      }\n    }\n  }\n`;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvUHJpc21hL1Bvc3QudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFxQztBQUU5QixNQUFNQyxZQUFZRCwrQ0FBRyxDQUFDOzs7Ozs7Ozs7O0FBVTdCLENBQUMsQ0FBQztBQUNLLE1BQU1FLGNBQWNGLCtDQUFHLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTJCL0IsQ0FBQyxDQUFDO0FBQ0ssTUFBTUcsY0FBY0gsK0NBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCL0IsQ0FBQyxDQUFDO0FBQ0ssTUFBTUksY0FBY0osK0NBQUcsQ0FBQzs7Ozs7Ozs7Ozs7QUFXL0IsQ0FBQyxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9zcmMvUHJpc21hL1Bvc3QudHN4PzlhMWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ3FsIH0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5cbmV4cG9ydCBjb25zdCBHRVRfUE9TVFMgPSBncWxgXG4gIHF1ZXJ5IHtcbiAgICBwb3N0cyB7XG4gICAgICBsZW5ndGhcbiAgICAgIHRpdGxlXG4gICAgICBjb250ZW50XG4gICAgICBkYXRlXG4gICAgICByZWxhdGlvblxuICAgIH1cbiAgfVxuYDtcbmV4cG9ydCBjb25zdCBDUkVBVEVfUE9TVCA9IGdxbGBcbiAgbXV0YXRpb24gQ3JlYXRlUG9zdChcbiAgICAkdGl0bGU6IFN0cmluZyFcbiAgICAkZGF0ZTogU3RyaW5nIVxuICAgICRsZW5ndGg6IEludCFcbiAgICAkY29udGVudDogU3RyaW5nIVxuICAgICRyZWxhdGlvbjogU3RyaW5nIVxuICApIHtcbiAgICBwb3N0Q3JlYXRlKFxuICAgICAgdGl0bGU6ICR0aXRsZVxuICAgICAgZGF0ZTogJGRhdGVcbiAgICAgIGxlbmd0aDogJGxlbmd0aFxuICAgICAgY29udGVudDogJGNvbnRlbnRcbiAgICAgIHJlbGF0aW9uOiAkcmVsYXRpb25cbiAgICApIHtcbiAgICAgIHVzZXJFcnJvcnMge1xuICAgICAgICBtZXNzYWdlXG4gICAgICB9XG4gICAgICBwb3N0IHtcbiAgICAgICAgdGl0bGVcbiAgICAgICAgZGF0ZVxuICAgICAgICBsZW5ndGhcbiAgICAgICAgY29udGVudFxuICAgICAgICByZWxhdGlvblxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcbmV4cG9ydCBjb25zdCBVUERBVEVfUE9TVCA9IGdxbGBcbiAgbXV0YXRpb24gVXBkYXRlUG9zdChcbiAgICAkbGVuZ3RoSWQ6IEludCFcbiAgICAkdGl0bGU6IFN0cmluZ1xuICAgICRjb250ZW50OiBTdHJpbmdcbiAgICAkcmVsYXRpb246IFN0cmluZ1xuICApIHtcbiAgICBwb3N0VXBkYXRlKFxuICAgICAgbGVuZ3RoSWQ6ICRsZW5ndGhJZFxuICAgICAgdGl0bGU6ICR0aXRsZVxuICAgICAgY29udGVudDogJGNvbnRlbnRcbiAgICAgIHJlbGF0aW9uOiAkcmVsYXRpb25cbiAgICApIHtcbiAgICAgIHVzZXJFcnJvcnMge1xuICAgICAgICBtZXNzYWdlXG4gICAgICB9XG4gICAgICBwb3N0IHtcbiAgICAgICAgY29udGVudFxuICAgICAgICB0aXRsZVxuICAgICAgICBjb250ZW50XG4gICAgICAgIGRhdGVcbiAgICAgICAgcmVsYXRpb25cbiAgICAgIH1cbiAgICB9XG4gIH1cbmA7XG5leHBvcnQgY29uc3QgREVMRVRFX1BPU1QgPSBncWxgXG4gIG11dGF0aW9uIFBvc3REZWxldGUoJGxlbmd0aElkOiBJbnQhKSB7XG4gICAgcG9zdERlbGV0ZShsZW5ndGhJZDogJGxlbmd0aElkKSB7XG4gICAgICB1c2VyRXJyb3JzIHtcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfVxuICAgICAgcG9zdCB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfVxuICAgIH1cbiAgfVxuYDtcbiJdLCJuYW1lcyI6WyJncWwiLCJHRVRfUE9TVFMiLCJDUkVBVEVfUE9TVCIsIlVQREFURV9QT1NUIiwiREVMRVRFX1BPU1QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/Prisma/Post.tsx\n");

/***/ }),

/***/ "./src/components/Calendar/EventLists.tsx":
/*!************************************************!*\
  !*** ./src/components/Calendar/EventLists.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @apollo/client */ \"@apollo/client\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Prisma_Post__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../Prisma/Post */ \"./src/Prisma/Post.tsx\");\n/* harmony import */ var _function_Reload__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../function/Reload */ \"./src/function/Reload.tsx\");\n\n\n\n\n\n\nconst EventLists = (props)=>{\n    const { title , content , date , id , relation  } = props;\n    const [newTitle, setNewTitle] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(title);\n    const [newContent, setNewContent] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(content);\n    const [newRelation, setNewRelation] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(relation);\n    const [edit, setEdit] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [open, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    const [UpdatePost] = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_1__.useMutation)(_Prisma_Post__WEBPACK_IMPORTED_MODULE_4__.UPDATE_POST);\n    const [DeletePost] = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_1__.useMutation)(_Prisma_Post__WEBPACK_IMPORTED_MODULE_4__.DELETE_POST);\n    function editHandler() {\n        setEdit(!edit);\n        if (edit) {\n            UpdatePost({\n                variables: {\n                    lengthId: id,\n                    title: newTitle,\n                    content: newContent,\n                    relation: newRelation\n                }\n            });\n            setTimeout(_function_Reload__WEBPACK_IMPORTED_MODULE_5__.doReload, 1000);\n        }\n    }\n    function openHandler() {\n        setOpen(!open);\n    }\n    function deleteHandler() {\n        DeletePost({\n            variables: {\n                lengthId: id\n            }\n        });\n        setTimeout(_function_Reload__WEBPACK_IMPORTED_MODULE_5__.doReload, 1000);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            !edit && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            newTitle,\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                onClick: openHandler,\n                                children: \"Content\"\n                            }, void 0, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                                lineNumber: 56,\n                                columnNumber: 13\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                                onClick: editHandler,\n                                children: \"Edit\"\n                            }, void 0, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 13\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 54,\n                        columnNumber: 11\n                    }, undefined),\n                    open && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: newContent\n                            }, void 0, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                                lineNumber: 61,\n                                columnNumber: 15\n                            }, undefined),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: newRelation\n                            }, void 0, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                                lineNumber: 62,\n                                columnNumber: 15\n                            }, undefined)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 60,\n                        columnNumber: 13\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                lineNumber: 53,\n                columnNumber: 9\n            }, undefined),\n            edit && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        value: newTitle,\n                        onChange: (e)=>setNewTitle(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 69,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        value: newContent,\n                        onChange: (e)=>setNewContent(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 74,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                        type: \"text\",\n                        value: newRelation,\n                        onChange: (e)=>setNewRelation(e.target.value)\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 79,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                        onClick: editHandler,\n                        children: \"finish\"\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 84,\n                        columnNumber: 11\n                    }, undefined),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_2__.Button, {\n                        onClick: deleteHandler,\n                        children: \"DELETE\"\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                        lineNumber: 85,\n                        columnNumber: 11\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n                lineNumber: 68,\n                columnNumber: 9\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/youta/type-front/src/components/Calendar/EventLists.tsx\",\n        lineNumber: 51,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventLists);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9DYWxlbmRhci9FdmVudExpc3RzLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQTZDO0FBQ047QUFDQztBQUNxQjtBQUNaO0FBU2pELE1BQU1PLGFBQWEsQ0FBQ0MsUUFBaUI7SUFDbkMsTUFBTSxFQUFFQyxNQUFLLEVBQUVDLFFBQU8sRUFBRUMsS0FBSSxFQUFFQyxHQUFFLEVBQUVDLFNBQVEsRUFBRSxHQUFHTDtJQUMvQyxNQUFNLENBQUNNLFVBQVVDLFlBQVksR0FBR1osK0NBQVFBLENBQUNNO0lBQ3pDLE1BQU0sQ0FBQ08sWUFBWUMsY0FBYyxHQUFHZCwrQ0FBUUEsQ0FBQ087SUFDN0MsTUFBTSxDQUFDUSxhQUFhQyxlQUFlLEdBQUdoQiwrQ0FBUUEsQ0FBQ1U7SUFDL0MsTUFBTSxDQUFDTyxNQUFNQyxRQUFRLEdBQUdsQiwrQ0FBUUEsQ0FBQyxLQUFLO0lBQ3RDLE1BQU0sQ0FBQ21CLE1BQU1DLFFBQVEsR0FBR3BCLCtDQUFRQSxDQUFDLEtBQUs7SUFDdEMsTUFBTSxDQUFDcUIsV0FBVyxHQUFHeEIsMkRBQVdBLENBQUNJLHFEQUFXQTtJQUM1QyxNQUFNLENBQUNxQixXQUFXLEdBQUd6QiwyREFBV0EsQ0FBQ0sscURBQVdBO0lBRTVDLFNBQVNxQixjQUFjO1FBQ3JCTCxRQUFRLENBQUNEO1FBQ1QsSUFBSUEsTUFBTTtZQUNSSSxXQUFXO2dCQUNURyxXQUFXO29CQUNUQyxVQUFVaEI7b0JBQ1ZILE9BQU9LO29CQUNQSixTQUFTTTtvQkFDVEgsVUFBVUs7Z0JBQ1o7WUFDRjtZQUNBVyxXQUFXdkIsc0RBQVFBLEVBQUU7UUFDdkIsQ0FBQztJQUNIO0lBQ0EsU0FBU3dCLGNBQWM7UUFDckJQLFFBQVEsQ0FBQ0Q7SUFDWDtJQUVBLFNBQVNTLGdCQUFnQjtRQUN2Qk4sV0FBVztZQUNURSxXQUFXO2dCQUNUQyxVQUFVaEI7WUFDWjtRQUNGO1FBQ0FpQixXQUFXdkIsc0RBQVFBLEVBQUU7SUFDdkI7SUFDQSxxQkFDRSw4REFBQzBCOztZQUNFLENBQUNaLHNCQUNBLDhEQUFDWTs7a0NBQ0MsOERBQUNBOzs0QkFDRWxCOzBDQUNELDhEQUFDYixpREFBTUE7Z0NBQUNnQyxTQUFTSDswQ0FBYTs7Ozs7OzBDQUM5Qiw4REFBQzdCLGlEQUFNQTtnQ0FBQ2dDLFNBQVNQOzBDQUFhOzs7Ozs7Ozs7Ozs7b0JBRS9CSixzQkFDQyw4REFBQ1U7OzBDQUNDLDhEQUFDQTswQ0FBS2hCOzs7Ozs7MENBQ04sOERBQUNnQjswQ0FBS2Q7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQUtiRSxzQkFDQyw4REFBQ2M7O2tDQUNDLDhEQUFDQzt3QkFDQ0MsTUFBSzt3QkFDTEMsT0FBT3ZCO3dCQUNQd0IsVUFBVSxDQUFDQyxJQUFNeEIsWUFBWXdCLEVBQUVDLE1BQU0sQ0FBQ0gsS0FBSzs7Ozs7O2tDQUU3Qyw4REFBQ0Y7d0JBQ0NDLE1BQUs7d0JBQ0xDLE9BQU9yQjt3QkFDUHNCLFVBQVUsQ0FBQ0MsSUFBTXRCLGNBQWNzQixFQUFFQyxNQUFNLENBQUNILEtBQUs7Ozs7OztrQ0FFL0MsOERBQUNGO3dCQUNDQyxNQUFLO3dCQUNMQyxPQUFPbkI7d0JBQ1BvQixVQUFVLENBQUNDLElBQU1wQixlQUFlb0IsRUFBRUMsTUFBTSxDQUFDSCxLQUFLOzs7Ozs7a0NBRWhELDhEQUFDcEMsaURBQU1BO3dCQUFDZ0MsU0FBU1A7a0NBQWE7Ozs7OztrQ0FDOUIsOERBQUN6QixpREFBTUE7d0JBQUNnQyxTQUFTRjtrQ0FBZTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBSzFDO0FBRUEsaUVBQWV4QixVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9zcmMvY29tcG9uZW50cy9DYWxlbmRhci9FdmVudExpc3RzLnRzeD8xNjczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZU11dGF0aW9uIH0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5pbXBvcnQgeyBCdXR0b24gfSBmcm9tIFwiQG11aS9tYXRlcmlhbFwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBVUERBVEVfUE9TVCwgREVMRVRFX1BPU1QgfSBmcm9tIFwiLi4vLi4vUHJpc21hL1Bvc3RcIjtcbmltcG9ydCB7IGRvUmVsb2FkIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9uL1JlbG9hZFwiO1xuXG5pbnRlcmZhY2UgUHJvcHMge1xuICBpZDogbnVtYmVyO1xuICByZWxhdGlvbjogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICB0aXRsZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICBjb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gIGRhdGU6IHN0cmluZyB8IHVuZGVmaW5lZDtcbn1cbmNvbnN0IEV2ZW50TGlzdHMgPSAocHJvcHM6IFByb3BzKSA9PiB7XG4gIGNvbnN0IHsgdGl0bGUsIGNvbnRlbnQsIGRhdGUsIGlkLCByZWxhdGlvbiB9ID0gcHJvcHM7XG4gIGNvbnN0IFtuZXdUaXRsZSwgc2V0TmV3VGl0bGVdID0gdXNlU3RhdGUodGl0bGUpO1xuICBjb25zdCBbbmV3Q29udGVudCwgc2V0TmV3Q29udGVudF0gPSB1c2VTdGF0ZShjb250ZW50KTtcbiAgY29uc3QgW25ld1JlbGF0aW9uLCBzZXROZXdSZWxhdGlvbl0gPSB1c2VTdGF0ZShyZWxhdGlvbik7XG4gIGNvbnN0IFtlZGl0LCBzZXRFZGl0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbVXBkYXRlUG9zdF0gPSB1c2VNdXRhdGlvbihVUERBVEVfUE9TVCk7XG4gIGNvbnN0IFtEZWxldGVQb3N0XSA9IHVzZU11dGF0aW9uKERFTEVURV9QT1NUKTtcblxuICBmdW5jdGlvbiBlZGl0SGFuZGxlcigpIHtcbiAgICBzZXRFZGl0KCFlZGl0KTtcbiAgICBpZiAoZWRpdCkge1xuICAgICAgVXBkYXRlUG9zdCh7XG4gICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgIGxlbmd0aElkOiBpZCxcbiAgICAgICAgICB0aXRsZTogbmV3VGl0bGUsXG4gICAgICAgICAgY29udGVudDogbmV3Q29udGVudCxcbiAgICAgICAgICByZWxhdGlvbjogbmV3UmVsYXRpb24sXG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICAgIHNldFRpbWVvdXQoZG9SZWxvYWQsIDEwMDApO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBvcGVuSGFuZGxlcigpIHtcbiAgICBzZXRPcGVuKCFvcGVuKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUhhbmRsZXIoKSB7XG4gICAgRGVsZXRlUG9zdCh7XG4gICAgICB2YXJpYWJsZXM6IHtcbiAgICAgICAgbGVuZ3RoSWQ6IGlkLFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBzZXRUaW1lb3V0KGRvUmVsb2FkLCAxMDAwKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICB7IWVkaXQgJiYgKFxuICAgICAgICA8ZGl2PlxuICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICB7bmV3VGl0bGV9XG4gICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e29wZW5IYW5kbGVyfT5Db250ZW50PC9CdXR0b24+XG4gICAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2VkaXRIYW5kbGVyfT5FZGl0PC9CdXR0b24+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAge29wZW4gJiYgKFxuICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgPGRpdj57bmV3Q29udGVudH08L2Rpdj5cbiAgICAgICAgICAgICAgPGRpdj57bmV3UmVsYXRpb259PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICApfVxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICB7ZWRpdCAmJiAoXG4gICAgICAgIDxmb3JtPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWU9e25ld1RpdGxlfVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXROZXdUaXRsZShlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8aW5wdXRcbiAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgIHZhbHVlPXtuZXdDb250ZW50fVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXROZXdDb250ZW50KGUudGFyZ2V0LnZhbHVlKX1cbiAgICAgICAgICAvPlxuICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgdmFsdWU9e25ld1JlbGF0aW9ufVxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXROZXdSZWxhdGlvbihlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2VkaXRIYW5kbGVyfT5maW5pc2g8L0J1dHRvbj5cbiAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2RlbGV0ZUhhbmRsZXJ9PkRFTEVURTwvQnV0dG9uPlxuICAgICAgICA8L2Zvcm0+XG4gICAgICApfVxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRXZlbnRMaXN0cztcbiJdLCJuYW1lcyI6WyJ1c2VNdXRhdGlvbiIsIkJ1dHRvbiIsIlJlYWN0IiwidXNlU3RhdGUiLCJVUERBVEVfUE9TVCIsIkRFTEVURV9QT1NUIiwiZG9SZWxvYWQiLCJFdmVudExpc3RzIiwicHJvcHMiLCJ0aXRsZSIsImNvbnRlbnQiLCJkYXRlIiwiaWQiLCJyZWxhdGlvbiIsIm5ld1RpdGxlIiwic2V0TmV3VGl0bGUiLCJuZXdDb250ZW50Iiwic2V0TmV3Q29udGVudCIsIm5ld1JlbGF0aW9uIiwic2V0TmV3UmVsYXRpb24iLCJlZGl0Iiwic2V0RWRpdCIsIm9wZW4iLCJzZXRPcGVuIiwiVXBkYXRlUG9zdCIsIkRlbGV0ZVBvc3QiLCJlZGl0SGFuZGxlciIsInZhcmlhYmxlcyIsImxlbmd0aElkIiwic2V0VGltZW91dCIsIm9wZW5IYW5kbGVyIiwiZGVsZXRlSGFuZGxlciIsImRpdiIsIm9uQ2xpY2siLCJmb3JtIiwiaW5wdXQiLCJ0eXBlIiwidmFsdWUiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Calendar/EventLists.tsx\n");

/***/ }),

/***/ "./src/components/Calendar/calendar.tsx":
/*!**********************************************!*\
  !*** ./src/components/Calendar/calendar.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _EventLists__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EventLists */ \"./src/components/Calendar/EventLists.tsx\");\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @fullcalendar/react */ \"./node_modules/@fullcalendar/react/dist/main.cjs.js\");\n/* harmony import */ var _fullcalendar_react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @fullcalendar/daygrid */ \"./node_modules/@fullcalendar/daygrid/main.cjs.js\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @fullcalendar/interaction */ \"@fullcalendar/interaction\");\n/* harmony import */ var _fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mui/system */ \"@mui/system\");\n/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_mui_system__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @apollo/client */ \"@apollo/client\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_8__);\n/* harmony import */ var _Prisma_Post__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../Prisma/Post */ \"./src/Prisma/Post.tsx\");\n/* harmony import */ var _styles_calendar_module_css__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../../styles/calendar.module.css */ \"./styles/calendar.module.css\");\n/* harmony import */ var _styles_calendar_module_css__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_styles_calendar_module_css__WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var _function_Reload__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../function/Reload */ \"./src/function/Reload.tsx\");\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst Calendar = ()=>{\n    const [eventTitle, setEventTitle] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [eventContent, setEventContent] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [open, setOpen] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [eventDay, setEventDay] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    const [alert, setAlert] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [errorAlert, setErrorAlert] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const { data , error , loading  } = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_8__.useQuery)(_Prisma_Post__WEBPACK_IMPORTED_MODULE_9__.GET_POSTS);\n    const [CreatePost] = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_8__.useMutation)(_Prisma_Post__WEBPACK_IMPORTED_MODULE_9__.CREATE_POST);\n    const [eventRelation, setEventRelation] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (alert || errorAlert) {\n            setTimeout(()=>{\n                if (alert) {\n                    setAlert(false);\n                } else {\n                    setErrorAlert(false);\n                }\n            }, 3000);\n        }\n    });\n    if (error) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"Error \"\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n        lineNumber: 42,\n        columnNumber: 21\n    }, undefined);\n    if (loading) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.CircularProgress, {}, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n        lineNumber: 43,\n        columnNumber: 23\n    }, undefined);\n    const { posts  } = data;\n    const handleDateClick = (arg)=>{\n        setEventDay(arg.dateStr);\n    };\n    function titleChange(e) {\n        setEventTitle(e.target.value);\n    }\n    function contentChange(e) {\n        setEventContent(e.target.value);\n    }\n    function handleModal() {\n        setOpen(!open);\n    }\n    function submitHandler(e) {\n        e.preventDefault();\n        const isValid = eventDay.length && eventTitle.length >= 1;\n        if (isValid) {\n            CreatePost({\n                variables: {\n                    title: eventTitle,\n                    content: eventContent,\n                    date: eventDay,\n                    relation: eventRelation,\n                    length: 1 + Math.floor(Math.random() * 100000)\n                }\n            });\n            setAlert(true);\n        } else {\n            setErrorAlert(true);\n        }\n        setEventContent(\"\");\n        setEventTitle(\"\");\n        setOpen(false);\n        setTimeout(_function_Reload__WEBPACK_IMPORTED_MODULE_10__.doReload, 1000);\n    }\n    function alertClose() {\n        setAlert(false);\n        setErrorAlert(false);\n    }\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: (_styles_calendar_module_css__WEBPACK_IMPORTED_MODULE_11___default().calendar),\n        children: [\n            alert && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Alert, {\n                onClose: ()=>{\n                    alertClose();\n                },\n                severity: \"success\",\n                children: \"This is a success alert — check it out!\"\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                lineNumber: 91,\n                columnNumber: 9\n            }, undefined),\n            errorAlert && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Alert, {\n                onClose: ()=>{\n                    alertClose();\n                },\n                severity: \"error\",\n                children: \"This is a success alert — check it out!\"\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                lineNumber: 101,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_fullcalendar_react__WEBPACK_IMPORTED_MODULE_3___default()), {\n                plugins: [\n                    _fullcalendar_daygrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n                    (_fullcalendar_interaction__WEBPACK_IMPORTED_MODULE_5___default())\n                ],\n                initialView: \"dayGridMonth\",\n                editable: true,\n                events: posts,\n                dateClick: handleDateClick\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                lineNumber: 110,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                children: [\n                    eventDay,\n                    eventDay && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Button, {\n                        onClick: handleModal,\n                        children: \"Add\"\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                        lineNumber: 119,\n                        columnNumber: 22\n                    }, undefined)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                lineNumber: 117,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                children: posts.map((post)=>{\n                    if (eventDay === post.date) {\n                        return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_EventLists__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                                title: post.title,\n                                content: post.content,\n                                date: post.date,\n                                id: post.length,\n                                relation: post.relation\n                            }, void 0, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                                lineNumber: 133,\n                                columnNumber: 19\n                            }, undefined)\n                        }, post.length, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                            lineNumber: 132,\n                            columnNumber: 17\n                        }, undefined);\n                    }\n                })\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                lineNumber: 121,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Modal, {\n                open: open,\n                onClose: handleModal,\n                \"aria-labelledby\": \"modal-modal-title\",\n                \"aria-describedby\": \"modal-modal-description\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_system__WEBPACK_IMPORTED_MODULE_7__.Box, {\n                    style: {\n                        backgroundColor: \"white\"\n                    },\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Typography, {\n                            children: eventDay\n                        }, void 0, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                            lineNumber: 154,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                            onSubmit: (e)=>submitHandler(e),\n                            children: [\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"text\",\n                                    value: eventTitle,\n                                    onChange: (e)=>titleChange(e)\n                                }, void 0, false, {\n                                    fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                                    lineNumber: 156,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                    value: eventContent,\n                                    onChange: (e)=>contentChange(e)\n                                }, void 0, false, {\n                                    fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                                    lineNumber: 161,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"text\",\n                                    value: eventRelation,\n                                    onChange: (e)=>setEventRelation(e.target.value)\n                                }, void 0, false, {\n                                    fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                                    lineNumber: 162,\n                                    columnNumber: 13\n                                }, undefined),\n                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                    type: \"submit\"\n                                }, void 0, false, {\n                                    fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                                    lineNumber: 167,\n                                    columnNumber: 13\n                                }, undefined)\n                            ]\n                        }, void 0, true, {\n                            fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                            lineNumber: 155,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_6__.Button, {\n                            onClick: handleModal,\n                            children: \"close modal\"\n                        }, void 0, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                            lineNumber: 170,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                    lineNumber: 153,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n                lineNumber: 147,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/youta/type-front/src/components/Calendar/calendar.tsx\",\n        lineNumber: 89,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Calendar);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9DYWxlbmRhci9jYWxlbmRhci50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBNEM7QUFDTjtBQUNTO0FBQ0c7QUFDMEI7QUFDbEQ7QUFPSDtBQUNXO0FBQ3FCO0FBQ0k7QUFDRjtBQUNSO0FBRWpELE1BQU1tQixXQUFxQixJQUFNO0lBQy9CLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHcEIsK0NBQVFBLENBQVM7SUFDckQsTUFBTSxDQUFDcUIsY0FBY0MsZ0JBQWdCLEdBQUd0QiwrQ0FBUUEsQ0FBUztJQUN6RCxNQUFNLENBQUN1QixNQUFNQyxRQUFRLEdBQUd4QiwrQ0FBUUEsQ0FBVSxLQUFLO0lBQy9DLE1BQU0sQ0FBQ3lCLFVBQVVDLFlBQVksR0FBRzFCLCtDQUFRQSxDQUFTO0lBQ2pELE1BQU0sQ0FBQzJCLE9BQU9DLFNBQVMsR0FBRzVCLCtDQUFRQSxDQUFVLEtBQUs7SUFDakQsTUFBTSxDQUFDNkIsWUFBWUMsY0FBYyxHQUFHOUIsK0NBQVFBLENBQVUsS0FBSztJQUMzRCxNQUFNLEVBQUUrQixLQUFJLEVBQUVDLE1BQUssRUFBRUMsUUFBTyxFQUFFLEdBQUdwQix3REFBUUEsQ0FBQ0MsbURBQVNBO0lBQ25ELE1BQU0sQ0FBQ29CLFdBQVcsR0FBR3RCLDJEQUFXQSxDQUFDRyxxREFBV0E7SUFDNUMsTUFBTSxDQUFDb0IsZUFBZUMsaUJBQWlCLEdBQUdwQywrQ0FBUUE7SUFFbERELGdEQUFTQSxDQUFDLElBQU07UUFDZCxJQUFJNEIsU0FBU0UsWUFBWTtZQUN2QlEsV0FBVyxJQUFNO2dCQUNmLElBQUlWLE9BQU87b0JBQ1RDLFNBQVMsS0FBSztnQkFDaEIsT0FBTztvQkFDTEUsY0FBYyxLQUFLO2dCQUNyQixDQUFDO1lBQ0gsR0FBRztRQUNMLENBQUM7SUFDSDtJQUNBLElBQUlFLE9BQU8scUJBQU8sOERBQUNNO2tCQUFJOzs7Ozs7SUFDdkIsSUFBSUwsU0FBUyxxQkFBTyw4REFB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QU96QjtvQ0FBY2lFLFVBQVUsQ0FBQzFDLElBQU1HLGNBQWNIOzs7Ozs7OENBQzlELDhEQUFDd0M7b0NBQ0NDLE1BQUs7b0NBQ0x2QyxPQUFPWDtvQ0FDUG1ELFVBQVUsQ0FBQzFDLElBQU1SLGlCQUFpQlEsRUFBRUMsTUFBTSxDQUFDQyxLQUFLOzs7Ozs7OENBRWxELDhEQUFDc0M7b0NBQU1DLE1BQUs7Ozs7Ozs7Ozs7OztzQ0FHZCw4REFBQzlFLGlEQUFNQTs0QkFBQ2lFLFNBQVN4QjtzQ0FBYTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLeEM7QUFFQSxpRUFBZTlCLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3NyYy9jb21wb25lbnRzL0NhbGVuZGFyL2NhbGVuZGFyLnRzeD8xMDQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBFdmVudExpc3RzIGZyb20gXCIuL0V2ZW50TGlzdHNcIjtcbmltcG9ydCBGdWxsQ2FsZW5kYXIgZnJvbSBcIkBmdWxsY2FsZW5kYXIvcmVhY3RcIjtcbmltcG9ydCBkYXlHcmlkUGx1Z2luIGZyb20gXCJAZnVsbGNhbGVuZGFyL2RheWdyaWRcIjtcbmltcG9ydCBpbnRlcmFjdGlvblBsdWdpbiwgeyBEYXRlQ2xpY2tBcmcgfSBmcm9tIFwiQGZ1bGxjYWxlbmRhci9pbnRlcmFjdGlvblwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHtcbiAgQWxlcnQsXG4gIEJ1dHRvbixcbiAgQ2lyY3VsYXJQcm9ncmVzcyxcbiAgTW9kYWwsXG4gIFR5cG9ncmFwaHksXG59IGZyb20gXCJAbXVpL21hdGVyaWFsXCI7XG5pbXBvcnQgeyBCb3ggfSBmcm9tIFwiQG11aS9zeXN0ZW1cIjtcbmltcG9ydCB7IHVzZU11dGF0aW9uLCB1c2VRdWVyeSB9IGZyb20gXCJAYXBvbGxvL2NsaWVudFwiO1xuaW1wb3J0IHsgR0VUX1BPU1RTLCBDUkVBVEVfUE9TVCB9IGZyb20gXCIuLi8uLi9QcmlzbWEvUG9zdFwiO1xuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi4vLi4vLi4vc3R5bGVzL2NhbGVuZGFyLm1vZHVsZS5jc3NcIjtcbmltcG9ydCB7IGRvUmVsb2FkIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9uL1JlbG9hZFwiO1xuXG5jb25zdCBDYWxlbmRhcjogUmVhY3QuRkMgPSAoKSA9PiB7XG4gIGNvbnN0IFtldmVudFRpdGxlLCBzZXRFdmVudFRpdGxlXSA9IHVzZVN0YXRlPHN0cmluZz4oXCJcIik7XG4gIGNvbnN0IFtldmVudENvbnRlbnQsIHNldEV2ZW50Q29udGVudF0gPSB1c2VTdGF0ZTxzdHJpbmc+KFwiXCIpO1xuICBjb25zdCBbb3Blbiwgc2V0T3Blbl0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtldmVudERheSwgc2V0RXZlbnREYXldID0gdXNlU3RhdGU8c3RyaW5nPihcIlwiKTtcbiAgY29uc3QgW2FsZXJ0LCBzZXRBbGVydF0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtlcnJvckFsZXJ0LCBzZXRFcnJvckFsZXJ0XSA9IHVzZVN0YXRlPGJvb2xlYW4+KGZhbHNlKTtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciwgbG9hZGluZyB9ID0gdXNlUXVlcnkoR0VUX1BPU1RTKTtcbiAgY29uc3QgW0NyZWF0ZVBvc3RdID0gdXNlTXV0YXRpb24oQ1JFQVRFX1BPU1QpO1xuICBjb25zdCBbZXZlbnRSZWxhdGlvbiwgc2V0RXZlbnRSZWxhdGlvbl0gPSB1c2VTdGF0ZTxzdHJpbmc+KCk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoYWxlcnQgfHwgZXJyb3JBbGVydCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChhbGVydCkge1xuICAgICAgICAgIHNldEFsZXJ0KGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZXRFcnJvckFsZXJ0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfSwgMzAwMCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKGVycm9yKSByZXR1cm4gPGRpdj5FcnJvciA8L2Rpdj47XG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPENpcmN1bGFyUHJvZ3Jlc3MgLz47XG4gIGNvbnN0IHsgcG9zdHMgfSA9IGRhdGE7XG5cbiAgY29uc3QgaGFuZGxlRGF0ZUNsaWNrID0gKGFyZzogRGF0ZUNsaWNrQXJnKSA9PiB7XG4gICAgc2V0RXZlbnREYXkoYXJnLmRhdGVTdHIpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRpdGxlQ2hhbmdlKGU6IHsgdGFyZ2V0OiB7IHZhbHVlOiBSZWFjdC5TZXRTdGF0ZUFjdGlvbjxzdHJpbmc+IH0gfSkge1xuICAgIHNldEV2ZW50VGl0bGUoZS50YXJnZXQudmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIGNvbnRlbnRDaGFuZ2UoZToge1xuICAgIHRhcmdldDogeyB2YWx1ZTogUmVhY3QuU2V0U3RhdGVBY3Rpb248c3RyaW5nPiB9O1xuICB9KSB7XG4gICAgc2V0RXZlbnRDb250ZW50KGUudGFyZ2V0LnZhbHVlKTtcbiAgfVxuICBmdW5jdGlvbiBoYW5kbGVNb2RhbCgpIHtcbiAgICBzZXRPcGVuKCFvcGVuKTtcbiAgfVxuICBmdW5jdGlvbiBzdWJtaXRIYW5kbGVyKGU6IFJlYWN0LkZvcm1FdmVudDxIVE1MRm9ybUVsZW1lbnQ+KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IGlzVmFsaWQgPSBldmVudERheS5sZW5ndGggJiYgZXZlbnRUaXRsZS5sZW5ndGggPj0gMTtcbiAgICBpZiAoaXNWYWxpZCkge1xuICAgICAgQ3JlYXRlUG9zdCh7XG4gICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgIHRpdGxlOiBldmVudFRpdGxlLFxuICAgICAgICAgIGNvbnRlbnQ6IGV2ZW50Q29udGVudCxcbiAgICAgICAgICBkYXRlOiBldmVudERheSxcbiAgICAgICAgICByZWxhdGlvbjogZXZlbnRSZWxhdGlvbixcbiAgICAgICAgICBsZW5ndGg6IDEgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMDApLFxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgICBzZXRBbGVydCh0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0RXJyb3JBbGVydCh0cnVlKTtcbiAgICB9XG4gICAgc2V0RXZlbnRDb250ZW50KFwiXCIpO1xuICAgIHNldEV2ZW50VGl0bGUoXCJcIik7XG4gICAgc2V0T3BlbihmYWxzZSk7XG4gICAgc2V0VGltZW91dChkb1JlbG9hZCwgMTAwMCk7XG4gIH1cblxuICBmdW5jdGlvbiBhbGVydENsb3NlKCkge1xuICAgIHNldEFsZXJ0KGZhbHNlKTtcbiAgICBzZXRFcnJvckFsZXJ0KGZhbHNlKTtcbiAgfVxuICByZXR1cm4gKFxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2FsZW5kYXJ9PlxuICAgICAge2FsZXJ0ICYmIChcbiAgICAgICAgPEFsZXJ0XG4gICAgICAgICAgb25DbG9zZT17KCkgPT4ge1xuICAgICAgICAgICAgYWxlcnRDbG9zZSgpO1xuICAgICAgICAgIH19XG4gICAgICAgICAgc2V2ZXJpdHk9XCJzdWNjZXNzXCJcbiAgICAgICAgPlxuICAgICAgICAgIFRoaXMgaXMgYSBzdWNjZXNzIGFsZXJ0IOKAlCBjaGVjayBpdCBvdXQhXG4gICAgICAgIDwvQWxlcnQ+XG4gICAgICApfVxuICAgICAge2Vycm9yQWxlcnQgJiYgKFxuICAgICAgICA8QWxlcnRcbiAgICAgICAgICBvbkNsb3NlPXsoKSA9PiB7XG4gICAgICAgICAgICBhbGVydENsb3NlKCk7XG4gICAgICAgICAgfX1cbiAgICAgICAgICBzZXZlcml0eT1cImVycm9yXCJcbiAgICAgICAgPlxuICAgICAgICAgIFRoaXMgaXMgYSBzdWNjZXNzIGFsZXJ0IOKAlCBjaGVjayBpdCBvdXQhXG4gICAgICAgIDwvQWxlcnQ+XG4gICAgICApfVxuICAgICAgPEZ1bGxDYWxlbmRhclxuICAgICAgICBwbHVnaW5zPXtbZGF5R3JpZFBsdWdpbiwgaW50ZXJhY3Rpb25QbHVnaW5dfVxuICAgICAgICBpbml0aWFsVmlldz1cImRheUdyaWRNb250aFwiXG4gICAgICAgIGVkaXRhYmxlPXt0cnVlfVxuICAgICAgICBldmVudHM9e3Bvc3RzfVxuICAgICAgICBkYXRlQ2xpY2s9e2hhbmRsZURhdGVDbGlja31cbiAgICAgIC8+XG4gICAgICA8aDI+XG4gICAgICAgIHtldmVudERheX1cbiAgICAgICAge2V2ZW50RGF5ICYmIDxCdXR0b24gb25DbGljaz17aGFuZGxlTW9kYWx9PkFkZDwvQnV0dG9uPn1cbiAgICAgIDwvaDI+XG4gICAgICA8dWw+XG4gICAgICAgIHtwb3N0cy5tYXAoXG4gICAgICAgICAgKHBvc3Q6IHtcbiAgICAgICAgICAgIHJlbGF0aW9uOiBzdHJpbmc7XG4gICAgICAgICAgICBsZW5ndGg6IG51bWJlcjtcbiAgICAgICAgICAgIHRpdGxlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb250ZW50OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICBkYXRlOiBzdHJpbmcgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50RGF5ID09PSBwb3N0LmRhdGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICA8bGkga2V5PXtwb3N0Lmxlbmd0aH0+XG4gICAgICAgICAgICAgICAgICA8RXZlbnRMaXN0c1xuICAgICAgICAgICAgICAgICAgICB0aXRsZT17cG9zdC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgY29udGVudD17cG9zdC5jb250ZW50fVxuICAgICAgICAgICAgICAgICAgICBkYXRlPXtwb3N0LmRhdGV9XG4gICAgICAgICAgICAgICAgICAgIGlkPXtwb3N0Lmxlbmd0aH1cbiAgICAgICAgICAgICAgICAgICAgcmVsYXRpb249e3Bvc3QucmVsYXRpb259XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApfVxuICAgICAgPC91bD5cblxuICAgICAgPE1vZGFsXG4gICAgICAgIG9wZW49e29wZW59XG4gICAgICAgIG9uQ2xvc2U9e2hhbmRsZU1vZGFsfVxuICAgICAgICBhcmlhLWxhYmVsbGVkYnk9XCJtb2RhbC1tb2RhbC10aXRsZVwiXG4gICAgICAgIGFyaWEtZGVzY3JpYmVkYnk9XCJtb2RhbC1tb2RhbC1kZXNjcmlwdGlvblwiXG4gICAgICA+XG4gICAgICAgIDxCb3ggc3R5bGU9e3sgYmFja2dyb3VuZENvbG9yOiBcIndoaXRlXCIgfX0+XG4gICAgICAgICAgPFR5cG9ncmFwaHk+e2V2ZW50RGF5fTwvVHlwb2dyYXBoeT5cbiAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17KGUpID0+IHN1Ym1pdEhhbmRsZXIoZSl9PlxuICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgICAgICAgdmFsdWU9e2V2ZW50VGl0bGV9XG4gICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gdGl0bGVDaGFuZ2UoZSl9XG4gICAgICAgICAgICAvPlxuICAgICAgICAgICAgPHRleHRhcmVhIHZhbHVlPXtldmVudENvbnRlbnR9IG9uQ2hhbmdlPXsoZSkgPT4gY29udGVudENoYW5nZShlKX0gLz5cbiAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgIHZhbHVlPXtldmVudFJlbGF0aW9ufVxuICAgICAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldEV2ZW50UmVsYXRpb24oZS50YXJnZXQudmFsdWUpfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAgICAgICAgICA8L2Zvcm0+XG5cbiAgICAgICAgICA8QnV0dG9uIG9uQ2xpY2s9e2hhbmRsZU1vZGFsfT5jbG9zZSBtb2RhbDwvQnV0dG9uPlxuICAgICAgICA8L0JveD5cbiAgICAgIDwvTW9kYWw+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBDYWxlbmRhcjtcbiJdLCJuYW1lcyI6WyJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIkV2ZW50TGlzdHMiLCJGdWxsQ2FsZW5kYXIiLCJkYXlHcmlkUGx1Z2luIiwiaW50ZXJhY3Rpb25QbHVnaW4iLCJSZWFjdCIsIkFsZXJ0IiwiQnV0dG9uIiwiQ2lyY3VsYXJQcm9ncmVzcyIsIk1vZGFsIiwiVHlwb2dyYXBoeSIsIkJveCIsInVzZU11dGF0aW9uIiwidXNlUXVlcnkiLCJHRVRfUE9TVFMiLCJDUkVBVEVfUE9TVCIsInN0eWxlcyIsImRvUmVsb2FkIiwiQ2FsZW5kYXIiLCJldmVudFRpdGxlIiwic2V0RXZlbnRUaXRsZSIsImV2ZW50Q29udGVudCIsInNldEV2ZW50Q29udGVudCIsIm9wZW4iLCJzZXRPcGVuIiwiZXZlbnREYXkiLCJzZXRFdmVudERheSIsImFsZXJ0Iiwic2V0QWxlcnQiLCJlcnJvckFsZXJ0Iiwic2V0RXJyb3JBbGVydCIsImRhdGEiLCJlcnJvciIsImxvYWRpbmciLCJDcmVhdGVQb3N0IiwiZXZlbnRSZWxhdGlvbiIsInNldEV2ZW50UmVsYXRpb24iLCJzZXRUaW1lb3V0IiwiZGl2IiwicG9zdHMiLCJoYW5kbGVEYXRlQ2xpY2siLCJhcmciLCJkYXRlU3RyIiwidGl0bGVDaGFuZ2UiLCJlIiwidGFyZ2V0IiwidmFsdWUiLCJjb250ZW50Q2hhbmdlIiwiaGFuZGxlTW9kYWwiLCJzdWJtaXRIYW5kbGVyIiwicHJldmVudERlZmF1bHQiLCJpc1ZhbGlkIiwibGVuZ3RoIiwidmFyaWFibGVzIiwidGl0bGUiLCJjb250ZW50IiwiZGF0ZSIsInJlbGF0aW9uIiwiTWF0aCIsImZsb29yIiwicmFuZG9tIiwiYWxlcnRDbG9zZSIsImNsYXNzTmFtZSIsImNhbGVuZGFyIiwib25DbG9zZSIsInNldmVyaXR5IiwicGx1Z2lucyIsImluaXRpYWxWaWV3IiwiZWRpdGFibGUiLCJldmVudHMiLCJkYXRlQ2xpY2siLCJoMiIsIm9uQ2xpY2siLCJ1bCIsIm1hcCIsInBvc3QiLCJsaSIsImlkIiwiYXJpYS1sYWJlbGxlZGJ5IiwiYXJpYS1kZXNjcmliZWRieSIsInN0eWxlIiwiYmFja2dyb3VuZENvbG9yIiwiZm9ybSIsIm9uU3VibWl0IiwiaW5wdXQiLCJ0eXBlIiwib25DaGFuZ2UiLCJ0ZXh0YXJlYSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Calendar/calendar.tsx\n");

/***/ }),

/***/ "./src/components/Friend/Friend.tsx":
/*!******************************************!*\
  !*** ./src/components/Friend/Friend.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _styles_friend_module_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../styles/friend.module.css */ \"./styles/friend.module.css\");\n/* harmony import */ var _styles_friend_module_css__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_styles_friend_module_css__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _mui_icons_material_AccessibilityNew__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mui/icons-material/AccessibilityNew */ \"@mui/icons-material/AccessibilityNew\");\n/* harmony import */ var _mui_icons_material_AccessibilityNew__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_mui_icons_material_AccessibilityNew__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\nconst Friend = (props)=>{\n    const { name  } = props.friend;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Button, {\n            className: (_styles_friend_module_css__WEBPACK_IMPORTED_MODULE_4___default().friend),\n            href: `/Friend/${name}`,\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_mui_icons_material_AccessibilityNew__WEBPACK_IMPORTED_MODULE_3___default()), {}, void 0, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Friend/Friend.tsx\",\n                    lineNumber: 18,\n                    columnNumber: 9\n                }, undefined),\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    children: name\n                }, void 0, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Friend/Friend.tsx\",\n                    lineNumber: 19,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/youta/type-front/src/components/Friend/Friend.tsx\",\n            lineNumber: 17,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Friend/Friend.tsx\",\n        lineNumber: 16,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Friend);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9GcmllbmQvRnJpZW5kLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQXVDO0FBQ2I7QUFDNkI7QUFDaUI7QUFTeEUsTUFBTUksU0FBUyxDQUFDQyxRQUFrQjtJQUNoQyxNQUFNLEVBQUVDLEtBQUksRUFBRSxHQUFHRCxNQUFNRSxNQUFNO0lBQzdCLHFCQUNFLDhEQUFDQztrQkFDQyw0RUFBQ1IsaURBQU1BO1lBQUNTLFdBQVdQLHlFQUFhO1lBQUVRLE1BQU0sQ0FBQyxRQUFRLEVBQUVKLEtBQUssQ0FBQzs7OEJBQ3ZELDhEQUFDSCw2RUFBb0JBOzs7Ozs4QkFDckIsOERBQUNLOzhCQUFLRjs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFJZDtBQUVBLGlFQUFlRixNQUFNQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9zcmMvY29tcG9uZW50cy9GcmllbmQvRnJpZW5kLnRzeD80NmRkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJ1dHRvbiB9IGZyb20gXCJAbXVpL21hdGVyaWFsXCI7XG5pbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuLi8uLi8uLi9zdHlsZXMvZnJpZW5kLm1vZHVsZS5jc3NcIjtcbmltcG9ydCBBY2Nlc3NpYmlsaXR5TmV3SWNvbiBmcm9tIFwiQG11aS9pY29ucy1tYXRlcmlhbC9BY2Nlc3NpYmlsaXR5TmV3XCI7XG5pbnRlcmZhY2UgRnJpZW5kIHtcbiAgZnJpZW5kOiB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgcmVsYXRpb246IHN0cmluZztcbiAgfTtcbn1cblxuY29uc3QgRnJpZW5kID0gKHByb3BzOiBGcmllbmQpID0+IHtcbiAgY29uc3QgeyBuYW1lIH0gPSBwcm9wcy5mcmllbmQ7XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxCdXR0b24gY2xhc3NOYW1lPXtzdHlsZXMuZnJpZW5kfSBocmVmPXtgL0ZyaWVuZC8ke25hbWV9YH0+XG4gICAgICAgIDxBY2Nlc3NpYmlsaXR5TmV3SWNvbiAvPlxuICAgICAgICA8ZGl2PntuYW1lfTwvZGl2PlxuICAgICAgPC9CdXR0b24+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBGcmllbmQ7XG4iXSwibmFtZXMiOlsiQnV0dG9uIiwiUmVhY3QiLCJzdHlsZXMiLCJBY2Nlc3NpYmlsaXR5TmV3SWNvbiIsIkZyaWVuZCIsInByb3BzIiwibmFtZSIsImZyaWVuZCIsImRpdiIsImNsYXNzTmFtZSIsImhyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Friend/Friend.tsx\n");

/***/ }),

/***/ "./src/components/Friend/FriendList.tsx":
/*!**********************************************!*\
  !*** ./src/components/Friend/FriendList.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   \"friends\": () => (/* binding */ friends)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Friend__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Friend */ \"./src/components/Friend/Friend.tsx\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @apollo/client */ \"@apollo/client\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Prisma_Friend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Prisma/Friend */ \"./src/Prisma/Friend.tsx\");\n\n\n\n\n\n\n\nconst friends = [];\nconst FriendList = ()=>{\n    const { data , error , loading  } = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_4__.useQuery)(_Prisma_Friend__WEBPACK_IMPORTED_MODULE_5__.GET_FRIENDS);\n    if (error) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"Error \"\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Friend/FriendList.tsx\",\n        lineNumber: 12,\n        columnNumber: 21\n    }, undefined);\n    if (loading) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.CircularProgress, {}, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Friend/FriendList.tsx\",\n        lineNumber: 13,\n        columnNumber: 23\n    }, undefined);\n    const { friends  } = data;\n    console.log(friends);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.List, {\n            children: friends.map((friend)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_Friend__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                        friend: friend\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Friend/FriendList.tsx\",\n                        lineNumber: 22,\n                        columnNumber: 13\n                    }, undefined)\n                }, friend.id, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Friend/FriendList.tsx\",\n                    lineNumber: 21,\n                    columnNumber: 11\n                }, undefined))\n        }, void 0, false, {\n            fileName: \"/Users/youta/type-front/src/components/Friend/FriendList.tsx\",\n            lineNumber: 19,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Friend/FriendList.tsx\",\n        lineNumber: 18,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FriendList);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9GcmllbmQvRnJpZW5kTGlzdC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBcUM7QUFDWDtBQUNJO0FBQ1k7QUFDTztBQUNDO0FBRTNDLE1BQU1NLFVBQVUsRUFBRSxDQUFDO0FBRTFCLE1BQU1DLGFBQWEsSUFBTTtJQUN2QixNQUFNLEVBQUVDLEtBQUksRUFBRUMsTUFBSyxFQUFFQyxRQUFPLEVBQUUsR0FBR1Asd0RBQVFBLENBQUNFLHVEQUFXQTtJQUNyRCxJQUFJSSxPQUFPLHFCQUFPLDhEQUFDRTtrQkFBSTs7Ozs7O0lBQ3ZCLElBQUlELFNBQVMscUJBQU8sOERBQUNOLDJEQUFnQkE7Ozs7O0lBQ3JDLE1BQU0sRUFBRUUsUUFBTyxFQUFFLEdBQUdFO0lBRXBCSSxRQUFRQyxHQUFHLENBQUNQO0lBQ1oscUJBQ0UsOERBQUNLO2tCQUNDLDRFQUFDWCwrQ0FBSUE7c0JBQ0ZNLFFBQVFRLEdBQUcsQ0FBQyxDQUFDQyx1QkFDWiw4REFBQ0M7OEJBQ0MsNEVBQUNkLCtDQUFNQTt3QkFBQ2EsUUFBUUE7Ozs7OzttQkFEVEEsT0FBT0UsRUFBRTs7Ozs7Ozs7Ozs7Ozs7O0FBTzVCO0FBRUEsaUVBQWVWLFVBQVVBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3NyYy9jb21wb25lbnRzL0ZyaWVuZC9GcmllbmRMaXN0LnRzeD8xMjUxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IExpc3QgfSBmcm9tIFwiQG11aS9tYXRlcmlhbFwiO1xuaW1wb3J0IFJlYWN0IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IEZyaWVuZCBmcm9tIFwiLi9GcmllbmRcIjtcbmltcG9ydCB7IHVzZVF1ZXJ5IH0gZnJvbSBcIkBhcG9sbG8vY2xpZW50XCI7XG5pbXBvcnQgeyBDaXJjdWxhclByb2dyZXNzIH0gZnJvbSBcIkBtdWkvbWF0ZXJpYWxcIjtcbmltcG9ydCB7IEdFVF9GUklFTkRTIH0gZnJvbSBcIi4uLy4uL1ByaXNtYS9GcmllbmRcIjtcblxuZXhwb3J0IGNvbnN0IGZyaWVuZHMgPSBbXTtcblxuY29uc3QgRnJpZW5kTGlzdCA9ICgpID0+IHtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciwgbG9hZGluZyB9ID0gdXNlUXVlcnkoR0VUX0ZSSUVORFMpO1xuICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PkVycm9yIDwvZGl2PjtcbiAgaWYgKGxvYWRpbmcpIHJldHVybiA8Q2lyY3VsYXJQcm9ncmVzcyAvPjtcbiAgY29uc3QgeyBmcmllbmRzIH0gPSBkYXRhO1xuXG4gIGNvbnNvbGUubG9nKGZyaWVuZHMpO1xuICByZXR1cm4gKFxuICAgIDxkaXY+XG4gICAgICA8TGlzdD5cbiAgICAgICAge2ZyaWVuZHMubWFwKChmcmllbmQpID0+IChcbiAgICAgICAgICA8bGkga2V5PXtmcmllbmQuaWR9PlxuICAgICAgICAgICAgPEZyaWVuZCBmcmllbmQ9e2ZyaWVuZH0gLz5cbiAgICAgICAgICA8L2xpPlxuICAgICAgICApKX1cbiAgICAgIDwvTGlzdD5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZyaWVuZExpc3Q7XG4iXSwibmFtZXMiOlsiTGlzdCIsIlJlYWN0IiwiRnJpZW5kIiwidXNlUXVlcnkiLCJDaXJjdWxhclByb2dyZXNzIiwiR0VUX0ZSSUVORFMiLCJmcmllbmRzIiwiRnJpZW5kTGlzdCIsImRhdGEiLCJlcnJvciIsImxvYWRpbmciLCJkaXYiLCJjb25zb2xlIiwibG9nIiwibWFwIiwiZnJpZW5kIiwibGkiLCJpZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Friend/FriendList.tsx\n");

/***/ }),

/***/ "./src/components/Header/DrawerComp.tsx":
/*!**********************************************!*\
  !*** ./src/components/Header/DrawerComp.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _mui_icons_material_Menu__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mui/icons-material/Menu */ \"@mui/icons-material/Menu\");\n/* harmony import */ var _mui_icons_material_Menu__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_mui_icons_material_Menu__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nconst DrawerComp = (props)=>{\n    const [openDrawer, setOpenDrawer] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(false);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Drawer, {\n                open: openDrawer,\n                onClose: ()=>setOpenDrawer(false),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.List, {\n                    children: props.pages.map((page)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ListItemButton, {\n                                href: page.link,\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ListItemText, {\n                                    children: page.name\n                                }, void 0, false, {\n                                    fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                                    lineNumber: 28,\n                                    columnNumber: 17\n                                }, undefined)\n                            }, void 0, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                                lineNumber: 27,\n                                columnNumber: 15\n                            }, undefined)\n                        }, page.link, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                            lineNumber: 26,\n                            columnNumber: 13\n                        }, undefined))\n                }, void 0, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                lineNumber: 23,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.IconButton, {\n                sx: {\n                    color: \"white\"\n                },\n                onClick: ()=>setOpenDrawer(!openDrawer),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_mui_icons_material_Menu__WEBPACK_IMPORTED_MODULE_2___default()), {}, void 0, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                    lineNumber: 38,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n                lineNumber: 34,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/youta/type-front/src/components/Header/DrawerComp.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawerComp);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9IZWFkZXIvRHJhd2VyQ29tcC50c3guanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUE7QUFNdUI7QUFDeUI7QUFDUjtBQVV4QyxNQUFNUSxhQUFhLENBQUNDLFFBQWdCO0lBQ2xDLE1BQU0sQ0FBQ0MsWUFBWUMsY0FBYyxHQUFHSiwrQ0FBUUEsQ0FBQyxLQUFLO0lBQ2xELHFCQUNFLDhEQUFDSzs7MEJBQ0MsOERBQUNaLGlEQUFNQTtnQkFBQ2EsTUFBTUg7Z0JBQVlJLFNBQVMsSUFBTUgsY0FBYyxLQUFLOzBCQUMxRCw0RUFBQ1QsK0NBQUlBOzhCQUNGTyxNQUFNTSxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDQyxxQkFDaEIsOERBQUNDO3NDQUNDLDRFQUFDZix5REFBY0E7Z0NBQUNnQixNQUFNRixLQUFLRyxJQUFJOzBDQUM3Qiw0RUFBQ2hCLHVEQUFZQTs4Q0FBRWEsS0FBS0ksSUFBSTs7Ozs7Ozs7Ozs7MkJBRm5CSixLQUFLRyxJQUFJOzs7Ozs7Ozs7Ozs7Ozs7MEJBUXhCLDhEQUFDbkIscURBQVVBO2dCQUNUcUIsSUFBSTtvQkFBRUMsT0FBTztnQkFBUTtnQkFDckJDLFNBQVMsSUFBTWIsY0FBYyxDQUFDRDswQkFFOUIsNEVBQUNMLGlFQUFRQTs7Ozs7Ozs7Ozs7Ozs7OztBQUlqQjtBQUVBLGlFQUFlRyxVQUFVQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXIvRHJhd2VyQ29tcC50c3g/MGEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBEcmF3ZXIsXG4gIEljb25CdXR0b24sXG4gIExpc3QsXG4gIExpc3RJdGVtQnV0dG9uLFxuICBMaXN0SXRlbVRleHQsXG59IGZyb20gXCJAbXVpL21hdGVyaWFsXCI7XG5pbXBvcnQgTWVudUljb24gZnJvbSBcIkBtdWkvaWNvbnMtbWF0ZXJpYWwvTWVudVwiO1xuaW1wb3J0IFJlYWN0LCB7IHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5cbmludGVyZmFjZSBQYWdlIHtcbiAgcGFnZXM6IHtcbiAgICBuYW1lOiBzdHJpbmc7XG4gICAgbGluazogc3RyaW5nO1xuICB9W107XG59XG5cblxuY29uc3QgRHJhd2VyQ29tcCA9IChwcm9wczogUGFnZSkgPT4ge1xuICBjb25zdCBbb3BlbkRyYXdlciwgc2V0T3BlbkRyYXdlcl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIHJldHVybiAoXG4gICAgPGRpdj5cbiAgICAgIDxEcmF3ZXIgb3Blbj17b3BlbkRyYXdlcn0gb25DbG9zZT17KCkgPT4gc2V0T3BlbkRyYXdlcihmYWxzZSl9PlxuICAgICAgICA8TGlzdD5cbiAgICAgICAgICB7cHJvcHMucGFnZXMubWFwKChwYWdlKSA9PiAoXG4gICAgICAgICAgICA8bGkga2V5PXtwYWdlLmxpbmt9PlxuICAgICAgICAgICAgICA8TGlzdEl0ZW1CdXR0b24gaHJlZj17cGFnZS5saW5rfT5cbiAgICAgICAgICAgICAgICA8TGlzdEl0ZW1UZXh0PntwYWdlLm5hbWV9PC9MaXN0SXRlbVRleHQ+XG4gICAgICAgICAgICAgIDwvTGlzdEl0ZW1CdXR0b24+XG4gICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICkpfVxuICAgICAgICA8L0xpc3Q+XG4gICAgICA8L0RyYXdlcj5cbiAgICAgIDxJY29uQnV0dG9uXG4gICAgICAgIHN4PXt7IGNvbG9yOiBcIndoaXRlXCIgfX1cbiAgICAgICAgb25DbGljaz17KCkgPT4gc2V0T3BlbkRyYXdlcighb3BlbkRyYXdlcil9XG4gICAgICA+XG4gICAgICAgIDxNZW51SWNvbiAvPlxuICAgICAgPC9JY29uQnV0dG9uPlxuICAgIDwvZGl2PlxuICApO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRHJhd2VyQ29tcDtcbiJdLCJuYW1lcyI6WyJEcmF3ZXIiLCJJY29uQnV0dG9uIiwiTGlzdCIsIkxpc3RJdGVtQnV0dG9uIiwiTGlzdEl0ZW1UZXh0IiwiTWVudUljb24iLCJSZWFjdCIsInVzZVN0YXRlIiwiRHJhd2VyQ29tcCIsInByb3BzIiwib3BlbkRyYXdlciIsInNldE9wZW5EcmF3ZXIiLCJkaXYiLCJvcGVuIiwib25DbG9zZSIsInBhZ2VzIiwibWFwIiwicGFnZSIsImxpIiwiaHJlZiIsImxpbmsiLCJuYW1lIiwic3giLCJjb2xvciIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Header/DrawerComp.tsx\n");

/***/ }),

/***/ "./src/components/Header/DrawerFriend.tsx":
/*!************************************************!*\
  !*** ./src/components/Header/DrawerFriend.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _mui_icons_material_RecordVoiceOver__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mui/icons-material/RecordVoiceOver */ \"@mui/icons-material/RecordVoiceOver\");\n/* harmony import */ var _mui_icons_material_RecordVoiceOver__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_mui_icons_material_RecordVoiceOver__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @apollo/client */ \"@apollo/client\");\n/* harmony import */ var _apollo_client__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_apollo_client__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _Prisma_Friend__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../Prisma/Friend */ \"./src/Prisma/Friend.tsx\");\n\n\n\n\n\n\nconst DrawerFriend = ()=>{\n    const [openDrawer, setOpenDrawer] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(false);\n    const { data , error , loading  } = (0,_apollo_client__WEBPACK_IMPORTED_MODULE_4__.useQuery)(_Prisma_Friend__WEBPACK_IMPORTED_MODULE_5__.GET_FRIENDS);\n    if (loading) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"loading...\"\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n        lineNumber: 17,\n        columnNumber: 23\n    }, undefined);\n    if (error) return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: \"error\"\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n        lineNumber: 18,\n        columnNumber: 21\n    }, undefined);\n    const { friends  } = data;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Drawer, {\n                open: openDrawer,\n                onClose: ()=>setOpenDrawer(false),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.List, {\n                    children: [\n                        friends.length === 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            children: \"no one\"\n                        }, void 0, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                            lineNumber: 25,\n                            columnNumber: 36\n                        }, undefined),\n                        friends.map((friend)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ListItemButton, {\n                                    href: \"/Friend/\" + friend.name,\n                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.ListItemText, {\n                                        children: friend.name\n                                    }, void 0, false, {\n                                        fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                                        lineNumber: 29,\n                                        columnNumber: 17\n                                    }, undefined)\n                                }, void 0, false, {\n                                    fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                                    lineNumber: 28,\n                                    columnNumber: 15\n                                }, undefined)\n                            }, friend.id, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                                lineNumber: 27,\n                                columnNumber: 13\n                            }, undefined))\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                    lineNumber: 24,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                lineNumber: 23,\n                columnNumber: 7\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.IconButton, {\n                sx: {\n                    color: \"white\"\n                },\n                onClick: ()=>setOpenDrawer(!openDrawer),\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((_mui_icons_material_RecordVoiceOver__WEBPACK_IMPORTED_MODULE_3___default()), {}, void 0, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                    lineNumber: 39,\n                    columnNumber: 9\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n                lineNumber: 35,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/youta/type-front/src/components/Header/DrawerFriend.tsx\",\n        lineNumber: 22,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DrawerFriend);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9IZWFkZXIvRHJhd2VyRnJpZW5kLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQU11QjtBQUNpQjtBQUM4QjtBQUM1QjtBQUNRO0FBRWxELE1BQU1VLGVBQWUsSUFBTTtJQUN6QixNQUFNLENBQUNDLFlBQVlDLGNBQWMsR0FBR04sK0NBQVFBLENBQUMsS0FBSztJQUNsRCxNQUFNLEVBQUVPLEtBQUksRUFBRUMsTUFBSyxFQUFFQyxRQUFPLEVBQUUsR0FBR1Asd0RBQVFBLENBQUNDLHVEQUFXQTtJQUVyRCxJQUFJTSxTQUFTLHFCQUFPLDhEQUFDQztrQkFBSTs7Ozs7O0lBQ3pCLElBQUlGLE9BQU8scUJBQU8sOERBQUNFO2tCQUFJOzs7Ozs7SUFDdkIsTUFBTSxFQUFFQyxRQUFPLEVBQUUsR0FBR0o7SUFFcEIscUJBQ0UsOERBQUNHOzswQkFDQyw4REFBQ2hCLGlEQUFNQTtnQkFBQ2tCLE1BQU1QO2dCQUFZUSxTQUFTLElBQU1QLGNBQWMsS0FBSzswQkFDMUQsNEVBQUNWLCtDQUFJQTs7d0JBQ0ZlLFFBQVFHLE1BQU0sS0FBSyxtQkFBSyw4REFBQ0o7c0NBQUk7Ozs7Ozt3QkFDN0JDLFFBQVFJLEdBQUcsQ0FBQyxDQUFDQyx1QkFDWiw4REFBQ0M7MENBQ0MsNEVBQUNwQix5REFBY0E7b0NBQUNxQixNQUFNLGFBQWFGLE9BQU9HLElBQUk7OENBQzVDLDRFQUFDckIsdURBQVlBO2tEQUFFa0IsT0FBT0csSUFBSTs7Ozs7Ozs7Ozs7K0JBRnJCSCxPQUFPSSxFQUFFOzs7Ozs7Ozs7Ozs7Ozs7OzBCQVF4Qiw4REFBQ3pCLHFEQUFVQTtnQkFDVDBCLElBQUk7b0JBQUVDLE9BQU87Z0JBQVE7Z0JBQ3JCQyxTQUFTLElBQU1qQixjQUFjLENBQUNEOzBCQUU5Qiw0RUFBQ0osNEVBQW1CQTs7Ozs7Ozs7Ozs7Ozs7OztBQUk1QjtBQUVBLGlFQUFlRyxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9zcmMvY29tcG9uZW50cy9IZWFkZXIvRHJhd2VyRnJpZW5kLnRzeD81NTFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIERyYXdlcixcbiAgSWNvbkJ1dHRvbixcbiAgTGlzdCxcbiAgTGlzdEl0ZW1CdXR0b24sXG4gIExpc3RJdGVtVGV4dCxcbn0gZnJvbSBcIkBtdWkvbWF0ZXJpYWxcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IFJlY29yZFZvaWNlT3Zlckljb24gZnJvbSBcIkBtdWkvaWNvbnMtbWF0ZXJpYWwvUmVjb3JkVm9pY2VPdmVyXCI7XG5pbXBvcnQgeyB1c2VRdWVyeSB9IGZyb20gXCJAYXBvbGxvL2NsaWVudFwiO1xuaW1wb3J0IHsgR0VUX0ZSSUVORFMgfSBmcm9tIFwiLi4vLi4vUHJpc21hL0ZyaWVuZFwiO1xuXG5jb25zdCBEcmF3ZXJGcmllbmQgPSAoKSA9PiB7XG4gIGNvbnN0IFtvcGVuRHJhd2VyLCBzZXRPcGVuRHJhd2VyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgeyBkYXRhLCBlcnJvciwgbG9hZGluZyB9ID0gdXNlUXVlcnkoR0VUX0ZSSUVORFMpO1xuXG4gIGlmIChsb2FkaW5nKSByZXR1cm4gPGRpdj5sb2FkaW5nLi4uPC9kaXY+O1xuICBpZiAoZXJyb3IpIHJldHVybiA8ZGl2PmVycm9yPC9kaXY+O1xuICBjb25zdCB7IGZyaWVuZHMgfSA9IGRhdGE7XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2PlxuICAgICAgPERyYXdlciBvcGVuPXtvcGVuRHJhd2VyfSBvbkNsb3NlPXsoKSA9PiBzZXRPcGVuRHJhd2VyKGZhbHNlKX0+XG4gICAgICAgIDxMaXN0PlxuICAgICAgICAgIHtmcmllbmRzLmxlbmd0aCA9PT0gMCAmJiA8ZGl2Pm5vIG9uZTwvZGl2Pn1cbiAgICAgICAgICB7ZnJpZW5kcy5tYXAoKGZyaWVuZCkgPT4gKFxuICAgICAgICAgICAgPGxpIGtleT17ZnJpZW5kLmlkfT5cbiAgICAgICAgICAgICAgPExpc3RJdGVtQnV0dG9uIGhyZWY9e1wiL0ZyaWVuZC9cIiArIGZyaWVuZC5uYW1lfT5cbiAgICAgICAgICAgICAgICA8TGlzdEl0ZW1UZXh0PntmcmllbmQubmFtZX08L0xpc3RJdGVtVGV4dD5cbiAgICAgICAgICAgICAgPC9MaXN0SXRlbUJ1dHRvbj5cbiAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgKSl9XG4gICAgICAgIDwvTGlzdD5cbiAgICAgIDwvRHJhd2VyPlxuICAgICAgPEljb25CdXR0b25cbiAgICAgICAgc3g9e3sgY29sb3I6IFwid2hpdGVcIiB9fVxuICAgICAgICBvbkNsaWNrPXsoKSA9PiBzZXRPcGVuRHJhd2VyKCFvcGVuRHJhd2VyKX1cbiAgICAgID5cbiAgICAgICAgPFJlY29yZFZvaWNlT3Zlckljb24gLz5cbiAgICAgIDwvSWNvbkJ1dHRvbj5cbiAgICA8L2Rpdj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IERyYXdlckZyaWVuZDtcbiJdLCJuYW1lcyI6WyJEcmF3ZXIiLCJJY29uQnV0dG9uIiwiTGlzdCIsIkxpc3RJdGVtQnV0dG9uIiwiTGlzdEl0ZW1UZXh0IiwiUmVhY3QiLCJ1c2VTdGF0ZSIsIlJlY29yZFZvaWNlT3Zlckljb24iLCJ1c2VRdWVyeSIsIkdFVF9GUklFTkRTIiwiRHJhd2VyRnJpZW5kIiwib3BlbkRyYXdlciIsInNldE9wZW5EcmF3ZXIiLCJkYXRhIiwiZXJyb3IiLCJsb2FkaW5nIiwiZGl2IiwiZnJpZW5kcyIsIm9wZW4iLCJvbkNsb3NlIiwibGVuZ3RoIiwibWFwIiwiZnJpZW5kIiwibGkiLCJocmVmIiwibmFtZSIsImlkIiwic3giLCJjb2xvciIsIm9uQ2xpY2siXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Header/DrawerFriend.tsx\n");

/***/ }),

/***/ "./src/components/Header/Header.tsx":
/*!******************************************!*\
  !*** ./src/components/Header/Header.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/material */ \"@mui/material\");\n/* harmony import */ var _mui_material__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mui_material__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _DrawerComp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./DrawerComp */ \"./src/components/Header/DrawerComp.tsx\");\n/* harmony import */ var _DrawerFriend__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DrawerFriend */ \"./src/components/Header/DrawerFriend.tsx\");\n\n\n\n\n\nconst Header = ()=>{\n    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    const theme = (0,_mui_material__WEBPACK_IMPORTED_MODULE_1__.useTheme)();\n    const isMatch = (0,_mui_material__WEBPACK_IMPORTED_MODULE_1__.useMediaQuery)(theme.breakpoints.down(\"md\"));\n    const PAGES = [\n        {\n            name: \"add friend\",\n            link: \"/Friend/Add\"\n        },\n        {\n            name: \"delete friend\",\n            link: \"/Friend/Delete\"\n        },\n        {\n            name: \"about me\",\n            link: \"nvoenv\"\n        },\n        {\n            name: \"contact me\",\n            link: \"nove\"\n        }\n    ];\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.AppBar, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Toolbar, {\n            children: [\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DrawerFriend__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                    fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n                    lineNumber: 29,\n                    columnNumber: 9\n                }, undefined),\n                isMatch ? /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Typography, {\n                            sx: {\n                                margin: \"auto\"\n                            },\n                            children: \"MEMO TO TALK\"\n                        }, void 0, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n                            lineNumber: 33,\n                            columnNumber: 13\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_DrawerComp__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n                            pages: PAGES\n                        }, void 0, false, {\n                            fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n                            lineNumber: 34,\n                            columnNumber: 13\n                        }, undefined)\n                    ]\n                }, void 0, true) : /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Tabs, {\n                        textColor: \"inherit\",\n                        sx: {\n                            marginLeft: \"auto\"\n                        },\n                        value: value,\n                        onChange: ()=>setValue,\n                        children: PAGES.map((page, index)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_mui_material__WEBPACK_IMPORTED_MODULE_1__.Tab, {\n                                label: page.name,\n                                href: page.link\n                            }, index, false, {\n                                fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n                                lineNumber: 45,\n                                columnNumber: 17\n                            }, undefined))\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n                        lineNumber: 38,\n                        columnNumber: 13\n                    }, undefined)\n                }, void 0, false)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n            lineNumber: 28,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/youta/type-front/src/components/Header/Header.tsx\",\n        lineNumber: 27,\n        columnNumber: 5\n    }, undefined);\n};\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvY29tcG9uZW50cy9IZWFkZXIvSGVhZGVyLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBQTtBQVN1QjtBQUNpQjtBQUNGO0FBQ0k7QUFFMUMsTUFBTVcsU0FBUyxJQUFNO0lBQ25CLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHTCwrQ0FBUUEsQ0FBQztJQUVuQyxNQUFNTSxRQUFRUix1REFBUUE7SUFDdEIsTUFBTVMsVUFBVVYsNERBQWFBLENBQUNTLE1BQU1FLFdBQVcsQ0FBQ0MsSUFBSSxDQUFDO0lBQ3JELE1BQU1DLFFBQVE7UUFDWjtZQUFFQyxNQUFNO1lBQWNDLE1BQU07UUFBYztRQUMxQztZQUFFRCxNQUFNO1lBQWlCQyxNQUFNO1FBQWlCO1FBQ2hEO1lBQUVELE1BQU07WUFBWUMsTUFBTTtRQUFTO1FBQ25DO1lBQUVELE1BQU07WUFBY0MsTUFBTTtRQUFPO0tBQ3BDO0lBQ0QscUJBQ0UsOERBQUNwQixpREFBTUE7a0JBQ0wsNEVBQUNHLGtEQUFPQTs7OEJBQ04sOERBQUNPLHFEQUFZQTs7Ozs7Z0JBRVpLLHdCQUNDOztzQ0FDRSw4REFBQ1gscURBQVVBOzRCQUFDaUIsSUFBSTtnQ0FBRUMsUUFBUTs0QkFBTztzQ0FBRzs7Ozs7O3NDQUNwQyw4REFBQ2IsbURBQVVBOzRCQUFDYyxPQUFPTDs7Ozs7OztpREFHckI7OEJBQ0UsNEVBQUNoQiwrQ0FBSUE7d0JBQ0hzQixXQUFVO3dCQUNWSCxJQUFJOzRCQUFFSSxZQUFZO3dCQUFPO3dCQUN6QmIsT0FBT0E7d0JBQ1BjLFVBQVUsSUFBTWI7a0NBRWZLLE1BQU1TLEdBQUcsQ0FBQyxDQUFDQyxNQUFNQyxzQkFDaEIsOERBQUM1Qiw4Q0FBR0E7Z0NBQWE2QixPQUFPRixLQUFLVCxJQUFJO2dDQUFFWSxNQUFNSCxLQUFLUixJQUFJOytCQUF4Q1M7Ozs7Ozs7Ozs7aUNBSWpCOzs7Ozs7Ozs7Ozs7QUFJVDtBQUVBLGlFQUFlbEIsTUFBTUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3R5cGVzY3JpcHQtcG9ydGZvbGlvLy4vc3JjL2NvbXBvbmVudHMvSGVhZGVyL0hlYWRlci50c3g/OGQyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBcHBCYXIsXG4gIEJ1dHRvbixcbiAgVGFiLFxuICBUYWJzLFxuICBUb29sYmFyLFxuICBUeXBvZ3JhcGh5LFxuICB1c2VNZWRpYVF1ZXJ5LFxuICB1c2VUaGVtZSxcbn0gZnJvbSBcIkBtdWkvbWF0ZXJpYWxcIjtcbmltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IERyYXdlckNvbXAgZnJvbSBcIi4vRHJhd2VyQ29tcFwiO1xuaW1wb3J0IERyYXdlckZyaWVuZCBmcm9tIFwiLi9EcmF3ZXJGcmllbmRcIjtcblxuY29uc3QgSGVhZGVyID0gKCkgPT4ge1xuICBjb25zdCBbdmFsdWUsIHNldFZhbHVlXSA9IHVzZVN0YXRlKDApO1xuXG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgaXNNYXRjaCA9IHVzZU1lZGlhUXVlcnkodGhlbWUuYnJlYWtwb2ludHMuZG93bihcIm1kXCIpKTtcbiAgY29uc3QgUEFHRVMgPSBbXG4gICAgeyBuYW1lOiBcImFkZCBmcmllbmRcIiwgbGluazogXCIvRnJpZW5kL0FkZFwiIH0sXG4gICAgeyBuYW1lOiBcImRlbGV0ZSBmcmllbmRcIiwgbGluazogXCIvRnJpZW5kL0RlbGV0ZVwiIH0sXG4gICAgeyBuYW1lOiBcImFib3V0IG1lXCIsIGxpbms6IFwibnZvZW52XCIgfSxcbiAgICB7IG5hbWU6IFwiY29udGFjdCBtZVwiLCBsaW5rOiBcIm5vdmVcIiB9LFxuICBdO1xuICByZXR1cm4gKFxuICAgIDxBcHBCYXI+XG4gICAgICA8VG9vbGJhcj5cbiAgICAgICAgPERyYXdlckZyaWVuZCAvPlxuXG4gICAgICAgIHtpc01hdGNoID8gKFxuICAgICAgICAgIDw+XG4gICAgICAgICAgICA8VHlwb2dyYXBoeSBzeD17eyBtYXJnaW46IFwiYXV0b1wiIH19Pk1FTU8gVE8gVEFMSzwvVHlwb2dyYXBoeT5cbiAgICAgICAgICAgIDxEcmF3ZXJDb21wIHBhZ2VzPXtQQUdFU30gLz5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKSA6IChcbiAgICAgICAgICA8PlxuICAgICAgICAgICAgPFRhYnNcbiAgICAgICAgICAgICAgdGV4dENvbG9yPVwiaW5oZXJpdFwiXG4gICAgICAgICAgICAgIHN4PXt7IG1hcmdpbkxlZnQ6IFwiYXV0b1wiIH19XG4gICAgICAgICAgICAgIHZhbHVlPXt2YWx1ZX1cbiAgICAgICAgICAgICAgb25DaGFuZ2U9eygpID0+IHNldFZhbHVlfVxuICAgICAgICAgICAgPlxuICAgICAgICAgICAgICB7UEFHRVMubWFwKChwYWdlLCBpbmRleCkgPT4gKFxuICAgICAgICAgICAgICAgIDxUYWIga2V5PXtpbmRleH0gbGFiZWw9e3BhZ2UubmFtZX0gaHJlZj17cGFnZS5saW5rfSAvPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDwvVGFicz5cbiAgICAgICAgICA8Lz5cbiAgICAgICAgKX1cbiAgICAgIDwvVG9vbGJhcj5cbiAgICA8L0FwcEJhcj5cbiAgKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEhlYWRlcjtcbiJdLCJuYW1lcyI6WyJBcHBCYXIiLCJUYWIiLCJUYWJzIiwiVG9vbGJhciIsIlR5cG9ncmFwaHkiLCJ1c2VNZWRpYVF1ZXJ5IiwidXNlVGhlbWUiLCJSZWFjdCIsInVzZVN0YXRlIiwiRHJhd2VyQ29tcCIsIkRyYXdlckZyaWVuZCIsIkhlYWRlciIsInZhbHVlIiwic2V0VmFsdWUiLCJ0aGVtZSIsImlzTWF0Y2giLCJicmVha3BvaW50cyIsImRvd24iLCJQQUdFUyIsIm5hbWUiLCJsaW5rIiwic3giLCJtYXJnaW4iLCJwYWdlcyIsInRleHRDb2xvciIsIm1hcmdpbkxlZnQiLCJvbkNoYW5nZSIsIm1hcCIsInBhZ2UiLCJpbmRleCIsImxhYmVsIiwiaHJlZiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/components/Header/Header.tsx\n");

/***/ }),

/***/ "./src/function/Reload.tsx":
/*!*********************************!*\
  !*** ./src/function/Reload.tsx ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"doReload\": () => (/* binding */ doReload)\n/* harmony export */ });\nconst doReload = ()=>{\n    location.reload();\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvZnVuY3Rpb24vUmVsb2FkLnRzeC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sTUFBTUEsV0FBVyxJQUFNO0lBQzdCQyxTQUFTQyxNQUFNO0FBQ2hCLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3NyYy9mdW5jdGlvbi9SZWxvYWQudHN4PzkyMDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IGRvUmVsb2FkID0gKCkgPT4ge1xuXHRsb2NhdGlvbi5yZWxvYWQoKVxufVxuIl0sIm5hbWVzIjpbImRvUmVsb2FkIiwibG9jYXRpb24iLCJyZWxvYWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/function/Reload.tsx\n");

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Home)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"react/jsx-dev-runtime\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Calendar_calendar__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/Calendar/calendar */ \"./src/components/Calendar/calendar.tsx\");\n/* harmony import */ var _components_Header_Header__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../components/Header/Header */ \"./src/components/Header/Header.tsx\");\n/* harmony import */ var _components_Friend_FriendList__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../components/Friend/FriendList */ \"./src/components/Friend/FriendList.tsx\");\n/* harmony import */ var _styles_app_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../styles/_app.module.css */ \"./styles/_app.module.css\");\n/* harmony import */ var _styles_app_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_styles_app_module_css__WEBPACK_IMPORTED_MODULE_5__);\n\n\n\n\n\n\nfunction Home() {\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((react__WEBPACK_IMPORTED_MODULE_1___default().StrictMode), {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Header_Header__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n                fileName: \"/Users/youta/type-front/src/pages/index.tsx\",\n                lineNumber: 12,\n                columnNumber: 9\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: (_styles_app_module_css__WEBPACK_IMPORTED_MODULE_5___default().flex),\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Calendar_calendar__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/pages/index.tsx\",\n                        lineNumber: 14,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: (_styles_app_module_css__WEBPACK_IMPORTED_MODULE_5___default().sub),\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Friend_FriendList__WEBPACK_IMPORTED_MODULE_4__[\"default\"], {}, void 0, false, {\n                            fileName: \"/Users/youta/type-front/src/pages/index.tsx\",\n                            lineNumber: 16,\n                            columnNumber: 13\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/youta/type-front/src/pages/index.tsx\",\n                        lineNumber: 15,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/youta/type-front/src/pages/index.tsx\",\n                lineNumber: 13,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/youta/type-front/src/pages/index.tsx\",\n        lineNumber: 11,\n        columnNumber: 5\n    }, this);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUEwQjtBQUU2QjtBQUNOO0FBQ1E7QUFDUjtBQUdsQyxTQUFTSyxPQUFPO0lBQzdCLHFCQUNFLDhEQUFDTCx5REFBZ0I7OzBCQUNiLDhEQUFDRSxpRUFBTUE7Ozs7OzBCQUNQLDhEQUFDSztnQkFBSUMsV0FBV0osb0VBQVc7O2tDQUN6Qiw4REFBQ0gscUVBQVFBOzs7OztrQ0FDVCw4REFBQ007d0JBQUlDLFdBQVdKLG1FQUFVO2tDQUN4Qiw0RUFBQ0QscUVBQVVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXZCLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL3NyYy9wYWdlcy9pbmRleC50c3g/MTlhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgVG9kbyBmcm9tIFwiLi4vY29tcG9uZW50cy9Ub2RvL1RvZG9cIjtcbmltcG9ydCBDYWxlbmRhciBmcm9tIFwiLi4vY29tcG9uZW50cy9DYWxlbmRhci9jYWxlbmRhclwiO1xuaW1wb3J0IEhlYWRlciBmcm9tIFwiLi4vY29tcG9uZW50cy9IZWFkZXIvSGVhZGVyXCI7XG5pbXBvcnQgRnJpZW5kTGlzdCBmcm9tIFwiLi4vY29tcG9uZW50cy9GcmllbmQvRnJpZW5kTGlzdFwiO1xuaW1wb3J0IHN0eWxlcyBmcm9tIFwiLi4vLi4vc3R5bGVzL19hcHAubW9kdWxlLmNzc1wiXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgcmV0dXJuIChcbiAgICA8UmVhY3QuU3RyaWN0TW9kZT5cbiAgICAgICAgPEhlYWRlciAvPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT17c3R5bGVzLmZsZXh9PlxuICAgICAgICAgIDxDYWxlbmRhciAvPlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuc3VifT5cbiAgICAgICAgICAgIDxGcmllbmRMaXN0IC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICB7LyogPFRvZG8gLz4gKi99XG4gICAgPC9SZWFjdC5TdHJpY3RNb2RlPlxuICApO1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiQ2FsZW5kYXIiLCJIZWFkZXIiLCJGcmllbmRMaXN0Iiwic3R5bGVzIiwiSG9tZSIsIlN0cmljdE1vZGUiLCJkaXYiLCJjbGFzc05hbWUiLCJmbGV4Iiwic3ViIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/main.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/common/main.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n;\nvar tslib = __webpack_require__(/*! tslib */ \"./node_modules/@fullcalendar/common/node_modules/tslib/tslib.es6.js\");\nvar vdom_cjs = __webpack_require__(/*! ./vdom.cjs */ \"./node_modules/@fullcalendar/common/vdom.cjs.js\");\n// no public types yet. when there are, export from:\n// import {} from './api-type-deps'\nvar EventSourceApi = /** @class */ function() {\n    function EventSourceApi(context, internalEventSource) {\n        this.context = context;\n        this.internalEventSource = internalEventSource;\n    }\n    EventSourceApi.prototype.remove = function() {\n        this.context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: this.internalEventSource.sourceId\n        });\n    };\n    EventSourceApi.prototype.refetch = function() {\n        this.context.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            sourceIds: [\n                this.internalEventSource.sourceId\n            ],\n            isRefetch: true\n        });\n    };\n    Object.defineProperty(EventSourceApi.prototype, \"id\", {\n        get: function() {\n            return this.internalEventSource.publicId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventSourceApi.prototype, \"url\", {\n        get: function() {\n            return this.internalEventSource.meta.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventSourceApi.prototype, \"format\", {\n        get: function() {\n            return this.internalEventSource.meta.format; // TODO: bad. not guaranteed\n        },\n        enumerable: false,\n        configurable: true\n    });\n    return EventSourceApi;\n}();\nfunction removeElement(el) {\n    if (el.parentNode) {\n        el.parentNode.removeChild(el);\n    }\n}\n// Querying\n// ----------------------------------------------------------------------------------------------------------------\nfunction elementClosest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    // really bad fallback for IE\n    // from https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n    }\n    if (!document.documentElement.contains(el)) {\n        return null;\n    }\n    do {\n        if (elementMatches(el, selector)) {\n            return el;\n        }\n        el = el.parentElement || el.parentNode;\n    }while (el !== null && el.nodeType === 1);\n    return null;\n}\nfunction elementMatches(el, selector) {\n    var method = el.matches || el.matchesSelector || el.msMatchesSelector;\n    return method.call(el, selector);\n}\n// accepts multiple subject els\n// returns a real array. good for methods like forEach\n// TODO: accept the document\nfunction findElements(container, selector) {\n    var containers = container instanceof HTMLElement ? [\n        container\n    ] : container;\n    var allMatches = [];\n    for(var i = 0; i < containers.length; i += 1){\n        var matches = containers[i].querySelectorAll(selector);\n        for(var j = 0; j < matches.length; j += 1){\n            allMatches.push(matches[j]);\n        }\n    }\n    return allMatches;\n}\n// accepts multiple subject els\n// only queries direct child elements // TODO: rename to findDirectChildren!\nfunction findDirectChildren(parent, selector) {\n    var parents = parent instanceof HTMLElement ? [\n        parent\n    ] : parent;\n    var allMatches = [];\n    for(var i = 0; i < parents.length; i += 1){\n        var childNodes = parents[i].children; // only ever elements\n        for(var j = 0; j < childNodes.length; j += 1){\n            var childNode = childNodes[j];\n            if (!selector || elementMatches(childNode, selector)) {\n                allMatches.push(childNode);\n            }\n        }\n    }\n    return allMatches;\n}\n// Style\n// ----------------------------------------------------------------------------------------------------------------\nvar PIXEL_PROP_RE = /(top|left|right|bottom|width|height)$/i;\nfunction applyStyle(el, props) {\n    for(var propName in props){\n        applyStyleProp(el, propName, props[propName]);\n    }\n}\nfunction applyStyleProp(el, name, val) {\n    if (val == null) {\n        el.style[name] = \"\";\n    } else if (typeof val === \"number\" && PIXEL_PROP_RE.test(name)) {\n        el.style[name] = val + \"px\";\n    } else {\n        el.style[name] = val;\n    }\n}\n// Event Handling\n// ----------------------------------------------------------------------------------------------------------------\n// if intercepting bubbled events at the document/window/body level,\n// and want to see originating element (the 'target'), use this util instead\n// of `ev.target` because it goes within web-component boundaries.\nfunction getEventTargetViaRoot(ev) {\n    var _a, _b;\n    return (_b = (_a = ev.composedPath) === null || _a === void 0 ? void 0 : _a.call(ev)[0]) !== null && _b !== void 0 ? _b : ev.target;\n}\n// Shadow DOM consuderations\n// ----------------------------------------------------------------------------------------------------------------\nfunction getElRoot(el) {\n    return el.getRootNode ? el.getRootNode() : document;\n}\n// Unique ID for DOM attribute\nvar guid$1 = 0;\nfunction getUniqueDomId() {\n    guid$1 += 1;\n    return \"fc-dom-\" + guid$1;\n}\n// Stops a mouse/touch event from doing it's native browser action\nfunction preventDefault(ev) {\n    ev.preventDefault();\n}\n// Event Delegation\n// ----------------------------------------------------------------------------------------------------------------\nfunction buildDelegationHandler(selector, handler) {\n    return function(ev) {\n        var matchedChild = elementClosest(ev.target, selector);\n        if (matchedChild) {\n            handler.call(matchedChild, ev, matchedChild);\n        }\n    };\n}\nfunction listenBySelector(container, eventType, selector, handler) {\n    var attachedHandler = buildDelegationHandler(selector, handler);\n    container.addEventListener(eventType, attachedHandler);\n    return function() {\n        container.removeEventListener(eventType, attachedHandler);\n    };\n}\nfunction listenToHoverBySelector(container, selector, onMouseEnter, onMouseLeave) {\n    var currentMatchedChild;\n    return listenBySelector(container, \"mouseover\", selector, function(mouseOverEv, matchedChild) {\n        if (matchedChild !== currentMatchedChild) {\n            currentMatchedChild = matchedChild;\n            onMouseEnter(mouseOverEv, matchedChild);\n            var realOnMouseLeave_1 = function(mouseLeaveEv) {\n                currentMatchedChild = null;\n                onMouseLeave(mouseLeaveEv, matchedChild);\n                matchedChild.removeEventListener(\"mouseleave\", realOnMouseLeave_1);\n            };\n            // listen to the next mouseleave, and then unattach\n            matchedChild.addEventListener(\"mouseleave\", realOnMouseLeave_1);\n        }\n    });\n}\n// Animation\n// ----------------------------------------------------------------------------------------------------------------\nvar transitionEventNames = [\n    \"webkitTransitionEnd\",\n    \"otransitionend\",\n    \"oTransitionEnd\",\n    \"msTransitionEnd\",\n    \"transitionend\"\n];\n// triggered only when the next single subsequent transition finishes\nfunction whenTransitionDone(el, callback) {\n    var realCallback = function(ev) {\n        callback(ev);\n        transitionEventNames.forEach(function(eventName) {\n            el.removeEventListener(eventName, realCallback);\n        });\n    };\n    transitionEventNames.forEach(function(eventName) {\n        el.addEventListener(eventName, realCallback); // cross-browser way to determine when the transition finishes\n    });\n}\n// ARIA workarounds\n// ----------------------------------------------------------------------------------------------------------------\nfunction createAriaClickAttrs(handler) {\n    return tslib.__assign({\n        onClick: handler\n    }, createAriaKeyboardAttrs(handler));\n}\nfunction createAriaKeyboardAttrs(handler) {\n    return {\n        tabIndex: 0,\n        onKeyDown: function(ev) {\n            if (ev.key === \"Enter\" || ev.key === \" \") {\n                handler(ev);\n                ev.preventDefault(); // if space, don't scroll down page\n            }\n        }\n    };\n}\nvar guidNumber = 0;\nfunction guid() {\n    guidNumber += 1;\n    return String(guidNumber);\n}\n/* FullCalendar-specific DOM Utilities\n----------------------------------------------------------------------------------------------------------------------*/ // Make the mouse cursor express that an event is not allowed in the current area\nfunction disableCursor() {\n    document.body.classList.add(\"fc-not-allowed\");\n}\n// Returns the mouse cursor to its original look\nfunction enableCursor() {\n    document.body.classList.remove(\"fc-not-allowed\");\n}\n/* Selection\n----------------------------------------------------------------------------------------------------------------------*/ function preventSelection(el) {\n    el.classList.add(\"fc-unselectable\");\n    el.addEventListener(\"selectstart\", preventDefault);\n}\nfunction allowSelection(el) {\n    el.classList.remove(\"fc-unselectable\");\n    el.removeEventListener(\"selectstart\", preventDefault);\n}\n/* Context Menu\n----------------------------------------------------------------------------------------------------------------------*/ function preventContextMenu(el) {\n    el.addEventListener(\"contextmenu\", preventDefault);\n}\nfunction allowContextMenu(el) {\n    el.removeEventListener(\"contextmenu\", preventDefault);\n}\nfunction parseFieldSpecs(input) {\n    var specs = [];\n    var tokens = [];\n    var i;\n    var token;\n    if (typeof input === \"string\") {\n        tokens = input.split(/\\s*,\\s*/);\n    } else if (typeof input === \"function\") {\n        tokens = [\n            input\n        ];\n    } else if (Array.isArray(input)) {\n        tokens = input;\n    }\n    for(i = 0; i < tokens.length; i += 1){\n        token = tokens[i];\n        if (typeof token === \"string\") {\n            specs.push(token.charAt(0) === \"-\" ? {\n                field: token.substring(1),\n                order: -1\n            } : {\n                field: token,\n                order: 1\n            });\n        } else if (typeof token === \"function\") {\n            specs.push({\n                func: token\n            });\n        }\n    }\n    return specs;\n}\nfunction compareByFieldSpecs(obj0, obj1, fieldSpecs) {\n    var i;\n    var cmp;\n    for(i = 0; i < fieldSpecs.length; i += 1){\n        cmp = compareByFieldSpec(obj0, obj1, fieldSpecs[i]);\n        if (cmp) {\n            return cmp;\n        }\n    }\n    return 0;\n}\nfunction compareByFieldSpec(obj0, obj1, fieldSpec) {\n    if (fieldSpec.func) {\n        return fieldSpec.func(obj0, obj1);\n    }\n    return flexibleCompare(obj0[fieldSpec.field], obj1[fieldSpec.field]) * (fieldSpec.order || 1);\n}\nfunction flexibleCompare(a, b) {\n    if (!a && !b) {\n        return 0;\n    }\n    if (b == null) {\n        return -1;\n    }\n    if (a == null) {\n        return 1;\n    }\n    if (typeof a === \"string\" || typeof b === \"string\") {\n        return String(a).localeCompare(String(b));\n    }\n    return a - b;\n}\n/* String Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function padStart(val, len) {\n    var s = String(val);\n    return \"000\".substr(0, len - s.length) + s;\n}\nfunction formatWithOrdinals(formatter, args, fallbackText) {\n    if (typeof formatter === \"function\") {\n        return formatter.apply(void 0, args);\n    }\n    if (typeof formatter === \"string\") {\n        return args.reduce(function(str, arg, index) {\n            return str.replace(\"$\" + index, arg || \"\");\n        }, formatter);\n    }\n    return fallbackText;\n}\n/* Number Utilities\n----------------------------------------------------------------------------------------------------------------------*/ function compareNumbers(a, b) {\n    return a - b;\n}\nfunction isInt(n) {\n    return n % 1 === 0;\n}\n/* FC-specific DOM dimension stuff\n----------------------------------------------------------------------------------------------------------------------*/ function computeSmallestCellWidth(cellEl) {\n    var allWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-frame\");\n    var contentWidthEl = cellEl.querySelector(\".fc-scrollgrid-shrink-cushion\");\n    if (!allWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-frame className\"); // TODO: use const\n    }\n    if (!contentWidthEl) {\n        throw new Error(\"needs fc-scrollgrid-shrink-cushion className\");\n    }\n    return cellEl.getBoundingClientRect().width - allWidthEl.getBoundingClientRect().width + // the cell padding+border\n    contentWidthEl.getBoundingClientRect().width;\n}\nvar DAY_IDS = [\n    \"sun\",\n    \"mon\",\n    \"tue\",\n    \"wed\",\n    \"thu\",\n    \"fri\",\n    \"sat\"\n];\n// Adding\nfunction addWeeks(m, n) {\n    var a = dateToUtcArray(m);\n    a[2] += n * 7;\n    return arrayToUtcDate(a);\n}\nfunction addDays(m, n) {\n    var a = dateToUtcArray(m);\n    a[2] += n;\n    return arrayToUtcDate(a);\n}\nfunction addMs(m, n) {\n    var a = dateToUtcArray(m);\n    a[6] += n;\n    return arrayToUtcDate(a);\n}\n// Diffing (all return floats)\n// TODO: why not use ranges?\nfunction diffWeeks(m0, m1) {\n    return diffDays(m0, m1) / 7;\n}\nfunction diffDays(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60 * 24);\n}\nfunction diffHours(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60 * 60);\n}\nfunction diffMinutes(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / (1000 * 60);\n}\nfunction diffSeconds(m0, m1) {\n    return (m1.valueOf() - m0.valueOf()) / 1000;\n}\nfunction diffDayAndTime(m0, m1) {\n    var m0day = startOfDay(m0);\n    var m1day = startOfDay(m1);\n    return {\n        years: 0,\n        months: 0,\n        days: Math.round(diffDays(m0day, m1day)),\n        milliseconds: m1.valueOf() - m1day.valueOf() - (m0.valueOf() - m0day.valueOf())\n    };\n}\n// Diffing Whole Units\nfunction diffWholeWeeks(m0, m1) {\n    var d = diffWholeDays(m0, m1);\n    if (d !== null && d % 7 === 0) {\n        return d / 7;\n    }\n    return null;\n}\nfunction diffWholeDays(m0, m1) {\n    if (timeAsMs(m0) === timeAsMs(m1)) {\n        return Math.round(diffDays(m0, m1));\n    }\n    return null;\n}\n// Start-Of\nfunction startOfDay(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate()\n    ]);\n}\nfunction startOfHour(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours()\n    ]);\n}\nfunction startOfMinute(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes()\n    ]);\n}\nfunction startOfSecond(m) {\n    return arrayToUtcDate([\n        m.getUTCFullYear(),\n        m.getUTCMonth(),\n        m.getUTCDate(),\n        m.getUTCHours(),\n        m.getUTCMinutes(),\n        m.getUTCSeconds()\n    ]);\n}\n// Week Computation\nfunction weekOfYear(marker, dow, doy) {\n    var y = marker.getUTCFullYear();\n    var w = weekOfGivenYear(marker, y, dow, doy);\n    if (w < 1) {\n        return weekOfGivenYear(marker, y - 1, dow, doy);\n    }\n    var nextW = weekOfGivenYear(marker, y + 1, dow, doy);\n    if (nextW >= 1) {\n        return Math.min(w, nextW);\n    }\n    return w;\n}\nfunction weekOfGivenYear(marker, year, dow, doy) {\n    var firstWeekStart = arrayToUtcDate([\n        year,\n        0,\n        1 + firstWeekOffset(year, dow, doy)\n    ]);\n    var dayStart = startOfDay(marker);\n    var days = Math.round(diffDays(firstWeekStart, dayStart));\n    return Math.floor(days / 7) + 1; // zero-indexed\n}\n// start-of-first-week - start-of-year\nfunction firstWeekOffset(year, dow, doy) {\n    // first-week day -- which january is always in the first week (4 for iso, 1 for other)\n    var fwd = 7 + dow - doy;\n    // first-week day local weekday -- which local weekday is fwd\n    var fwdlw = (7 + arrayToUtcDate([\n        year,\n        0,\n        fwd\n    ]).getUTCDay() - dow) % 7;\n    return -fwdlw + fwd - 1;\n}\n// Array Conversion\nfunction dateToLocalArray(date) {\n    return [\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds(),\n        date.getMilliseconds()\n    ];\n}\nfunction arrayToLocalDate(a) {\n    return new Date(a[0], a[1] || 0, a[2] == null ? 1 : a[2], a[3] || 0, a[4] || 0, a[5] || 0);\n}\nfunction dateToUtcArray(date) {\n    return [\n        date.getUTCFullYear(),\n        date.getUTCMonth(),\n        date.getUTCDate(),\n        date.getUTCHours(),\n        date.getUTCMinutes(),\n        date.getUTCSeconds(),\n        date.getUTCMilliseconds()\n    ];\n}\nfunction arrayToUtcDate(a) {\n    // according to web standards (and Safari), a month index is required.\n    // massage if only given a year.\n    if (a.length === 1) {\n        a = a.concat([\n            0\n        ]);\n    }\n    return new Date(Date.UTC.apply(Date, a));\n}\n// Other Utils\nfunction isValidDate(m) {\n    return !isNaN(m.valueOf());\n}\nfunction timeAsMs(m) {\n    return m.getUTCHours() * 1000 * 60 * 60 + m.getUTCMinutes() * 1000 * 60 + m.getUTCSeconds() * 1000 + m.getUTCMilliseconds();\n}\nfunction createEventInstance(defId, range, forcedStartTzo, forcedEndTzo) {\n    return {\n        instanceId: guid(),\n        defId: defId,\n        range: range,\n        forcedStartTzo: forcedStartTzo == null ? null : forcedStartTzo,\n        forcedEndTzo: forcedEndTzo == null ? null : forcedEndTzo\n    };\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n// Merges an array of objects into a single object.\n// The second argument allows for an array of property names who's object values will be merged together.\nfunction mergeProps(propObjs, complexPropsMap) {\n    var dest = {};\n    if (complexPropsMap) {\n        for(var name_1 in complexPropsMap){\n            var complexObjs = [];\n            // collect the trailing object values, stopping when a non-object is discovered\n            for(var i = propObjs.length - 1; i >= 0; i -= 1){\n                var val = propObjs[i][name_1];\n                if (typeof val === \"object\" && val) {\n                    complexObjs.unshift(val);\n                } else if (val !== undefined) {\n                    dest[name_1] = val; // if there were no objects, this value will be used\n                    break;\n                }\n            }\n            // if the trailing values were objects, use the merged value\n            if (complexObjs.length) {\n                dest[name_1] = mergeProps(complexObjs);\n            }\n        }\n    }\n    // copy values into the destination, going from last to first\n    for(var i = propObjs.length - 1; i >= 0; i -= 1){\n        var props = propObjs[i];\n        for(var name_2 in props){\n            if (!(name_2 in dest)) {\n                dest[name_2] = props[name_2];\n            }\n        }\n    }\n    return dest;\n}\nfunction filterHash(hash, func) {\n    var filtered = {};\n    for(var key in hash){\n        if (func(hash[key], key)) {\n            filtered[key] = hash[key];\n        }\n    }\n    return filtered;\n}\nfunction mapHash(hash, func) {\n    var newHash = {};\n    for(var key in hash){\n        newHash[key] = func(hash[key], key);\n    }\n    return newHash;\n}\nfunction arrayToHash(a) {\n    var hash = {};\n    for(var _i = 0, a_1 = a; _i < a_1.length; _i++){\n        var item = a_1[_i];\n        hash[item] = true;\n    }\n    return hash;\n}\nfunction buildHashFromArray(a, func) {\n    var hash = {};\n    for(var i = 0; i < a.length; i += 1){\n        var tuple = func(a[i], i);\n        hash[tuple[0]] = tuple[1];\n    }\n    return hash;\n}\nfunction hashValuesToArray(obj) {\n    var a = [];\n    for(var key in obj){\n        a.push(obj[key]);\n    }\n    return a;\n}\nfunction isPropsEqual(obj0, obj1) {\n    if (obj0 === obj1) {\n        return true;\n    }\n    for(var key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                return false;\n            }\n        }\n    }\n    for(var key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction getUnequalProps(obj0, obj1) {\n    var keys = [];\n    for(var key in obj0){\n        if (hasOwnProperty.call(obj0, key)) {\n            if (!(key in obj1)) {\n                keys.push(key);\n            }\n        }\n    }\n    for(var key in obj1){\n        if (hasOwnProperty.call(obj1, key)) {\n            if (obj0[key] !== obj1[key]) {\n                keys.push(key);\n            }\n        }\n    }\n    return keys;\n}\nfunction compareObjs(oldProps, newProps, equalityFuncs) {\n    if (equalityFuncs === void 0) {\n        equalityFuncs = {};\n    }\n    if (oldProps === newProps) {\n        return true;\n    }\n    for(var key in newProps){\n        if (key in oldProps && isObjValsEqual(oldProps[key], newProps[key], equalityFuncs[key])) ;\n        else {\n            return false;\n        }\n    }\n    // check for props that were omitted in the new\n    for(var key in oldProps){\n        if (!(key in newProps)) {\n            return false;\n        }\n    }\n    return true;\n}\n/*\nassumed \"true\" equality for handler names like \"onReceiveSomething\"\n*/ function isObjValsEqual(val0, val1, comparator) {\n    if (val0 === val1 || comparator === true) {\n        return true;\n    }\n    if (comparator) {\n        return comparator(val0, val1);\n    }\n    return false;\n}\nfunction collectFromHash(hash, startIndex, endIndex, step) {\n    if (startIndex === void 0) {\n        startIndex = 0;\n    }\n    if (step === void 0) {\n        step = 1;\n    }\n    var res = [];\n    if (endIndex == null) {\n        endIndex = Object.keys(hash).length;\n    }\n    for(var i = startIndex; i < endIndex; i += step){\n        var val = hash[i];\n        if (val !== undefined) {\n            res.push(val);\n        }\n    }\n    return res;\n}\nfunction parseRecurring(refined, defaultAllDay, dateEnv, recurringTypes) {\n    for(var i = 0; i < recurringTypes.length; i += 1){\n        var parsed = recurringTypes[i].parse(refined, dateEnv);\n        if (parsed) {\n            var allDay = refined.allDay;\n            if (allDay == null) {\n                allDay = defaultAllDay;\n                if (allDay == null) {\n                    allDay = parsed.allDayGuess;\n                    if (allDay == null) {\n                        allDay = false;\n                    }\n                }\n            }\n            return {\n                allDay: allDay,\n                duration: parsed.duration,\n                typeData: parsed.typeData,\n                typeId: i\n            };\n        }\n    }\n    return null;\n}\nfunction expandRecurring(eventStore, framingRange, context) {\n    var dateEnv = context.dateEnv, pluginHooks = context.pluginHooks, options = context.options;\n    var defs = eventStore.defs, instances = eventStore.instances;\n    // remove existing recurring instances\n    // TODO: bad. always expand events as a second step\n    instances = filterHash(instances, function(instance) {\n        return !defs[instance.defId].recurringDef;\n    });\n    for(var defId in defs){\n        var def = defs[defId];\n        if (def.recurringDef) {\n            var duration = def.recurringDef.duration;\n            if (!duration) {\n                duration = def.allDay ? options.defaultAllDayEventDuration : options.defaultTimedEventDuration;\n            }\n            var starts = expandRecurringRanges(def, duration, framingRange, dateEnv, pluginHooks.recurringTypes);\n            for(var _i = 0, starts_1 = starts; _i < starts_1.length; _i++){\n                var start = starts_1[_i];\n                var instance = createEventInstance(defId, {\n                    start: start,\n                    end: dateEnv.add(start, duration)\n                });\n                instances[instance.instanceId] = instance;\n            }\n        }\n    }\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\n/*\nEvent MUST have a recurringDef\n*/ function expandRecurringRanges(eventDef, duration, framingRange, dateEnv, recurringTypes) {\n    var typeDef = recurringTypes[eventDef.recurringDef.typeId];\n    var markers = typeDef.expand(eventDef.recurringDef.typeData, {\n        start: dateEnv.subtract(framingRange.start, duration),\n        end: framingRange.end\n    }, dateEnv);\n    // the recurrence plugins don't guarantee that all-day events are start-of-day, so we have to\n    if (eventDef.allDay) {\n        markers = markers.map(startOfDay);\n    }\n    return markers;\n}\nvar INTERNAL_UNITS = [\n    \"years\",\n    \"months\",\n    \"days\",\n    \"milliseconds\"\n];\nvar PARSE_RE = /^(-?)(?:(\\d+)\\.)?(\\d+):(\\d\\d)(?::(\\d\\d)(?:\\.(\\d\\d\\d))?)?/;\n// Parsing and Creation\nfunction createDuration(input, unit) {\n    var _a;\n    if (typeof input === \"string\") {\n        return parseString(input);\n    }\n    if (typeof input === \"object\" && input) {\n        return parseObject(input);\n    }\n    if (typeof input === \"number\") {\n        return parseObject((_a = {}, _a[unit || \"milliseconds\"] = input, _a));\n    }\n    return null;\n}\nfunction parseString(s) {\n    var m = PARSE_RE.exec(s);\n    if (m) {\n        var sign = m[1] ? -1 : 1;\n        return {\n            years: 0,\n            months: 0,\n            days: sign * (m[2] ? parseInt(m[2], 10) : 0),\n            milliseconds: sign * ((m[3] ? parseInt(m[3], 10) : 0) * 60 * 60 * 1000 + // hours\n            (m[4] ? parseInt(m[4], 10) : 0) * 60 * 1000 + // minutes\n            (m[5] ? parseInt(m[5], 10) : 0) * 1000 + // seconds\n            (m[6] ? parseInt(m[6], 10) : 0 // ms\n            ))\n        };\n    }\n    return null;\n}\nfunction parseObject(obj) {\n    var duration = {\n        years: obj.years || obj.year || 0,\n        months: obj.months || obj.month || 0,\n        days: obj.days || obj.day || 0,\n        milliseconds: (obj.hours || obj.hour || 0) * 60 * 60 * 1000 + // hours\n        (obj.minutes || obj.minute || 0) * 60 * 1000 + // minutes\n        (obj.seconds || obj.second || 0) * 1000 + // seconds\n        (obj.milliseconds || obj.millisecond || obj.ms || 0)\n    };\n    var weeks = obj.weeks || obj.week;\n    if (weeks) {\n        duration.days += weeks * 7;\n        duration.specifiedWeeks = true;\n    }\n    return duration;\n}\n// Equality\nfunction durationsEqual(d0, d1) {\n    return d0.years === d1.years && d0.months === d1.months && d0.days === d1.days && d0.milliseconds === d1.milliseconds;\n}\nfunction asCleanDays(dur) {\n    if (!dur.years && !dur.months && !dur.milliseconds) {\n        return dur.days;\n    }\n    return 0;\n}\n// Simple Math\nfunction addDurations(d0, d1) {\n    return {\n        years: d0.years + d1.years,\n        months: d0.months + d1.months,\n        days: d0.days + d1.days,\n        milliseconds: d0.milliseconds + d1.milliseconds\n    };\n}\nfunction subtractDurations(d1, d0) {\n    return {\n        years: d1.years - d0.years,\n        months: d1.months - d0.months,\n        days: d1.days - d0.days,\n        milliseconds: d1.milliseconds - d0.milliseconds\n    };\n}\nfunction multiplyDuration(d, n) {\n    return {\n        years: d.years * n,\n        months: d.months * n,\n        days: d.days * n,\n        milliseconds: d.milliseconds * n\n    };\n}\n// Conversions\n// \"Rough\" because they are based on average-case Gregorian months/years\nfunction asRoughYears(dur) {\n    return asRoughDays(dur) / 365;\n}\nfunction asRoughMonths(dur) {\n    return asRoughDays(dur) / 30;\n}\nfunction asRoughDays(dur) {\n    return asRoughMs(dur) / 864e5;\n}\nfunction asRoughMinutes(dur) {\n    return asRoughMs(dur) / (1000 * 60);\n}\nfunction asRoughSeconds(dur) {\n    return asRoughMs(dur) / 1000;\n}\nfunction asRoughMs(dur) {\n    return dur.years * (365 * 864e5) + dur.months * (30 * 864e5) + dur.days * 864e5 + dur.milliseconds;\n}\n// Advanced Math\nfunction wholeDivideDurations(numerator, denominator) {\n    var res = null;\n    for(var i = 0; i < INTERNAL_UNITS.length; i += 1){\n        var unit = INTERNAL_UNITS[i];\n        if (denominator[unit]) {\n            var localRes = numerator[unit] / denominator[unit];\n            if (!isInt(localRes) || res !== null && res !== localRes) {\n                return null;\n            }\n            res = localRes;\n        } else if (numerator[unit]) {\n            // needs to divide by something but can't!\n            return null;\n        }\n    }\n    return res;\n}\nfunction greatestDurationDenominator(dur) {\n    var ms = dur.milliseconds;\n    if (ms) {\n        if (ms % 1000 !== 0) {\n            return {\n                unit: \"millisecond\",\n                value: ms\n            };\n        }\n        if (ms % (1000 * 60) !== 0) {\n            return {\n                unit: \"second\",\n                value: ms / 1000\n            };\n        }\n        if (ms % (1000 * 60 * 60) !== 0) {\n            return {\n                unit: \"minute\",\n                value: ms / (1000 * 60)\n            };\n        }\n        if (ms) {\n            return {\n                unit: \"hour\",\n                value: ms / (1000 * 60 * 60)\n            };\n        }\n    }\n    if (dur.days) {\n        if (dur.specifiedWeeks && dur.days % 7 === 0) {\n            return {\n                unit: \"week\",\n                value: dur.days / 7\n            };\n        }\n        return {\n            unit: \"day\",\n            value: dur.days\n        };\n    }\n    if (dur.months) {\n        return {\n            unit: \"month\",\n            value: dur.months\n        };\n    }\n    if (dur.years) {\n        return {\n            unit: \"year\",\n            value: dur.years\n        };\n    }\n    return {\n        unit: \"millisecond\",\n        value: 0\n    };\n}\n// timeZoneOffset is in minutes\nfunction buildIsoString(marker, timeZoneOffset, stripZeroTime) {\n    if (stripZeroTime === void 0) {\n        stripZeroTime = false;\n    }\n    var s = marker.toISOString();\n    s = s.replace(\".000\", \"\");\n    if (stripZeroTime) {\n        s = s.replace(\"T00:00:00Z\", \"\");\n    }\n    if (s.length > 10) {\n        if (timeZoneOffset == null) {\n            s = s.replace(\"Z\", \"\");\n        } else if (timeZoneOffset !== 0) {\n            s = s.replace(\"Z\", formatTimeZoneOffset(timeZoneOffset, true));\n        }\n    // otherwise, its UTC-0 and we want to keep the Z\n    }\n    return s;\n}\n// formats the date, but with no time part\n// TODO: somehow merge with buildIsoString and stripZeroTime\n// TODO: rename. omit \"string\"\nfunction formatDayString(marker) {\n    return marker.toISOString().replace(/T.*$/, \"\");\n}\n// TODO: use Date::toISOString and use everything after the T?\nfunction formatIsoTimeString(marker) {\n    return padStart(marker.getUTCHours(), 2) + \":\" + padStart(marker.getUTCMinutes(), 2) + \":\" + padStart(marker.getUTCSeconds(), 2);\n}\nfunction formatTimeZoneOffset(minutes, doIso) {\n    if (doIso === void 0) {\n        doIso = false;\n    }\n    var sign = minutes < 0 ? \"-\" : \"+\";\n    var abs = Math.abs(minutes);\n    var hours = Math.floor(abs / 60);\n    var mins = Math.round(abs % 60);\n    if (doIso) {\n        return sign + padStart(hours, 2) + \":\" + padStart(mins, 2);\n    }\n    return \"GMT\" + sign + hours + (mins ? \":\" + padStart(mins, 2) : \"\");\n}\n// TODO: new util arrayify?\nfunction removeExact(array, exactVal) {\n    var removeCnt = 0;\n    var i = 0;\n    while(i < array.length){\n        if (array[i] === exactVal) {\n            array.splice(i, 1);\n            removeCnt += 1;\n        } else {\n            i += 1;\n        }\n    }\n    return removeCnt;\n}\nfunction isArraysEqual(a0, a1, equalityFunc) {\n    if (a0 === a1) {\n        return true;\n    }\n    var len = a0.length;\n    var i;\n    if (len !== a1.length) {\n        return false;\n    }\n    for(i = 0; i < len; i += 1){\n        if (!(equalityFunc ? equalityFunc(a0[i], a1[i]) : a0[i] === a1[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction memoize(workerFunc, resEquality, teardownFunc) {\n    var currentArgs;\n    var currentRes;\n    return function() {\n        var newArgs = [];\n        for(var _i = 0; _i < arguments.length; _i++){\n            newArgs[_i] = arguments[_i];\n        }\n        if (!currentArgs) {\n            currentRes = workerFunc.apply(this, newArgs);\n        } else if (!isArraysEqual(currentArgs, newArgs)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            var res = workerFunc.apply(this, newArgs);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArgs = newArgs;\n        return currentRes;\n    };\n}\nfunction memoizeObjArg(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArg;\n    var currentRes;\n    return function(newArg) {\n        if (!currentArg) {\n            currentRes = workerFunc.call(_this, newArg);\n        } else if (!isPropsEqual(currentArg, newArg)) {\n            if (teardownFunc) {\n                teardownFunc(currentRes);\n            }\n            var res = workerFunc.call(_this, newArg);\n            if (!resEquality || !resEquality(res, currentRes)) {\n                currentRes = res;\n            }\n        }\n        currentArg = newArg;\n        return currentRes;\n    };\n}\nfunction memoizeArraylike(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArgSets = [];\n    var currentResults = [];\n    return function(newArgSets) {\n        var currentLen = currentArgSets.length;\n        var newLen = newArgSets.length;\n        var i = 0;\n        for(; i < currentLen; i += 1){\n            if (!newArgSets[i]) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n            } else if (!isArraysEqual(currentArgSets[i], newArgSets[i])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResults[i]);\n                }\n                var res = workerFunc.apply(_this, newArgSets[i]);\n                if (!resEquality || !resEquality(res, currentResults[i])) {\n                    currentResults[i] = res;\n                }\n            }\n        }\n        for(; i < newLen; i += 1){\n            currentResults[i] = workerFunc.apply(_this, newArgSets[i]);\n        }\n        currentArgSets = newArgSets;\n        currentResults.splice(newLen); // remove excess\n        return currentResults;\n    };\n}\nfunction memoizeHashlike(workerFunc, resEquality, teardownFunc) {\n    var _this = this;\n    var currentArgHash = {};\n    var currentResHash = {};\n    return function(newArgHash) {\n        var newResHash = {};\n        for(var key in newArgHash){\n            if (!currentResHash[key]) {\n                newResHash[key] = workerFunc.apply(_this, newArgHash[key]);\n            } else if (!isArraysEqual(currentArgHash[key], newArgHash[key])) {\n                if (teardownFunc) {\n                    teardownFunc(currentResHash[key]);\n                }\n                var res = workerFunc.apply(_this, newArgHash[key]);\n                newResHash[key] = resEquality && resEquality(res, currentResHash[key]) ? currentResHash[key] : res;\n            } else {\n                newResHash[key] = currentResHash[key];\n            }\n        }\n        currentArgHash = newArgHash;\n        currentResHash = newResHash;\n        return newResHash;\n    };\n}\nvar EXTENDED_SETTINGS_AND_SEVERITIES = {\n    week: 3,\n    separator: 0,\n    omitZeroMinute: 0,\n    meridiem: 0,\n    omitCommas: 0\n};\nvar STANDARD_DATE_PROP_SEVERITIES = {\n    timeZoneName: 7,\n    era: 6,\n    year: 5,\n    month: 4,\n    day: 2,\n    weekday: 2,\n    hour: 1,\n    minute: 1,\n    second: 1\n};\nvar MERIDIEM_RE = /\\s*([ap])\\.?m\\.?/i; // eats up leading spaces too\nvar COMMA_RE = /,/g; // we need re for globalness\nvar MULTI_SPACE_RE = /\\s+/g;\nvar LTR_RE = /\\u200e/g; // control character\nvar UTC_RE = /UTC|GMT/;\nvar NativeFormatter = /** @class */ function() {\n    function NativeFormatter(formatSettings) {\n        var standardDateProps = {};\n        var extendedSettings = {};\n        var severity = 0;\n        for(var name_1 in formatSettings){\n            if (name_1 in EXTENDED_SETTINGS_AND_SEVERITIES) {\n                extendedSettings[name_1] = formatSettings[name_1];\n                severity = Math.max(EXTENDED_SETTINGS_AND_SEVERITIES[name_1], severity);\n            } else {\n                standardDateProps[name_1] = formatSettings[name_1];\n                if (name_1 in STANDARD_DATE_PROP_SEVERITIES) {\n                    severity = Math.max(STANDARD_DATE_PROP_SEVERITIES[name_1], severity);\n                }\n            }\n        }\n        this.standardDateProps = standardDateProps;\n        this.extendedSettings = extendedSettings;\n        this.severity = severity;\n        this.buildFormattingFunc = memoize(buildFormattingFunc);\n    }\n    NativeFormatter.prototype.format = function(date, context) {\n        return this.buildFormattingFunc(this.standardDateProps, this.extendedSettings, context)(date);\n    };\n    NativeFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        var _a = this, standardDateProps = _a.standardDateProps, extendedSettings = _a.extendedSettings;\n        var diffSeverity = computeMarkerDiffSeverity(start.marker, end.marker, context.calendarSystem);\n        if (!diffSeverity) {\n            return this.format(start, context);\n        }\n        var biggestUnitForPartial = diffSeverity;\n        if (biggestUnitForPartial > 1 && // the two dates are different in a way that's larger scale than time\n        (standardDateProps.year === \"numeric\" || standardDateProps.year === \"2-digit\") && (standardDateProps.month === \"numeric\" || standardDateProps.month === \"2-digit\") && (standardDateProps.day === \"numeric\" || standardDateProps.day === \"2-digit\")) {\n            biggestUnitForPartial = 1; // make it look like the dates are only different in terms of time\n        }\n        var full0 = this.format(start, context);\n        var full1 = this.format(end, context);\n        if (full0 === full1) {\n            return full0;\n        }\n        var partialDateProps = computePartialFormattingOptions(standardDateProps, biggestUnitForPartial);\n        var partialFormattingFunc = buildFormattingFunc(partialDateProps, extendedSettings, context);\n        var partial0 = partialFormattingFunc(start);\n        var partial1 = partialFormattingFunc(end);\n        var insertion = findCommonInsertion(full0, partial0, full1, partial1);\n        var separator = extendedSettings.separator || betterDefaultSeparator || context.defaultSeparator || \"\";\n        if (insertion) {\n            return insertion.before + partial0 + separator + partial1 + insertion.after;\n        }\n        return full0 + separator + full1;\n    };\n    NativeFormatter.prototype.getLargestUnit = function() {\n        switch(this.severity){\n            case 7:\n            case 6:\n            case 5:\n                return \"year\";\n            case 4:\n                return \"month\";\n            case 3:\n                return \"week\";\n            case 2:\n                return \"day\";\n            default:\n                return \"time\"; // really?\n        }\n    };\n    return NativeFormatter;\n}();\nfunction buildFormattingFunc(standardDateProps, extendedSettings, context) {\n    var standardDatePropCnt = Object.keys(standardDateProps).length;\n    if (standardDatePropCnt === 1 && standardDateProps.timeZoneName === \"short\") {\n        return function(date) {\n            return formatTimeZoneOffset(date.timeZoneOffset);\n        };\n    }\n    if (standardDatePropCnt === 0 && extendedSettings.week) {\n        return function(date) {\n            return formatWeekNumber(context.computeWeekNumber(date.marker), context.weekText, context.weekTextLong, context.locale, extendedSettings.week);\n        };\n    }\n    return buildNativeFormattingFunc(standardDateProps, extendedSettings, context);\n}\nfunction buildNativeFormattingFunc(standardDateProps, extendedSettings, context) {\n    standardDateProps = tslib.__assign({}, standardDateProps); // copy\n    extendedSettings = tslib.__assign({}, extendedSettings); // copy\n    sanitizeSettings(standardDateProps, extendedSettings);\n    standardDateProps.timeZone = \"UTC\"; // we leverage the only guaranteed timeZone for our UTC markers\n    var normalFormat = new Intl.DateTimeFormat(context.locale.codes, standardDateProps);\n    var zeroFormat; // needed?\n    if (extendedSettings.omitZeroMinute) {\n        var zeroProps = tslib.__assign({}, standardDateProps);\n        delete zeroProps.minute; // seconds and ms were already considered in sanitizeSettings\n        zeroFormat = new Intl.DateTimeFormat(context.locale.codes, zeroProps);\n    }\n    return function(date) {\n        var marker = date.marker;\n        var format;\n        if (zeroFormat && !marker.getUTCMinutes()) {\n            format = zeroFormat;\n        } else {\n            format = normalFormat;\n        }\n        var s = format.format(marker);\n        return postProcess(s, date, standardDateProps, extendedSettings, context);\n    };\n}\nfunction sanitizeSettings(standardDateProps, extendedSettings) {\n    // deal with a browser inconsistency where formatting the timezone\n    // requires that the hour/minute be present.\n    if (standardDateProps.timeZoneName) {\n        if (!standardDateProps.hour) {\n            standardDateProps.hour = \"2-digit\";\n        }\n        if (!standardDateProps.minute) {\n            standardDateProps.minute = \"2-digit\";\n        }\n    }\n    // only support short timezone names\n    if (standardDateProps.timeZoneName === \"long\") {\n        standardDateProps.timeZoneName = \"short\";\n    }\n    // if requesting to display seconds, MUST display minutes\n    if (extendedSettings.omitZeroMinute && (standardDateProps.second || standardDateProps.millisecond)) {\n        delete extendedSettings.omitZeroMinute;\n    }\n}\nfunction postProcess(s, date, standardDateProps, extendedSettings, context) {\n    s = s.replace(LTR_RE, \"\"); // remove left-to-right control chars. do first. good for other regexes\n    if (standardDateProps.timeZoneName === \"short\") {\n        s = injectTzoStr(s, context.timeZone === \"UTC\" || date.timeZoneOffset == null ? \"UTC\" : formatTimeZoneOffset(date.timeZoneOffset));\n    }\n    if (extendedSettings.omitCommas) {\n        s = s.replace(COMMA_RE, \"\").trim();\n    }\n    if (extendedSettings.omitZeroMinute) {\n        s = s.replace(\":00\", \"\"); // zeroFormat doesn't always achieve this\n    }\n    // ^ do anything that might create adjacent spaces before this point,\n    // because MERIDIEM_RE likes to eat up loading spaces\n    if (extendedSettings.meridiem === false) {\n        s = s.replace(MERIDIEM_RE, \"\").trim();\n    } else if (extendedSettings.meridiem === \"narrow\") {\n        s = s.replace(MERIDIEM_RE, function(m0, m1) {\n            return m1.toLocaleLowerCase();\n        });\n    } else if (extendedSettings.meridiem === \"short\") {\n        s = s.replace(MERIDIEM_RE, function(m0, m1) {\n            return m1.toLocaleLowerCase() + \"m\";\n        });\n    } else if (extendedSettings.meridiem === \"lowercase\") {\n        s = s.replace(MERIDIEM_RE, function(m0) {\n            return m0.toLocaleLowerCase();\n        });\n    }\n    s = s.replace(MULTI_SPACE_RE, \" \");\n    s = s.trim();\n    return s;\n}\nfunction injectTzoStr(s, tzoStr) {\n    var replaced = false;\n    s = s.replace(UTC_RE, function() {\n        replaced = true;\n        return tzoStr;\n    });\n    // IE11 doesn't include UTC/GMT in the original string, so append to end\n    if (!replaced) {\n        s += \" \" + tzoStr;\n    }\n    return s;\n}\nfunction formatWeekNumber(num, weekText, weekTextLong, locale, display) {\n    var parts = [];\n    if (display === \"long\") {\n        parts.push(weekTextLong);\n    } else if (display === \"short\" || display === \"narrow\") {\n        parts.push(weekText);\n    }\n    if (display === \"long\" || display === \"short\") {\n        parts.push(\" \");\n    }\n    parts.push(locale.simpleNumberFormat.format(num));\n    if (locale.options.direction === \"rtl\") {\n        parts.reverse();\n    }\n    return parts.join(\"\");\n}\n// Range Formatting Utils\n// 0 = exactly the same\n// 1 = different by time\n// and bigger\nfunction computeMarkerDiffSeverity(d0, d1, ca) {\n    if (ca.getMarkerYear(d0) !== ca.getMarkerYear(d1)) {\n        return 5;\n    }\n    if (ca.getMarkerMonth(d0) !== ca.getMarkerMonth(d1)) {\n        return 4;\n    }\n    if (ca.getMarkerDay(d0) !== ca.getMarkerDay(d1)) {\n        return 2;\n    }\n    if (timeAsMs(d0) !== timeAsMs(d1)) {\n        return 1;\n    }\n    return 0;\n}\nfunction computePartialFormattingOptions(options, biggestUnit) {\n    var partialOptions = {};\n    for(var name_2 in options){\n        if (!(name_2 in STANDARD_DATE_PROP_SEVERITIES) || // not a date part prop (like timeZone)\n        STANDARD_DATE_PROP_SEVERITIES[name_2] <= biggestUnit) {\n            partialOptions[name_2] = options[name_2];\n        }\n    }\n    return partialOptions;\n}\nfunction findCommonInsertion(full0, partial0, full1, partial1) {\n    var i0 = 0;\n    while(i0 < full0.length){\n        var found0 = full0.indexOf(partial0, i0);\n        if (found0 === -1) {\n            break;\n        }\n        var before0 = full0.substr(0, found0);\n        i0 = found0 + partial0.length;\n        var after0 = full0.substr(i0);\n        var i1 = 0;\n        while(i1 < full1.length){\n            var found1 = full1.indexOf(partial1, i1);\n            if (found1 === -1) {\n                break;\n            }\n            var before1 = full1.substr(0, found1);\n            i1 = found1 + partial1.length;\n            var after1 = full1.substr(i1);\n            if (before0 === before1 && after0 === after1) {\n                return {\n                    before: before0,\n                    after: after0\n                };\n            }\n        }\n    }\n    return null;\n}\nfunction expandZonedMarker(dateInfo, calendarSystem) {\n    var a = calendarSystem.markerToArray(dateInfo.marker);\n    return {\n        marker: dateInfo.marker,\n        timeZoneOffset: dateInfo.timeZoneOffset,\n        array: a,\n        year: a[0],\n        month: a[1],\n        day: a[2],\n        hour: a[3],\n        minute: a[4],\n        second: a[5],\n        millisecond: a[6]\n    };\n}\nfunction createVerboseFormattingArg(start, end, context, betterDefaultSeparator) {\n    var startInfo = expandZonedMarker(start, context.calendarSystem);\n    var endInfo = end ? expandZonedMarker(end, context.calendarSystem) : null;\n    return {\n        date: startInfo,\n        start: startInfo,\n        end: endInfo,\n        timeZone: context.timeZone,\n        localeCodes: context.locale.codes,\n        defaultSeparator: betterDefaultSeparator || context.defaultSeparator\n    };\n}\n/*\nTODO: fix the terminology of \"formatter\" vs \"formatting func\"\n*/ /*\nAt the time of instantiation, this object does not know which cmd-formatting system it will use.\nIt receives this at the time of formatting, as a setting.\n*/ var CmdFormatter = /** @class */ function() {\n    function CmdFormatter(cmdStr) {\n        this.cmdStr = cmdStr;\n    }\n    CmdFormatter.prototype.format = function(date, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    };\n    CmdFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        return context.cmdFormatter(this.cmdStr, createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    };\n    return CmdFormatter;\n}();\nvar FuncFormatter = /** @class */ function() {\n    function FuncFormatter(func) {\n        this.func = func;\n    }\n    FuncFormatter.prototype.format = function(date, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(date, null, context, betterDefaultSeparator));\n    };\n    FuncFormatter.prototype.formatRange = function(start, end, context, betterDefaultSeparator) {\n        return this.func(createVerboseFormattingArg(start, end, context, betterDefaultSeparator));\n    };\n    return FuncFormatter;\n}();\nfunction createFormatter(input) {\n    if (typeof input === \"object\" && input) {\n        return new NativeFormatter(input);\n    }\n    if (typeof input === \"string\") {\n        return new CmdFormatter(input);\n    }\n    if (typeof input === \"function\") {\n        return new FuncFormatter(input);\n    }\n    return null;\n}\n// base options\n// ------------\nvar BASE_OPTION_REFINERS = {\n    navLinkDayClick: identity,\n    navLinkWeekClick: identity,\n    duration: createDuration,\n    bootstrapFontAwesome: identity,\n    buttonIcons: identity,\n    customButtons: identity,\n    defaultAllDayEventDuration: createDuration,\n    defaultTimedEventDuration: createDuration,\n    nextDayThreshold: createDuration,\n    scrollTime: createDuration,\n    scrollTimeReset: Boolean,\n    slotMinTime: createDuration,\n    slotMaxTime: createDuration,\n    dayPopoverFormat: createFormatter,\n    slotDuration: createDuration,\n    snapDuration: createDuration,\n    headerToolbar: identity,\n    footerToolbar: identity,\n    defaultRangeSeparator: String,\n    titleRangeSeparator: String,\n    forceEventDuration: Boolean,\n    dayHeaders: Boolean,\n    dayHeaderFormat: createFormatter,\n    dayHeaderClassNames: identity,\n    dayHeaderContent: identity,\n    dayHeaderDidMount: identity,\n    dayHeaderWillUnmount: identity,\n    dayCellClassNames: identity,\n    dayCellContent: identity,\n    dayCellDidMount: identity,\n    dayCellWillUnmount: identity,\n    initialView: String,\n    aspectRatio: Number,\n    weekends: Boolean,\n    weekNumberCalculation: identity,\n    weekNumbers: Boolean,\n    weekNumberClassNames: identity,\n    weekNumberContent: identity,\n    weekNumberDidMount: identity,\n    weekNumberWillUnmount: identity,\n    editable: Boolean,\n    viewClassNames: identity,\n    viewDidMount: identity,\n    viewWillUnmount: identity,\n    nowIndicator: Boolean,\n    nowIndicatorClassNames: identity,\n    nowIndicatorContent: identity,\n    nowIndicatorDidMount: identity,\n    nowIndicatorWillUnmount: identity,\n    showNonCurrentDates: Boolean,\n    lazyFetching: Boolean,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String,\n    timeZone: String,\n    locales: identity,\n    locale: identity,\n    themeSystem: String,\n    dragRevertDuration: Number,\n    dragScroll: Boolean,\n    allDayMaintainDuration: Boolean,\n    unselectAuto: Boolean,\n    dropAccept: identity,\n    eventOrder: parseFieldSpecs,\n    eventOrderStrict: Boolean,\n    handleWindowResize: Boolean,\n    windowResizeDelay: Number,\n    longPressDelay: Number,\n    eventDragMinDistance: Number,\n    expandRows: Boolean,\n    height: identity,\n    contentHeight: identity,\n    direction: String,\n    weekNumberFormat: createFormatter,\n    eventResizableFromStart: Boolean,\n    displayEventTime: Boolean,\n    displayEventEnd: Boolean,\n    weekText: String,\n    weekTextLong: String,\n    progressiveEventRendering: Boolean,\n    businessHours: identity,\n    initialDate: identity,\n    now: identity,\n    eventDataTransform: identity,\n    stickyHeaderDates: identity,\n    stickyFooterScrollbar: identity,\n    viewHeight: identity,\n    defaultAllDay: Boolean,\n    eventSourceFailure: identity,\n    eventSourceSuccess: identity,\n    eventDisplay: String,\n    eventStartEditable: Boolean,\n    eventDurationEditable: Boolean,\n    eventOverlap: identity,\n    eventConstraint: identity,\n    eventAllow: identity,\n    eventBackgroundColor: String,\n    eventBorderColor: String,\n    eventTextColor: String,\n    eventColor: String,\n    eventClassNames: identity,\n    eventContent: identity,\n    eventDidMount: identity,\n    eventWillUnmount: identity,\n    selectConstraint: identity,\n    selectOverlap: identity,\n    selectAllow: identity,\n    droppable: Boolean,\n    unselectCancel: String,\n    slotLabelFormat: identity,\n    slotLaneClassNames: identity,\n    slotLaneContent: identity,\n    slotLaneDidMount: identity,\n    slotLaneWillUnmount: identity,\n    slotLabelClassNames: identity,\n    slotLabelContent: identity,\n    slotLabelDidMount: identity,\n    slotLabelWillUnmount: identity,\n    dayMaxEvents: identity,\n    dayMaxEventRows: identity,\n    dayMinWidth: Number,\n    slotLabelInterval: createDuration,\n    allDayText: String,\n    allDayClassNames: identity,\n    allDayContent: identity,\n    allDayDidMount: identity,\n    allDayWillUnmount: identity,\n    slotMinWidth: Number,\n    navLinks: Boolean,\n    eventTimeFormat: createFormatter,\n    rerenderDelay: Number,\n    moreLinkText: identity,\n    moreLinkHint: identity,\n    selectMinDistance: Number,\n    selectable: Boolean,\n    selectLongPressDelay: Number,\n    eventLongPressDelay: Number,\n    selectMirror: Boolean,\n    eventMaxStack: Number,\n    eventMinHeight: Number,\n    eventMinWidth: Number,\n    eventShortHeight: Number,\n    slotEventOverlap: Boolean,\n    plugins: identity,\n    firstDay: Number,\n    dayCount: Number,\n    dateAlignment: String,\n    dateIncrement: createDuration,\n    hiddenDays: identity,\n    monthMode: Boolean,\n    fixedWeekCount: Boolean,\n    validRange: identity,\n    visibleRange: identity,\n    titleFormat: identity,\n    eventInteractive: Boolean,\n    // only used by list-view, but languages define the value, so we need it in base options\n    noEventsText: String,\n    viewHint: identity,\n    navLinkHint: identity,\n    closeHint: String,\n    timeHint: String,\n    eventHint: String,\n    moreLinkClick: identity,\n    moreLinkClassNames: identity,\n    moreLinkContent: identity,\n    moreLinkDidMount: identity,\n    moreLinkWillUnmount: identity\n};\n// do NOT give a type here. need `typeof BASE_OPTION_DEFAULTS` to give real results.\n// raw values.\nvar BASE_OPTION_DEFAULTS = {\n    eventDisplay: \"auto\",\n    defaultRangeSeparator: \" - \",\n    titleRangeSeparator: \" – \",\n    defaultTimedEventDuration: \"01:00:00\",\n    defaultAllDayEventDuration: {\n        day: 1\n    },\n    forceEventDuration: false,\n    nextDayThreshold: \"00:00:00\",\n    dayHeaders: true,\n    initialView: \"\",\n    aspectRatio: 1.35,\n    headerToolbar: {\n        start: \"title\",\n        center: \"\",\n        end: \"today prev,next\"\n    },\n    weekends: true,\n    weekNumbers: false,\n    weekNumberCalculation: \"local\",\n    editable: false,\n    nowIndicator: false,\n    scrollTime: \"06:00:00\",\n    scrollTimeReset: true,\n    slotMinTime: \"00:00:00\",\n    slotMaxTime: \"24:00:00\",\n    showNonCurrentDates: true,\n    lazyFetching: true,\n    startParam: \"start\",\n    endParam: \"end\",\n    timeZoneParam: \"timeZone\",\n    timeZone: \"local\",\n    locales: [],\n    locale: \"\",\n    themeSystem: \"standard\",\n    dragRevertDuration: 500,\n    dragScroll: true,\n    allDayMaintainDuration: false,\n    unselectAuto: true,\n    dropAccept: \"*\",\n    eventOrder: \"start,-duration,allDay,title\",\n    dayPopoverFormat: {\n        month: \"long\",\n        day: \"numeric\",\n        year: \"numeric\"\n    },\n    handleWindowResize: true,\n    windowResizeDelay: 100,\n    longPressDelay: 1000,\n    eventDragMinDistance: 5,\n    expandRows: false,\n    navLinks: false,\n    selectable: false,\n    eventMinHeight: 15,\n    eventMinWidth: 30,\n    eventShortHeight: 30\n};\n// calendar listeners\n// ------------------\nvar CALENDAR_LISTENER_REFINERS = {\n    datesSet: identity,\n    eventsSet: identity,\n    eventAdd: identity,\n    eventChange: identity,\n    eventRemove: identity,\n    windowResize: identity,\n    eventClick: identity,\n    eventMouseEnter: identity,\n    eventMouseLeave: identity,\n    select: identity,\n    unselect: identity,\n    loading: identity,\n    // internal\n    _unmount: identity,\n    _beforeprint: identity,\n    _afterprint: identity,\n    _noEventDrop: identity,\n    _noEventResize: identity,\n    _resize: identity,\n    _scrollRequest: identity\n};\n// calendar-specific options\n// -------------------------\nvar CALENDAR_OPTION_REFINERS = {\n    buttonText: identity,\n    buttonHints: identity,\n    views: identity,\n    plugins: identity,\n    initialEvents: identity,\n    events: identity,\n    eventSources: identity\n};\nvar COMPLEX_OPTION_COMPARATORS = {\n    headerToolbar: isMaybeObjectsEqual,\n    footerToolbar: isMaybeObjectsEqual,\n    buttonText: isMaybeObjectsEqual,\n    buttonHints: isMaybeObjectsEqual,\n    buttonIcons: isMaybeObjectsEqual,\n    dateIncrement: isMaybeObjectsEqual\n};\nfunction isMaybeObjectsEqual(a, b) {\n    if (typeof a === \"object\" && typeof b === \"object\" && a && b) {\n        return isPropsEqual(a, b);\n    }\n    return a === b;\n}\n// view-specific options\n// ---------------------\nvar VIEW_OPTION_REFINERS = {\n    type: String,\n    component: identity,\n    buttonText: String,\n    buttonTextKey: String,\n    dateProfileGeneratorClass: identity,\n    usesMinMaxTime: Boolean,\n    classNames: identity,\n    content: identity,\n    didMount: identity,\n    willUnmount: identity\n};\n// util funcs\n// ----------------------------------------------------------------------------------------------------\nfunction mergeRawOptions(optionSets) {\n    return mergeProps(optionSets, COMPLEX_OPTION_COMPARATORS);\n}\nfunction refineProps(input, refiners) {\n    var refined = {};\n    var extra = {};\n    for(var propName in refiners){\n        if (propName in input) {\n            refined[propName] = refiners[propName](input[propName]);\n        }\n    }\n    for(var propName in input){\n        if (!(propName in refiners)) {\n            extra[propName] = input[propName];\n        }\n    }\n    return {\n        refined: refined,\n        extra: extra\n    };\n}\nfunction identity(raw) {\n    return raw;\n}\nfunction parseEvents(rawEvents, eventSource, context, allowOpenRange) {\n    var eventStore = createEmptyEventStore();\n    var eventRefiners = buildEventRefiners(context);\n    for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){\n        var rawEvent = rawEvents_1[_i];\n        var tuple = parseEvent(rawEvent, eventSource, context, allowOpenRange, eventRefiners);\n        if (tuple) {\n            eventTupleToStore(tuple, eventStore);\n        }\n    }\n    return eventStore;\n}\nfunction eventTupleToStore(tuple, eventStore) {\n    if (eventStore === void 0) {\n        eventStore = createEmptyEventStore();\n    }\n    eventStore.defs[tuple.def.defId] = tuple.def;\n    if (tuple.instance) {\n        eventStore.instances[tuple.instance.instanceId] = tuple.instance;\n    }\n    return eventStore;\n}\n// retrieves events that have the same groupId as the instance specified by `instanceId`\n// or they are the same as the instance.\n// why might instanceId not be in the store? an event from another calendar?\nfunction getRelevantEvents(eventStore, instanceId) {\n    var instance = eventStore.instances[instanceId];\n    if (instance) {\n        var def_1 = eventStore.defs[instance.defId];\n        // get events/instances with same group\n        var newStore = filterEventStoreDefs(eventStore, function(lookDef) {\n            return isEventDefsGrouped(def_1, lookDef);\n        });\n        // add the original\n        // TODO: wish we could use eventTupleToStore or something like it\n        newStore.defs[def_1.defId] = def_1;\n        newStore.instances[instance.instanceId] = instance;\n        return newStore;\n    }\n    return createEmptyEventStore();\n}\nfunction isEventDefsGrouped(def0, def1) {\n    return Boolean(def0.groupId && def0.groupId === def1.groupId);\n}\nfunction createEmptyEventStore() {\n    return {\n        defs: {},\n        instances: {}\n    };\n}\nfunction mergeEventStores(store0, store1) {\n    return {\n        defs: tslib.__assign(tslib.__assign({}, store0.defs), store1.defs),\n        instances: tslib.__assign(tslib.__assign({}, store0.instances), store1.instances)\n    };\n}\nfunction filterEventStoreDefs(eventStore, filterFunc) {\n    var defs = filterHash(eventStore.defs, filterFunc);\n    var instances = filterHash(eventStore.instances, function(instance) {\n        return defs[instance.defId] // still exists?\n        ;\n    });\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\nfunction excludeSubEventStore(master, sub) {\n    var defs = master.defs, instances = master.instances;\n    var filteredDefs = {};\n    var filteredInstances = {};\n    for(var defId in defs){\n        if (!sub.defs[defId]) {\n            filteredDefs[defId] = defs[defId];\n        }\n    }\n    for(var instanceId in instances){\n        if (!sub.instances[instanceId] && // not explicitly excluded\n        filteredDefs[instances[instanceId].defId] // def wasn't filtered away\n        ) {\n            filteredInstances[instanceId] = instances[instanceId];\n        }\n    }\n    return {\n        defs: filteredDefs,\n        instances: filteredInstances\n    };\n}\nfunction normalizeConstraint(input, context) {\n    if (Array.isArray(input)) {\n        return parseEvents(input, null, context, true); // allowOpenRange=true\n    }\n    if (typeof input === \"object\" && input) {\n        return parseEvents([\n            input\n        ], null, context, true); // allowOpenRange=true\n    }\n    if (input != null) {\n        return String(input);\n    }\n    return null;\n}\nfunction parseClassNames(raw) {\n    if (Array.isArray(raw)) {\n        return raw;\n    }\n    if (typeof raw === \"string\") {\n        return raw.split(/\\s+/);\n    }\n    return [];\n}\n// TODO: better called \"EventSettings\" or \"EventConfig\"\n// TODO: move this file into structs\n// TODO: separate constraint/overlap/allow, because selection uses only that, not other props\nvar EVENT_UI_REFINERS = {\n    display: String,\n    editable: Boolean,\n    startEditable: Boolean,\n    durationEditable: Boolean,\n    constraint: identity,\n    overlap: identity,\n    allow: identity,\n    className: parseClassNames,\n    classNames: parseClassNames,\n    color: String,\n    backgroundColor: String,\n    borderColor: String,\n    textColor: String\n};\nvar EMPTY_EVENT_UI = {\n    display: null,\n    startEditable: null,\n    durationEditable: null,\n    constraints: [],\n    overlap: null,\n    allows: [],\n    backgroundColor: \"\",\n    borderColor: \"\",\n    textColor: \"\",\n    classNames: []\n};\nfunction createEventUi(refined, context) {\n    var constraint = normalizeConstraint(refined.constraint, context);\n    return {\n        display: refined.display || null,\n        startEditable: refined.startEditable != null ? refined.startEditable : refined.editable,\n        durationEditable: refined.durationEditable != null ? refined.durationEditable : refined.editable,\n        constraints: constraint != null ? [\n            constraint\n        ] : [],\n        overlap: refined.overlap != null ? refined.overlap : null,\n        allows: refined.allow != null ? [\n            refined.allow\n        ] : [],\n        backgroundColor: refined.backgroundColor || refined.color || \"\",\n        borderColor: refined.borderColor || refined.color || \"\",\n        textColor: refined.textColor || \"\",\n        classNames: (refined.className || []).concat(refined.classNames || [])\n    };\n}\n// TODO: prevent against problems with <2 args!\nfunction combineEventUis(uis) {\n    return uis.reduce(combineTwoEventUis, EMPTY_EVENT_UI);\n}\nfunction combineTwoEventUis(item0, item1) {\n    return {\n        display: item1.display != null ? item1.display : item0.display,\n        startEditable: item1.startEditable != null ? item1.startEditable : item0.startEditable,\n        durationEditable: item1.durationEditable != null ? item1.durationEditable : item0.durationEditable,\n        constraints: item0.constraints.concat(item1.constraints),\n        overlap: typeof item1.overlap === \"boolean\" ? item1.overlap : item0.overlap,\n        allows: item0.allows.concat(item1.allows),\n        backgroundColor: item1.backgroundColor || item0.backgroundColor,\n        borderColor: item1.borderColor || item0.borderColor,\n        textColor: item1.textColor || item0.textColor,\n        classNames: item0.classNames.concat(item1.classNames)\n    };\n}\nvar EVENT_NON_DATE_REFINERS = {\n    id: String,\n    groupId: String,\n    title: String,\n    url: String,\n    interactive: Boolean\n};\nvar EVENT_DATE_REFINERS = {\n    start: identity,\n    end: identity,\n    date: identity,\n    allDay: Boolean\n};\nvar EVENT_REFINERS = tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_NON_DATE_REFINERS), EVENT_DATE_REFINERS), {\n    extendedProps: identity\n});\nfunction parseEvent(raw, eventSource, context, allowOpenRange, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventRefiners(context);\n    }\n    var _a = refineEventDef(raw, context, refiners), refined = _a.refined, extra = _a.extra;\n    var defaultAllDay = computeIsDefaultAllDay(eventSource, context);\n    var recurringRes = parseRecurring(refined, defaultAllDay, context.dateEnv, context.pluginHooks.recurringTypes);\n    if (recurringRes) {\n        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", recurringRes.allDay, Boolean(recurringRes.duration), context);\n        def.recurringDef = {\n            typeId: recurringRes.typeId,\n            typeData: recurringRes.typeData,\n            duration: recurringRes.duration\n        };\n        return {\n            def: def,\n            instance: null\n        };\n    }\n    var singleRes = parseSingle(refined, defaultAllDay, context, allowOpenRange);\n    if (singleRes) {\n        var def = parseEventDef(refined, extra, eventSource ? eventSource.sourceId : \"\", singleRes.allDay, singleRes.hasEnd, context);\n        var instance = createEventInstance(def.defId, singleRes.range, singleRes.forcedStartTzo, singleRes.forcedEndTzo);\n        return {\n            def: def,\n            instance: instance\n        };\n    }\n    return null;\n}\nfunction refineEventDef(raw, context, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventRefiners(context);\n    }\n    return refineProps(raw, refiners);\n}\nfunction buildEventRefiners(context) {\n    return tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_UI_REFINERS), EVENT_REFINERS), context.pluginHooks.eventRefiners);\n}\n/*\nWill NOT populate extendedProps with the leftover properties.\nWill NOT populate date-related props.\n*/ function parseEventDef(refined, extra, sourceId, allDay, hasEnd, context) {\n    var def = {\n        title: refined.title || \"\",\n        groupId: refined.groupId || \"\",\n        publicId: refined.id || \"\",\n        url: refined.url || \"\",\n        recurringDef: null,\n        defId: guid(),\n        sourceId: sourceId,\n        allDay: allDay,\n        hasEnd: hasEnd,\n        interactive: refined.interactive,\n        ui: createEventUi(refined, context),\n        extendedProps: tslib.__assign(tslib.__assign({}, refined.extendedProps || {}), extra)\n    };\n    for(var _i = 0, _a = context.pluginHooks.eventDefMemberAdders; _i < _a.length; _i++){\n        var memberAdder = _a[_i];\n        tslib.__assign(def, memberAdder(refined));\n    }\n    // help out EventApi from having user modify props\n    Object.freeze(def.ui.classNames);\n    Object.freeze(def.extendedProps);\n    return def;\n}\nfunction parseSingle(refined, defaultAllDay, context, allowOpenRange) {\n    var allDay = refined.allDay;\n    var startMeta;\n    var startMarker = null;\n    var hasEnd = false;\n    var endMeta;\n    var endMarker = null;\n    var startInput = refined.start != null ? refined.start : refined.date;\n    startMeta = context.dateEnv.createMarkerMeta(startInput);\n    if (startMeta) {\n        startMarker = startMeta.marker;\n    } else if (!allowOpenRange) {\n        return null;\n    }\n    if (refined.end != null) {\n        endMeta = context.dateEnv.createMarkerMeta(refined.end);\n    }\n    if (allDay == null) {\n        if (defaultAllDay != null) {\n            allDay = defaultAllDay;\n        } else {\n            // fall back to the date props LAST\n            allDay = (!startMeta || startMeta.isTimeUnspecified) && (!endMeta || endMeta.isTimeUnspecified);\n        }\n    }\n    if (allDay && startMarker) {\n        startMarker = startOfDay(startMarker);\n    }\n    if (endMeta) {\n        endMarker = endMeta.marker;\n        if (allDay) {\n            endMarker = startOfDay(endMarker);\n        }\n        if (startMarker && endMarker <= startMarker) {\n            endMarker = null;\n        }\n    }\n    if (endMarker) {\n        hasEnd = true;\n    } else if (!allowOpenRange) {\n        hasEnd = context.options.forceEventDuration || false;\n        endMarker = context.dateEnv.add(startMarker, allDay ? context.options.defaultAllDayEventDuration : context.options.defaultTimedEventDuration);\n    }\n    return {\n        allDay: allDay,\n        hasEnd: hasEnd,\n        range: {\n            start: startMarker,\n            end: endMarker\n        },\n        forcedStartTzo: startMeta ? startMeta.forcedTzo : null,\n        forcedEndTzo: endMeta ? endMeta.forcedTzo : null\n    };\n}\nfunction computeIsDefaultAllDay(eventSource, context) {\n    var res = null;\n    if (eventSource) {\n        res = eventSource.defaultAllDay;\n    }\n    if (res == null) {\n        res = context.options.defaultAllDay;\n    }\n    return res;\n}\n/* Date stuff that doesn't belong in datelib core\n----------------------------------------------------------------------------------------------------------------------*/ // given a timed range, computes an all-day range that has the same exact duration,\n// but whose start time is aligned with the start of the day.\nfunction computeAlignedDayRange(timedRange) {\n    var dayCnt = Math.floor(diffDays(timedRange.start, timedRange.end)) || 1;\n    var start = startOfDay(timedRange.start);\n    var end = addDays(start, dayCnt);\n    return {\n        start: start,\n        end: end\n    };\n}\n// given a timed range, computes an all-day range based on how for the end date bleeds into the next day\n// TODO: give nextDayThreshold a default arg\nfunction computeVisibleDayRange(timedRange, nextDayThreshold) {\n    if (nextDayThreshold === void 0) {\n        nextDayThreshold = createDuration(0);\n    }\n    var startDay = null;\n    var endDay = null;\n    if (timedRange.end) {\n        endDay = startOfDay(timedRange.end);\n        var endTimeMS = timedRange.end.valueOf() - endDay.valueOf(); // # of milliseconds into `endDay`\n        // If the end time is actually inclusively part of the next day and is equal to or\n        // beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.\n        // Otherwise, leaving it as inclusive will cause it to exclude `endDay`.\n        if (endTimeMS && endTimeMS >= asRoughMs(nextDayThreshold)) {\n            endDay = addDays(endDay, 1);\n        }\n    }\n    if (timedRange.start) {\n        startDay = startOfDay(timedRange.start); // the beginning of the day the range starts\n        // If end is within `startDay` but not past nextDayThreshold, assign the default duration of one day.\n        if (endDay && endDay <= startDay) {\n            endDay = addDays(startDay, 1);\n        }\n    }\n    return {\n        start: startDay,\n        end: endDay\n    };\n}\n// spans from one day into another?\nfunction isMultiDayRange(range) {\n    var visibleRange = computeVisibleDayRange(range);\n    return diffDays(visibleRange.start, visibleRange.end) > 1;\n}\nfunction diffDates(date0, date1, dateEnv, largeUnit) {\n    if (largeUnit === \"year\") {\n        return createDuration(dateEnv.diffWholeYears(date0, date1), \"year\");\n    }\n    if (largeUnit === \"month\") {\n        return createDuration(dateEnv.diffWholeMonths(date0, date1), \"month\");\n    }\n    return diffDayAndTime(date0, date1); // returns a duration\n}\nfunction parseRange(input, dateEnv) {\n    var start = null;\n    var end = null;\n    if (input.start) {\n        start = dateEnv.createMarker(input.start);\n    }\n    if (input.end) {\n        end = dateEnv.createMarker(input.end);\n    }\n    if (!start && !end) {\n        return null;\n    }\n    if (start && end && end < start) {\n        return null;\n    }\n    return {\n        start: start,\n        end: end\n    };\n}\n// SIDE-EFFECT: will mutate ranges.\n// Will return a new array result.\nfunction invertRanges(ranges, constraintRange) {\n    var invertedRanges = [];\n    var start = constraintRange.start; // the end of the previous range. the start of the new range\n    var i;\n    var dateRange;\n    // ranges need to be in order. required for our date-walking algorithm\n    ranges.sort(compareRanges);\n    for(i = 0; i < ranges.length; i += 1){\n        dateRange = ranges[i];\n        // add the span of time before the event (if there is any)\n        if (dateRange.start > start) {\n            invertedRanges.push({\n                start: start,\n                end: dateRange.start\n            });\n        }\n        if (dateRange.end > start) {\n            start = dateRange.end;\n        }\n    }\n    // add the span of time after the last event (if there is any)\n    if (start < constraintRange.end) {\n        invertedRanges.push({\n            start: start,\n            end: constraintRange.end\n        });\n    }\n    return invertedRanges;\n}\nfunction compareRanges(range0, range1) {\n    return range0.start.valueOf() - range1.start.valueOf(); // earlier ranges go first\n}\nfunction intersectRanges(range0, range1) {\n    var start = range0.start, end = range0.end;\n    var newRange = null;\n    if (range1.start !== null) {\n        if (start === null) {\n            start = range1.start;\n        } else {\n            start = new Date(Math.max(start.valueOf(), range1.start.valueOf()));\n        }\n    }\n    if (range1.end != null) {\n        if (end === null) {\n            end = range1.end;\n        } else {\n            end = new Date(Math.min(end.valueOf(), range1.end.valueOf()));\n        }\n    }\n    if (start === null || end === null || start < end) {\n        newRange = {\n            start: start,\n            end: end\n        };\n    }\n    return newRange;\n}\nfunction rangesEqual(range0, range1) {\n    return (range0.start === null ? null : range0.start.valueOf()) === (range1.start === null ? null : range1.start.valueOf()) && (range0.end === null ? null : range0.end.valueOf()) === (range1.end === null ? null : range1.end.valueOf());\n}\nfunction rangesIntersect(range0, range1) {\n    return (range0.end === null || range1.start === null || range0.end > range1.start) && (range0.start === null || range1.end === null || range0.start < range1.end);\n}\nfunction rangeContainsRange(outerRange, innerRange) {\n    return (outerRange.start === null || innerRange.start !== null && innerRange.start >= outerRange.start) && (outerRange.end === null || innerRange.end !== null && innerRange.end <= outerRange.end);\n}\nfunction rangeContainsMarker(range, date) {\n    return (range.start === null || date >= range.start) && (range.end === null || date < range.end);\n}\n// If the given date is not within the given range, move it inside.\n// (If it's past the end, make it one millisecond before the end).\nfunction constrainMarkerToRange(date, range) {\n    if (range.start != null && date < range.start) {\n        return range.start;\n    }\n    if (range.end != null && date >= range.end) {\n        return new Date(range.end.valueOf() - 1);\n    }\n    return date;\n}\n/*\nSpecifying nextDayThreshold signals that all-day ranges should be sliced.\n*/ function sliceEventStore(eventStore, eventUiBases, framingRange, nextDayThreshold) {\n    var inverseBgByGroupId = {};\n    var inverseBgByDefId = {};\n    var defByGroupId = {};\n    var bgRanges = [];\n    var fgRanges = [];\n    var eventUis = compileEventUis(eventStore.defs, eventUiBases);\n    for(var defId in eventStore.defs){\n        var def = eventStore.defs[defId];\n        var ui = eventUis[def.defId];\n        if (ui.display === \"inverse-background\") {\n            if (def.groupId) {\n                inverseBgByGroupId[def.groupId] = [];\n                if (!defByGroupId[def.groupId]) {\n                    defByGroupId[def.groupId] = def;\n                }\n            } else {\n                inverseBgByDefId[defId] = [];\n            }\n        }\n    }\n    for(var instanceId in eventStore.instances){\n        var instance = eventStore.instances[instanceId];\n        var def = eventStore.defs[instance.defId];\n        var ui = eventUis[def.defId];\n        var origRange = instance.range;\n        var normalRange = !def.allDay && nextDayThreshold ? computeVisibleDayRange(origRange, nextDayThreshold) : origRange;\n        var slicedRange = intersectRanges(normalRange, framingRange);\n        if (slicedRange) {\n            if (ui.display === \"inverse-background\") {\n                if (def.groupId) {\n                    inverseBgByGroupId[def.groupId].push(slicedRange);\n                } else {\n                    inverseBgByDefId[instance.defId].push(slicedRange);\n                }\n            } else if (ui.display !== \"none\") {\n                (ui.display === \"background\" ? bgRanges : fgRanges).push({\n                    def: def,\n                    ui: ui,\n                    instance: instance,\n                    range: slicedRange,\n                    isStart: normalRange.start && normalRange.start.valueOf() === slicedRange.start.valueOf(),\n                    isEnd: normalRange.end && normalRange.end.valueOf() === slicedRange.end.valueOf()\n                });\n            }\n        }\n    }\n    for(var groupId in inverseBgByGroupId){\n        var ranges = inverseBgByGroupId[groupId];\n        var invertedRanges = invertRanges(ranges, framingRange);\n        for(var _i = 0, invertedRanges_1 = invertedRanges; _i < invertedRanges_1.length; _i++){\n            var invertedRange = invertedRanges_1[_i];\n            var def = defByGroupId[groupId];\n            var ui = eventUis[def.defId];\n            bgRanges.push({\n                def: def,\n                ui: ui,\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    for(var defId in inverseBgByDefId){\n        var ranges = inverseBgByDefId[defId];\n        var invertedRanges = invertRanges(ranges, framingRange);\n        for(var _a = 0, invertedRanges_2 = invertedRanges; _a < invertedRanges_2.length; _a++){\n            var invertedRange = invertedRanges_2[_a];\n            bgRanges.push({\n                def: eventStore.defs[defId],\n                ui: eventUis[defId],\n                instance: null,\n                range: invertedRange,\n                isStart: false,\n                isEnd: false\n            });\n        }\n    }\n    return {\n        bg: bgRanges,\n        fg: fgRanges\n    };\n}\nfunction hasBgRendering(def) {\n    return def.ui.display === \"background\" || def.ui.display === \"inverse-background\";\n}\nfunction setElSeg(el, seg) {\n    el.fcSeg = seg;\n}\nfunction getElSeg(el) {\n    return el.fcSeg || el.parentNode.fcSeg || // for the harness\n    null;\n}\n// event ui computation\nfunction compileEventUis(eventDefs, eventUiBases) {\n    return mapHash(eventDefs, function(eventDef) {\n        return compileEventUi(eventDef, eventUiBases);\n    });\n}\nfunction compileEventUi(eventDef, eventUiBases) {\n    var uis = [];\n    if (eventUiBases[\"\"]) {\n        uis.push(eventUiBases[\"\"]);\n    }\n    if (eventUiBases[eventDef.defId]) {\n        uis.push(eventUiBases[eventDef.defId]);\n    }\n    uis.push(eventDef.ui);\n    return combineEventUis(uis);\n}\nfunction sortEventSegs(segs, eventOrderSpecs) {\n    var objs = segs.map(buildSegCompareObj);\n    objs.sort(function(obj0, obj1) {\n        return compareByFieldSpecs(obj0, obj1, eventOrderSpecs);\n    });\n    return objs.map(function(c) {\n        return c._seg;\n    });\n}\n// returns a object with all primitive props that can be compared\nfunction buildSegCompareObj(seg) {\n    var eventRange = seg.eventRange;\n    var eventDef = eventRange.def;\n    var range = eventRange.instance ? eventRange.instance.range : eventRange.range;\n    var start = range.start ? range.start.valueOf() : 0; // TODO: better support for open-range events\n    var end = range.end ? range.end.valueOf() : 0; // \"\n    return tslib.__assign(tslib.__assign(tslib.__assign({}, eventDef.extendedProps), eventDef), {\n        id: eventDef.publicId,\n        start: start,\n        end: end,\n        duration: end - start,\n        allDay: Number(eventDef.allDay),\n        _seg: seg\n    });\n}\nfunction computeSegDraggable(seg, context) {\n    var pluginHooks = context.pluginHooks;\n    var transformers = pluginHooks.isDraggableTransformers;\n    var _a = seg.eventRange, def = _a.def, ui = _a.ui;\n    var val = ui.startEditable;\n    for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){\n        var transformer = transformers_1[_i];\n        val = transformer(val, def, ui, context);\n    }\n    return val;\n}\nfunction computeSegStartResizable(seg, context) {\n    return seg.isStart && seg.eventRange.ui.durationEditable && context.options.eventResizableFromStart;\n}\nfunction computeSegEndResizable(seg, context) {\n    return seg.isEnd && seg.eventRange.ui.durationEditable;\n}\nfunction buildSegTimeText(seg, timeFormat, context, defaultDisplayEventTime, defaultDisplayEventEnd, startOverride, endOverride) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var displayEventTime = options.displayEventTime, displayEventEnd = options.displayEventEnd;\n    var eventDef = seg.eventRange.def;\n    var eventInstance = seg.eventRange.instance;\n    if (displayEventTime == null) {\n        displayEventTime = defaultDisplayEventTime !== false;\n    }\n    if (displayEventEnd == null) {\n        displayEventEnd = defaultDisplayEventEnd !== false;\n    }\n    var wholeEventStart = eventInstance.range.start;\n    var wholeEventEnd = eventInstance.range.end;\n    var segStart = startOverride || seg.start || seg.eventRange.range.start;\n    var segEnd = endOverride || seg.end || seg.eventRange.range.end;\n    var isStartDay = startOfDay(wholeEventStart).valueOf() === startOfDay(segStart).valueOf();\n    var isEndDay = startOfDay(addMs(wholeEventEnd, -1)).valueOf() === startOfDay(addMs(segEnd, -1)).valueOf();\n    if (displayEventTime && !eventDef.allDay && (isStartDay || isEndDay)) {\n        segStart = isStartDay ? wholeEventStart : segStart;\n        segEnd = isEndDay ? wholeEventEnd : segEnd;\n        if (displayEventEnd && eventDef.hasEnd) {\n            return dateEnv.formatRange(segStart, segEnd, timeFormat, {\n                forcedStartTzo: startOverride ? null : eventInstance.forcedStartTzo,\n                forcedEndTzo: endOverride ? null : eventInstance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(segStart, timeFormat, {\n            forcedTzo: startOverride ? null : eventInstance.forcedStartTzo\n        });\n    }\n    return \"\";\n}\nfunction getSegMeta(seg, todayRange, nowDate) {\n    var segRange = seg.eventRange.range;\n    return {\n        isPast: segRange.end < (nowDate || todayRange.start),\n        isFuture: segRange.start >= (nowDate || todayRange.end),\n        isToday: todayRange && rangeContainsMarker(todayRange, segRange.start)\n    };\n}\nfunction getEventClassNames(props) {\n    var classNames = [\n        \"fc-event\"\n    ];\n    if (props.isMirror) {\n        classNames.push(\"fc-event-mirror\");\n    }\n    if (props.isDraggable) {\n        classNames.push(\"fc-event-draggable\");\n    }\n    if (props.isStartResizable || props.isEndResizable) {\n        classNames.push(\"fc-event-resizable\");\n    }\n    if (props.isDragging) {\n        classNames.push(\"fc-event-dragging\");\n    }\n    if (props.isResizing) {\n        classNames.push(\"fc-event-resizing\");\n    }\n    if (props.isSelected) {\n        classNames.push(\"fc-event-selected\");\n    }\n    if (props.isStart) {\n        classNames.push(\"fc-event-start\");\n    }\n    if (props.isEnd) {\n        classNames.push(\"fc-event-end\");\n    }\n    if (props.isPast) {\n        classNames.push(\"fc-event-past\");\n    }\n    if (props.isToday) {\n        classNames.push(\"fc-event-today\");\n    }\n    if (props.isFuture) {\n        classNames.push(\"fc-event-future\");\n    }\n    return classNames;\n}\nfunction buildEventRangeKey(eventRange) {\n    return eventRange.instance ? eventRange.instance.instanceId : eventRange.def.defId + \":\" + eventRange.range.start.toISOString();\n// inverse-background events don't have specific instances. TODO: better solution\n}\nfunction getSegAnchorAttrs(seg, context) {\n    var _a = seg.eventRange, def = _a.def, instance = _a.instance;\n    var url = def.url;\n    if (url) {\n        return {\n            href: url\n        };\n    }\n    var emitter = context.emitter, options = context.options;\n    var eventInteractive = options.eventInteractive;\n    if (eventInteractive == null) {\n        eventInteractive = def.interactive;\n        if (eventInteractive == null) {\n            eventInteractive = Boolean(emitter.hasHandlers(\"eventClick\"));\n        }\n    }\n    // mock what happens in EventClicking\n    if (eventInteractive) {\n        // only attach keyboard-related handlers because click handler is already done in EventClicking\n        return createAriaKeyboardAttrs(function(ev) {\n            emitter.trigger(\"eventClick\", {\n                el: ev.target,\n                event: new EventApi(context, def, instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        });\n    }\n    return {};\n}\nvar STANDARD_PROPS = {\n    start: identity,\n    end: identity,\n    allDay: Boolean\n};\nfunction parseDateSpan(raw, dateEnv, defaultDuration) {\n    var span = parseOpenDateSpan(raw, dateEnv);\n    var range = span.range;\n    if (!range.start) {\n        return null;\n    }\n    if (!range.end) {\n        if (defaultDuration == null) {\n            return null;\n        }\n        range.end = dateEnv.add(range.start, defaultDuration);\n    }\n    return span;\n}\n/*\nTODO: somehow combine with parseRange?\nWill return null if the start/end props were present but parsed invalidly.\n*/ function parseOpenDateSpan(raw, dateEnv) {\n    var _a = refineProps(raw, STANDARD_PROPS), standardProps = _a.refined, extra = _a.extra;\n    var startMeta = standardProps.start ? dateEnv.createMarkerMeta(standardProps.start) : null;\n    var endMeta = standardProps.end ? dateEnv.createMarkerMeta(standardProps.end) : null;\n    var allDay = standardProps.allDay;\n    if (allDay == null) {\n        allDay = startMeta && startMeta.isTimeUnspecified && (!endMeta || endMeta.isTimeUnspecified);\n    }\n    return tslib.__assign({\n        range: {\n            start: startMeta ? startMeta.marker : null,\n            end: endMeta ? endMeta.marker : null\n        },\n        allDay: allDay\n    }, extra);\n}\nfunction isDateSpansEqual(span0, span1) {\n    return rangesEqual(span0.range, span1.range) && span0.allDay === span1.allDay && isSpanPropsEqual(span0, span1);\n}\n// the NON-DATE-RELATED props\nfunction isSpanPropsEqual(span0, span1) {\n    for(var propName in span1){\n        if (propName !== \"range\" && propName !== \"allDay\") {\n            if (span0[propName] !== span1[propName]) {\n                return false;\n            }\n        }\n    }\n    // are there any props that span0 has that span1 DOESN'T have?\n    // both have range/allDay, so no need to special-case.\n    for(var propName in span0){\n        if (!(propName in span1)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction buildDateSpanApi(span, dateEnv) {\n    return tslib.__assign(tslib.__assign({}, buildRangeApi(span.range, dateEnv, span.allDay)), {\n        allDay: span.allDay\n    });\n}\nfunction buildRangeApiWithTimeZone(range, dateEnv, omitTime) {\n    return tslib.__assign(tslib.__assign({}, buildRangeApi(range, dateEnv, omitTime)), {\n        timeZone: dateEnv.timeZone\n    });\n}\nfunction buildRangeApi(range, dateEnv, omitTime) {\n    return {\n        start: dateEnv.toDate(range.start),\n        end: dateEnv.toDate(range.end),\n        startStr: dateEnv.formatIso(range.start, {\n            omitTime: omitTime\n        }),\n        endStr: dateEnv.formatIso(range.end, {\n            omitTime: omitTime\n        })\n    };\n}\nfunction fabricateEventRange(dateSpan, eventUiBases, context) {\n    var res = refineEventDef({\n        editable: false\n    }, context);\n    var def = parseEventDef(res.refined, res.extra, \"\", dateSpan.allDay, true, context);\n    return {\n        def: def,\n        ui: compileEventUi(def, eventUiBases),\n        instance: createEventInstance(def.defId, dateSpan.range),\n        range: dateSpan.range,\n        isStart: true,\n        isEnd: true\n    };\n}\nfunction triggerDateSelect(selection, pev, context) {\n    context.emitter.trigger(\"select\", tslib.__assign(tslib.__assign({}, buildDateSpanApiWithContext(selection, context)), {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    }));\n}\nfunction triggerDateUnselect(pev, context) {\n    context.emitter.trigger(\"unselect\", {\n        jsEvent: pev ? pev.origEvent : null,\n        view: context.viewApi || context.calendarApi.view\n    });\n}\nfunction buildDateSpanApiWithContext(dateSpan, context) {\n    var props = {};\n    for(var _i = 0, _a = context.pluginHooks.dateSpanTransforms; _i < _a.length; _i++){\n        var transform = _a[_i];\n        tslib.__assign(props, transform(dateSpan, context));\n    }\n    tslib.__assign(props, buildDateSpanApi(dateSpan, context.dateEnv));\n    return props;\n}\n// Given an event's allDay status and start date, return what its fallback end date should be.\n// TODO: rename to computeDefaultEventEnd\nfunction getDefaultEventEnd(allDay, marker, context) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var end = marker;\n    if (allDay) {\n        end = startOfDay(end);\n        end = dateEnv.add(end, options.defaultAllDayEventDuration);\n    } else {\n        end = dateEnv.add(end, options.defaultTimedEventDuration);\n    }\n    return end;\n}\n// applies the mutation to ALL defs/instances within the event store\nfunction applyMutationToEventStore(eventStore, eventConfigBase, mutation, context) {\n    var eventConfigs = compileEventUis(eventStore.defs, eventConfigBase);\n    var dest = createEmptyEventStore();\n    for(var defId in eventStore.defs){\n        var def = eventStore.defs[defId];\n        dest.defs[defId] = applyMutationToEventDef(def, eventConfigs[defId], mutation, context);\n    }\n    for(var instanceId in eventStore.instances){\n        var instance = eventStore.instances[instanceId];\n        var def = dest.defs[instance.defId]; // important to grab the newly modified def\n        dest.instances[instanceId] = applyMutationToEventInstance(instance, def, eventConfigs[instance.defId], mutation, context);\n    }\n    return dest;\n}\nfunction applyMutationToEventDef(eventDef, eventConfig, mutation, context) {\n    var standardProps = mutation.standardProps || {};\n    // if hasEnd has not been specified, guess a good value based on deltas.\n    // if duration will change, there's no way the default duration will persist,\n    // and thus, we need to mark the event as having a real end\n    if (standardProps.hasEnd == null && eventConfig.durationEditable && (mutation.startDelta || mutation.endDelta)) {\n        standardProps.hasEnd = true; // TODO: is this mutation okay?\n    }\n    var copy = tslib.__assign(tslib.__assign(tslib.__assign({}, eventDef), standardProps), {\n        ui: tslib.__assign(tslib.__assign({}, eventDef.ui), standardProps.ui)\n    });\n    if (mutation.extendedProps) {\n        copy.extendedProps = tslib.__assign(tslib.__assign({}, copy.extendedProps), mutation.extendedProps);\n    }\n    for(var _i = 0, _a = context.pluginHooks.eventDefMutationAppliers; _i < _a.length; _i++){\n        var applier = _a[_i];\n        applier(copy, mutation, context);\n    }\n    if (!copy.hasEnd && context.options.forceEventDuration) {\n        copy.hasEnd = true;\n    }\n    return copy;\n}\nfunction applyMutationToEventInstance(eventInstance, eventDef, eventConfig, mutation, context) {\n    var dateEnv = context.dateEnv;\n    var forceAllDay = mutation.standardProps && mutation.standardProps.allDay === true;\n    var clearEnd = mutation.standardProps && mutation.standardProps.hasEnd === false;\n    var copy = tslib.__assign({}, eventInstance);\n    if (forceAllDay) {\n        copy.range = computeAlignedDayRange(copy.range);\n    }\n    if (mutation.datesDelta && eventConfig.startEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.datesDelta),\n            end: dateEnv.add(copy.range.end, mutation.datesDelta)\n        };\n    }\n    if (mutation.startDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: dateEnv.add(copy.range.start, mutation.startDelta),\n            end: copy.range.end\n        };\n    }\n    if (mutation.endDelta && eventConfig.durationEditable) {\n        copy.range = {\n            start: copy.range.start,\n            end: dateEnv.add(copy.range.end, mutation.endDelta)\n        };\n    }\n    if (clearEnd) {\n        copy.range = {\n            start: copy.range.start,\n            end: getDefaultEventEnd(eventDef.allDay, copy.range.start, context)\n        };\n    }\n    // in case event was all-day but the supplied deltas were not\n    // better util for this?\n    if (eventDef.allDay) {\n        copy.range = {\n            start: startOfDay(copy.range.start),\n            end: startOfDay(copy.range.end)\n        };\n    }\n    // handle invalid durations\n    if (copy.range.end < copy.range.start) {\n        copy.range.end = getDefaultEventEnd(eventDef.allDay, copy.range.start, context);\n    }\n    return copy;\n}\n// no public types yet. when there are, export from:\n// import {} from './api-type-deps'\nvar ViewApi = /** @class */ function() {\n    function ViewApi(type, getCurrentData, dateEnv) {\n        this.type = type;\n        this.getCurrentData = getCurrentData;\n        this.dateEnv = dateEnv;\n    }\n    Object.defineProperty(ViewApi.prototype, \"calendar\", {\n        get: function() {\n            return this.getCurrentData().calendarApi;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"title\", {\n        get: function() {\n            return this.getCurrentData().viewTitle;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"activeStart\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.start);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"activeEnd\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.activeRange.end);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"currentStart\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.start);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(ViewApi.prototype, \"currentEnd\", {\n        get: function() {\n            return this.dateEnv.toDate(this.getCurrentData().dateProfile.currentRange.end);\n        },\n        enumerable: false,\n        configurable: true\n    });\n    ViewApi.prototype.getOption = function(name) {\n        return this.getCurrentData().options[name]; // are the view-specific options\n    };\n    return ViewApi;\n}();\nvar EVENT_SOURCE_REFINERS = {\n    id: String,\n    defaultAllDay: Boolean,\n    url: String,\n    format: String,\n    events: identity,\n    eventDataTransform: identity,\n    // for any network-related sources\n    success: identity,\n    failure: identity\n};\nfunction parseEventSource(raw, context, refiners) {\n    if (refiners === void 0) {\n        refiners = buildEventSourceRefiners(context);\n    }\n    var rawObj;\n    if (typeof raw === \"string\") {\n        rawObj = {\n            url: raw\n        };\n    } else if (typeof raw === \"function\" || Array.isArray(raw)) {\n        rawObj = {\n            events: raw\n        };\n    } else if (typeof raw === \"object\" && raw) {\n        rawObj = raw;\n    }\n    if (rawObj) {\n        var _a = refineProps(rawObj, refiners), refined = _a.refined, extra = _a.extra;\n        var metaRes = buildEventSourceMeta(refined, context);\n        if (metaRes) {\n            return {\n                _raw: raw,\n                isFetching: false,\n                latestFetchId: \"\",\n                fetchRange: null,\n                defaultAllDay: refined.defaultAllDay,\n                eventDataTransform: refined.eventDataTransform,\n                success: refined.success,\n                failure: refined.failure,\n                publicId: refined.id || \"\",\n                sourceId: guid(),\n                sourceDefId: metaRes.sourceDefId,\n                meta: metaRes.meta,\n                ui: createEventUi(refined, context),\n                extendedProps: extra\n            };\n        }\n    }\n    return null;\n}\nfunction buildEventSourceRefiners(context) {\n    return tslib.__assign(tslib.__assign(tslib.__assign({}, EVENT_UI_REFINERS), EVENT_SOURCE_REFINERS), context.pluginHooks.eventSourceRefiners);\n}\nfunction buildEventSourceMeta(raw, context) {\n    var defs = context.pluginHooks.eventSourceDefs;\n    for(var i = defs.length - 1; i >= 0; i -= 1){\n        var def = defs[i];\n        var meta = def.parseMeta(raw);\n        if (meta) {\n            return {\n                sourceDefId: i,\n                meta: meta\n            };\n        }\n    }\n    return null;\n}\nfunction reduceCurrentDate(currentDate, action) {\n    switch(action.type){\n        case \"CHANGE_DATE\":\n            return action.dateMarker;\n        default:\n            return currentDate;\n    }\n}\nfunction getInitialDate(options, dateEnv) {\n    var initialDateInput = options.initialDate;\n    // compute the initial ambig-timezone date\n    if (initialDateInput != null) {\n        return dateEnv.createMarker(initialDateInput);\n    }\n    return getNow(options.now, dateEnv); // getNow already returns unzoned\n}\nfunction getNow(nowInput, dateEnv) {\n    if (typeof nowInput === \"function\") {\n        nowInput = nowInput();\n    }\n    if (nowInput == null) {\n        return dateEnv.createNowMarker();\n    }\n    return dateEnv.createMarker(nowInput);\n}\nvar CalendarApi = /** @class */ function() {\n    function CalendarApi() {}\n    CalendarApi.prototype.getCurrentData = function() {\n        return this.currentDataManager.getCurrentData();\n    };\n    CalendarApi.prototype.dispatch = function(action) {\n        return this.currentDataManager.dispatch(action);\n    };\n    Object.defineProperty(CalendarApi.prototype, \"view\", {\n        get: function() {\n            return this.getCurrentData().viewApi;\n        } // for public API\n        ,\n        enumerable: false,\n        configurable: true\n    });\n    CalendarApi.prototype.batchRendering = function(callback) {\n        callback();\n    };\n    CalendarApi.prototype.updateSize = function() {\n        this.trigger(\"_resize\", true);\n    };\n    // Options\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.setOption = function(name, val) {\n        this.dispatch({\n            type: \"SET_OPTION\",\n            optionName: name,\n            rawOptionValue: val\n        });\n    };\n    CalendarApi.prototype.getOption = function(name) {\n        return this.currentDataManager.currentCalendarOptionsInput[name];\n    };\n    CalendarApi.prototype.getAvailableLocaleCodes = function() {\n        return Object.keys(this.getCurrentData().availableRawLocales);\n    };\n    // Trigger\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.on = function(handlerName, handler) {\n        var currentDataManager = this.currentDataManager;\n        if (currentDataManager.currentCalendarOptionsRefiners[handlerName]) {\n            currentDataManager.emitter.on(handlerName, handler);\n        } else {\n            console.warn(\"Unknown listener name '\" + handlerName + \"'\");\n        }\n    };\n    CalendarApi.prototype.off = function(handlerName, handler) {\n        this.currentDataManager.emitter.off(handlerName, handler);\n    };\n    // not meant for public use\n    CalendarApi.prototype.trigger = function(handlerName) {\n        var _a;\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        (_a = this.currentDataManager.emitter).trigger.apply(_a, tslib.__spreadArray([\n            handlerName\n        ], args));\n    };\n    // View\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.changeView = function(viewType, dateOrRange) {\n        var _this = this;\n        this.batchRendering(function() {\n            _this.unselect();\n            if (dateOrRange) {\n                if (dateOrRange.start && dateOrRange.end) {\n                    _this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType: viewType\n                    });\n                    _this.dispatch({\n                        type: \"SET_OPTION\",\n                        optionName: \"visibleRange\",\n                        rawOptionValue: dateOrRange\n                    });\n                } else {\n                    var dateEnv = _this.getCurrentData().dateEnv;\n                    _this.dispatch({\n                        type: \"CHANGE_VIEW_TYPE\",\n                        viewType: viewType,\n                        dateMarker: dateEnv.createMarker(dateOrRange)\n                    });\n                }\n            } else {\n                _this.dispatch({\n                    type: \"CHANGE_VIEW_TYPE\",\n                    viewType: viewType\n                });\n            }\n        });\n    };\n    // Forces navigation to a view for the given date.\n    // `viewType` can be a specific view name or a generic one like \"week\" or \"day\".\n    // needs to change\n    CalendarApi.prototype.zoomTo = function(dateMarker, viewType) {\n        var state = this.getCurrentData();\n        var spec;\n        viewType = viewType || \"day\"; // day is default zoom\n        spec = state.viewSpecs[viewType] || this.getUnitViewSpec(viewType);\n        this.unselect();\n        if (spec) {\n            this.dispatch({\n                type: \"CHANGE_VIEW_TYPE\",\n                viewType: spec.type,\n                dateMarker: dateMarker\n            });\n        } else {\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: dateMarker\n            });\n        }\n    };\n    // Given a duration singular unit, like \"week\" or \"day\", finds a matching view spec.\n    // Preference is given to views that have corresponding buttons.\n    CalendarApi.prototype.getUnitViewSpec = function(unit) {\n        var _a = this.getCurrentData(), viewSpecs = _a.viewSpecs, toolbarConfig = _a.toolbarConfig;\n        var viewTypes = [].concat(toolbarConfig.header ? toolbarConfig.header.viewsWithButtons : [], toolbarConfig.footer ? toolbarConfig.footer.viewsWithButtons : []);\n        var i;\n        var spec;\n        for(var viewType in viewSpecs){\n            viewTypes.push(viewType);\n        }\n        for(i = 0; i < viewTypes.length; i += 1){\n            spec = viewSpecs[viewTypes[i]];\n            if (spec) {\n                if (spec.singleUnit === unit) {\n                    return spec;\n                }\n            }\n        }\n        return null;\n    };\n    // Current Date\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.prev = function() {\n        this.unselect();\n        this.dispatch({\n            type: \"PREV\"\n        });\n    };\n    CalendarApi.prototype.next = function() {\n        this.unselect();\n        this.dispatch({\n            type: \"NEXT\"\n        });\n    };\n    CalendarApi.prototype.prevYear = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, -1)\n        });\n    };\n    CalendarApi.prototype.nextYear = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.addYears(state.currentDate, 1)\n        });\n    };\n    CalendarApi.prototype.today = function() {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: getNow(state.calendarOptions.now, state.dateEnv)\n        });\n    };\n    CalendarApi.prototype.gotoDate = function(zonedDateInput) {\n        var state = this.getCurrentData();\n        this.unselect();\n        this.dispatch({\n            type: \"CHANGE_DATE\",\n            dateMarker: state.dateEnv.createMarker(zonedDateInput)\n        });\n    };\n    CalendarApi.prototype.incrementDate = function(deltaInput) {\n        var state = this.getCurrentData();\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.unselect();\n            this.dispatch({\n                type: \"CHANGE_DATE\",\n                dateMarker: state.dateEnv.add(state.currentDate, delta)\n            });\n        }\n    };\n    // for external API\n    CalendarApi.prototype.getDate = function() {\n        var state = this.getCurrentData();\n        return state.dateEnv.toDate(state.currentDate);\n    };\n    // Date Formatting Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.formatDate = function(d, formatter) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.format(dateEnv.createMarker(d), createFormatter(formatter));\n    };\n    // `settings` is for formatter AND isEndExclusive\n    CalendarApi.prototype.formatRange = function(d0, d1, settings) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.formatRange(dateEnv.createMarker(d0), dateEnv.createMarker(d1), createFormatter(settings), settings);\n    };\n    CalendarApi.prototype.formatIso = function(d, omitTime) {\n        var dateEnv = this.getCurrentData().dateEnv;\n        return dateEnv.formatIso(dateEnv.createMarker(d), {\n            omitTime: omitTime\n        });\n    };\n    // Date Selection / Event Selection / DayClick\n    // -----------------------------------------------------------------------------------------------------------------\n    // this public method receives start/end dates in any format, with any timezone\n    // NOTE: args were changed from v3\n    CalendarApi.prototype.select = function(dateOrObj, endDate) {\n        var selectionInput;\n        if (endDate == null) {\n            if (dateOrObj.start != null) {\n                selectionInput = dateOrObj;\n            } else {\n                selectionInput = {\n                    start: dateOrObj,\n                    end: null\n                };\n            }\n        } else {\n            selectionInput = {\n                start: dateOrObj,\n                end: endDate\n            };\n        }\n        var state = this.getCurrentData();\n        var selection = parseDateSpan(selectionInput, state.dateEnv, createDuration({\n            days: 1\n        }));\n        if (selection) {\n            this.dispatch({\n                type: \"SELECT_DATES\",\n                selection: selection\n            });\n            triggerDateSelect(selection, null, state);\n        }\n    };\n    // public method\n    CalendarApi.prototype.unselect = function(pev) {\n        var state = this.getCurrentData();\n        if (state.dateSelection) {\n            this.dispatch({\n                type: \"UNSELECT_DATES\"\n            });\n            triggerDateUnselect(pev, state);\n        }\n    };\n    // Public Events API\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.addEvent = function(eventInput, sourceInput) {\n        if (eventInput instanceof EventApi) {\n            var def = eventInput._def;\n            var instance = eventInput._instance;\n            var currentData = this.getCurrentData();\n            // not already present? don't want to add an old snapshot\n            if (!currentData.eventStore.defs[def.defId]) {\n                this.dispatch({\n                    type: \"ADD_EVENTS\",\n                    eventStore: eventTupleToStore({\n                        def: def,\n                        instance: instance\n                    })\n                });\n                this.triggerEventAdd(eventInput);\n            }\n            return eventInput;\n        }\n        var state = this.getCurrentData();\n        var eventSource;\n        if (sourceInput instanceof EventSourceApi) {\n            eventSource = sourceInput.internalEventSource;\n        } else if (typeof sourceInput === \"boolean\") {\n            if (sourceInput) {\n                eventSource = hashValuesToArray(state.eventSources)[0];\n            }\n        } else if (sourceInput != null) {\n            var sourceApi = this.getEventSourceById(sourceInput); // TODO: use an internal function\n            if (!sourceApi) {\n                console.warn('Could not find an event source with ID \"' + sourceInput + '\"'); // TODO: test\n                return null;\n            }\n            eventSource = sourceApi.internalEventSource;\n        }\n        var tuple = parseEvent(eventInput, eventSource, state, false);\n        if (tuple) {\n            var newEventApi = new EventApi(state, tuple.def, tuple.def.recurringDef ? null : tuple.instance);\n            this.dispatch({\n                type: \"ADD_EVENTS\",\n                eventStore: eventTupleToStore(tuple)\n            });\n            this.triggerEventAdd(newEventApi);\n            return newEventApi;\n        }\n        return null;\n    };\n    CalendarApi.prototype.triggerEventAdd = function(eventApi) {\n        var _this = this;\n        var emitter = this.getCurrentData().emitter;\n        emitter.trigger(\"eventAdd\", {\n            event: eventApi,\n            relatedEvents: [],\n            revert: function() {\n                _this.dispatch({\n                    type: \"REMOVE_EVENTS\",\n                    eventStore: eventApiToStore(eventApi)\n                });\n            }\n        });\n    };\n    // TODO: optimize\n    CalendarApi.prototype.getEventById = function(id) {\n        var state = this.getCurrentData();\n        var _a = state.eventStore, defs = _a.defs, instances = _a.instances;\n        id = String(id);\n        for(var defId in defs){\n            var def = defs[defId];\n            if (def.publicId === id) {\n                if (def.recurringDef) {\n                    return new EventApi(state, def, null);\n                }\n                for(var instanceId in instances){\n                    var instance = instances[instanceId];\n                    if (instance.defId === def.defId) {\n                        return new EventApi(state, def, instance);\n                    }\n                }\n            }\n        }\n        return null;\n    };\n    CalendarApi.prototype.getEvents = function() {\n        var currentData = this.getCurrentData();\n        return buildEventApis(currentData.eventStore, currentData);\n    };\n    CalendarApi.prototype.removeAllEvents = function() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENTS\"\n        });\n    };\n    // Public Event Sources API\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.getEventSources = function() {\n        var state = this.getCurrentData();\n        var sourceHash = state.eventSources;\n        var sourceApis = [];\n        for(var internalId in sourceHash){\n            sourceApis.push(new EventSourceApi(state, sourceHash[internalId]));\n        }\n        return sourceApis;\n    };\n    CalendarApi.prototype.getEventSourceById = function(id) {\n        var state = this.getCurrentData();\n        var sourceHash = state.eventSources;\n        id = String(id);\n        for(var sourceId in sourceHash){\n            if (sourceHash[sourceId].publicId === id) {\n                return new EventSourceApi(state, sourceHash[sourceId]);\n            }\n        }\n        return null;\n    };\n    CalendarApi.prototype.addEventSource = function(sourceInput) {\n        var state = this.getCurrentData();\n        if (sourceInput instanceof EventSourceApi) {\n            // not already present? don't want to add an old snapshot\n            if (!state.eventSources[sourceInput.internalEventSource.sourceId]) {\n                this.dispatch({\n                    type: \"ADD_EVENT_SOURCES\",\n                    sources: [\n                        sourceInput.internalEventSource\n                    ]\n                });\n            }\n            return sourceInput;\n        }\n        var eventSource = parseEventSource(sourceInput, state);\n        if (eventSource) {\n            this.dispatch({\n                type: \"ADD_EVENT_SOURCES\",\n                sources: [\n                    eventSource\n                ]\n            });\n            return new EventSourceApi(state, eventSource);\n        }\n        return null;\n    };\n    CalendarApi.prototype.removeAllEventSources = function() {\n        this.dispatch({\n            type: \"REMOVE_ALL_EVENT_SOURCES\"\n        });\n    };\n    CalendarApi.prototype.refetchEvents = function() {\n        this.dispatch({\n            type: \"FETCH_EVENT_SOURCES\",\n            isRefetch: true\n        });\n    };\n    // Scroll\n    // -----------------------------------------------------------------------------------------------------------------\n    CalendarApi.prototype.scrollToTime = function(timeInput) {\n        var time = createDuration(timeInput);\n        if (time) {\n            this.trigger(\"_scrollRequest\", {\n                time: time\n            });\n        }\n    };\n    return CalendarApi;\n}();\nvar EventApi = /** @class */ function() {\n    // instance will be null if expressing a recurring event that has no current instances,\n    // OR if trying to validate an incoming external event that has no dates assigned\n    function EventApi(context, def, instance) {\n        this._context = context;\n        this._def = def;\n        this._instance = instance || null;\n    }\n    /*\n    TODO: make event struct more responsible for this\n    */ EventApi.prototype.setProp = function(name, val) {\n        var _a, _b;\n        if (name in EVENT_DATE_REFINERS) {\n            console.warn(\"Could not set date-related prop 'name'. Use one of the date-related methods instead.\");\n        // TODO: make proper aliasing system?\n        } else if (name === \"id\") {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: {\n                    publicId: val\n                }\n            });\n        } else if (name in EVENT_NON_DATE_REFINERS) {\n            val = EVENT_NON_DATE_REFINERS[name](val);\n            this.mutate({\n                standardProps: (_a = {}, _a[name] = val, _a)\n            });\n        } else if (name in EVENT_UI_REFINERS) {\n            var ui = EVENT_UI_REFINERS[name](val);\n            if (name === \"color\") {\n                ui = {\n                    backgroundColor: val,\n                    borderColor: val\n                };\n            } else if (name === \"editable\") {\n                ui = {\n                    startEditable: val,\n                    durationEditable: val\n                };\n            } else {\n                ui = (_b = {}, _b[name] = val, _b);\n            }\n            this.mutate({\n                standardProps: {\n                    ui: ui\n                }\n            });\n        } else {\n            console.warn(\"Could not set prop '\" + name + \"'. Use setExtendedProp instead.\");\n        }\n    };\n    EventApi.prototype.setExtendedProp = function(name, val) {\n        var _a;\n        this.mutate({\n            extendedProps: (_a = {}, _a[name] = val, _a)\n        });\n    };\n    EventApi.prototype.setStart = function(startInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var start = dateEnv.createMarker(startInput);\n        if (start && this._instance) {\n            var instanceRange = this._instance.range;\n            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity); // what if parsed bad!?\n            if (options.maintainDuration) {\n                this.mutate({\n                    datesDelta: startDelta\n                });\n            } else {\n                this.mutate({\n                    startDelta: startDelta\n                });\n            }\n        }\n    };\n    EventApi.prototype.setEnd = function(endInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var end;\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return; // TODO: warning if parsed bad\n            }\n        }\n        if (this._instance) {\n            if (end) {\n                var endDelta = diffDates(this._instance.range.end, end, dateEnv, options.granularity);\n                this.mutate({\n                    endDelta: endDelta\n                });\n            } else {\n                this.mutate({\n                    standardProps: {\n                        hasEnd: false\n                    }\n                });\n            }\n        }\n    };\n    EventApi.prototype.setDates = function(startInput, endInput, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var dateEnv = this._context.dateEnv;\n        var standardProps = {\n            allDay: options.allDay\n        };\n        var start = dateEnv.createMarker(startInput);\n        var end;\n        if (!start) {\n            return; // TODO: warning if parsed bad\n        }\n        if (endInput != null) {\n            end = dateEnv.createMarker(endInput);\n            if (!end) {\n                return;\n            }\n        }\n        if (this._instance) {\n            var instanceRange = this._instance.range;\n            // when computing the diff for an event being converted to all-day,\n            // compute diff off of the all-day values the way event-mutation does.\n            if (options.allDay === true) {\n                instanceRange = computeAlignedDayRange(instanceRange);\n            }\n            var startDelta = diffDates(instanceRange.start, start, dateEnv, options.granularity);\n            if (end) {\n                var endDelta = diffDates(instanceRange.end, end, dateEnv, options.granularity);\n                if (durationsEqual(startDelta, endDelta)) {\n                    this.mutate({\n                        datesDelta: startDelta,\n                        standardProps: standardProps\n                    });\n                } else {\n                    this.mutate({\n                        startDelta: startDelta,\n                        endDelta: endDelta,\n                        standardProps: standardProps\n                    });\n                }\n            } else {\n                standardProps.hasEnd = false;\n                this.mutate({\n                    datesDelta: startDelta,\n                    standardProps: standardProps\n                });\n            }\n        }\n    };\n    EventApi.prototype.moveStart = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                startDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.moveEnd = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                endDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.moveDates = function(deltaInput) {\n        var delta = createDuration(deltaInput);\n        if (delta) {\n            this.mutate({\n                datesDelta: delta\n            });\n        }\n    };\n    EventApi.prototype.setAllDay = function(allDay, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var standardProps = {\n            allDay: allDay\n        };\n        var maintainDuration = options.maintainDuration;\n        if (maintainDuration == null) {\n            maintainDuration = this._context.options.allDayMaintainDuration;\n        }\n        if (this._def.allDay !== allDay) {\n            standardProps.hasEnd = maintainDuration;\n        }\n        this.mutate({\n            standardProps: standardProps\n        });\n    };\n    EventApi.prototype.formatRange = function(formatInput) {\n        var dateEnv = this._context.dateEnv;\n        var instance = this._instance;\n        var formatter = createFormatter(formatInput);\n        if (this._def.hasEnd) {\n            return dateEnv.formatRange(instance.range.start, instance.range.end, formatter, {\n                forcedStartTzo: instance.forcedStartTzo,\n                forcedEndTzo: instance.forcedEndTzo\n            });\n        }\n        return dateEnv.format(instance.range.start, formatter, {\n            forcedTzo: instance.forcedStartTzo\n        });\n    };\n    EventApi.prototype.mutate = function(mutation) {\n        var instance = this._instance;\n        if (instance) {\n            var def = this._def;\n            var context_1 = this._context;\n            var eventStore_1 = context_1.getCurrentData().eventStore;\n            var relevantEvents = getRelevantEvents(eventStore_1, instance.instanceId);\n            var eventConfigBase = {\n                \"\": {\n                    display: \"\",\n                    startEditable: true,\n                    durationEditable: true,\n                    constraints: [],\n                    overlap: null,\n                    allows: [],\n                    backgroundColor: \"\",\n                    borderColor: \"\",\n                    textColor: \"\",\n                    classNames: []\n                }\n            };\n            relevantEvents = applyMutationToEventStore(relevantEvents, eventConfigBase, mutation, context_1);\n            var oldEvent = new EventApi(context_1, def, instance); // snapshot\n            this._def = relevantEvents.defs[def.defId];\n            this._instance = relevantEvents.instances[instance.instanceId];\n            context_1.dispatch({\n                type: \"MERGE_EVENTS\",\n                eventStore: relevantEvents\n            });\n            context_1.emitter.trigger(\"eventChange\", {\n                oldEvent: oldEvent,\n                event: this,\n                relatedEvents: buildEventApis(relevantEvents, context_1, instance),\n                revert: function() {\n                    context_1.dispatch({\n                        type: \"RESET_EVENTS\",\n                        eventStore: eventStore_1\n                    });\n                }\n            });\n        }\n    };\n    EventApi.prototype.remove = function() {\n        var context = this._context;\n        var asStore = eventApiToStore(this);\n        context.dispatch({\n            type: \"REMOVE_EVENTS\",\n            eventStore: asStore\n        });\n        context.emitter.trigger(\"eventRemove\", {\n            event: this,\n            relatedEvents: [],\n            revert: function() {\n                context.dispatch({\n                    type: \"MERGE_EVENTS\",\n                    eventStore: asStore\n                });\n            }\n        });\n    };\n    Object.defineProperty(EventApi.prototype, \"source\", {\n        get: function() {\n            var sourceId = this._def.sourceId;\n            if (sourceId) {\n                return new EventSourceApi(this._context, this._context.getCurrentData().eventSources[sourceId]);\n            }\n            return null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"start\", {\n        get: function() {\n            return this._instance ? this._context.dateEnv.toDate(this._instance.range.start) : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"end\", {\n        get: function() {\n            return this._instance && this._def.hasEnd ? this._context.dateEnv.toDate(this._instance.range.end) : null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"startStr\", {\n        get: function() {\n            var instance = this._instance;\n            if (instance) {\n                return this._context.dateEnv.formatIso(instance.range.start, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedStartTzo\n                });\n            }\n            return \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"endStr\", {\n        get: function() {\n            var instance = this._instance;\n            if (instance && this._def.hasEnd) {\n                return this._context.dateEnv.formatIso(instance.range.end, {\n                    omitTime: this._def.allDay,\n                    forcedTzo: instance.forcedEndTzo\n                });\n            }\n            return \"\";\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"id\", {\n        // computable props that all access the def\n        // TODO: find a TypeScript-compatible way to do this at scale\n        get: function() {\n            return this._def.publicId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"groupId\", {\n        get: function() {\n            return this._def.groupId;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"allDay\", {\n        get: function() {\n            return this._def.allDay;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"title\", {\n        get: function() {\n            return this._def.title;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"url\", {\n        get: function() {\n            return this._def.url;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"display\", {\n        get: function() {\n            return this._def.ui.display || \"auto\";\n        } // bad. just normalize the type earlier\n        ,\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"startEditable\", {\n        get: function() {\n            return this._def.ui.startEditable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"durationEditable\", {\n        get: function() {\n            return this._def.ui.durationEditable;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"constraint\", {\n        get: function() {\n            return this._def.ui.constraints[0] || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"overlap\", {\n        get: function() {\n            return this._def.ui.overlap;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"allow\", {\n        get: function() {\n            return this._def.ui.allows[0] || null;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"backgroundColor\", {\n        get: function() {\n            return this._def.ui.backgroundColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"borderColor\", {\n        get: function() {\n            return this._def.ui.borderColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"textColor\", {\n        get: function() {\n            return this._def.ui.textColor;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"classNames\", {\n        // NOTE: user can't modify these because Object.freeze was called in event-def parsing\n        get: function() {\n            return this._def.ui.classNames;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(EventApi.prototype, \"extendedProps\", {\n        get: function() {\n            return this._def.extendedProps;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    EventApi.prototype.toPlainObject = function(settings) {\n        if (settings === void 0) {\n            settings = {};\n        }\n        var def = this._def;\n        var ui = def.ui;\n        var _a = this, startStr = _a.startStr, endStr = _a.endStr;\n        var res = {};\n        if (def.title) {\n            res.title = def.title;\n        }\n        if (startStr) {\n            res.start = startStr;\n        }\n        if (endStr) {\n            res.end = endStr;\n        }\n        if (def.publicId) {\n            res.id = def.publicId;\n        }\n        if (def.groupId) {\n            res.groupId = def.groupId;\n        }\n        if (def.url) {\n            res.url = def.url;\n        }\n        if (ui.display && ui.display !== \"auto\") {\n            res.display = ui.display;\n        }\n        // TODO: what about recurring-event properties???\n        // TODO: include startEditable/durationEditable/constraint/overlap/allow\n        if (settings.collapseColor && ui.backgroundColor && ui.backgroundColor === ui.borderColor) {\n            res.color = ui.backgroundColor;\n        } else {\n            if (ui.backgroundColor) {\n                res.backgroundColor = ui.backgroundColor;\n            }\n            if (ui.borderColor) {\n                res.borderColor = ui.borderColor;\n            }\n        }\n        if (ui.textColor) {\n            res.textColor = ui.textColor;\n        }\n        if (ui.classNames.length) {\n            res.classNames = ui.classNames;\n        }\n        if (Object.keys(def.extendedProps).length) {\n            if (settings.collapseExtendedProps) {\n                tslib.__assign(res, def.extendedProps);\n            } else {\n                res.extendedProps = def.extendedProps;\n            }\n        }\n        return res;\n    };\n    EventApi.prototype.toJSON = function() {\n        return this.toPlainObject();\n    };\n    return EventApi;\n}();\nfunction eventApiToStore(eventApi) {\n    var _a, _b;\n    var def = eventApi._def;\n    var instance = eventApi._instance;\n    return {\n        defs: (_a = {}, _a[def.defId] = def, _a),\n        instances: instance ? (_b = {}, _b[instance.instanceId] = instance, _b) : {}\n    };\n}\nfunction buildEventApis(eventStore, context, excludeInstance) {\n    var defs = eventStore.defs, instances = eventStore.instances;\n    var eventApis = [];\n    var excludeInstanceId = excludeInstance ? excludeInstance.instanceId : \"\";\n    for(var id in instances){\n        var instance = instances[id];\n        var def = defs[instance.defId];\n        if (instance.instanceId !== excludeInstanceId) {\n            eventApis.push(new EventApi(context, def, instance));\n        }\n    }\n    return eventApis;\n}\nvar calendarSystemClassMap = {};\nfunction registerCalendarSystem(name, theClass) {\n    calendarSystemClassMap[name] = theClass;\n}\nfunction createCalendarSystem(name) {\n    return new calendarSystemClassMap[name]();\n}\nvar GregorianCalendarSystem = /** @class */ function() {\n    function GregorianCalendarSystem() {}\n    GregorianCalendarSystem.prototype.getMarkerYear = function(d) {\n        return d.getUTCFullYear();\n    };\n    GregorianCalendarSystem.prototype.getMarkerMonth = function(d) {\n        return d.getUTCMonth();\n    };\n    GregorianCalendarSystem.prototype.getMarkerDay = function(d) {\n        return d.getUTCDate();\n    };\n    GregorianCalendarSystem.prototype.arrayToMarker = function(arr) {\n        return arrayToUtcDate(arr);\n    };\n    GregorianCalendarSystem.prototype.markerToArray = function(marker) {\n        return dateToUtcArray(marker);\n    };\n    return GregorianCalendarSystem;\n}();\nregisterCalendarSystem(\"gregory\", GregorianCalendarSystem);\nvar ISO_RE = /^\\s*(\\d{4})(-?(\\d{2})(-?(\\d{2})([T ](\\d{2}):?(\\d{2})(:?(\\d{2})(\\.(\\d+))?)?(Z|(([-+])(\\d{2})(:?(\\d{2}))?))?)?)?)?$/;\nfunction parse(str) {\n    var m = ISO_RE.exec(str);\n    if (m) {\n        var marker = new Date(Date.UTC(Number(m[1]), m[3] ? Number(m[3]) - 1 : 0, Number(m[5] || 1), Number(m[7] || 0), Number(m[8] || 0), Number(m[10] || 0), m[12] ? Number(\"0.\" + m[12]) * 1000 : 0));\n        if (isValidDate(marker)) {\n            var timeZoneOffset = null;\n            if (m[13]) {\n                timeZoneOffset = (m[15] === \"-\" ? -1 : 1) * (Number(m[16] || 0) * 60 + Number(m[18] || 0));\n            }\n            return {\n                marker: marker,\n                isTimeUnspecified: !m[6],\n                timeZoneOffset: timeZoneOffset\n            };\n        }\n    }\n    return null;\n}\nvar DateEnv = /** @class */ function() {\n    function DateEnv(settings) {\n        var timeZone = this.timeZone = settings.timeZone;\n        var isNamedTimeZone = timeZone !== \"local\" && timeZone !== \"UTC\";\n        if (settings.namedTimeZoneImpl && isNamedTimeZone) {\n            this.namedTimeZoneImpl = new settings.namedTimeZoneImpl(timeZone);\n        }\n        this.canComputeOffset = Boolean(!isNamedTimeZone || this.namedTimeZoneImpl);\n        this.calendarSystem = createCalendarSystem(settings.calendarSystem);\n        this.locale = settings.locale;\n        this.weekDow = settings.locale.week.dow;\n        this.weekDoy = settings.locale.week.doy;\n        if (settings.weekNumberCalculation === \"ISO\") {\n            this.weekDow = 1;\n            this.weekDoy = 4;\n        }\n        if (typeof settings.firstDay === \"number\") {\n            this.weekDow = settings.firstDay;\n        }\n        if (typeof settings.weekNumberCalculation === \"function\") {\n            this.weekNumberFunc = settings.weekNumberCalculation;\n        }\n        this.weekText = settings.weekText != null ? settings.weekText : settings.locale.options.weekText;\n        this.weekTextLong = (settings.weekTextLong != null ? settings.weekTextLong : settings.locale.options.weekTextLong) || this.weekText;\n        this.cmdFormatter = settings.cmdFormatter;\n        this.defaultSeparator = settings.defaultSeparator;\n    }\n    // Creating / Parsing\n    DateEnv.prototype.createMarker = function(input) {\n        var meta = this.createMarkerMeta(input);\n        if (meta === null) {\n            return null;\n        }\n        return meta.marker;\n    };\n    DateEnv.prototype.createNowMarker = function() {\n        if (this.canComputeOffset) {\n            return this.timestampToMarker(new Date().valueOf());\n        }\n        // if we can't compute the current date val for a timezone,\n        // better to give the current local date vals than UTC\n        return arrayToUtcDate(dateToLocalArray(new Date()));\n    };\n    DateEnv.prototype.createMarkerMeta = function(input) {\n        if (typeof input === \"string\") {\n            return this.parse(input);\n        }\n        var marker = null;\n        if (typeof input === \"number\") {\n            marker = this.timestampToMarker(input);\n        } else if (input instanceof Date) {\n            input = input.valueOf();\n            if (!isNaN(input)) {\n                marker = this.timestampToMarker(input);\n            }\n        } else if (Array.isArray(input)) {\n            marker = arrayToUtcDate(input);\n        }\n        if (marker === null || !isValidDate(marker)) {\n            return null;\n        }\n        return {\n            marker: marker,\n            isTimeUnspecified: false,\n            forcedTzo: null\n        };\n    };\n    DateEnv.prototype.parse = function(s) {\n        var parts = parse(s);\n        if (parts === null) {\n            return null;\n        }\n        var marker = parts.marker;\n        var forcedTzo = null;\n        if (parts.timeZoneOffset !== null) {\n            if (this.canComputeOffset) {\n                marker = this.timestampToMarker(marker.valueOf() - parts.timeZoneOffset * 60 * 1000);\n            } else {\n                forcedTzo = parts.timeZoneOffset;\n            }\n        }\n        return {\n            marker: marker,\n            isTimeUnspecified: parts.isTimeUnspecified,\n            forcedTzo: forcedTzo\n        };\n    };\n    // Accessors\n    DateEnv.prototype.getYear = function(marker) {\n        return this.calendarSystem.getMarkerYear(marker);\n    };\n    DateEnv.prototype.getMonth = function(marker) {\n        return this.calendarSystem.getMarkerMonth(marker);\n    };\n    // Adding / Subtracting\n    DateEnv.prototype.add = function(marker, dur) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] += dur.years;\n        a[1] += dur.months;\n        a[2] += dur.days;\n        a[6] += dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.subtract = function(marker, dur) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] -= dur.years;\n        a[1] -= dur.months;\n        a[2] -= dur.days;\n        a[6] -= dur.milliseconds;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.addYears = function(marker, n) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[0] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    DateEnv.prototype.addMonths = function(marker, n) {\n        var a = this.calendarSystem.markerToArray(marker);\n        a[1] += n;\n        return this.calendarSystem.arrayToMarker(a);\n    };\n    // Diffing Whole Units\n    DateEnv.prototype.diffWholeYears = function(m0, m1) {\n        var calendarSystem = this.calendarSystem;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1) && calendarSystem.getMarkerMonth(m0) === calendarSystem.getMarkerMonth(m1)) {\n            return calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0);\n        }\n        return null;\n    };\n    DateEnv.prototype.diffWholeMonths = function(m0, m1) {\n        var calendarSystem = this.calendarSystem;\n        if (timeAsMs(m0) === timeAsMs(m1) && calendarSystem.getMarkerDay(m0) === calendarSystem.getMarkerDay(m1)) {\n            return calendarSystem.getMarkerMonth(m1) - calendarSystem.getMarkerMonth(m0) + (calendarSystem.getMarkerYear(m1) - calendarSystem.getMarkerYear(m0)) * 12;\n        }\n        return null;\n    };\n    // Range / Duration\n    DateEnv.prototype.greatestWholeUnit = function(m0, m1) {\n        var n = this.diffWholeYears(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"year\",\n                value: n\n            };\n        }\n        n = this.diffWholeMonths(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"month\",\n                value: n\n            };\n        }\n        n = diffWholeWeeks(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"week\",\n                value: n\n            };\n        }\n        n = diffWholeDays(m0, m1);\n        if (n !== null) {\n            return {\n                unit: \"day\",\n                value: n\n            };\n        }\n        n = diffHours(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"hour\",\n                value: n\n            };\n        }\n        n = diffMinutes(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"minute\",\n                value: n\n            };\n        }\n        n = diffSeconds(m0, m1);\n        if (isInt(n)) {\n            return {\n                unit: \"second\",\n                value: n\n            };\n        }\n        return {\n            unit: \"millisecond\",\n            value: m1.valueOf() - m0.valueOf()\n        };\n    };\n    DateEnv.prototype.countDurationsBetween = function(m0, m1, d) {\n        // TODO: can use greatestWholeUnit\n        var diff;\n        if (d.years) {\n            diff = this.diffWholeYears(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughYears(d);\n            }\n        }\n        if (d.months) {\n            diff = this.diffWholeMonths(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughMonths(d);\n            }\n        }\n        if (d.days) {\n            diff = diffWholeDays(m0, m1);\n            if (diff !== null) {\n                return diff / asRoughDays(d);\n            }\n        }\n        return (m1.valueOf() - m0.valueOf()) / asRoughMs(d);\n    };\n    // Start-Of\n    // these DON'T return zoned-dates. only UTC start-of dates\n    DateEnv.prototype.startOf = function(m, unit) {\n        if (unit === \"year\") {\n            return this.startOfYear(m);\n        }\n        if (unit === \"month\") {\n            return this.startOfMonth(m);\n        }\n        if (unit === \"week\") {\n            return this.startOfWeek(m);\n        }\n        if (unit === \"day\") {\n            return startOfDay(m);\n        }\n        if (unit === \"hour\") {\n            return startOfHour(m);\n        }\n        if (unit === \"minute\") {\n            return startOfMinute(m);\n        }\n        if (unit === \"second\") {\n            return startOfSecond(m);\n        }\n        return null;\n    };\n    DateEnv.prototype.startOfYear = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m)\n        ]);\n    };\n    DateEnv.prototype.startOfMonth = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m)\n        ]);\n    };\n    DateEnv.prototype.startOfWeek = function(m) {\n        return this.calendarSystem.arrayToMarker([\n            this.calendarSystem.getMarkerYear(m),\n            this.calendarSystem.getMarkerMonth(m),\n            m.getUTCDate() - (m.getUTCDay() - this.weekDow + 7) % 7\n        ]);\n    };\n    // Week Number\n    DateEnv.prototype.computeWeekNumber = function(marker) {\n        if (this.weekNumberFunc) {\n            return this.weekNumberFunc(this.toDate(marker));\n        }\n        return weekOfYear(marker, this.weekDow, this.weekDoy);\n    };\n    // TODO: choke on timeZoneName: long\n    DateEnv.prototype.format = function(marker, formatter, dateOptions) {\n        if (dateOptions === void 0) {\n            dateOptions = {};\n        }\n        return formatter.format({\n            marker: marker,\n            timeZoneOffset: dateOptions.forcedTzo != null ? dateOptions.forcedTzo : this.offsetForMarker(marker)\n        }, this);\n    };\n    DateEnv.prototype.formatRange = function(start, end, formatter, dateOptions) {\n        if (dateOptions === void 0) {\n            dateOptions = {};\n        }\n        if (dateOptions.isEndExclusive) {\n            end = addMs(end, -1);\n        }\n        return formatter.formatRange({\n            marker: start,\n            timeZoneOffset: dateOptions.forcedStartTzo != null ? dateOptions.forcedStartTzo : this.offsetForMarker(start)\n        }, {\n            marker: end,\n            timeZoneOffset: dateOptions.forcedEndTzo != null ? dateOptions.forcedEndTzo : this.offsetForMarker(end)\n        }, this, dateOptions.defaultSeparator);\n    };\n    /*\n    DUMB: the omitTime arg is dumb. if we omit the time, we want to omit the timezone offset. and if we do that,\n    might as well use buildIsoString or some other util directly\n    */ DateEnv.prototype.formatIso = function(marker, extraOptions) {\n        if (extraOptions === void 0) {\n            extraOptions = {};\n        }\n        var timeZoneOffset = null;\n        if (!extraOptions.omitTimeZoneOffset) {\n            if (extraOptions.forcedTzo != null) {\n                timeZoneOffset = extraOptions.forcedTzo;\n            } else {\n                timeZoneOffset = this.offsetForMarker(marker);\n            }\n        }\n        return buildIsoString(marker, timeZoneOffset, extraOptions.omitTime);\n    };\n    // TimeZone\n    DateEnv.prototype.timestampToMarker = function(ms) {\n        if (this.timeZone === \"local\") {\n            return arrayToUtcDate(dateToLocalArray(new Date(ms)));\n        }\n        if (this.timeZone === \"UTC\" || !this.namedTimeZoneImpl) {\n            return new Date(ms);\n        }\n        return arrayToUtcDate(this.namedTimeZoneImpl.timestampToArray(ms));\n    };\n    DateEnv.prototype.offsetForMarker = function(m) {\n        if (this.timeZone === \"local\") {\n            return -arrayToLocalDate(dateToUtcArray(m)).getTimezoneOffset(); // convert \"inverse\" offset to \"normal\" offset\n        }\n        if (this.timeZone === \"UTC\") {\n            return 0;\n        }\n        if (this.namedTimeZoneImpl) {\n            return this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m));\n        }\n        return null;\n    };\n    // Conversion\n    DateEnv.prototype.toDate = function(m, forcedTzo) {\n        if (this.timeZone === \"local\") {\n            return arrayToLocalDate(dateToUtcArray(m));\n        }\n        if (this.timeZone === \"UTC\") {\n            return new Date(m.valueOf()); // make sure it's a copy\n        }\n        if (!this.namedTimeZoneImpl) {\n            return new Date(m.valueOf() - (forcedTzo || 0));\n        }\n        return new Date(m.valueOf() - this.namedTimeZoneImpl.offsetForArray(dateToUtcArray(m)) * 1000 * 60);\n    };\n    return DateEnv;\n}();\nvar globalLocales = [];\nvar MINIMAL_RAW_EN_LOCALE = {\n    code: \"en\",\n    week: {\n        dow: 0,\n        doy: 4\n    },\n    direction: \"ltr\",\n    buttonText: {\n        prev: \"prev\",\n        next: \"next\",\n        prevYear: \"prev year\",\n        nextYear: \"next year\",\n        year: \"year\",\n        today: \"today\",\n        month: \"month\",\n        week: \"week\",\n        day: \"day\",\n        list: \"list\"\n    },\n    weekText: \"W\",\n    weekTextLong: \"Week\",\n    closeHint: \"Close\",\n    timeHint: \"Time\",\n    eventHint: \"Event\",\n    allDayText: \"all-day\",\n    moreLinkText: \"more\",\n    noEventsText: \"No events to display\"\n};\nvar RAW_EN_LOCALE = tslib.__assign(tslib.__assign({}, MINIMAL_RAW_EN_LOCALE), {\n    // Includes things we don't want other locales to inherit,\n    // things that derive from other translatable strings.\n    buttonHints: {\n        prev: \"Previous $0\",\n        next: \"Next $0\",\n        today: function(buttonText, unit) {\n            return unit === \"day\" ? \"Today\" : \"This \" + buttonText;\n        }\n    },\n    viewHint: \"$0 view\",\n    navLinkHint: \"Go to $0\",\n    moreLinkHint: function(eventCnt) {\n        return \"Show \" + eventCnt + \" more event\" + (eventCnt === 1 ? \"\" : \"s\");\n    }\n});\nfunction organizeRawLocales(explicitRawLocales) {\n    var defaultCode = explicitRawLocales.length > 0 ? explicitRawLocales[0].code : \"en\";\n    var allRawLocales = globalLocales.concat(explicitRawLocales);\n    var rawLocaleMap = {\n        en: RAW_EN_LOCALE\n    };\n    for(var _i = 0, allRawLocales_1 = allRawLocales; _i < allRawLocales_1.length; _i++){\n        var rawLocale = allRawLocales_1[_i];\n        rawLocaleMap[rawLocale.code] = rawLocale;\n    }\n    return {\n        map: rawLocaleMap,\n        defaultCode: defaultCode\n    };\n}\nfunction buildLocale(inputSingular, available) {\n    if (typeof inputSingular === \"object\" && !Array.isArray(inputSingular)) {\n        return parseLocale(inputSingular.code, [\n            inputSingular.code\n        ], inputSingular);\n    }\n    return queryLocale(inputSingular, available);\n}\nfunction queryLocale(codeArg, available) {\n    var codes = [].concat(codeArg || []); // will convert to array\n    var raw = queryRawLocale(codes, available) || RAW_EN_LOCALE;\n    return parseLocale(codeArg, codes, raw);\n}\nfunction queryRawLocale(codes, available) {\n    for(var i = 0; i < codes.length; i += 1){\n        var parts = codes[i].toLocaleLowerCase().split(\"-\");\n        for(var j = parts.length; j > 0; j -= 1){\n            var simpleId = parts.slice(0, j).join(\"-\");\n            if (available[simpleId]) {\n                return available[simpleId];\n            }\n        }\n    }\n    return null;\n}\nfunction parseLocale(codeArg, codes, raw) {\n    var merged = mergeProps([\n        MINIMAL_RAW_EN_LOCALE,\n        raw\n    ], [\n        \"buttonText\"\n    ]);\n    delete merged.code; // don't want this part of the options\n    var week = merged.week;\n    delete merged.week;\n    return {\n        codeArg: codeArg,\n        codes: codes,\n        week: week,\n        simpleNumberFormat: new Intl.NumberFormat(codeArg),\n        options: merged\n    };\n}\nfunction formatDate(dateInput, options) {\n    if (options === void 0) {\n        options = {};\n    }\n    var dateEnv = buildDateEnv$1(options);\n    var formatter = createFormatter(options);\n    var dateMeta = dateEnv.createMarkerMeta(dateInput);\n    if (!dateMeta) {\n        return \"\";\n    }\n    return dateEnv.format(dateMeta.marker, formatter, {\n        forcedTzo: dateMeta.forcedTzo\n    });\n}\nfunction formatRange(startInput, endInput, options) {\n    var dateEnv = buildDateEnv$1(typeof options === \"object\" && options ? options : {}); // pass in if non-null object\n    var formatter = createFormatter(options);\n    var startMeta = dateEnv.createMarkerMeta(startInput);\n    var endMeta = dateEnv.createMarkerMeta(endInput);\n    if (!startMeta || !endMeta) {\n        return \"\";\n    }\n    return dateEnv.formatRange(startMeta.marker, endMeta.marker, formatter, {\n        forcedStartTzo: startMeta.forcedTzo,\n        forcedEndTzo: endMeta.forcedTzo,\n        isEndExclusive: options.isEndExclusive,\n        defaultSeparator: BASE_OPTION_DEFAULTS.defaultRangeSeparator\n    });\n}\n// TODO: more DRY and optimized\nfunction buildDateEnv$1(settings) {\n    var locale = buildLocale(settings.locale || \"en\", organizeRawLocales([]).map); // TODO: don't hardcode 'en' everywhere\n    return new DateEnv(tslib.__assign(tslib.__assign({\n        timeZone: BASE_OPTION_DEFAULTS.timeZone,\n        calendarSystem: \"gregory\"\n    }, settings), {\n        locale: locale\n    }));\n}\nvar DEF_DEFAULTS = {\n    startTime: \"09:00\",\n    endTime: \"17:00\",\n    daysOfWeek: [\n        1,\n        2,\n        3,\n        4,\n        5\n    ],\n    display: \"inverse-background\",\n    classNames: \"fc-non-business\",\n    groupId: \"_businessHours\"\n};\n/*\nTODO: pass around as EventDefHash!!!\n*/ function parseBusinessHours(input, context) {\n    return parseEvents(refineInputs(input), null, context);\n}\nfunction refineInputs(input) {\n    var rawDefs;\n    if (input === true) {\n        rawDefs = [\n            {}\n        ]; // will get DEF_DEFAULTS verbatim\n    } else if (Array.isArray(input)) {\n        // if specifying an array, every sub-definition NEEDS a day-of-week\n        rawDefs = input.filter(function(rawDef) {\n            return rawDef.daysOfWeek;\n        });\n    } else if (typeof input === \"object\" && input) {\n        rawDefs = [\n            input\n        ];\n    } else {\n        rawDefs = [];\n    }\n    rawDefs = rawDefs.map(function(rawDef) {\n        return tslib.__assign(tslib.__assign({}, DEF_DEFAULTS), rawDef);\n    });\n    return rawDefs;\n}\nfunction pointInsideRect(point, rect) {\n    return point.left >= rect.left && point.left < rect.right && point.top >= rect.top && point.top < rect.bottom;\n}\n// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false\nfunction intersectRects(rect1, rect2) {\n    var res = {\n        left: Math.max(rect1.left, rect2.left),\n        right: Math.min(rect1.right, rect2.right),\n        top: Math.max(rect1.top, rect2.top),\n        bottom: Math.min(rect1.bottom, rect2.bottom)\n    };\n    if (res.left < res.right && res.top < res.bottom) {\n        return res;\n    }\n    return false;\n}\nfunction translateRect(rect, deltaX, deltaY) {\n    return {\n        left: rect.left + deltaX,\n        right: rect.right + deltaX,\n        top: rect.top + deltaY,\n        bottom: rect.bottom + deltaY\n    };\n}\n// Returns a new point that will have been moved to reside within the given rectangle\nfunction constrainPoint(point, rect) {\n    return {\n        left: Math.min(Math.max(point.left, rect.left), rect.right),\n        top: Math.min(Math.max(point.top, rect.top), rect.bottom)\n    };\n}\n// Returns a point that is the center of the given rectangle\nfunction getRectCenter(rect) {\n    return {\n        left: (rect.left + rect.right) / 2,\n        top: (rect.top + rect.bottom) / 2\n    };\n}\n// Subtracts point2's coordinates from point1's coordinates, returning a delta\nfunction diffPoints(point1, point2) {\n    return {\n        left: point1.left - point2.left,\n        top: point1.top - point2.top\n    };\n}\nvar canVGrowWithinCell;\nfunction getCanVGrowWithinCell() {\n    if (canVGrowWithinCell == null) {\n        canVGrowWithinCell = computeCanVGrowWithinCell();\n    }\n    return canVGrowWithinCell;\n}\nfunction computeCanVGrowWithinCell() {\n    // for SSR, because this function is call immediately at top-level\n    // TODO: just make this logic execute top-level, immediately, instead of doing lazily\n    if (typeof document === \"undefined\") {\n        return true;\n    }\n    var el = document.createElement(\"div\");\n    el.style.position = \"absolute\";\n    el.style.top = \"0px\";\n    el.style.left = \"0px\";\n    el.innerHTML = \"<table><tr><td><div></div></td></tr></table>\";\n    el.querySelector(\"table\").style.height = \"100px\";\n    el.querySelector(\"div\").style.height = \"100%\";\n    document.body.appendChild(el);\n    var div = el.querySelector(\"div\");\n    var possible = div.offsetHeight > 0;\n    document.body.removeChild(el);\n    return possible;\n}\nvar EMPTY_EVENT_STORE = createEmptyEventStore(); // for purecomponents. TODO: keep elsewhere\nvar Splitter = /** @class */ function() {\n    function Splitter() {\n        this.getKeysForEventDefs = memoize(this._getKeysForEventDefs);\n        this.splitDateSelection = memoize(this._splitDateSpan);\n        this.splitEventStore = memoize(this._splitEventStore);\n        this.splitIndividualUi = memoize(this._splitIndividualUi);\n        this.splitEventDrag = memoize(this._splitInteraction);\n        this.splitEventResize = memoize(this._splitInteraction);\n        this.eventUiBuilders = {}; // TODO: typescript protection\n    }\n    Splitter.prototype.splitProps = function(props) {\n        var _this = this;\n        var keyInfos = this.getKeyInfo(props);\n        var defKeys = this.getKeysForEventDefs(props.eventStore);\n        var dateSelections = this.splitDateSelection(props.dateSelection);\n        var individualUi = this.splitIndividualUi(props.eventUiBases, defKeys); // the individual *bases*\n        var eventStores = this.splitEventStore(props.eventStore, defKeys);\n        var eventDrags = this.splitEventDrag(props.eventDrag);\n        var eventResizes = this.splitEventResize(props.eventResize);\n        var splitProps = {};\n        this.eventUiBuilders = mapHash(keyInfos, function(info, key) {\n            return _this.eventUiBuilders[key] || memoize(buildEventUiForKey);\n        });\n        for(var key in keyInfos){\n            var keyInfo = keyInfos[key];\n            var eventStore = eventStores[key] || EMPTY_EVENT_STORE;\n            var buildEventUi = this.eventUiBuilders[key];\n            splitProps[key] = {\n                businessHours: keyInfo.businessHours || props.businessHours,\n                dateSelection: dateSelections[key] || null,\n                eventStore: eventStore,\n                eventUiBases: buildEventUi(props.eventUiBases[\"\"], keyInfo.ui, individualUi[key]),\n                eventSelection: eventStore.instances[props.eventSelection] ? props.eventSelection : \"\",\n                eventDrag: eventDrags[key] || null,\n                eventResize: eventResizes[key] || null\n            };\n        }\n        return splitProps;\n    };\n    Splitter.prototype._splitDateSpan = function(dateSpan) {\n        var dateSpans = {};\n        if (dateSpan) {\n            var keys = this.getKeysForDateSpan(dateSpan);\n            for(var _i = 0, keys_1 = keys; _i < keys_1.length; _i++){\n                var key = keys_1[_i];\n                dateSpans[key] = dateSpan;\n            }\n        }\n        return dateSpans;\n    };\n    Splitter.prototype._getKeysForEventDefs = function(eventStore) {\n        var _this = this;\n        return mapHash(eventStore.defs, function(eventDef) {\n            return _this.getKeysForEventDef(eventDef);\n        });\n    };\n    Splitter.prototype._splitEventStore = function(eventStore, defKeys) {\n        var defs = eventStore.defs, instances = eventStore.instances;\n        var splitStores = {};\n        for(var defId in defs){\n            for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){\n                var key = _a[_i];\n                if (!splitStores[key]) {\n                    splitStores[key] = createEmptyEventStore();\n                }\n                splitStores[key].defs[defId] = defs[defId];\n            }\n        }\n        for(var instanceId in instances){\n            var instance = instances[instanceId];\n            for(var _b = 0, _c = defKeys[instance.defId]; _b < _c.length; _b++){\n                var key = _c[_b];\n                if (splitStores[key]) {\n                    splitStores[key].instances[instanceId] = instance;\n                }\n            }\n        }\n        return splitStores;\n    };\n    Splitter.prototype._splitIndividualUi = function(eventUiBases, defKeys) {\n        var splitHashes = {};\n        for(var defId in eventUiBases){\n            if (defId) {\n                for(var _i = 0, _a = defKeys[defId]; _i < _a.length; _i++){\n                    var key = _a[_i];\n                    if (!splitHashes[key]) {\n                        splitHashes[key] = {};\n                    }\n                    splitHashes[key][defId] = eventUiBases[defId];\n                }\n            }\n        }\n        return splitHashes;\n    };\n    Splitter.prototype._splitInteraction = function(interaction) {\n        var splitStates = {};\n        if (interaction) {\n            var affectedStores_1 = this._splitEventStore(interaction.affectedEvents, this._getKeysForEventDefs(interaction.affectedEvents));\n            // can't rely on defKeys because event data is mutated\n            var mutatedKeysByDefId = this._getKeysForEventDefs(interaction.mutatedEvents);\n            var mutatedStores_1 = this._splitEventStore(interaction.mutatedEvents, mutatedKeysByDefId);\n            var populate = function(key) {\n                if (!splitStates[key]) {\n                    splitStates[key] = {\n                        affectedEvents: affectedStores_1[key] || EMPTY_EVENT_STORE,\n                        mutatedEvents: mutatedStores_1[key] || EMPTY_EVENT_STORE,\n                        isEvent: interaction.isEvent\n                    };\n                }\n            };\n            for(var key in affectedStores_1){\n                populate(key);\n            }\n            for(var key in mutatedStores_1){\n                populate(key);\n            }\n        }\n        return splitStates;\n    };\n    return Splitter;\n}();\nfunction buildEventUiForKey(allUi, eventUiForKey, individualUi) {\n    var baseParts = [];\n    if (allUi) {\n        baseParts.push(allUi);\n    }\n    if (eventUiForKey) {\n        baseParts.push(eventUiForKey);\n    }\n    var stuff = {\n        \"\": combineEventUis(baseParts)\n    };\n    if (individualUi) {\n        tslib.__assign(stuff, individualUi);\n    }\n    return stuff;\n}\nfunction getDateMeta(date, todayRange, nowDate, dateProfile) {\n    return {\n        dow: date.getUTCDay(),\n        isDisabled: Boolean(dateProfile && !rangeContainsMarker(dateProfile.activeRange, date)),\n        isOther: Boolean(dateProfile && !rangeContainsMarker(dateProfile.currentRange, date)),\n        isToday: Boolean(todayRange && rangeContainsMarker(todayRange, date)),\n        isPast: Boolean(nowDate ? date < nowDate : todayRange ? date < todayRange.start : false),\n        isFuture: Boolean(nowDate ? date > nowDate : todayRange ? date >= todayRange.end : false)\n    };\n}\nfunction getDayClassNames(meta, theme) {\n    var classNames = [\n        \"fc-day\",\n        \"fc-day-\" + DAY_IDS[meta.dow]\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-day-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-day-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-day-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-day-future\");\n        }\n        if (meta.isOther) {\n            classNames.push(\"fc-day-other\");\n        }\n    }\n    return classNames;\n}\nfunction getSlotClassNames(meta, theme) {\n    var classNames = [\n        \"fc-slot\",\n        \"fc-slot-\" + DAY_IDS[meta.dow]\n    ];\n    if (meta.isDisabled) {\n        classNames.push(\"fc-slot-disabled\");\n    } else {\n        if (meta.isToday) {\n            classNames.push(\"fc-slot-today\");\n            classNames.push(theme.getClass(\"today\"));\n        }\n        if (meta.isPast) {\n            classNames.push(\"fc-slot-past\");\n        }\n        if (meta.isFuture) {\n            classNames.push(\"fc-slot-future\");\n        }\n    }\n    return classNames;\n}\nvar DAY_FORMAT = createFormatter({\n    year: \"numeric\",\n    month: \"long\",\n    day: \"numeric\"\n});\nvar WEEK_FORMAT = createFormatter({\n    week: \"long\"\n});\nfunction buildNavLinkAttrs(context, dateMarker, viewType, isTabbable) {\n    if (viewType === void 0) {\n        viewType = \"day\";\n    }\n    if (isTabbable === void 0) {\n        isTabbable = true;\n    }\n    var dateEnv = context.dateEnv, options = context.options, calendarApi = context.calendarApi;\n    var dateStr = dateEnv.format(dateMarker, viewType === \"week\" ? WEEK_FORMAT : DAY_FORMAT);\n    if (options.navLinks) {\n        var zonedDate = dateEnv.toDate(dateMarker);\n        var handleInteraction = function(ev) {\n            var customAction = viewType === \"day\" ? options.navLinkDayClick : viewType === \"week\" ? options.navLinkWeekClick : null;\n            if (typeof customAction === \"function\") {\n                customAction.call(calendarApi, dateEnv.toDate(dateMarker), ev);\n            } else {\n                if (typeof customAction === \"string\") {\n                    viewType = customAction;\n                }\n                calendarApi.zoomTo(dateMarker, viewType);\n            }\n        };\n        return tslib.__assign({\n            title: formatWithOrdinals(options.navLinkHint, [\n                dateStr,\n                zonedDate\n            ], dateStr),\n            \"data-navlink\": \"\"\n        }, isTabbable ? createAriaClickAttrs(handleInteraction) : {\n            onClick: handleInteraction\n        });\n    }\n    return {\n        \"aria-label\": dateStr\n    };\n}\nvar _isRtlScrollbarOnLeft = null;\nfunction getIsRtlScrollbarOnLeft() {\n    if (_isRtlScrollbarOnLeft === null) {\n        _isRtlScrollbarOnLeft = computeIsRtlScrollbarOnLeft();\n    }\n    return _isRtlScrollbarOnLeft;\n}\nfunction computeIsRtlScrollbarOnLeft() {\n    var outerEl = document.createElement(\"div\");\n    applyStyle(outerEl, {\n        position: \"absolute\",\n        top: -1000,\n        left: 0,\n        border: 0,\n        padding: 0,\n        overflow: \"scroll\",\n        direction: \"rtl\"\n    });\n    outerEl.innerHTML = \"<div></div>\";\n    document.body.appendChild(outerEl);\n    var innerEl = outerEl.firstChild;\n    var res = innerEl.getBoundingClientRect().left > outerEl.getBoundingClientRect().left;\n    removeElement(outerEl);\n    return res;\n}\nvar _scrollbarWidths;\nfunction getScrollbarWidths() {\n    if (!_scrollbarWidths) {\n        _scrollbarWidths = computeScrollbarWidths();\n    }\n    return _scrollbarWidths;\n}\nfunction computeScrollbarWidths() {\n    var el = document.createElement(\"div\");\n    el.style.overflow = \"scroll\";\n    el.style.position = \"absolute\";\n    el.style.top = \"-9999px\";\n    el.style.left = \"-9999px\";\n    document.body.appendChild(el);\n    var res = computeScrollbarWidthsForEl(el);\n    document.body.removeChild(el);\n    return res;\n}\n// WARNING: will include border\nfunction computeScrollbarWidthsForEl(el) {\n    return {\n        x: el.offsetHeight - el.clientHeight,\n        y: el.offsetWidth - el.clientWidth\n    };\n}\nfunction computeEdges(el, getPadding) {\n    if (getPadding === void 0) {\n        getPadding = false;\n    }\n    var computedStyle = window.getComputedStyle(el);\n    var borderLeft = parseInt(computedStyle.borderLeftWidth, 10) || 0;\n    var borderRight = parseInt(computedStyle.borderRightWidth, 10) || 0;\n    var borderTop = parseInt(computedStyle.borderTopWidth, 10) || 0;\n    var borderBottom = parseInt(computedStyle.borderBottomWidth, 10) || 0;\n    var badScrollbarWidths = computeScrollbarWidthsForEl(el); // includes border!\n    var scrollbarLeftRight = badScrollbarWidths.y - borderLeft - borderRight;\n    var scrollbarBottom = badScrollbarWidths.x - borderTop - borderBottom;\n    var res = {\n        borderLeft: borderLeft,\n        borderRight: borderRight,\n        borderTop: borderTop,\n        borderBottom: borderBottom,\n        scrollbarBottom: scrollbarBottom,\n        scrollbarLeft: 0,\n        scrollbarRight: 0\n    };\n    if (getIsRtlScrollbarOnLeft() && computedStyle.direction === \"rtl\") {\n        res.scrollbarLeft = scrollbarLeftRight;\n    } else {\n        res.scrollbarRight = scrollbarLeftRight;\n    }\n    if (getPadding) {\n        res.paddingLeft = parseInt(computedStyle.paddingLeft, 10) || 0;\n        res.paddingRight = parseInt(computedStyle.paddingRight, 10) || 0;\n        res.paddingTop = parseInt(computedStyle.paddingTop, 10) || 0;\n        res.paddingBottom = parseInt(computedStyle.paddingBottom, 10) || 0;\n    }\n    return res;\n}\nfunction computeInnerRect(el, goWithinPadding, doFromWindowViewport) {\n    if (goWithinPadding === void 0) {\n        goWithinPadding = false;\n    }\n    var outerRect = doFromWindowViewport ? el.getBoundingClientRect() : computeRect(el);\n    var edges = computeEdges(el, goWithinPadding);\n    var res = {\n        left: outerRect.left + edges.borderLeft + edges.scrollbarLeft,\n        right: outerRect.right - edges.borderRight - edges.scrollbarRight,\n        top: outerRect.top + edges.borderTop,\n        bottom: outerRect.bottom - edges.borderBottom - edges.scrollbarBottom\n    };\n    if (goWithinPadding) {\n        res.left += edges.paddingLeft;\n        res.right -= edges.paddingRight;\n        res.top += edges.paddingTop;\n        res.bottom -= edges.paddingBottom;\n    }\n    return res;\n}\nfunction computeRect(el) {\n    var rect = el.getBoundingClientRect();\n    return {\n        left: rect.left + window.pageXOffset,\n        top: rect.top + window.pageYOffset,\n        right: rect.right + window.pageXOffset,\n        bottom: rect.bottom + window.pageYOffset\n    };\n}\nfunction computeClippedClientRect(el) {\n    var clippingParents = getClippingParents(el);\n    var rect = el.getBoundingClientRect();\n    for(var _i = 0, clippingParents_1 = clippingParents; _i < clippingParents_1.length; _i++){\n        var clippingParent = clippingParents_1[_i];\n        var intersection = intersectRects(rect, clippingParent.getBoundingClientRect());\n        if (intersection) {\n            rect = intersection;\n        } else {\n            return null;\n        }\n    }\n    return rect;\n}\nfunction computeHeightAndMargins(el) {\n    return el.getBoundingClientRect().height + computeVMargins(el);\n}\nfunction computeVMargins(el) {\n    var computed = window.getComputedStyle(el);\n    return parseInt(computed.marginTop, 10) + parseInt(computed.marginBottom, 10);\n}\n// does not return window\nfunction getClippingParents(el) {\n    var parents = [];\n    while(el instanceof HTMLElement){\n        var computedStyle = window.getComputedStyle(el);\n        if (computedStyle.position === \"fixed\") {\n            break;\n        }\n        if (/(auto|scroll)/.test(computedStyle.overflow + computedStyle.overflowY + computedStyle.overflowX)) {\n            parents.push(el);\n        }\n        el = el.parentNode;\n    }\n    return parents;\n}\n// given a function that resolves a result asynchronously.\n// the function can either call passed-in success and failure callbacks,\n// or it can return a promise.\n// if you need to pass additional params to func, bind them first.\nfunction unpromisify(func, success, failure) {\n    // guard against success/failure callbacks being called more than once\n    // and guard against a promise AND callback being used together.\n    var isResolved = false;\n    var wrappedSuccess = function() {\n        if (!isResolved) {\n            isResolved = true;\n            success.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n    };\n    var wrappedFailure = function() {\n        if (!isResolved) {\n            isResolved = true;\n            if (failure) {\n                failure.apply(this, arguments); // eslint-disable-line prefer-rest-params\n            }\n        }\n    };\n    var res = func(wrappedSuccess, wrappedFailure);\n    if (res && typeof res.then === \"function\") {\n        res.then(wrappedSuccess, wrappedFailure);\n    }\n}\nvar Emitter = /** @class */ function() {\n    function Emitter() {\n        this.handlers = {};\n        this.thisContext = null;\n    }\n    Emitter.prototype.setThisContext = function(thisContext) {\n        this.thisContext = thisContext;\n    };\n    Emitter.prototype.setOptions = function(options) {\n        this.options = options;\n    };\n    Emitter.prototype.on = function(type, handler) {\n        addToHash(this.handlers, type, handler);\n    };\n    Emitter.prototype.off = function(type, handler) {\n        removeFromHash(this.handlers, type, handler);\n    };\n    Emitter.prototype.trigger = function(type) {\n        var args = [];\n        for(var _i = 1; _i < arguments.length; _i++){\n            args[_i - 1] = arguments[_i];\n        }\n        var attachedHandlers = this.handlers[type] || [];\n        var optionHandler = this.options && this.options[type];\n        var handlers = [].concat(optionHandler || [], attachedHandlers);\n        for(var _a = 0, handlers_1 = handlers; _a < handlers_1.length; _a++){\n            var handler = handlers_1[_a];\n            handler.apply(this.thisContext, args);\n        }\n    };\n    Emitter.prototype.hasHandlers = function(type) {\n        return Boolean(this.handlers[type] && this.handlers[type].length || this.options && this.options[type]);\n    };\n    return Emitter;\n}();\nfunction addToHash(hash, type, handler) {\n    (hash[type] || (hash[type] = [])).push(handler);\n}\nfunction removeFromHash(hash, type, handler) {\n    if (handler) {\n        if (hash[type]) {\n            hash[type] = hash[type].filter(function(func) {\n                return func !== handler;\n            });\n        }\n    } else {\n        delete hash[type]; // remove all handler funcs for this type\n    }\n}\n/*\nRecords offset information for a set of elements, relative to an origin element.\nCan record the left/right OR the top/bottom OR both.\nProvides methods for querying the cache by position.\n*/ var PositionCache = /** @class */ function() {\n    function PositionCache(originEl, els, isHorizontal, isVertical) {\n        this.els = els;\n        var originClientRect = this.originClientRect = originEl.getBoundingClientRect(); // relative to viewport top-left\n        if (isHorizontal) {\n            this.buildElHorizontals(originClientRect.left);\n        }\n        if (isVertical) {\n            this.buildElVerticals(originClientRect.top);\n        }\n    }\n    // Populates the left/right internal coordinate arrays\n    PositionCache.prototype.buildElHorizontals = function(originClientLeft) {\n        var lefts = [];\n        var rights = [];\n        for(var _i = 0, _a = this.els; _i < _a.length; _i++){\n            var el = _a[_i];\n            var rect = el.getBoundingClientRect();\n            lefts.push(rect.left - originClientLeft);\n            rights.push(rect.right - originClientLeft);\n        }\n        this.lefts = lefts;\n        this.rights = rights;\n    };\n    // Populates the top/bottom internal coordinate arrays\n    PositionCache.prototype.buildElVerticals = function(originClientTop) {\n        var tops = [];\n        var bottoms = [];\n        for(var _i = 0, _a = this.els; _i < _a.length; _i++){\n            var el = _a[_i];\n            var rect = el.getBoundingClientRect();\n            tops.push(rect.top - originClientTop);\n            bottoms.push(rect.bottom - originClientTop);\n        }\n        this.tops = tops;\n        this.bottoms = bottoms;\n    };\n    // Given a left offset (from document left), returns the index of the el that it horizontally intersects.\n    // If no intersection is made, returns undefined.\n    PositionCache.prototype.leftToIndex = function(leftPosition) {\n        var _a = this, lefts = _a.lefts, rights = _a.rights;\n        var len = lefts.length;\n        var i;\n        for(i = 0; i < len; i += 1){\n            if (leftPosition >= lefts[i] && leftPosition < rights[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    };\n    // Given a top offset (from document top), returns the index of the el that it vertically intersects.\n    // If no intersection is made, returns undefined.\n    PositionCache.prototype.topToIndex = function(topPosition) {\n        var _a = this, tops = _a.tops, bottoms = _a.bottoms;\n        var len = tops.length;\n        var i;\n        for(i = 0; i < len; i += 1){\n            if (topPosition >= tops[i] && topPosition < bottoms[i]) {\n                return i;\n            }\n        }\n        return undefined; // TODO: better\n    };\n    // Gets the width of the element at the given index\n    PositionCache.prototype.getWidth = function(leftIndex) {\n        return this.rights[leftIndex] - this.lefts[leftIndex];\n    };\n    // Gets the height of the element at the given index\n    PositionCache.prototype.getHeight = function(topIndex) {\n        return this.bottoms[topIndex] - this.tops[topIndex];\n    };\n    return PositionCache;\n}();\n/* eslint max-classes-per-file: \"off\" */ /*\nAn object for getting/setting scroll-related information for an element.\nInternally, this is done very differently for window versus DOM element,\nso this object serves as a common interface.\n*/ var ScrollController = /** @class */ function() {\n    function ScrollController() {}\n    ScrollController.prototype.getMaxScrollTop = function() {\n        return this.getScrollHeight() - this.getClientHeight();\n    };\n    ScrollController.prototype.getMaxScrollLeft = function() {\n        return this.getScrollWidth() - this.getClientWidth();\n    };\n    ScrollController.prototype.canScrollVertically = function() {\n        return this.getMaxScrollTop() > 0;\n    };\n    ScrollController.prototype.canScrollHorizontally = function() {\n        return this.getMaxScrollLeft() > 0;\n    };\n    ScrollController.prototype.canScrollUp = function() {\n        return this.getScrollTop() > 0;\n    };\n    ScrollController.prototype.canScrollDown = function() {\n        return this.getScrollTop() < this.getMaxScrollTop();\n    };\n    ScrollController.prototype.canScrollLeft = function() {\n        return this.getScrollLeft() > 0;\n    };\n    ScrollController.prototype.canScrollRight = function() {\n        return this.getScrollLeft() < this.getMaxScrollLeft();\n    };\n    return ScrollController;\n}();\nvar ElementScrollController = /** @class */ function(_super) {\n    tslib.__extends(ElementScrollController, _super);\n    function ElementScrollController(el) {\n        var _this = _super.call(this) || this;\n        _this.el = el;\n        return _this;\n    }\n    ElementScrollController.prototype.getScrollTop = function() {\n        return this.el.scrollTop;\n    };\n    ElementScrollController.prototype.getScrollLeft = function() {\n        return this.el.scrollLeft;\n    };\n    ElementScrollController.prototype.setScrollTop = function(top) {\n        this.el.scrollTop = top;\n    };\n    ElementScrollController.prototype.setScrollLeft = function(left) {\n        this.el.scrollLeft = left;\n    };\n    ElementScrollController.prototype.getScrollWidth = function() {\n        return this.el.scrollWidth;\n    };\n    ElementScrollController.prototype.getScrollHeight = function() {\n        return this.el.scrollHeight;\n    };\n    ElementScrollController.prototype.getClientHeight = function() {\n        return this.el.clientHeight;\n    };\n    ElementScrollController.prototype.getClientWidth = function() {\n        return this.el.clientWidth;\n    };\n    return ElementScrollController;\n}(ScrollController);\nvar WindowScrollController = /** @class */ function(_super) {\n    tslib.__extends(WindowScrollController, _super);\n    function WindowScrollController() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    WindowScrollController.prototype.getScrollTop = function() {\n        return window.pageYOffset;\n    };\n    WindowScrollController.prototype.getScrollLeft = function() {\n        return window.pageXOffset;\n    };\n    WindowScrollController.prototype.setScrollTop = function(n) {\n        window.scroll(window.pageXOffset, n);\n    };\n    WindowScrollController.prototype.setScrollLeft = function(n) {\n        window.scroll(n, window.pageYOffset);\n    };\n    WindowScrollController.prototype.getScrollWidth = function() {\n        return document.documentElement.scrollWidth;\n    };\n    WindowScrollController.prototype.getScrollHeight = function() {\n        return document.documentElement.scrollHeight;\n    };\n    WindowScrollController.prototype.getClientHeight = function() {\n        return document.documentElement.clientHeight;\n    };\n    WindowScrollController.prototype.getClientWidth = function() {\n        return document.documentElement.clientWidth;\n    };\n    return WindowScrollController;\n}(ScrollController);\nvar Theme = /** @class */ function() {\n    function Theme(calendarOptions) {\n        if (this.iconOverrideOption) {\n            this.setIconOverride(calendarOptions[this.iconOverrideOption]);\n        }\n    }\n    Theme.prototype.setIconOverride = function(iconOverrideHash) {\n        var iconClassesCopy;\n        var buttonName;\n        if (typeof iconOverrideHash === \"object\" && iconOverrideHash) {\n            iconClassesCopy = tslib.__assign({}, this.iconClasses);\n            for(buttonName in iconOverrideHash){\n                iconClassesCopy[buttonName] = this.applyIconOverridePrefix(iconOverrideHash[buttonName]);\n            }\n            this.iconClasses = iconClassesCopy;\n        } else if (iconOverrideHash === false) {\n            this.iconClasses = {};\n        }\n    };\n    Theme.prototype.applyIconOverridePrefix = function(className) {\n        var prefix = this.iconOverridePrefix;\n        if (prefix && className.indexOf(prefix) !== 0) {\n            className = prefix + className;\n        }\n        return className;\n    };\n    Theme.prototype.getClass = function(key) {\n        return this.classes[key] || \"\";\n    };\n    Theme.prototype.getIconClass = function(buttonName, isRtl) {\n        var className;\n        if (isRtl && this.rtlIconClasses) {\n            className = this.rtlIconClasses[buttonName] || this.iconClasses[buttonName];\n        } else {\n            className = this.iconClasses[buttonName];\n        }\n        if (className) {\n            return this.baseIconClass + \" \" + className;\n        }\n        return \"\";\n    };\n    Theme.prototype.getCustomButtonIconClass = function(customButtonProps) {\n        var className;\n        if (this.iconOverrideCustomButtonOption) {\n            className = customButtonProps[this.iconOverrideCustomButtonOption];\n            if (className) {\n                return this.baseIconClass + \" \" + this.applyIconOverridePrefix(className);\n            }\n        }\n        return \"\";\n    };\n    return Theme;\n}();\nTheme.prototype.classes = {};\nTheme.prototype.iconClasses = {};\nTheme.prototype.baseIconClass = \"\";\nTheme.prototype.iconOverridePrefix = \"\";\nvar ScrollResponder = /** @class */ function() {\n    function ScrollResponder(execFunc, emitter, scrollTime, scrollTimeReset) {\n        var _this = this;\n        this.execFunc = execFunc;\n        this.emitter = emitter;\n        this.scrollTime = scrollTime;\n        this.scrollTimeReset = scrollTimeReset;\n        this.handleScrollRequest = function(request) {\n            _this.queuedRequest = tslib.__assign({}, _this.queuedRequest || {}, request);\n            _this.drain();\n        };\n        emitter.on(\"_scrollRequest\", this.handleScrollRequest);\n        this.fireInitialScroll();\n    }\n    ScrollResponder.prototype.detach = function() {\n        this.emitter.off(\"_scrollRequest\", this.handleScrollRequest);\n    };\n    ScrollResponder.prototype.update = function(isDatesNew) {\n        if (isDatesNew && this.scrollTimeReset) {\n            this.fireInitialScroll(); // will drain\n        } else {\n            this.drain();\n        }\n    };\n    ScrollResponder.prototype.fireInitialScroll = function() {\n        this.handleScrollRequest({\n            time: this.scrollTime\n        });\n    };\n    ScrollResponder.prototype.drain = function() {\n        if (this.queuedRequest && this.execFunc(this.queuedRequest)) {\n            this.queuedRequest = null;\n        }\n    };\n    return ScrollResponder;\n}();\nvar ViewContextType = vdom_cjs.createContext({}); // for Components\nfunction buildViewContext(viewSpec, viewApi, viewOptions, dateProfileGenerator, dateEnv, theme, pluginHooks, dispatch, getCurrentData, emitter, calendarApi, registerInteractiveComponent, unregisterInteractiveComponent) {\n    return {\n        dateEnv: dateEnv,\n        options: viewOptions,\n        pluginHooks: pluginHooks,\n        emitter: emitter,\n        dispatch: dispatch,\n        getCurrentData: getCurrentData,\n        calendarApi: calendarApi,\n        viewSpec: viewSpec,\n        viewApi: viewApi,\n        dateProfileGenerator: dateProfileGenerator,\n        theme: theme,\n        isRtl: viewOptions.direction === \"rtl\",\n        addResizeHandler: function(handler) {\n            emitter.on(\"_resize\", handler);\n        },\n        removeResizeHandler: function(handler) {\n            emitter.off(\"_resize\", handler);\n        },\n        createScrollResponder: function(execFunc) {\n            return new ScrollResponder(execFunc, emitter, createDuration(viewOptions.scrollTime), viewOptions.scrollTimeReset);\n        },\n        registerInteractiveComponent: registerInteractiveComponent,\n        unregisterInteractiveComponent: unregisterInteractiveComponent\n    };\n}\n/* eslint max-classes-per-file: off */ var PureComponent = /** @class */ function(_super) {\n    tslib.__extends(PureComponent, _super);\n    function PureComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    PureComponent.prototype.shouldComponentUpdate = function(nextProps, nextState) {\n        if (this.debug) {\n            // eslint-disable-next-line no-console\n            console.log(getUnequalProps(nextProps, this.props), getUnequalProps(nextState, this.state));\n        }\n        return !compareObjs(this.props, nextProps, this.propEquality) || !compareObjs(this.state, nextState, this.stateEquality);\n    };\n    // HACK for freakin' React StrictMode\n    PureComponent.prototype.safeSetState = function(newState) {\n        if (!compareObjs(this.state, tslib.__assign(tslib.__assign({}, this.state), newState), this.stateEquality)) {\n            this.setState(newState);\n        }\n    };\n    PureComponent.addPropsEquality = addPropsEquality;\n    PureComponent.addStateEquality = addStateEquality;\n    PureComponent.contextType = ViewContextType;\n    return PureComponent;\n}(vdom_cjs.Component);\nPureComponent.prototype.propEquality = {};\nPureComponent.prototype.stateEquality = {};\nvar BaseComponent = /** @class */ function(_super) {\n    tslib.__extends(BaseComponent, _super);\n    function BaseComponent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    BaseComponent.contextType = ViewContextType;\n    return BaseComponent;\n}(PureComponent);\nfunction addPropsEquality(propEquality) {\n    var hash = Object.create(this.prototype.propEquality);\n    tslib.__assign(hash, propEquality);\n    this.prototype.propEquality = hash;\n}\nfunction addStateEquality(stateEquality) {\n    var hash = Object.create(this.prototype.stateEquality);\n    tslib.__assign(hash, stateEquality);\n    this.prototype.stateEquality = hash;\n}\n// use other one\nfunction setRef(ref, current) {\n    if (typeof ref === \"function\") {\n        ref(current);\n    } else if (ref) {\n        // see https://github.com/facebook/react/issues/13029\n        ref.current = current;\n    }\n}\n/*\nan INTERACTABLE date component\n\nPURPOSES:\n- hook up to fg, fill, and mirror renderers\n- interface for dragging and hits\n*/ var DateComponent = /** @class */ function(_super) {\n    tslib.__extends(DateComponent, _super);\n    function DateComponent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.uid = guid();\n        return _this;\n    }\n    // Hit System\n    // -----------------------------------------------------------------------------------------------------------------\n    DateComponent.prototype.prepareHits = function() {};\n    DateComponent.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {\n        return null; // this should be abstract\n    };\n    // Pointer Interaction Utils\n    // -----------------------------------------------------------------------------------------------------------------\n    DateComponent.prototype.isValidSegDownEl = function(el) {\n        return !this.props.eventDrag && // HACK\n        !this.props.eventResize && // HACK\n        !elementClosest(el, \".fc-event-mirror\");\n    };\n    DateComponent.prototype.isValidDateDownEl = function(el) {\n        return !elementClosest(el, \".fc-event:not(.fc-bg-event)\") && !elementClosest(el, \".fc-more-link\") && // a \"more..\" link\n        !elementClosest(el, \"a[data-navlink]\") && // a clickable nav link\n        !elementClosest(el, \".fc-popover\"); // hack\n    };\n    return DateComponent;\n}(BaseComponent);\n// TODO: easier way to add new hooks? need to update a million things\nfunction createPlugin(input) {\n    return {\n        id: guid(),\n        deps: input.deps || [],\n        reducers: input.reducers || [],\n        isLoadingFuncs: input.isLoadingFuncs || [],\n        contextInit: [].concat(input.contextInit || []),\n        eventRefiners: input.eventRefiners || {},\n        eventDefMemberAdders: input.eventDefMemberAdders || [],\n        eventSourceRefiners: input.eventSourceRefiners || {},\n        isDraggableTransformers: input.isDraggableTransformers || [],\n        eventDragMutationMassagers: input.eventDragMutationMassagers || [],\n        eventDefMutationAppliers: input.eventDefMutationAppliers || [],\n        dateSelectionTransformers: input.dateSelectionTransformers || [],\n        datePointTransforms: input.datePointTransforms || [],\n        dateSpanTransforms: input.dateSpanTransforms || [],\n        views: input.views || {},\n        viewPropsTransformers: input.viewPropsTransformers || [],\n        isPropsValid: input.isPropsValid || null,\n        externalDefTransforms: input.externalDefTransforms || [],\n        viewContainerAppends: input.viewContainerAppends || [],\n        eventDropTransformers: input.eventDropTransformers || [],\n        componentInteractions: input.componentInteractions || [],\n        calendarInteractions: input.calendarInteractions || [],\n        themeClasses: input.themeClasses || {},\n        eventSourceDefs: input.eventSourceDefs || [],\n        cmdFormatter: input.cmdFormatter,\n        recurringTypes: input.recurringTypes || [],\n        namedTimeZonedImpl: input.namedTimeZonedImpl,\n        initialView: input.initialView || \"\",\n        elementDraggingImpl: input.elementDraggingImpl,\n        optionChangeHandlers: input.optionChangeHandlers || {},\n        scrollGridImpl: input.scrollGridImpl || null,\n        contentTypeHandlers: input.contentTypeHandlers || {},\n        listenerRefiners: input.listenerRefiners || {},\n        optionRefiners: input.optionRefiners || {},\n        propSetHandlers: input.propSetHandlers || {}\n    };\n}\nfunction buildPluginHooks(pluginDefs, globalDefs) {\n    var isAdded = {};\n    var hooks = {\n        reducers: [],\n        isLoadingFuncs: [],\n        contextInit: [],\n        eventRefiners: {},\n        eventDefMemberAdders: [],\n        eventSourceRefiners: {},\n        isDraggableTransformers: [],\n        eventDragMutationMassagers: [],\n        eventDefMutationAppliers: [],\n        dateSelectionTransformers: [],\n        datePointTransforms: [],\n        dateSpanTransforms: [],\n        views: {},\n        viewPropsTransformers: [],\n        isPropsValid: null,\n        externalDefTransforms: [],\n        viewContainerAppends: [],\n        eventDropTransformers: [],\n        componentInteractions: [],\n        calendarInteractions: [],\n        themeClasses: {},\n        eventSourceDefs: [],\n        cmdFormatter: null,\n        recurringTypes: [],\n        namedTimeZonedImpl: null,\n        initialView: \"\",\n        elementDraggingImpl: null,\n        optionChangeHandlers: {},\n        scrollGridImpl: null,\n        contentTypeHandlers: {},\n        listenerRefiners: {},\n        optionRefiners: {},\n        propSetHandlers: {}\n    };\n    function addDefs(defs) {\n        for(var _i = 0, defs_1 = defs; _i < defs_1.length; _i++){\n            var def = defs_1[_i];\n            if (!isAdded[def.id]) {\n                isAdded[def.id] = true;\n                addDefs(def.deps);\n                hooks = combineHooks(hooks, def);\n            }\n        }\n    }\n    if (pluginDefs) {\n        addDefs(pluginDefs);\n    }\n    addDefs(globalDefs);\n    return hooks;\n}\nfunction buildBuildPluginHooks() {\n    var currentOverrideDefs = [];\n    var currentGlobalDefs = [];\n    var currentHooks;\n    return function(overrideDefs, globalDefs) {\n        if (!currentHooks || !isArraysEqual(overrideDefs, currentOverrideDefs) || !isArraysEqual(globalDefs, currentGlobalDefs)) {\n            currentHooks = buildPluginHooks(overrideDefs, globalDefs);\n        }\n        currentOverrideDefs = overrideDefs;\n        currentGlobalDefs = globalDefs;\n        return currentHooks;\n    };\n}\nfunction combineHooks(hooks0, hooks1) {\n    return {\n        reducers: hooks0.reducers.concat(hooks1.reducers),\n        isLoadingFuncs: hooks0.isLoadingFuncs.concat(hooks1.isLoadingFuncs),\n        contextInit: hooks0.contextInit.concat(hooks1.contextInit),\n        eventRefiners: tslib.__assign(tslib.__assign({}, hooks0.eventRefiners), hooks1.eventRefiners),\n        eventDefMemberAdders: hooks0.eventDefMemberAdders.concat(hooks1.eventDefMemberAdders),\n        eventSourceRefiners: tslib.__assign(tslib.__assign({}, hooks0.eventSourceRefiners), hooks1.eventSourceRefiners),\n        isDraggableTransformers: hooks0.isDraggableTransformers.concat(hooks1.isDraggableTransformers),\n        eventDragMutationMassagers: hooks0.eventDragMutationMassagers.concat(hooks1.eventDragMutationMassagers),\n        eventDefMutationAppliers: hooks0.eventDefMutationAppliers.concat(hooks1.eventDefMutationAppliers),\n        dateSelectionTransformers: hooks0.dateSelectionTransformers.concat(hooks1.dateSelectionTransformers),\n        datePointTransforms: hooks0.datePointTransforms.concat(hooks1.datePointTransforms),\n        dateSpanTransforms: hooks0.dateSpanTransforms.concat(hooks1.dateSpanTransforms),\n        views: tslib.__assign(tslib.__assign({}, hooks0.views), hooks1.views),\n        viewPropsTransformers: hooks0.viewPropsTransformers.concat(hooks1.viewPropsTransformers),\n        isPropsValid: hooks1.isPropsValid || hooks0.isPropsValid,\n        externalDefTransforms: hooks0.externalDefTransforms.concat(hooks1.externalDefTransforms),\n        viewContainerAppends: hooks0.viewContainerAppends.concat(hooks1.viewContainerAppends),\n        eventDropTransformers: hooks0.eventDropTransformers.concat(hooks1.eventDropTransformers),\n        calendarInteractions: hooks0.calendarInteractions.concat(hooks1.calendarInteractions),\n        componentInteractions: hooks0.componentInteractions.concat(hooks1.componentInteractions),\n        themeClasses: tslib.__assign(tslib.__assign({}, hooks0.themeClasses), hooks1.themeClasses),\n        eventSourceDefs: hooks0.eventSourceDefs.concat(hooks1.eventSourceDefs),\n        cmdFormatter: hooks1.cmdFormatter || hooks0.cmdFormatter,\n        recurringTypes: hooks0.recurringTypes.concat(hooks1.recurringTypes),\n        namedTimeZonedImpl: hooks1.namedTimeZonedImpl || hooks0.namedTimeZonedImpl,\n        initialView: hooks0.initialView || hooks1.initialView,\n        elementDraggingImpl: hooks0.elementDraggingImpl || hooks1.elementDraggingImpl,\n        optionChangeHandlers: tslib.__assign(tslib.__assign({}, hooks0.optionChangeHandlers), hooks1.optionChangeHandlers),\n        scrollGridImpl: hooks1.scrollGridImpl || hooks0.scrollGridImpl,\n        contentTypeHandlers: tslib.__assign(tslib.__assign({}, hooks0.contentTypeHandlers), hooks1.contentTypeHandlers),\n        listenerRefiners: tslib.__assign(tslib.__assign({}, hooks0.listenerRefiners), hooks1.listenerRefiners),\n        optionRefiners: tslib.__assign(tslib.__assign({}, hooks0.optionRefiners), hooks1.optionRefiners),\n        propSetHandlers: tslib.__assign(tslib.__assign({}, hooks0.propSetHandlers), hooks1.propSetHandlers)\n    };\n}\nvar StandardTheme = /** @class */ function(_super) {\n    tslib.__extends(StandardTheme, _super);\n    function StandardTheme() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return StandardTheme;\n}(Theme);\nStandardTheme.prototype.classes = {\n    root: \"fc-theme-standard\",\n    tableCellShaded: \"fc-cell-shaded\",\n    buttonGroup: \"fc-button-group\",\n    button: \"fc-button fc-button-primary\",\n    buttonActive: \"fc-button-active\"\n};\nStandardTheme.prototype.baseIconClass = \"fc-icon\";\nStandardTheme.prototype.iconClasses = {\n    close: \"fc-icon-x\",\n    prev: \"fc-icon-chevron-left\",\n    next: \"fc-icon-chevron-right\",\n    prevYear: \"fc-icon-chevrons-left\",\n    nextYear: \"fc-icon-chevrons-right\"\n};\nStandardTheme.prototype.rtlIconClasses = {\n    prev: \"fc-icon-chevron-right\",\n    next: \"fc-icon-chevron-left\",\n    prevYear: \"fc-icon-chevrons-right\",\n    nextYear: \"fc-icon-chevrons-left\"\n};\nStandardTheme.prototype.iconOverrideOption = \"buttonIcons\"; // TODO: make TS-friendly\nStandardTheme.prototype.iconOverrideCustomButtonOption = \"icon\";\nStandardTheme.prototype.iconOverridePrefix = \"fc-icon-\";\nfunction compileViewDefs(defaultConfigs, overrideConfigs) {\n    var hash = {};\n    var viewType;\n    for(viewType in defaultConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    for(viewType in overrideConfigs){\n        ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    }\n    return hash;\n}\nfunction ensureViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    if (hash[viewType]) {\n        return hash[viewType];\n    }\n    var viewDef = buildViewDef(viewType, hash, defaultConfigs, overrideConfigs);\n    if (viewDef) {\n        hash[viewType] = viewDef;\n    }\n    return viewDef;\n}\nfunction buildViewDef(viewType, hash, defaultConfigs, overrideConfigs) {\n    var defaultConfig = defaultConfigs[viewType];\n    var overrideConfig = overrideConfigs[viewType];\n    var queryProp = function(name) {\n        return defaultConfig && defaultConfig[name] !== null ? defaultConfig[name] : overrideConfig && overrideConfig[name] !== null ? overrideConfig[name] : null;\n    };\n    var theComponent = queryProp(\"component\");\n    var superType = queryProp(\"superType\");\n    var superDef = null;\n    if (superType) {\n        if (superType === viewType) {\n            throw new Error(\"Can't have a custom view type that references itself\");\n        }\n        superDef = ensureViewDef(superType, hash, defaultConfigs, overrideConfigs);\n    }\n    if (!theComponent && superDef) {\n        theComponent = superDef.component;\n    }\n    if (!theComponent) {\n        return null; // don't throw a warning, might be settings for a single-unit view\n    }\n    return {\n        type: viewType,\n        component: theComponent,\n        defaults: tslib.__assign(tslib.__assign({}, superDef ? superDef.defaults : {}), defaultConfig ? defaultConfig.rawOptions : {}),\n        overrides: tslib.__assign(tslib.__assign({}, superDef ? superDef.overrides : {}), overrideConfig ? overrideConfig.rawOptions : {})\n    };\n}\n/* eslint max-classes-per-file: off */ // NOTE: in JSX, you should always use this class with <HookProps> arg. otherwise, will default to any???\nvar RenderHook = /** @class */ function(_super) {\n    tslib.__extends(RenderHook, _super);\n    function RenderHook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = vdom_cjs.createRef();\n        _this.handleRootEl = function(el) {\n            setRef(_this.rootElRef, el);\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, el);\n            }\n        };\n        return _this;\n    }\n    RenderHook.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        var hookProps = props.hookProps;\n        return vdom_cjs.createElement(MountHook, {\n            hookProps: hookProps,\n            didMount: props.didMount,\n            willUnmount: props.willUnmount,\n            elRef: this.handleRootEl\n        }, function(rootElRef) {\n            return vdom_cjs.createElement(ContentHook, {\n                hookProps: hookProps,\n                content: props.content,\n                defaultContent: props.defaultContent,\n                backupElRef: _this.rootElRef\n            }, function(innerElRef, innerContent) {\n                return props.children(rootElRef, normalizeClassNames(props.classNames, hookProps), innerElRef, innerContent);\n            });\n        });\n    };\n    return RenderHook;\n}(BaseComponent);\n// TODO: rename to be about function, not default. use in above type\n// for forcing rerender of components that use the ContentHook\nvar CustomContentRenderContext = vdom_cjs.createContext(0);\nfunction ContentHook(props) {\n    return vdom_cjs.createElement(CustomContentRenderContext.Consumer, null, function(renderId) {\n        return vdom_cjs.createElement(ContentHookInner, tslib.__assign({\n            renderId: renderId\n        }, props));\n    });\n}\nvar ContentHookInner = /** @class */ function(_super) {\n    tslib.__extends(ContentHookInner, _super);\n    function ContentHookInner() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.innerElRef = vdom_cjs.createRef();\n        return _this;\n    }\n    ContentHookInner.prototype.render = function() {\n        return this.props.children(this.innerElRef, this.renderInnerContent());\n    };\n    ContentHookInner.prototype.componentDidMount = function() {\n        this.updateCustomContent();\n    };\n    ContentHookInner.prototype.componentDidUpdate = function() {\n        this.updateCustomContent();\n    };\n    ContentHookInner.prototype.componentWillUnmount = function() {\n        if (this.customContentInfo && this.customContentInfo.destroy) {\n            this.customContentInfo.destroy();\n        }\n    };\n    ContentHookInner.prototype.renderInnerContent = function() {\n        var customContentInfo = this.customContentInfo; // only populated if using non-[p]react node(s)\n        var innerContent = this.getInnerContent();\n        var meta = this.getContentMeta(innerContent);\n        // initial run, or content-type changing? (from vue -> react for example)\n        if (!customContentInfo || customContentInfo.contentKey !== meta.contentKey) {\n            // clearing old value\n            if (customContentInfo) {\n                if (customContentInfo.destroy) {\n                    customContentInfo.destroy();\n                }\n                customContentInfo = this.customContentInfo = null;\n            }\n            // assigning new value\n            if (meta.contentKey) {\n                customContentInfo = this.customContentInfo = tslib.__assign({\n                    contentKey: meta.contentKey,\n                    contentVal: innerContent[meta.contentKey]\n                }, meta.buildLifecycleFuncs());\n            }\n        // updating\n        } else if (customContentInfo) {\n            customContentInfo.contentVal = innerContent[meta.contentKey];\n        }\n        return customContentInfo ? [] // signal that something was specified\n         : innerContent; // assume a [p]react vdom node. use it\n    };\n    ContentHookInner.prototype.getInnerContent = function() {\n        var props = this.props;\n        var innerContent = normalizeContent(props.content, props.hookProps);\n        if (innerContent === undefined) {\n            innerContent = normalizeContent(props.defaultContent, props.hookProps);\n        }\n        return innerContent == null ? null : innerContent; // convert undefined to null (better for React)\n    };\n    ContentHookInner.prototype.getContentMeta = function(innerContent) {\n        var contentTypeHandlers = this.context.pluginHooks.contentTypeHandlers;\n        var contentKey = \"\";\n        var buildLifecycleFuncs = null;\n        if (innerContent) {\n            for(var searchKey in contentTypeHandlers){\n                if (innerContent[searchKey] !== undefined) {\n                    contentKey = searchKey;\n                    buildLifecycleFuncs = contentTypeHandlers[searchKey];\n                    break;\n                }\n            }\n        }\n        return {\n            contentKey: contentKey,\n            buildLifecycleFuncs: buildLifecycleFuncs\n        };\n    };\n    ContentHookInner.prototype.updateCustomContent = function() {\n        if (this.customContentInfo) {\n            this.customContentInfo.render(this.innerElRef.current || this.props.backupElRef.current, this.customContentInfo.contentVal);\n        }\n    };\n    return ContentHookInner;\n}(BaseComponent);\nvar MountHook = /** @class */ function(_super) {\n    tslib.__extends(MountHook, _super);\n    function MountHook() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, rootEl);\n            }\n        };\n        return _this;\n    }\n    MountHook.prototype.render = function() {\n        return this.props.children(this.handleRootEl);\n    };\n    MountHook.prototype.componentDidMount = function() {\n        var callback = this.props.didMount;\n        if (callback) {\n            callback(tslib.__assign(tslib.__assign({}, this.props.hookProps), {\n                el: this.rootEl\n            }));\n        }\n    };\n    MountHook.prototype.componentWillUnmount = function() {\n        var callback = this.props.willUnmount;\n        if (callback) {\n            callback(tslib.__assign(tslib.__assign({}, this.props.hookProps), {\n                el: this.rootEl\n            }));\n        }\n    };\n    return MountHook;\n}(BaseComponent);\nfunction buildClassNameNormalizer() {\n    var currentGenerator;\n    var currentHookProps;\n    var currentClassNames = [];\n    return function(generator, hookProps) {\n        if (!currentHookProps || !isPropsEqual(currentHookProps, hookProps) || generator !== currentGenerator) {\n            currentGenerator = generator;\n            currentHookProps = hookProps;\n            currentClassNames = normalizeClassNames(generator, hookProps);\n        }\n        return currentClassNames;\n    };\n}\nfunction normalizeClassNames(classNames, hookProps) {\n    if (typeof classNames === \"function\") {\n        classNames = classNames(hookProps);\n    }\n    return parseClassNames(classNames);\n}\nfunction normalizeContent(input, hookProps) {\n    if (typeof input === \"function\") {\n        return input(hookProps, vdom_cjs.createElement); // give the function the vdom-creation func\n    }\n    return input;\n}\nvar ViewRoot = /** @class */ function(_super) {\n    tslib.__extends(ViewRoot, _super);\n    function ViewRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.normalizeClassNames = buildClassNameNormalizer();\n        return _this;\n    }\n    ViewRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = {\n            view: context.viewApi\n        };\n        var customClassNames = this.normalizeClassNames(options.viewClassNames, hookProps);\n        return vdom_cjs.createElement(MountHook, {\n            hookProps: hookProps,\n            didMount: options.viewDidMount,\n            willUnmount: options.viewWillUnmount,\n            elRef: props.elRef\n        }, function(rootElRef) {\n            return props.children(rootElRef, [\n                \"fc-\" + props.viewSpec.type + \"-view\",\n                \"fc-view\"\n            ].concat(customClassNames));\n        });\n    };\n    return ViewRoot;\n}(BaseComponent);\nfunction parseViewConfigs(inputs) {\n    return mapHash(inputs, parseViewConfig);\n}\nfunction parseViewConfig(input) {\n    var rawOptions = typeof input === \"function\" ? {\n        component: input\n    } : input;\n    var component = rawOptions.component;\n    if (rawOptions.content) {\n        component = createViewHookComponent(rawOptions);\n    // TODO: remove content/classNames/didMount/etc from options?\n    }\n    return {\n        superType: rawOptions.type,\n        component: component,\n        rawOptions: rawOptions\n    };\n}\nfunction createViewHookComponent(options) {\n    return function(viewProps) {\n        return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n            return vdom_cjs.createElement(ViewRoot, {\n                viewSpec: context.viewSpec\n            }, function(viewElRef, viewClassNames) {\n                var hookProps = tslib.__assign(tslib.__assign({}, viewProps), {\n                    nextDayThreshold: context.options.nextDayThreshold\n                });\n                return vdom_cjs.createElement(RenderHook, {\n                    hookProps: hookProps,\n                    classNames: options.classNames,\n                    content: options.content,\n                    didMount: options.didMount,\n                    willUnmount: options.willUnmount,\n                    elRef: viewElRef\n                }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                    return vdom_cjs.createElement(\"div\", {\n                        className: viewClassNames.concat(customClassNames).join(\" \"),\n                        ref: rootElRef\n                    }, innerContent);\n                });\n            });\n        });\n    };\n}\nfunction buildViewSpecs(defaultInputs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    var defaultConfigs = parseViewConfigs(defaultInputs);\n    var overrideConfigs = parseViewConfigs(optionOverrides.views);\n    var viewDefs = compileViewDefs(defaultConfigs, overrideConfigs);\n    return mapHash(viewDefs, function(viewDef) {\n        return buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults);\n    });\n}\nfunction buildViewSpec(viewDef, overrideConfigs, optionOverrides, dynamicOptionOverrides, localeDefaults) {\n    var durationInput = viewDef.overrides.duration || viewDef.defaults.duration || dynamicOptionOverrides.duration || optionOverrides.duration;\n    var duration = null;\n    var durationUnit = \"\";\n    var singleUnit = \"\";\n    var singleUnitOverrides = {};\n    if (durationInput) {\n        duration = createDurationCached(durationInput);\n        if (duration) {\n            var denom = greatestDurationDenominator(duration);\n            durationUnit = denom.unit;\n            if (denom.value === 1) {\n                singleUnit = durationUnit;\n                singleUnitOverrides = overrideConfigs[durationUnit] ? overrideConfigs[durationUnit].rawOptions : {};\n            }\n        }\n    }\n    var queryButtonText = function(optionsSubset) {\n        var buttonTextMap = optionsSubset.buttonText || {};\n        var buttonTextKey = viewDef.defaults.buttonTextKey;\n        if (buttonTextKey != null && buttonTextMap[buttonTextKey] != null) {\n            return buttonTextMap[buttonTextKey];\n        }\n        if (buttonTextMap[viewDef.type] != null) {\n            return buttonTextMap[viewDef.type];\n        }\n        if (buttonTextMap[singleUnit] != null) {\n            return buttonTextMap[singleUnit];\n        }\n        return null;\n    };\n    var queryButtonTitle = function(optionsSubset) {\n        var buttonHints = optionsSubset.buttonHints || {};\n        var buttonKey = viewDef.defaults.buttonTextKey; // use same key as text\n        if (buttonKey != null && buttonHints[buttonKey] != null) {\n            return buttonHints[buttonKey];\n        }\n        if (buttonHints[viewDef.type] != null) {\n            return buttonHints[viewDef.type];\n        }\n        if (buttonHints[singleUnit] != null) {\n            return buttonHints[singleUnit];\n        }\n        return null;\n    };\n    return {\n        type: viewDef.type,\n        component: viewDef.component,\n        duration: duration,\n        durationUnit: durationUnit,\n        singleUnit: singleUnit,\n        optionDefaults: viewDef.defaults,\n        optionOverrides: tslib.__assign(tslib.__assign({}, singleUnitOverrides), viewDef.overrides),\n        buttonTextOverride: queryButtonText(dynamicOptionOverrides) || queryButtonText(optionOverrides) || // constructor-specified buttonText lookup hash takes precedence\n        viewDef.overrides.buttonText,\n        buttonTextDefault: queryButtonText(localeDefaults) || viewDef.defaults.buttonText || queryButtonText(BASE_OPTION_DEFAULTS) || viewDef.type,\n        // not DRY\n        buttonTitleOverride: queryButtonTitle(dynamicOptionOverrides) || queryButtonTitle(optionOverrides) || viewDef.overrides.buttonHint,\n        buttonTitleDefault: queryButtonTitle(localeDefaults) || viewDef.defaults.buttonHint || queryButtonTitle(BASE_OPTION_DEFAULTS)\n    };\n}\n// hack to get memoization working\nvar durationInputMap = {};\nfunction createDurationCached(durationInput) {\n    var json = JSON.stringify(durationInput);\n    var res = durationInputMap[json];\n    if (res === undefined) {\n        res = createDuration(durationInput);\n        durationInputMap[json] = res;\n    }\n    return res;\n}\nvar DateProfileGenerator = /** @class */ function() {\n    function DateProfileGenerator(props) {\n        this.props = props;\n        this.nowDate = getNow(props.nowInput, props.dateEnv);\n        this.initHiddenDays();\n    }\n    /* Date Range Computation\n    ------------------------------------------------------------------------------------------------------------------*/ // Builds a structure with info about what the dates/ranges will be for the \"prev\" view.\n    DateProfileGenerator.prototype.buildPrev = function(currentDateProfile, currentDate, forceToValid) {\n        var dateEnv = this.props.dateEnv;\n        var prevDate = dateEnv.subtract(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(prevDate, -1, forceToValid);\n    };\n    // Builds a structure with info about what the dates/ranges will be for the \"next\" view.\n    DateProfileGenerator.prototype.buildNext = function(currentDateProfile, currentDate, forceToValid) {\n        var dateEnv = this.props.dateEnv;\n        var nextDate = dateEnv.add(dateEnv.startOf(currentDate, currentDateProfile.currentRangeUnit), currentDateProfile.dateIncrement);\n        return this.build(nextDate, 1, forceToValid);\n    };\n    // Builds a structure holding dates/ranges for rendering around the given date.\n    // Optional direction param indicates whether the date is being incremented/decremented\n    // from its previous value. decremented = -1, incremented = 1 (default).\n    DateProfileGenerator.prototype.build = function(currentDate, direction, forceToValid) {\n        if (forceToValid === void 0) {\n            forceToValid = true;\n        }\n        var props = this.props;\n        var validRange;\n        var currentInfo;\n        var isRangeAllDay;\n        var renderRange;\n        var activeRange;\n        var isValid;\n        validRange = this.buildValidRange();\n        validRange = this.trimHiddenDays(validRange);\n        if (forceToValid) {\n            currentDate = constrainMarkerToRange(currentDate, validRange);\n        }\n        currentInfo = this.buildCurrentRangeInfo(currentDate, direction);\n        isRangeAllDay = /^(year|month|week|day)$/.test(currentInfo.unit);\n        renderRange = this.buildRenderRange(this.trimHiddenDays(currentInfo.range), currentInfo.unit, isRangeAllDay);\n        renderRange = this.trimHiddenDays(renderRange);\n        activeRange = renderRange;\n        if (!props.showNonCurrentDates) {\n            activeRange = intersectRanges(activeRange, currentInfo.range);\n        }\n        activeRange = this.adjustActiveRange(activeRange);\n        activeRange = intersectRanges(activeRange, validRange); // might return null\n        // it's invalid if the originally requested date is not contained,\n        // or if the range is completely outside of the valid range.\n        isValid = rangesIntersect(currentInfo.range, validRange);\n        return {\n            // constraint for where prev/next operations can go and where events can be dragged/resized to.\n            // an object with optional start and end properties.\n            validRange: validRange,\n            // range the view is formally responsible for.\n            // for example, a month view might have 1st-31st, excluding padded dates\n            currentRange: currentInfo.range,\n            // name of largest unit being displayed, like \"month\" or \"week\"\n            currentRangeUnit: currentInfo.unit,\n            isRangeAllDay: isRangeAllDay,\n            // dates that display events and accept drag-n-drop\n            // will be `null` if no dates accept events\n            activeRange: activeRange,\n            // date range with a rendered skeleton\n            // includes not-active days that need some sort of DOM\n            renderRange: renderRange,\n            // Duration object that denotes the first visible time of any given day\n            slotMinTime: props.slotMinTime,\n            // Duration object that denotes the exclusive visible end time of any given day\n            slotMaxTime: props.slotMaxTime,\n            isValid: isValid,\n            // how far the current date will move for a prev/next operation\n            dateIncrement: this.buildDateIncrement(currentInfo.duration)\n        };\n    };\n    // Builds an object with optional start/end properties.\n    // Indicates the minimum/maximum dates to display.\n    // not responsible for trimming hidden days.\n    DateProfileGenerator.prototype.buildValidRange = function() {\n        var input = this.props.validRangeInput;\n        var simpleInput = typeof input === \"function\" ? input.call(this.props.calendarApi, this.nowDate) : input;\n        return this.refineRange(simpleInput) || {\n            start: null,\n            end: null\n        }; // completely open-ended\n    };\n    // Builds a structure with info about the \"current\" range, the range that is\n    // highlighted as being the current month for example.\n    // See build() for a description of `direction`.\n    // Guaranteed to have `range` and `unit` properties. `duration` is optional.\n    DateProfileGenerator.prototype.buildCurrentRangeInfo = function(date, direction) {\n        var props = this.props;\n        var duration = null;\n        var unit = null;\n        var range = null;\n        var dayCount;\n        if (props.duration) {\n            duration = props.duration;\n            unit = props.durationUnit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        } else if (dayCount = this.props.dayCount) {\n            unit = \"day\";\n            range = this.buildRangeFromDayCount(date, direction, dayCount);\n        } else if (range = this.buildCustomVisibleRange(date)) {\n            unit = props.dateEnv.greatestWholeUnit(range.start, range.end).unit;\n        } else {\n            duration = this.getFallbackDuration();\n            unit = greatestDurationDenominator(duration).unit;\n            range = this.buildRangeFromDuration(date, direction, duration, unit);\n        }\n        return {\n            duration: duration,\n            unit: unit,\n            range: range\n        };\n    };\n    DateProfileGenerator.prototype.getFallbackDuration = function() {\n        return createDuration({\n            day: 1\n        });\n    };\n    // Returns a new activeRange to have time values (un-ambiguate)\n    // slotMinTime or slotMaxTime causes the range to expand.\n    DateProfileGenerator.prototype.adjustActiveRange = function(range) {\n        var _a = this.props, dateEnv = _a.dateEnv, usesMinMaxTime = _a.usesMinMaxTime, slotMinTime = _a.slotMinTime, slotMaxTime = _a.slotMaxTime;\n        var start = range.start, end = range.end;\n        if (usesMinMaxTime) {\n            // expand active range if slotMinTime is negative (why not when positive?)\n            if (asRoughDays(slotMinTime) < 0) {\n                start = startOfDay(start); // necessary?\n                start = dateEnv.add(start, slotMinTime);\n            }\n            // expand active range if slotMaxTime is beyond one day (why not when negative?)\n            if (asRoughDays(slotMaxTime) > 1) {\n                end = startOfDay(end); // necessary?\n                end = addDays(end, -1);\n                end = dateEnv.add(end, slotMaxTime);\n            }\n        }\n        return {\n            start: start,\n            end: end\n        };\n    };\n    // Builds the \"current\" range when it is specified as an explicit duration.\n    // `unit` is the already-computed greatestDurationDenominator unit of duration.\n    DateProfileGenerator.prototype.buildRangeFromDuration = function(date, direction, duration, unit) {\n        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n        var start;\n        var end;\n        var res;\n        // compute what the alignment should be\n        if (!dateAlignment) {\n            var dateIncrement = this.props.dateIncrement;\n            if (dateIncrement) {\n                // use the smaller of the two units\n                if (asRoughMs(dateIncrement) < asRoughMs(duration)) {\n                    dateAlignment = greatestDurationDenominator(dateIncrement).unit;\n                } else {\n                    dateAlignment = unit;\n                }\n            } else {\n                dateAlignment = unit;\n            }\n        }\n        // if the view displays a single day or smaller\n        if (asRoughDays(duration) <= 1) {\n            if (this.isHiddenDay(start)) {\n                start = this.skipHiddenDays(start, direction);\n                start = startOfDay(start);\n            }\n        }\n        function computeRes() {\n            start = dateEnv.startOf(date, dateAlignment);\n            end = dateEnv.add(start, duration);\n            res = {\n                start: start,\n                end: end\n            };\n        }\n        computeRes();\n        // if range is completely enveloped by hidden days, go past the hidden days\n        if (!this.trimHiddenDays(res)) {\n            date = this.skipHiddenDays(date, direction);\n            computeRes();\n        }\n        return res;\n    };\n    // Builds the \"current\" range when a dayCount is specified.\n    DateProfileGenerator.prototype.buildRangeFromDayCount = function(date, direction, dayCount) {\n        var _a = this.props, dateEnv = _a.dateEnv, dateAlignment = _a.dateAlignment;\n        var runningCount = 0;\n        var start = date;\n        var end;\n        if (dateAlignment) {\n            start = dateEnv.startOf(start, dateAlignment);\n        }\n        start = startOfDay(start);\n        start = this.skipHiddenDays(start, direction);\n        end = start;\n        do {\n            end = addDays(end, 1);\n            if (!this.isHiddenDay(end)) {\n                runningCount += 1;\n            }\n        }while (runningCount < dayCount);\n        return {\n            start: start,\n            end: end\n        };\n    };\n    // Builds a normalized range object for the \"visible\" range,\n    // which is a way to define the currentRange and activeRange at the same time.\n    DateProfileGenerator.prototype.buildCustomVisibleRange = function(date) {\n        var props = this.props;\n        var input = props.visibleRangeInput;\n        var simpleInput = typeof input === \"function\" ? input.call(props.calendarApi, props.dateEnv.toDate(date)) : input;\n        var range = this.refineRange(simpleInput);\n        if (range && (range.start == null || range.end == null)) {\n            return null;\n        }\n        return range;\n    };\n    // Computes the range that will represent the element/cells for *rendering*,\n    // but which may have voided days/times.\n    // not responsible for trimming hidden days.\n    DateProfileGenerator.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {\n        return currentRange;\n    };\n    // Compute the duration value that should be added/substracted to the current date\n    // when a prev/next operation happens.\n    DateProfileGenerator.prototype.buildDateIncrement = function(fallback) {\n        var dateIncrement = this.props.dateIncrement;\n        var customAlignment;\n        if (dateIncrement) {\n            return dateIncrement;\n        }\n        if (customAlignment = this.props.dateAlignment) {\n            return createDuration(1, customAlignment);\n        }\n        if (fallback) {\n            return fallback;\n        }\n        return createDuration({\n            days: 1\n        });\n    };\n    DateProfileGenerator.prototype.refineRange = function(rangeInput) {\n        if (rangeInput) {\n            var range = parseRange(rangeInput, this.props.dateEnv);\n            if (range) {\n                range = computeVisibleDayRange(range);\n            }\n            return range;\n        }\n        return null;\n    };\n    /* Hidden Days\n    ------------------------------------------------------------------------------------------------------------------*/ // Initializes internal variables related to calculating hidden days-of-week\n    DateProfileGenerator.prototype.initHiddenDays = function() {\n        var hiddenDays = this.props.hiddenDays || []; // array of day-of-week indices that are hidden\n        var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)\n        var dayCnt = 0;\n        var i;\n        if (this.props.weekends === false) {\n            hiddenDays.push(0, 6); // 0=sunday, 6=saturday\n        }\n        for(i = 0; i < 7; i += 1){\n            if (!(isHiddenDayHash[i] = hiddenDays.indexOf(i) !== -1)) {\n                dayCnt += 1;\n            }\n        }\n        if (!dayCnt) {\n            throw new Error(\"invalid hiddenDays\"); // all days were hidden? bad.\n        }\n        this.isHiddenDayHash = isHiddenDayHash;\n    };\n    // Remove days from the beginning and end of the range that are computed as hidden.\n    // If the whole range is trimmed off, returns null\n    DateProfileGenerator.prototype.trimHiddenDays = function(range) {\n        var start = range.start, end = range.end;\n        if (start) {\n            start = this.skipHiddenDays(start);\n        }\n        if (end) {\n            end = this.skipHiddenDays(end, -1, true);\n        }\n        if (start == null || end == null || start < end) {\n            return {\n                start: start,\n                end: end\n            };\n        }\n        return null;\n    };\n    // Is the current day hidden?\n    // `day` is a day-of-week index (0-6), or a Date (used for UTC)\n    DateProfileGenerator.prototype.isHiddenDay = function(day) {\n        if (day instanceof Date) {\n            day = day.getUTCDay();\n        }\n        return this.isHiddenDayHash[day];\n    };\n    // Incrementing the current day until it is no longer a hidden day, returning a copy.\n    // DOES NOT CONSIDER validRange!\n    // If the initial value of `date` is not a hidden day, don't do anything.\n    // Pass `isExclusive` as `true` if you are dealing with an end date.\n    // `inc` defaults to `1` (increment one day forward each time)\n    DateProfileGenerator.prototype.skipHiddenDays = function(date, inc, isExclusive) {\n        if (inc === void 0) {\n            inc = 1;\n        }\n        if (isExclusive === void 0) {\n            isExclusive = false;\n        }\n        while(this.isHiddenDayHash[(date.getUTCDay() + (isExclusive ? inc : 0) + 7) % 7]){\n            date = addDays(date, inc);\n        }\n        return date;\n    };\n    return DateProfileGenerator;\n}();\nfunction reduceViewType(viewType, action) {\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            viewType = action.viewType;\n    }\n    return viewType;\n}\nfunction reduceDynamicOptionOverrides(dynamicOptionOverrides, action) {\n    var _a;\n    switch(action.type){\n        case \"SET_OPTION\":\n            return tslib.__assign(tslib.__assign({}, dynamicOptionOverrides), (_a = {}, _a[action.optionName] = action.rawOptionValue, _a));\n        default:\n            return dynamicOptionOverrides;\n    }\n}\nfunction reduceDateProfile(currentDateProfile, action, currentDate, dateProfileGenerator) {\n    var dp;\n    switch(action.type){\n        case \"CHANGE_VIEW_TYPE\":\n            return dateProfileGenerator.build(action.dateMarker || currentDate);\n        case \"CHANGE_DATE\":\n            return dateProfileGenerator.build(action.dateMarker);\n        case \"PREV\":\n            dp = dateProfileGenerator.buildPrev(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n        case \"NEXT\":\n            dp = dateProfileGenerator.buildNext(currentDateProfile, currentDate);\n            if (dp.isValid) {\n                return dp;\n            }\n            break;\n    }\n    return currentDateProfile;\n}\nfunction initEventSources(calendarOptions, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null;\n    return addSources({}, parseInitialSources(calendarOptions, context), activeRange, context);\n}\nfunction reduceEventSources(eventSources, action, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    switch(action.type){\n        case \"ADD_EVENT_SOURCES\":\n            return addSources(eventSources, action.sources, activeRange, context);\n        case \"REMOVE_EVENT_SOURCE\":\n            return removeSource(eventSources, action.sourceId);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return fetchDirtySources(eventSources, activeRange, context);\n            }\n            return eventSources;\n        case \"FETCH_EVENT_SOURCES\":\n            return fetchSourcesByIds(eventSources, action.sourceIds ? arrayToHash(action.sourceIds) : excludeStaticSources(eventSources, context), activeRange, action.isRefetch || false, context);\n        case \"RECEIVE_EVENTS\":\n        case \"RECEIVE_EVENT_ERROR\":\n            return receiveResponse(eventSources, action.sourceId, action.fetchId, action.fetchRange);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return {};\n        default:\n            return eventSources;\n    }\n}\nfunction reduceEventSourcesNewTimeZone(eventSources, dateProfile, context) {\n    var activeRange = dateProfile ? dateProfile.activeRange : null; // need this check?\n    return fetchSourcesByIds(eventSources, excludeStaticSources(eventSources, context), activeRange, true, context);\n}\nfunction computeEventSourcesLoading(eventSources) {\n    for(var sourceId in eventSources){\n        if (eventSources[sourceId].isFetching) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction addSources(eventSourceHash, sources, fetchRange, context) {\n    var hash = {};\n    for(var _i = 0, sources_1 = sources; _i < sources_1.length; _i++){\n        var source = sources_1[_i];\n        hash[source.sourceId] = source;\n    }\n    if (fetchRange) {\n        hash = fetchDirtySources(hash, fetchRange, context);\n    }\n    return tslib.__assign(tslib.__assign({}, eventSourceHash), hash);\n}\nfunction removeSource(eventSourceHash, sourceId) {\n    return filterHash(eventSourceHash, function(eventSource) {\n        return eventSource.sourceId !== sourceId;\n    });\n}\nfunction fetchDirtySources(sourceHash, fetchRange, context) {\n    return fetchSourcesByIds(sourceHash, filterHash(sourceHash, function(eventSource) {\n        return isSourceDirty(eventSource, fetchRange, context);\n    }), fetchRange, false, context);\n}\nfunction isSourceDirty(eventSource, fetchRange, context) {\n    if (!doesSourceNeedRange(eventSource, context)) {\n        return !eventSource.latestFetchId;\n    }\n    return !context.options.lazyFetching || !eventSource.fetchRange || eventSource.isFetching || // always cancel outdated in-progress fetches\n    fetchRange.start < eventSource.fetchRange.start || fetchRange.end > eventSource.fetchRange.end;\n}\nfunction fetchSourcesByIds(prevSources, sourceIdHash, fetchRange, isRefetch, context) {\n    var nextSources = {};\n    for(var sourceId in prevSources){\n        var source = prevSources[sourceId];\n        if (sourceIdHash[sourceId]) {\n            nextSources[sourceId] = fetchSource(source, fetchRange, isRefetch, context);\n        } else {\n            nextSources[sourceId] = source;\n        }\n    }\n    return nextSources;\n}\nfunction fetchSource(eventSource, fetchRange, isRefetch, context) {\n    var options = context.options, calendarApi = context.calendarApi;\n    var sourceDef = context.pluginHooks.eventSourceDefs[eventSource.sourceDefId];\n    var fetchId = guid();\n    sourceDef.fetch({\n        eventSource: eventSource,\n        range: fetchRange,\n        isRefetch: isRefetch,\n        context: context\n    }, function(res) {\n        var rawEvents = res.rawEvents;\n        if (options.eventSourceSuccess) {\n            rawEvents = options.eventSourceSuccess.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n        }\n        if (eventSource.success) {\n            rawEvents = eventSource.success.call(calendarApi, rawEvents, res.xhr) || rawEvents;\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENTS\",\n            sourceId: eventSource.sourceId,\n            fetchId: fetchId,\n            fetchRange: fetchRange,\n            rawEvents: rawEvents\n        });\n    }, function(error) {\n        console.warn(error.message, error);\n        if (options.eventSourceFailure) {\n            options.eventSourceFailure.call(calendarApi, error);\n        }\n        if (eventSource.failure) {\n            eventSource.failure(error);\n        }\n        context.dispatch({\n            type: \"RECEIVE_EVENT_ERROR\",\n            sourceId: eventSource.sourceId,\n            fetchId: fetchId,\n            fetchRange: fetchRange,\n            error: error\n        });\n    });\n    return tslib.__assign(tslib.__assign({}, eventSource), {\n        isFetching: true,\n        latestFetchId: fetchId\n    });\n}\nfunction receiveResponse(sourceHash, sourceId, fetchId, fetchRange) {\n    var _a;\n    var eventSource = sourceHash[sourceId];\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId) {\n        return tslib.__assign(tslib.__assign({}, sourceHash), (_a = {}, _a[sourceId] = tslib.__assign(tslib.__assign({}, eventSource), {\n            isFetching: false,\n            fetchRange: fetchRange\n        }), _a));\n    }\n    return sourceHash;\n}\nfunction excludeStaticSources(eventSources, context) {\n    return filterHash(eventSources, function(eventSource) {\n        return doesSourceNeedRange(eventSource, context);\n    });\n}\nfunction parseInitialSources(rawOptions, context) {\n    var refiners = buildEventSourceRefiners(context);\n    var rawSources = [].concat(rawOptions.eventSources || []);\n    var sources = []; // parsed\n    if (rawOptions.initialEvents) {\n        rawSources.unshift(rawOptions.initialEvents);\n    }\n    if (rawOptions.events) {\n        rawSources.unshift(rawOptions.events);\n    }\n    for(var _i = 0, rawSources_1 = rawSources; _i < rawSources_1.length; _i++){\n        var rawSource = rawSources_1[_i];\n        var source = parseEventSource(rawSource, context, refiners);\n        if (source) {\n            sources.push(source);\n        }\n    }\n    return sources;\n}\nfunction doesSourceNeedRange(eventSource, context) {\n    var defs = context.pluginHooks.eventSourceDefs;\n    return !defs[eventSource.sourceDefId].ignoreRange;\n}\nfunction reduceEventStore(eventStore, action, eventSources, dateProfile, context) {\n    switch(action.type){\n        case \"RECEIVE_EVENTS\":\n            return receiveRawEvents(eventStore, eventSources[action.sourceId], action.fetchId, action.fetchRange, action.rawEvents, context);\n        case \"ADD_EVENTS\":\n            return addEvent(eventStore, action.eventStore, dateProfile ? dateProfile.activeRange : null, context);\n        case \"RESET_EVENTS\":\n            return action.eventStore;\n        case \"MERGE_EVENTS\":\n            return mergeEventStores(eventStore, action.eventStore);\n        case \"PREV\":\n        case \"NEXT\":\n        case \"CHANGE_DATE\":\n        case \"CHANGE_VIEW_TYPE\":\n            if (dateProfile) {\n                return expandRecurring(eventStore, dateProfile.activeRange, context);\n            }\n            return eventStore;\n        case \"REMOVE_EVENTS\":\n            return excludeSubEventStore(eventStore, action.eventStore);\n        case \"REMOVE_EVENT_SOURCE\":\n            return excludeEventsBySourceId(eventStore, action.sourceId);\n        case \"REMOVE_ALL_EVENT_SOURCES\":\n            return filterEventStoreDefs(eventStore, function(eventDef) {\n                return !eventDef.sourceId // only keep events with no source id\n                ;\n            });\n        case \"REMOVE_ALL_EVENTS\":\n            return createEmptyEventStore();\n        default:\n            return eventStore;\n    }\n}\nfunction receiveRawEvents(eventStore, eventSource, fetchId, fetchRange, rawEvents, context) {\n    if (eventSource && // not already removed\n    fetchId === eventSource.latestFetchId // TODO: wish this logic was always in event-sources\n    ) {\n        var subset = parseEvents(transformRawEvents(rawEvents, eventSource, context), eventSource, context);\n        if (fetchRange) {\n            subset = expandRecurring(subset, fetchRange, context);\n        }\n        return mergeEventStores(excludeEventsBySourceId(eventStore, eventSource.sourceId), subset);\n    }\n    return eventStore;\n}\nfunction transformRawEvents(rawEvents, eventSource, context) {\n    var calEachTransform = context.options.eventDataTransform;\n    var sourceEachTransform = eventSource ? eventSource.eventDataTransform : null;\n    if (sourceEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, sourceEachTransform);\n    }\n    if (calEachTransform) {\n        rawEvents = transformEachRawEvent(rawEvents, calEachTransform);\n    }\n    return rawEvents;\n}\nfunction transformEachRawEvent(rawEvents, func) {\n    var refinedEvents;\n    if (!func) {\n        refinedEvents = rawEvents;\n    } else {\n        refinedEvents = [];\n        for(var _i = 0, rawEvents_1 = rawEvents; _i < rawEvents_1.length; _i++){\n            var rawEvent = rawEvents_1[_i];\n            var refinedEvent = func(rawEvent);\n            if (refinedEvent) {\n                refinedEvents.push(refinedEvent);\n            } else if (refinedEvent == null) {\n                refinedEvents.push(rawEvent);\n            } // if a different falsy value, do nothing\n        }\n    }\n    return refinedEvents;\n}\nfunction addEvent(eventStore, subset, expandRange, context) {\n    if (expandRange) {\n        subset = expandRecurring(subset, expandRange, context);\n    }\n    return mergeEventStores(eventStore, subset);\n}\nfunction rezoneEventStoreDates(eventStore, oldDateEnv, newDateEnv) {\n    var defs = eventStore.defs;\n    var instances = mapHash(eventStore.instances, function(instance) {\n        var def = defs[instance.defId];\n        if (def.allDay || def.recurringDef) {\n            return instance; // isn't dependent on timezone\n        }\n        return tslib.__assign(tslib.__assign({}, instance), {\n            range: {\n                start: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.start, instance.forcedStartTzo)),\n                end: newDateEnv.createMarker(oldDateEnv.toDate(instance.range.end, instance.forcedEndTzo))\n            },\n            forcedStartTzo: newDateEnv.canComputeOffset ? null : instance.forcedStartTzo,\n            forcedEndTzo: newDateEnv.canComputeOffset ? null : instance.forcedEndTzo\n        });\n    });\n    return {\n        defs: defs,\n        instances: instances\n    };\n}\nfunction excludeEventsBySourceId(eventStore, sourceId) {\n    return filterEventStoreDefs(eventStore, function(eventDef) {\n        return eventDef.sourceId !== sourceId;\n    });\n}\n// QUESTION: why not just return instances? do a general object-property-exclusion util\nfunction excludeInstances(eventStore, removals) {\n    return {\n        defs: eventStore.defs,\n        instances: filterHash(eventStore.instances, function(instance) {\n            return !removals[instance.instanceId];\n        })\n    };\n}\nfunction reduceDateSelection(currentSelection, action) {\n    switch(action.type){\n        case \"UNSELECT_DATES\":\n            return null;\n        case \"SELECT_DATES\":\n            return action.selection;\n        default:\n            return currentSelection;\n    }\n}\nfunction reduceSelectedEvent(currentInstanceId, action) {\n    switch(action.type){\n        case \"UNSELECT_EVENT\":\n            return \"\";\n        case \"SELECT_EVENT\":\n            return action.eventInstanceId;\n        default:\n            return currentInstanceId;\n    }\n}\nfunction reduceEventDrag(currentDrag, action) {\n    var newDrag;\n    switch(action.type){\n        case \"UNSET_EVENT_DRAG\":\n            return null;\n        case \"SET_EVENT_DRAG\":\n            newDrag = action.state;\n            return {\n                affectedEvents: newDrag.affectedEvents,\n                mutatedEvents: newDrag.mutatedEvents,\n                isEvent: newDrag.isEvent\n            };\n        default:\n            return currentDrag;\n    }\n}\nfunction reduceEventResize(currentResize, action) {\n    var newResize;\n    switch(action.type){\n        case \"UNSET_EVENT_RESIZE\":\n            return null;\n        case \"SET_EVENT_RESIZE\":\n            newResize = action.state;\n            return {\n                affectedEvents: newResize.affectedEvents,\n                mutatedEvents: newResize.mutatedEvents,\n                isEvent: newResize.isEvent\n            };\n        default:\n            return currentResize;\n    }\n}\nfunction parseToolbars(calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var header = calendarOptions.headerToolbar ? parseToolbar(calendarOptions.headerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    var footer = calendarOptions.footerToolbar ? parseToolbar(calendarOptions.footerToolbar, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) : null;\n    return {\n        header: header,\n        footer: footer\n    };\n}\nfunction parseToolbar(sectionStrHash, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var sectionWidgets = {};\n    var viewsWithButtons = [];\n    var hasTitle = false;\n    for(var sectionName in sectionStrHash){\n        var sectionStr = sectionStrHash[sectionName];\n        var sectionRes = parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi);\n        sectionWidgets[sectionName] = sectionRes.widgets;\n        viewsWithButtons.push.apply(viewsWithButtons, sectionRes.viewsWithButtons);\n        hasTitle = hasTitle || sectionRes.hasTitle;\n    }\n    return {\n        sectionWidgets: sectionWidgets,\n        viewsWithButtons: viewsWithButtons,\n        hasTitle: hasTitle\n    };\n}\n/*\nBAD: querying icons and text here. should be done at render time\n*/ function parseSection(sectionStr, calendarOptions, calendarOptionOverrides, theme, viewSpecs, calendarApi) {\n    var isRtl = calendarOptions.direction === \"rtl\";\n    var calendarCustomButtons = calendarOptions.customButtons || {};\n    var calendarButtonTextOverrides = calendarOptionOverrides.buttonText || {};\n    var calendarButtonText = calendarOptions.buttonText || {};\n    var calendarButtonHintOverrides = calendarOptionOverrides.buttonHints || {};\n    var calendarButtonHints = calendarOptions.buttonHints || {};\n    var sectionSubstrs = sectionStr ? sectionStr.split(\" \") : [];\n    var viewsWithButtons = [];\n    var hasTitle = false;\n    var widgets = sectionSubstrs.map(function(buttonGroupStr) {\n        return buttonGroupStr.split(\",\").map(function(buttonName) {\n            if (buttonName === \"title\") {\n                hasTitle = true;\n                return {\n                    buttonName: buttonName\n                };\n            }\n            var customButtonProps;\n            var viewSpec;\n            var buttonClick;\n            var buttonIcon; // only one of these will be set\n            var buttonText; // \"\n            var buttonHint;\n            // ^ for the title=\"\" attribute, for accessibility\n            if (customButtonProps = calendarCustomButtons[buttonName]) {\n                buttonClick = function(ev) {\n                    if (customButtonProps.click) {\n                        customButtonProps.click.call(ev.target, ev, ev.target); // TODO: use Calendar this context?\n                    }\n                };\n                (buttonIcon = theme.getCustomButtonIconClass(customButtonProps)) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = customButtonProps.text);\n                buttonHint = customButtonProps.hint || customButtonProps.text;\n            } else if (viewSpec = viewSpecs[buttonName]) {\n                viewsWithButtons.push(buttonName);\n                buttonClick = function() {\n                    calendarApi.changeView(buttonName);\n                };\n                (buttonText = viewSpec.buttonTextOverride) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = viewSpec.buttonTextDefault);\n                var textFallback = viewSpec.buttonTextOverride || viewSpec.buttonTextDefault;\n                buttonHint = formatWithOrdinals(viewSpec.buttonTitleOverride || viewSpec.buttonTitleDefault || calendarOptions.viewHint, [\n                    textFallback,\n                    buttonName\n                ], textFallback);\n            } else if (calendarApi[buttonName]) {\n                buttonClick = function() {\n                    calendarApi[buttonName]();\n                };\n                (buttonText = calendarButtonTextOverrides[buttonName]) || (buttonIcon = theme.getIconClass(buttonName, isRtl)) || (buttonText = calendarButtonText[buttonName]); // everything else is considered default\n                if (buttonName === \"prevYear\" || buttonName === \"nextYear\") {\n                    var prevOrNext = buttonName === \"prevYear\" ? \"prev\" : \"next\";\n                    buttonHint = formatWithOrdinals(calendarButtonHintOverrides[prevOrNext] || calendarButtonHints[prevOrNext], [\n                        calendarButtonText.year || \"year\",\n                        \"year\"\n                    ], calendarButtonText[buttonName]);\n                } else {\n                    buttonHint = function(navUnit) {\n                        return formatWithOrdinals(calendarButtonHintOverrides[buttonName] || calendarButtonHints[buttonName], [\n                            calendarButtonText[navUnit] || navUnit,\n                            navUnit\n                        ], calendarButtonText[buttonName]);\n                    };\n                }\n            }\n            return {\n                buttonName: buttonName,\n                buttonClick: buttonClick,\n                buttonIcon: buttonIcon,\n                buttonText: buttonText,\n                buttonHint: buttonHint\n            };\n        });\n    });\n    return {\n        widgets: widgets,\n        viewsWithButtons: viewsWithButtons,\n        hasTitle: hasTitle\n    };\n}\nvar eventSourceDef$2 = {\n    ignoreRange: true,\n    parseMeta: function(refined) {\n        if (Array.isArray(refined.events)) {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch: function(arg, success) {\n        success({\n            rawEvents: arg.eventSource.meta\n        });\n    }\n};\nvar arrayEventSourcePlugin = createPlugin({\n    eventSourceDefs: [\n        eventSourceDef$2\n    ]\n});\nvar eventSourceDef$1 = {\n    parseMeta: function(refined) {\n        if (typeof refined.events === \"function\") {\n            return refined.events;\n        }\n        return null;\n    },\n    fetch: function(arg, success, failure) {\n        var dateEnv = arg.context.dateEnv;\n        var func = arg.eventSource.meta;\n        unpromisify(func.bind(null, buildRangeApiWithTimeZone(arg.range, dateEnv)), function(rawEvents) {\n            success({\n                rawEvents: rawEvents\n            }); // needs an object response\n        }, failure);\n    }\n};\nvar funcEventSourcePlugin = createPlugin({\n    eventSourceDefs: [\n        eventSourceDef$1\n    ]\n});\nfunction requestJson(method, url, params, successCallback, failureCallback) {\n    method = method.toUpperCase();\n    var body = null;\n    if (method === \"GET\") {\n        url = injectQueryStringParams(url, params);\n    } else {\n        body = encodeParams(params);\n    }\n    var xhr = new XMLHttpRequest();\n    xhr.open(method, url, true);\n    if (method !== \"GET\") {\n        xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n    }\n    xhr.onload = function() {\n        if (xhr.status >= 200 && xhr.status < 400) {\n            var parsed = false;\n            var res = void 0;\n            try {\n                res = JSON.parse(xhr.responseText);\n                parsed = true;\n            } catch (err) {\n            // will handle parsed=false\n            }\n            if (parsed) {\n                successCallback(res, xhr);\n            } else {\n                failureCallback(\"Failure parsing JSON\", xhr);\n            }\n        } else {\n            failureCallback(\"Request failed\", xhr);\n        }\n    };\n    xhr.onerror = function() {\n        failureCallback(\"Request failed\", xhr);\n    };\n    xhr.send(body);\n}\nfunction injectQueryStringParams(url, params) {\n    return url + (url.indexOf(\"?\") === -1 ? \"?\" : \"&\") + encodeParams(params);\n}\nfunction encodeParams(params) {\n    var parts = [];\n    for(var key in params){\n        parts.push(encodeURIComponent(key) + \"=\" + encodeURIComponent(params[key]));\n    }\n    return parts.join(\"&\");\n}\nvar JSON_FEED_EVENT_SOURCE_REFINERS = {\n    method: String,\n    extraParams: identity,\n    startParam: String,\n    endParam: String,\n    timeZoneParam: String\n};\nvar eventSourceDef = {\n    parseMeta: function(refined) {\n        if (refined.url && (refined.format === \"json\" || !refined.format)) {\n            return {\n                url: refined.url,\n                format: \"json\",\n                method: (refined.method || \"GET\").toUpperCase(),\n                extraParams: refined.extraParams,\n                startParam: refined.startParam,\n                endParam: refined.endParam,\n                timeZoneParam: refined.timeZoneParam\n            };\n        }\n        return null;\n    },\n    fetch: function(arg, success, failure) {\n        var meta = arg.eventSource.meta;\n        var requestParams = buildRequestParams(meta, arg.range, arg.context);\n        requestJson(meta.method, meta.url, requestParams, function(rawEvents, xhr) {\n            success({\n                rawEvents: rawEvents,\n                xhr: xhr\n            });\n        }, function(errorMessage, xhr) {\n            failure({\n                message: errorMessage,\n                xhr: xhr\n            });\n        });\n    }\n};\nvar jsonFeedEventSourcePlugin = createPlugin({\n    eventSourceRefiners: JSON_FEED_EVENT_SOURCE_REFINERS,\n    eventSourceDefs: [\n        eventSourceDef\n    ]\n});\nfunction buildRequestParams(meta, range, context) {\n    var dateEnv = context.dateEnv, options = context.options;\n    var startParam;\n    var endParam;\n    var timeZoneParam;\n    var customRequestParams;\n    var params = {};\n    startParam = meta.startParam;\n    if (startParam == null) {\n        startParam = options.startParam;\n    }\n    endParam = meta.endParam;\n    if (endParam == null) {\n        endParam = options.endParam;\n    }\n    timeZoneParam = meta.timeZoneParam;\n    if (timeZoneParam == null) {\n        timeZoneParam = options.timeZoneParam;\n    }\n    // retrieve any outbound GET/POST data from the options\n    if (typeof meta.extraParams === \"function\") {\n        // supplied as a function that returns a key/value object\n        customRequestParams = meta.extraParams();\n    } else {\n        // probably supplied as a straight key/value object\n        customRequestParams = meta.extraParams || {};\n    }\n    tslib.__assign(params, customRequestParams);\n    params[startParam] = dateEnv.formatIso(range.start);\n    params[endParam] = dateEnv.formatIso(range.end);\n    if (dateEnv.timeZone !== \"local\") {\n        params[timeZoneParam] = dateEnv.timeZone;\n    }\n    return params;\n}\nvar SIMPLE_RECURRING_REFINERS = {\n    daysOfWeek: identity,\n    startTime: createDuration,\n    endTime: createDuration,\n    duration: createDuration,\n    startRecur: identity,\n    endRecur: identity\n};\nvar recurring = {\n    parse: function(refined, dateEnv) {\n        if (refined.daysOfWeek || refined.startTime || refined.endTime || refined.startRecur || refined.endRecur) {\n            var recurringData = {\n                daysOfWeek: refined.daysOfWeek || null,\n                startTime: refined.startTime || null,\n                endTime: refined.endTime || null,\n                startRecur: refined.startRecur ? dateEnv.createMarker(refined.startRecur) : null,\n                endRecur: refined.endRecur ? dateEnv.createMarker(refined.endRecur) : null\n            };\n            var duration = void 0;\n            if (refined.duration) {\n                duration = refined.duration;\n            }\n            if (!duration && refined.startTime && refined.endTime) {\n                duration = subtractDurations(refined.endTime, refined.startTime);\n            }\n            return {\n                allDayGuess: Boolean(!refined.startTime && !refined.endTime),\n                duration: duration,\n                typeData: recurringData\n            };\n        }\n        return null;\n    },\n    expand: function(typeData, framingRange, dateEnv) {\n        var clippedFramingRange = intersectRanges(framingRange, {\n            start: typeData.startRecur,\n            end: typeData.endRecur\n        });\n        if (clippedFramingRange) {\n            return expandRanges(typeData.daysOfWeek, typeData.startTime, clippedFramingRange, dateEnv);\n        }\n        return [];\n    }\n};\nvar simpleRecurringEventsPlugin = createPlugin({\n    recurringTypes: [\n        recurring\n    ],\n    eventRefiners: SIMPLE_RECURRING_REFINERS\n});\nfunction expandRanges(daysOfWeek, startTime, framingRange, dateEnv) {\n    var dowHash = daysOfWeek ? arrayToHash(daysOfWeek) : null;\n    var dayMarker = startOfDay(framingRange.start);\n    var endMarker = framingRange.end;\n    var instanceStarts = [];\n    while(dayMarker < endMarker){\n        var instanceStart = void 0;\n        // if everyday, or this particular day-of-week\n        if (!dowHash || dowHash[dayMarker.getUTCDay()]) {\n            if (startTime) {\n                instanceStart = dateEnv.add(dayMarker, startTime);\n            } else {\n                instanceStart = dayMarker;\n            }\n            instanceStarts.push(instanceStart);\n        }\n        dayMarker = addDays(dayMarker, 1);\n    }\n    return instanceStarts;\n}\nvar changeHandlerPlugin = createPlugin({\n    optionChangeHandlers: {\n        events: function(events, context) {\n            handleEventSources([\n                events\n            ], context);\n        },\n        eventSources: handleEventSources\n    }\n});\n/*\nBUG: if `event` was supplied, all previously-given `eventSources` will be wiped out\n*/ function handleEventSources(inputs, context) {\n    var unfoundSources = hashValuesToArray(context.getCurrentData().eventSources);\n    var newInputs = [];\n    for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){\n        var input = inputs_1[_i];\n        var inputFound = false;\n        for(var i = 0; i < unfoundSources.length; i += 1){\n            if (unfoundSources[i]._raw === input) {\n                unfoundSources.splice(i, 1); // delete\n                inputFound = true;\n                break;\n            }\n        }\n        if (!inputFound) {\n            newInputs.push(input);\n        }\n    }\n    for(var _a = 0, unfoundSources_1 = unfoundSources; _a < unfoundSources_1.length; _a++){\n        var unfoundSource = unfoundSources_1[_a];\n        context.dispatch({\n            type: \"REMOVE_EVENT_SOURCE\",\n            sourceId: unfoundSource.sourceId\n        });\n    }\n    for(var _b = 0, newInputs_1 = newInputs; _b < newInputs_1.length; _b++){\n        var newInput = newInputs_1[_b];\n        context.calendarApi.addEventSource(newInput);\n    }\n}\nfunction handleDateProfile(dateProfile, context) {\n    context.emitter.trigger(\"datesSet\", tslib.__assign(tslib.__assign({}, buildRangeApiWithTimeZone(dateProfile.activeRange, context.dateEnv)), {\n        view: context.viewApi\n    }));\n}\nfunction handleEventStore(eventStore, context) {\n    var emitter = context.emitter;\n    if (emitter.hasHandlers(\"eventsSet\")) {\n        emitter.trigger(\"eventsSet\", buildEventApis(eventStore, context));\n    }\n}\n/*\nthis array is exposed on the root namespace so that UMD plugins can add to it.\nsee the rollup-bundles script.\n*/ var globalPlugins = [\n    arrayEventSourcePlugin,\n    funcEventSourcePlugin,\n    jsonFeedEventSourcePlugin,\n    simpleRecurringEventsPlugin,\n    changeHandlerPlugin,\n    createPlugin({\n        isLoadingFuncs: [\n            function(state) {\n                return computeEventSourcesLoading(state.eventSources);\n            }\n        ],\n        contentTypeHandlers: {\n            html: buildHtmlRenderer,\n            domNodes: buildDomNodeRenderer\n        },\n        propSetHandlers: {\n            dateProfile: handleDateProfile,\n            eventStore: handleEventStore\n        }\n    })\n];\nfunction buildHtmlRenderer() {\n    var currentEl = null;\n    var currentHtml = \"\";\n    function render(el, html) {\n        if (el !== currentEl || html !== currentHtml) {\n            el.innerHTML = html;\n        }\n        currentEl = el;\n        currentHtml = html;\n    }\n    function destroy() {\n        currentEl.innerHTML = \"\";\n        currentEl = null;\n        currentHtml = \"\";\n    }\n    return {\n        render: render,\n        destroy: destroy\n    };\n}\nfunction buildDomNodeRenderer() {\n    var currentEl = null;\n    var currentDomNodes = [];\n    function render(el, domNodes) {\n        var newDomNodes = Array.prototype.slice.call(domNodes);\n        if (el !== currentEl || !isArraysEqual(currentDomNodes, newDomNodes)) {\n            // append first, remove second (for scroll resetting)\n            for(var _i = 0, newDomNodes_1 = newDomNodes; _i < newDomNodes_1.length; _i++){\n                var newNode = newDomNodes_1[_i];\n                el.appendChild(newNode);\n            }\n            destroy();\n        }\n        currentEl = el;\n        currentDomNodes = newDomNodes;\n    }\n    function destroy() {\n        currentDomNodes.forEach(removeElement);\n        currentDomNodes = [];\n        currentEl = null;\n    }\n    return {\n        render: render,\n        destroy: destroy\n    };\n}\nvar DelayedRunner = /** @class */ function() {\n    function DelayedRunner(drainedOption) {\n        this.drainedOption = drainedOption;\n        this.isRunning = false;\n        this.isDirty = false;\n        this.pauseDepths = {};\n        this.timeoutId = 0;\n    }\n    DelayedRunner.prototype.request = function(delay) {\n        this.isDirty = true;\n        if (!this.isPaused()) {\n            this.clearTimeout();\n            if (delay == null) {\n                this.tryDrain();\n            } else {\n                this.timeoutId = setTimeout(this.tryDrain.bind(this), delay);\n            }\n        }\n    };\n    DelayedRunner.prototype.pause = function(scope) {\n        if (scope === void 0) {\n            scope = \"\";\n        }\n        var pauseDepths = this.pauseDepths;\n        pauseDepths[scope] = (pauseDepths[scope] || 0) + 1;\n        this.clearTimeout();\n    };\n    DelayedRunner.prototype.resume = function(scope, force) {\n        if (scope === void 0) {\n            scope = \"\";\n        }\n        var pauseDepths = this.pauseDepths;\n        if (scope in pauseDepths) {\n            if (force) {\n                delete pauseDepths[scope];\n            } else {\n                pauseDepths[scope] -= 1;\n                var depth = pauseDepths[scope];\n                if (depth <= 0) {\n                    delete pauseDepths[scope];\n                }\n            }\n            this.tryDrain();\n        }\n    };\n    DelayedRunner.prototype.isPaused = function() {\n        return Object.keys(this.pauseDepths).length;\n    };\n    DelayedRunner.prototype.tryDrain = function() {\n        if (!this.isRunning && !this.isPaused()) {\n            this.isRunning = true;\n            while(this.isDirty){\n                this.isDirty = false;\n                this.drained(); // might set isDirty to true again\n            }\n            this.isRunning = false;\n        }\n    };\n    DelayedRunner.prototype.clear = function() {\n        this.clearTimeout();\n        this.isDirty = false;\n        this.pauseDepths = {};\n    };\n    DelayedRunner.prototype.clearTimeout = function() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n            this.timeoutId = 0;\n        }\n    };\n    DelayedRunner.prototype.drained = function() {\n        if (this.drainedOption) {\n            this.drainedOption();\n        }\n    };\n    return DelayedRunner;\n}();\nvar TaskRunner = /** @class */ function() {\n    function TaskRunner(runTaskOption, drainedOption) {\n        this.runTaskOption = runTaskOption;\n        this.drainedOption = drainedOption;\n        this.queue = [];\n        this.delayedRunner = new DelayedRunner(this.drain.bind(this));\n    }\n    TaskRunner.prototype.request = function(task, delay) {\n        this.queue.push(task);\n        this.delayedRunner.request(delay);\n    };\n    TaskRunner.prototype.pause = function(scope) {\n        this.delayedRunner.pause(scope);\n    };\n    TaskRunner.prototype.resume = function(scope, force) {\n        this.delayedRunner.resume(scope, force);\n    };\n    TaskRunner.prototype.drain = function() {\n        var queue = this.queue;\n        while(queue.length){\n            var completedTasks = [];\n            var task = void 0;\n            while(task = queue.shift()){\n                this.runTask(task);\n                completedTasks.push(task);\n            }\n            this.drained(completedTasks);\n        } // keep going, in case new tasks were added in the drained handler\n    };\n    TaskRunner.prototype.runTask = function(task) {\n        if (this.runTaskOption) {\n            this.runTaskOption(task);\n        }\n    };\n    TaskRunner.prototype.drained = function(completedTasks) {\n        if (this.drainedOption) {\n            this.drainedOption(completedTasks);\n        }\n    };\n    return TaskRunner;\n}();\n// Computes what the title at the top of the calendarApi should be for this view\nfunction buildTitle(dateProfile, viewOptions, dateEnv) {\n    var range;\n    // for views that span a large unit of time, show the proper interval, ignoring stray days before and after\n    if (/^(year|month)$/.test(dateProfile.currentRangeUnit)) {\n        range = dateProfile.currentRange;\n    } else {\n        range = dateProfile.activeRange;\n    }\n    return dateEnv.formatRange(range.start, range.end, createFormatter(viewOptions.titleFormat || buildTitleFormat(dateProfile)), {\n        isEndExclusive: dateProfile.isRangeAllDay,\n        defaultSeparator: viewOptions.titleRangeSeparator\n    });\n}\n// Generates the format string that should be used to generate the title for the current date range.\n// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.\nfunction buildTitleFormat(dateProfile) {\n    var currentRangeUnit = dateProfile.currentRangeUnit;\n    if (currentRangeUnit === \"year\") {\n        return {\n            year: \"numeric\"\n        };\n    }\n    if (currentRangeUnit === \"month\") {\n        return {\n            year: \"numeric\",\n            month: \"long\"\n        }; // like \"September 2014\"\n    }\n    var days = diffWholeDays(dateProfile.currentRange.start, dateProfile.currentRange.end);\n    if (days !== null && days > 1) {\n        // multi-day range. shorter, like \"Sep 9 - 10 2014\"\n        return {\n            year: \"numeric\",\n            month: \"short\",\n            day: \"numeric\"\n        };\n    }\n    // one day. longer, like \"September 9 2014\"\n    return {\n        year: \"numeric\",\n        month: \"long\",\n        day: \"numeric\"\n    };\n}\n// in future refactor, do the redux-style function(state=initial) for initial-state\n// also, whatever is happening in constructor, have it happen in action queue too\nvar CalendarDataManager = /** @class */ function() {\n    function CalendarDataManager(props) {\n        var _this = this;\n        this.computeOptionsData = memoize(this._computeOptionsData);\n        this.computeCurrentViewData = memoize(this._computeCurrentViewData);\n        this.organizeRawLocales = memoize(organizeRawLocales);\n        this.buildLocale = memoize(buildLocale);\n        this.buildPluginHooks = buildBuildPluginHooks();\n        this.buildDateEnv = memoize(buildDateEnv);\n        this.buildTheme = memoize(buildTheme);\n        this.parseToolbars = memoize(parseToolbars);\n        this.buildViewSpecs = memoize(buildViewSpecs);\n        this.buildDateProfileGenerator = memoizeObjArg(buildDateProfileGenerator);\n        this.buildViewApi = memoize(buildViewApi);\n        this.buildViewUiProps = memoizeObjArg(buildViewUiProps);\n        this.buildEventUiBySource = memoize(buildEventUiBySource, isPropsEqual);\n        this.buildEventUiBases = memoize(buildEventUiBases);\n        this.parseContextBusinessHours = memoizeObjArg(parseContextBusinessHours);\n        this.buildTitle = memoize(buildTitle);\n        this.emitter = new Emitter();\n        this.actionRunner = new TaskRunner(this._handleAction.bind(this), this.updateData.bind(this));\n        this.currentCalendarOptionsInput = {};\n        this.currentCalendarOptionsRefined = {};\n        this.currentViewOptionsInput = {};\n        this.currentViewOptionsRefined = {};\n        this.currentCalendarOptionsRefiners = {};\n        this.getCurrentData = function() {\n            return _this.data;\n        };\n        this.dispatch = function(action) {\n            _this.actionRunner.request(action); // protects against recursive calls to _handleAction\n        };\n        this.props = props;\n        this.actionRunner.pause();\n        var dynamicOptionOverrides = {};\n        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        var currentViewType = optionsData.calendarOptions.initialView || optionsData.pluginHooks.initialView;\n        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        this.emitter.setThisContext(props.calendarApi);\n        this.emitter.setOptions(currentViewData.options);\n        var currentDate = getInitialDate(optionsData.calendarOptions, optionsData.dateEnv);\n        var dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        if (!rangeContainsMarker(dateProfile.activeRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        var calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        };\n        // needs to be after setThisContext\n        for(var _i = 0, _a = optionsData.pluginHooks.contextInit; _i < _a.length; _i++){\n            var callback = _a[_i];\n            callback(calendarContext);\n        }\n        // NOT DRY\n        var eventSources = initEventSources(optionsData.calendarOptions, dateProfile, calendarContext);\n        var initialState = {\n            dynamicOptionOverrides: dynamicOptionOverrides,\n            currentViewType: currentViewType,\n            currentDate: currentDate,\n            dateProfile: dateProfile,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            eventSources: eventSources,\n            eventUiBases: {},\n            eventStore: createEmptyEventStore(),\n            renderableEventStore: createEmptyEventStore(),\n            dateSelection: null,\n            eventSelection: \"\",\n            eventDrag: null,\n            eventResize: null,\n            selectionConfig: this.buildViewUiProps(calendarContext).selectionConfig\n        };\n        var contextAndState = tslib.__assign(tslib.__assign({}, calendarContext), initialState);\n        for(var _b = 0, _c = optionsData.pluginHooks.reducers; _b < _c.length; _b++){\n            var reducer = _c[_b];\n            tslib.__assign(initialState, reducer(null, null, contextAndState));\n        }\n        if (computeIsLoading(initialState, calendarContext)) {\n            this.emitter.trigger(\"loading\", true); // NOT DRY\n        }\n        this.state = initialState;\n        this.updateData();\n        this.actionRunner.resume();\n    }\n    CalendarDataManager.prototype.resetOptions = function(optionOverrides, append) {\n        var props = this.props;\n        props.optionOverrides = append ? tslib.__assign(tslib.__assign({}, props.optionOverrides), optionOverrides) : optionOverrides;\n        this.actionRunner.request({\n            type: \"NOTHING\"\n        });\n    };\n    CalendarDataManager.prototype._handleAction = function(action) {\n        var _a = this, props = _a.props, state = _a.state, emitter = _a.emitter;\n        var dynamicOptionOverrides = reduceDynamicOptionOverrides(state.dynamicOptionOverrides, action);\n        var optionsData = this.computeOptionsData(props.optionOverrides, dynamicOptionOverrides, props.calendarApi);\n        var currentViewType = reduceViewType(state.currentViewType, action);\n        var currentViewData = this.computeCurrentViewData(currentViewType, optionsData, props.optionOverrides, dynamicOptionOverrides);\n        // wire things up\n        // TODO: not DRY\n        props.calendarApi.currentDataManager = this;\n        emitter.setThisContext(props.calendarApi);\n        emitter.setOptions(currentViewData.options);\n        var calendarContext = {\n            dateEnv: optionsData.dateEnv,\n            options: optionsData.calendarOptions,\n            pluginHooks: optionsData.pluginHooks,\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: emitter,\n            getCurrentData: this.getCurrentData\n        };\n        var currentDate = state.currentDate, dateProfile = state.dateProfile;\n        if (this.data && this.data.dateProfileGenerator !== currentViewData.dateProfileGenerator) {\n            dateProfile = currentViewData.dateProfileGenerator.build(currentDate);\n        }\n        currentDate = reduceCurrentDate(currentDate, action);\n        dateProfile = reduceDateProfile(dateProfile, action, currentDate, currentViewData.dateProfileGenerator);\n        if (action.type === \"PREV\" || // TODO: move this logic into DateProfileGenerator\n        action.type === \"NEXT\" || // \"\n        !rangeContainsMarker(dateProfile.currentRange, currentDate)) {\n            currentDate = dateProfile.currentRange.start;\n        }\n        var eventSources = reduceEventSources(state.eventSources, action, dateProfile, calendarContext);\n        var eventStore = reduceEventStore(state.eventStore, action, eventSources, dateProfile, calendarContext);\n        var isEventsLoading = computeEventSourcesLoading(eventSources); // BAD. also called in this func in computeIsLoading\n        var renderableEventStore = isEventsLoading && !currentViewData.options.progressiveEventRendering ? state.renderableEventStore || eventStore : eventStore;\n        var _b = this.buildViewUiProps(calendarContext), eventUiSingleBase = _b.eventUiSingleBase, selectionConfig = _b.selectionConfig; // will memoize obj\n        var eventUiBySource = this.buildEventUiBySource(eventSources);\n        var eventUiBases = this.buildEventUiBases(renderableEventStore.defs, eventUiSingleBase, eventUiBySource);\n        var newState = {\n            dynamicOptionOverrides: dynamicOptionOverrides,\n            currentViewType: currentViewType,\n            currentDate: currentDate,\n            dateProfile: dateProfile,\n            eventSources: eventSources,\n            eventStore: eventStore,\n            renderableEventStore: renderableEventStore,\n            selectionConfig: selectionConfig,\n            eventUiBases: eventUiBases,\n            businessHours: this.parseContextBusinessHours(calendarContext),\n            dateSelection: reduceDateSelection(state.dateSelection, action),\n            eventSelection: reduceSelectedEvent(state.eventSelection, action),\n            eventDrag: reduceEventDrag(state.eventDrag, action),\n            eventResize: reduceEventResize(state.eventResize, action)\n        };\n        var contextAndState = tslib.__assign(tslib.__assign({}, calendarContext), newState);\n        for(var _i = 0, _c = optionsData.pluginHooks.reducers; _i < _c.length; _i++){\n            var reducer = _c[_i];\n            tslib.__assign(newState, reducer(state, action, contextAndState)); // give the OLD state, for old value\n        }\n        var wasLoading = computeIsLoading(state, calendarContext);\n        var isLoading = computeIsLoading(newState, calendarContext);\n        // TODO: use propSetHandlers in plugin system\n        if (!wasLoading && isLoading) {\n            emitter.trigger(\"loading\", true);\n        } else if (wasLoading && !isLoading) {\n            emitter.trigger(\"loading\", false);\n        }\n        this.state = newState;\n        if (props.onAction) {\n            props.onAction(action);\n        }\n    };\n    CalendarDataManager.prototype.updateData = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        var oldData = this.data;\n        var optionsData = this.computeOptionsData(props.optionOverrides, state.dynamicOptionOverrides, props.calendarApi);\n        var currentViewData = this.computeCurrentViewData(state.currentViewType, optionsData, props.optionOverrides, state.dynamicOptionOverrides);\n        var data = this.data = tslib.__assign(tslib.__assign(tslib.__assign({\n            viewTitle: this.buildTitle(state.dateProfile, currentViewData.options, optionsData.dateEnv),\n            calendarApi: props.calendarApi,\n            dispatch: this.dispatch,\n            emitter: this.emitter,\n            getCurrentData: this.getCurrentData\n        }, optionsData), currentViewData), state);\n        var changeHandlers = optionsData.pluginHooks.optionChangeHandlers;\n        var oldCalendarOptions = oldData && oldData.calendarOptions;\n        var newCalendarOptions = optionsData.calendarOptions;\n        if (oldCalendarOptions && oldCalendarOptions !== newCalendarOptions) {\n            if (oldCalendarOptions.timeZone !== newCalendarOptions.timeZone) {\n                // hack\n                state.eventSources = data.eventSources = reduceEventSourcesNewTimeZone(data.eventSources, state.dateProfile, data);\n                state.eventStore = data.eventStore = rezoneEventStoreDates(data.eventStore, oldData.dateEnv, data.dateEnv);\n            }\n            for(var optionName in changeHandlers){\n                if (oldCalendarOptions[optionName] !== newCalendarOptions[optionName]) {\n                    changeHandlers[optionName](newCalendarOptions[optionName], data);\n                }\n            }\n        }\n        if (props.onData) {\n            props.onData(data);\n        }\n    };\n    CalendarDataManager.prototype._computeOptionsData = function(optionOverrides, dynamicOptionOverrides, calendarApi) {\n        // TODO: blacklist options that are handled by optionChangeHandlers\n        var _a = this.processRawCalendarOptions(optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, pluginHooks = _a.pluginHooks, localeDefaults = _a.localeDefaults, availableLocaleData = _a.availableLocaleData, extra = _a.extra;\n        warnUnknownOptions(extra);\n        var dateEnv = this.buildDateEnv(refinedOptions.timeZone, refinedOptions.locale, refinedOptions.weekNumberCalculation, refinedOptions.firstDay, refinedOptions.weekText, pluginHooks, availableLocaleData, refinedOptions.defaultRangeSeparator);\n        var viewSpecs = this.buildViewSpecs(pluginHooks.views, optionOverrides, dynamicOptionOverrides, localeDefaults);\n        var theme = this.buildTheme(refinedOptions, pluginHooks);\n        var toolbarConfig = this.parseToolbars(refinedOptions, optionOverrides, theme, viewSpecs, calendarApi);\n        return {\n            calendarOptions: refinedOptions,\n            pluginHooks: pluginHooks,\n            dateEnv: dateEnv,\n            viewSpecs: viewSpecs,\n            theme: theme,\n            toolbarConfig: toolbarConfig,\n            localeDefaults: localeDefaults,\n            availableRawLocales: availableLocaleData.map\n        };\n    };\n    // always called from behind a memoizer\n    CalendarDataManager.prototype.processRawCalendarOptions = function(optionOverrides, dynamicOptionOverrides) {\n        var _a = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]), locales = _a.locales, locale = _a.locale;\n        var availableLocaleData = this.organizeRawLocales(locales);\n        var availableRawLocales = availableLocaleData.map;\n        var localeDefaults = this.buildLocale(locale || availableLocaleData.defaultCode, availableRawLocales).options;\n        var pluginHooks = this.buildPluginHooks(optionOverrides.plugins || [], globalPlugins);\n        var refiners = this.currentCalendarOptionsRefiners = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        var extra = {};\n        var raw = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            localeDefaults,\n            optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        var refined = {};\n        var currentRaw = this.currentCalendarOptionsInput;\n        var currentRefined = this.currentCalendarOptionsRefined;\n        var anyChanges = false;\n        for(var optionName in raw){\n            if (optionName !== \"plugins\") {\n                if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && optionName in currentRaw && COMPLEX_OPTION_COMPARATORS[optionName](currentRaw[optionName], raw[optionName])) {\n                    refined[optionName] = currentRefined[optionName];\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                    anyChanges = true;\n                } else {\n                    extra[optionName] = currentRaw[optionName];\n                }\n            }\n        }\n        if (anyChanges) {\n            this.currentCalendarOptionsInput = raw;\n            this.currentCalendarOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentCalendarOptionsInput,\n            refinedOptions: this.currentCalendarOptionsRefined,\n            pluginHooks: pluginHooks,\n            availableLocaleData: availableLocaleData,\n            localeDefaults: localeDefaults,\n            extra: extra\n        };\n    };\n    CalendarDataManager.prototype._computeCurrentViewData = function(viewType, optionsData, optionOverrides, dynamicOptionOverrides) {\n        var viewSpec = optionsData.viewSpecs[viewType];\n        if (!viewSpec) {\n            throw new Error('viewType \"' + viewType + \"\\\" is not available. Please make sure you've loaded all neccessary plugins\");\n        }\n        var _a = this.processRawViewOptions(viewSpec, optionsData.pluginHooks, optionsData.localeDefaults, optionOverrides, dynamicOptionOverrides), refinedOptions = _a.refinedOptions, extra = _a.extra;\n        warnUnknownOptions(extra);\n        var dateProfileGenerator = this.buildDateProfileGenerator({\n            dateProfileGeneratorClass: viewSpec.optionDefaults.dateProfileGeneratorClass,\n            duration: viewSpec.duration,\n            durationUnit: viewSpec.durationUnit,\n            usesMinMaxTime: viewSpec.optionDefaults.usesMinMaxTime,\n            dateEnv: optionsData.dateEnv,\n            calendarApi: this.props.calendarApi,\n            slotMinTime: refinedOptions.slotMinTime,\n            slotMaxTime: refinedOptions.slotMaxTime,\n            showNonCurrentDates: refinedOptions.showNonCurrentDates,\n            dayCount: refinedOptions.dayCount,\n            dateAlignment: refinedOptions.dateAlignment,\n            dateIncrement: refinedOptions.dateIncrement,\n            hiddenDays: refinedOptions.hiddenDays,\n            weekends: refinedOptions.weekends,\n            nowInput: refinedOptions.now,\n            validRangeInput: refinedOptions.validRange,\n            visibleRangeInput: refinedOptions.visibleRange,\n            monthMode: refinedOptions.monthMode,\n            fixedWeekCount: refinedOptions.fixedWeekCount\n        });\n        var viewApi = this.buildViewApi(viewType, this.getCurrentData, optionsData.dateEnv);\n        return {\n            viewSpec: viewSpec,\n            options: refinedOptions,\n            dateProfileGenerator: dateProfileGenerator,\n            viewApi: viewApi\n        };\n    };\n    CalendarDataManager.prototype.processRawViewOptions = function(viewSpec, pluginHooks, localeDefaults, optionOverrides, dynamicOptionOverrides) {\n        var raw = mergeRawOptions([\n            BASE_OPTION_DEFAULTS,\n            viewSpec.optionDefaults,\n            localeDefaults,\n            optionOverrides,\n            viewSpec.optionOverrides,\n            dynamicOptionOverrides\n        ]);\n        var refiners = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({}, BASE_OPTION_REFINERS), CALENDAR_LISTENER_REFINERS), CALENDAR_OPTION_REFINERS), VIEW_OPTION_REFINERS), pluginHooks.listenerRefiners), pluginHooks.optionRefiners);\n        var refined = {};\n        var currentRaw = this.currentViewOptionsInput;\n        var currentRefined = this.currentViewOptionsRefined;\n        var anyChanges = false;\n        var extra = {};\n        for(var optionName in raw){\n            if (raw[optionName] === currentRaw[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], currentRaw[optionName])) {\n                refined[optionName] = currentRefined[optionName];\n            } else {\n                if (raw[optionName] === this.currentCalendarOptionsInput[optionName] || COMPLEX_OPTION_COMPARATORS[optionName] && COMPLEX_OPTION_COMPARATORS[optionName](raw[optionName], this.currentCalendarOptionsInput[optionName])) {\n                    if (optionName in this.currentCalendarOptionsRefined) {\n                        refined[optionName] = this.currentCalendarOptionsRefined[optionName];\n                    }\n                } else if (refiners[optionName]) {\n                    refined[optionName] = refiners[optionName](raw[optionName]);\n                } else {\n                    extra[optionName] = raw[optionName];\n                }\n                anyChanges = true;\n            }\n        }\n        if (anyChanges) {\n            this.currentViewOptionsInput = raw;\n            this.currentViewOptionsRefined = refined;\n        }\n        return {\n            rawOptions: this.currentViewOptionsInput,\n            refinedOptions: this.currentViewOptionsRefined,\n            extra: extra\n        };\n    };\n    return CalendarDataManager;\n}();\nfunction buildDateEnv(timeZone, explicitLocale, weekNumberCalculation, firstDay, weekText, pluginHooks, availableLocaleData, defaultSeparator) {\n    var locale = buildLocale(explicitLocale || availableLocaleData.defaultCode, availableLocaleData.map);\n    return new DateEnv({\n        calendarSystem: \"gregory\",\n        timeZone: timeZone,\n        namedTimeZoneImpl: pluginHooks.namedTimeZonedImpl,\n        locale: locale,\n        weekNumberCalculation: weekNumberCalculation,\n        firstDay: firstDay,\n        weekText: weekText,\n        cmdFormatter: pluginHooks.cmdFormatter,\n        defaultSeparator: defaultSeparator\n    });\n}\nfunction buildTheme(options, pluginHooks) {\n    var ThemeClass = pluginHooks.themeClasses[options.themeSystem] || StandardTheme;\n    return new ThemeClass(options);\n}\nfunction buildDateProfileGenerator(props) {\n    var DateProfileGeneratorClass = props.dateProfileGeneratorClass || DateProfileGenerator;\n    return new DateProfileGeneratorClass(props);\n}\nfunction buildViewApi(type, getCurrentData, dateEnv) {\n    return new ViewApi(type, getCurrentData, dateEnv);\n}\nfunction buildEventUiBySource(eventSources) {\n    return mapHash(eventSources, function(eventSource) {\n        return eventSource.ui;\n    });\n}\nfunction buildEventUiBases(eventDefs, eventUiSingleBase, eventUiBySource) {\n    var eventUiBases = {\n        \"\": eventUiSingleBase\n    };\n    for(var defId in eventDefs){\n        var def = eventDefs[defId];\n        if (def.sourceId && eventUiBySource[def.sourceId]) {\n            eventUiBases[defId] = eventUiBySource[def.sourceId];\n        }\n    }\n    return eventUiBases;\n}\nfunction buildViewUiProps(calendarContext) {\n    var options = calendarContext.options;\n    return {\n        eventUiSingleBase: createEventUi({\n            display: options.eventDisplay,\n            editable: options.editable,\n            startEditable: options.eventStartEditable,\n            durationEditable: options.eventDurationEditable,\n            constraint: options.eventConstraint,\n            overlap: typeof options.eventOverlap === \"boolean\" ? options.eventOverlap : undefined,\n            allow: options.eventAllow,\n            backgroundColor: options.eventBackgroundColor,\n            borderColor: options.eventBorderColor,\n            textColor: options.eventTextColor,\n            color: options.eventColor\n        }, calendarContext),\n        selectionConfig: createEventUi({\n            constraint: options.selectConstraint,\n            overlap: typeof options.selectOverlap === \"boolean\" ? options.selectOverlap : undefined,\n            allow: options.selectAllow\n        }, calendarContext)\n    };\n}\nfunction computeIsLoading(state, context) {\n    for(var _i = 0, _a = context.pluginHooks.isLoadingFuncs; _i < _a.length; _i++){\n        var isLoadingFunc = _a[_i];\n        if (isLoadingFunc(state)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction parseContextBusinessHours(calendarContext) {\n    return parseBusinessHours(calendarContext.options.businessHours, calendarContext);\n}\nfunction warnUnknownOptions(options, viewName) {\n    for(var optionName in options){\n        console.warn(\"Unknown option '\" + optionName + \"'\" + (viewName ? \" for view '\" + viewName + \"'\" : \"\"));\n    }\n}\n// TODO: move this to react plugin?\nvar CalendarDataProvider = /** @class */ function(_super) {\n    tslib.__extends(CalendarDataProvider, _super);\n    function CalendarDataProvider(props) {\n        var _this = _super.call(this, props) || this;\n        _this.handleData = function(data) {\n            if (!_this.dataManager) {\n                // eslint-disable-next-line react/no-direct-mutation-state\n                _this.state = data; // can't use setState yet\n            } else {\n                _this.setState(data);\n            }\n        };\n        _this.dataManager = new CalendarDataManager({\n            optionOverrides: props.optionOverrides,\n            calendarApi: props.calendarApi,\n            onData: _this.handleData\n        });\n        return _this;\n    }\n    CalendarDataProvider.prototype.render = function() {\n        return this.props.children(this.state);\n    };\n    CalendarDataProvider.prototype.componentDidUpdate = function(prevProps) {\n        var newOptionOverrides = this.props.optionOverrides;\n        if (newOptionOverrides !== prevProps.optionOverrides) {\n            this.dataManager.resetOptions(newOptionOverrides);\n        }\n    };\n    return CalendarDataProvider;\n}(vdom_cjs.Component);\n// HELPERS\n/*\nif nextDayThreshold is specified, slicing is done in an all-day fashion.\nyou can get nextDayThreshold from context.nextDayThreshold\n*/ function sliceEvents(props, allDay) {\n    return sliceEventStore(props.eventStore, props.eventUiBases, props.dateProfile.activeRange, allDay ? props.nextDayThreshold : null).fg;\n}\nvar NamedTimeZoneImpl = /** @class */ function() {\n    function NamedTimeZoneImpl(timeZoneName) {\n        this.timeZoneName = timeZoneName;\n    }\n    return NamedTimeZoneImpl;\n}();\nvar SegHierarchy = /** @class */ function() {\n    function SegHierarchy() {\n        // settings\n        this.strictOrder = false;\n        this.allowReslicing = false;\n        this.maxCoord = -1; // -1 means no max\n        this.maxStackCnt = -1; // -1 means no max\n        this.levelCoords = []; // ordered\n        this.entriesByLevel = []; // parallel with levelCoords\n        this.stackCnts = {}; // TODO: use better technique!?\n    }\n    SegHierarchy.prototype.addSegs = function(inputs) {\n        var hiddenEntries = [];\n        for(var _i = 0, inputs_1 = inputs; _i < inputs_1.length; _i++){\n            var input = inputs_1[_i];\n            this.insertEntry(input, hiddenEntries);\n        }\n        return hiddenEntries;\n    };\n    SegHierarchy.prototype.insertEntry = function(entry, hiddenEntries) {\n        var insertion = this.findInsertion(entry);\n        if (this.isInsertionValid(insertion, entry)) {\n            this.insertEntryAt(entry, insertion);\n            return 1;\n        }\n        return this.handleInvalidInsertion(insertion, entry, hiddenEntries);\n    };\n    SegHierarchy.prototype.isInsertionValid = function(insertion, entry) {\n        return (this.maxCoord === -1 || insertion.levelCoord + entry.thickness <= this.maxCoord) && (this.maxStackCnt === -1 || insertion.stackCnt < this.maxStackCnt);\n    };\n    // returns number of new entries inserted\n    SegHierarchy.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {\n        if (this.allowReslicing && insertion.touchingEntry) {\n            return this.splitEntry(entry, insertion.touchingEntry, hiddenEntries);\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    };\n    SegHierarchy.prototype.splitEntry = function(entry, barrier, hiddenEntries) {\n        var partCnt = 0;\n        var splitHiddenEntries = [];\n        var entrySpan = entry.span;\n        var barrierSpan = barrier.span;\n        if (entrySpan.start < barrierSpan.start) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: entrySpan.start,\n                    end: barrierSpan.start\n                }\n            }, splitHiddenEntries);\n        }\n        if (entrySpan.end > barrierSpan.end) {\n            partCnt += this.insertEntry({\n                index: entry.index,\n                thickness: entry.thickness,\n                span: {\n                    start: barrierSpan.end,\n                    end: entrySpan.end\n                }\n            }, splitHiddenEntries);\n        }\n        if (partCnt) {\n            hiddenEntries.push.apply(hiddenEntries, tslib.__spreadArray([\n                {\n                    index: entry.index,\n                    thickness: entry.thickness,\n                    span: intersectSpans(barrierSpan, entrySpan)\n                }\n            ], splitHiddenEntries));\n            return partCnt;\n        }\n        hiddenEntries.push(entry);\n        return 0;\n    };\n    SegHierarchy.prototype.insertEntryAt = function(entry, insertion) {\n        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;\n        if (insertion.lateral === -1) {\n            // create a new level\n            insertAt(levelCoords, insertion.level, insertion.levelCoord);\n            insertAt(entriesByLevel, insertion.level, [\n                entry\n            ]);\n        } else {\n            // insert into existing level\n            insertAt(entriesByLevel[insertion.level], insertion.lateral, entry);\n        }\n        this.stackCnts[buildEntryKey(entry)] = insertion.stackCnt;\n    };\n    SegHierarchy.prototype.findInsertion = function(newEntry) {\n        var _a = this, levelCoords = _a.levelCoords, entriesByLevel = _a.entriesByLevel, strictOrder = _a.strictOrder, stackCnts = _a.stackCnts;\n        var levelCnt = levelCoords.length;\n        var candidateCoord = 0;\n        var touchingLevel = -1;\n        var touchingLateral = -1;\n        var touchingEntry = null;\n        var stackCnt = 0;\n        for(var trackingLevel = 0; trackingLevel < levelCnt; trackingLevel += 1){\n            var trackingCoord = levelCoords[trackingLevel];\n            // if the current level is past the placed entry, we have found a good empty space and can stop.\n            // if strictOrder, keep finding more lateral intersections.\n            if (!strictOrder && trackingCoord >= candidateCoord + newEntry.thickness) {\n                break;\n            }\n            var trackingEntries = entriesByLevel[trackingLevel];\n            var trackingEntry = void 0;\n            var searchRes = binarySearch(trackingEntries, newEntry.span.start, getEntrySpanEnd); // find first entry after newEntry's end\n            var lateralIndex = searchRes[0] + searchRes[1]; // if exact match (which doesn't collide), go to next one\n            while((trackingEntry = trackingEntries[lateralIndex]) && // but not past the whole entry list\n            trackingEntry.span.start < newEntry.span.end // and not entirely past newEntry\n            ){\n                var trackingEntryBottom = trackingCoord + trackingEntry.thickness;\n                // intersects into the top of the candidate?\n                if (trackingEntryBottom > candidateCoord) {\n                    candidateCoord = trackingEntryBottom;\n                    touchingEntry = trackingEntry;\n                    touchingLevel = trackingLevel;\n                    touchingLateral = lateralIndex;\n                }\n                // butts up against top of candidate? (will happen if just intersected as well)\n                if (trackingEntryBottom === candidateCoord) {\n                    // accumulate the highest possible stackCnt of the trackingEntries that butt up\n                    stackCnt = Math.max(stackCnt, stackCnts[buildEntryKey(trackingEntry)] + 1);\n                }\n                lateralIndex += 1;\n            }\n        }\n        // the destination level will be after touchingEntry's level. find it\n        var destLevel = 0;\n        if (touchingEntry) {\n            destLevel = touchingLevel + 1;\n            while(destLevel < levelCnt && levelCoords[destLevel] < candidateCoord){\n                destLevel += 1;\n            }\n        }\n        // if adding to an existing level, find where to insert\n        var destLateral = -1;\n        if (destLevel < levelCnt && levelCoords[destLevel] === candidateCoord) {\n            destLateral = binarySearch(entriesByLevel[destLevel], newEntry.span.end, getEntrySpanEnd)[0];\n        }\n        return {\n            touchingLevel: touchingLevel,\n            touchingLateral: touchingLateral,\n            touchingEntry: touchingEntry,\n            stackCnt: stackCnt,\n            levelCoord: candidateCoord,\n            level: destLevel,\n            lateral: destLateral\n        };\n    };\n    // sorted by levelCoord (lowest to highest)\n    SegHierarchy.prototype.toRects = function() {\n        var _a = this, entriesByLevel = _a.entriesByLevel, levelCoords = _a.levelCoords;\n        var levelCnt = entriesByLevel.length;\n        var rects = [];\n        for(var level = 0; level < levelCnt; level += 1){\n            var entries = entriesByLevel[level];\n            var levelCoord = levelCoords[level];\n            for(var _i = 0, entries_1 = entries; _i < entries_1.length; _i++){\n                var entry = entries_1[_i];\n                rects.push(tslib.__assign(tslib.__assign({}, entry), {\n                    levelCoord: levelCoord\n                }));\n            }\n        }\n        return rects;\n    };\n    return SegHierarchy;\n}();\nfunction getEntrySpanEnd(entry) {\n    return entry.span.end;\n}\nfunction buildEntryKey(entry) {\n    return entry.index + \":\" + entry.span.start;\n}\n// returns groups with entries sorted by input order\nfunction groupIntersectingEntries(entries) {\n    var merges = [];\n    for(var _i = 0, entries_2 = entries; _i < entries_2.length; _i++){\n        var entry = entries_2[_i];\n        var filteredMerges = [];\n        var hungryMerge = {\n            span: entry.span,\n            entries: [\n                entry\n            ]\n        };\n        for(var _a = 0, merges_1 = merges; _a < merges_1.length; _a++){\n            var merge = merges_1[_a];\n            if (intersectSpans(merge.span, hungryMerge.span)) {\n                hungryMerge = {\n                    entries: merge.entries.concat(hungryMerge.entries),\n                    span: joinSpans(merge.span, hungryMerge.span)\n                };\n            } else {\n                filteredMerges.push(merge);\n            }\n        }\n        filteredMerges.push(hungryMerge);\n        merges = filteredMerges;\n    }\n    return merges;\n}\nfunction joinSpans(span0, span1) {\n    return {\n        start: Math.min(span0.start, span1.start),\n        end: Math.max(span0.end, span1.end)\n    };\n}\nfunction intersectSpans(span0, span1) {\n    var start = Math.max(span0.start, span1.start);\n    var end = Math.min(span0.end, span1.end);\n    if (start < end) {\n        return {\n            start: start,\n            end: end\n        };\n    }\n    return null;\n}\n// general util\n// ---------------------------------------------------------------------------------------------------------------------\nfunction insertAt(arr, index, item) {\n    arr.splice(index, 0, item);\n}\nfunction binarySearch(a, searchVal, getItemVal) {\n    var startIndex = 0;\n    var endIndex = a.length; // exclusive\n    if (!endIndex || searchVal < getItemVal(a[startIndex])) {\n        return [\n            0,\n            0\n        ];\n    }\n    if (searchVal > getItemVal(a[endIndex - 1])) {\n        return [\n            endIndex,\n            0\n        ];\n    }\n    while(startIndex < endIndex){\n        var middleIndex = Math.floor(startIndex + (endIndex - startIndex) / 2);\n        var middleVal = getItemVal(a[middleIndex]);\n        if (searchVal < middleVal) {\n            endIndex = middleIndex;\n        } else if (searchVal > middleVal) {\n            startIndex = middleIndex + 1;\n        } else {\n            return [\n                middleIndex,\n                1\n            ];\n        }\n    }\n    return [\n        startIndex,\n        0\n    ];\n}\nvar Interaction = /** @class */ function() {\n    function Interaction(settings) {\n        this.component = settings.component;\n        this.isHitComboAllowed = settings.isHitComboAllowed || null;\n    }\n    Interaction.prototype.destroy = function() {};\n    return Interaction;\n}();\nfunction parseInteractionSettings(component, input) {\n    return {\n        component: component,\n        el: input.el,\n        useEventCenter: input.useEventCenter != null ? input.useEventCenter : true,\n        isHitComboAllowed: input.isHitComboAllowed || null\n    };\n}\nfunction interactionSettingsToStore(settings) {\n    var _a;\n    return _a = {}, _a[settings.component.uid] = settings, _a;\n}\n// global state\nvar interactionSettingsStore = {};\n/*\nAn abstraction for a dragging interaction originating on an event.\nDoes higher-level things than PointerDragger, such as possibly:\n- a \"mirror\" that moves with the pointer\n- a minimum number of pixels or other criteria for a true drag to begin\n\nsubclasses must emit:\n- pointerdown\n- dragstart\n- dragmove\n- pointerup\n- dragend\n*/ var ElementDragging = /** @class */ function() {\n    function ElementDragging(el, selector) {\n        this.emitter = new Emitter();\n    }\n    ElementDragging.prototype.destroy = function() {};\n    ElementDragging.prototype.setMirrorIsVisible = function(bool) {\n    // optional if subclass doesn't want to support a mirror\n    };\n    ElementDragging.prototype.setMirrorNeedsRevert = function(bool) {\n    // optional if subclass doesn't want to support a mirror\n    };\n    ElementDragging.prototype.setAutoScrollEnabled = function(bool) {\n    // optional\n    };\n    return ElementDragging;\n}();\n// TODO: get rid of this in favor of options system,\n// tho it's really easy to access this globally rather than pass thru options.\nvar config = {};\n/*\nInformation about what will happen when an external element is dragged-and-dropped\nonto a calendar. Contains information for creating an event.\n*/ var DRAG_META_REFINERS = {\n    startTime: createDuration,\n    duration: createDuration,\n    create: Boolean,\n    sourceId: String\n};\nfunction parseDragMeta(raw) {\n    var _a = refineProps(raw, DRAG_META_REFINERS), refined = _a.refined, extra = _a.extra;\n    return {\n        startTime: refined.startTime || null,\n        duration: refined.duration || null,\n        create: refined.create != null ? refined.create : true,\n        sourceId: refined.sourceId,\n        leftoverProps: extra\n    };\n}\nvar ToolbarSection = /** @class */ function(_super) {\n    tslib.__extends(ToolbarSection, _super);\n    function ToolbarSection() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    ToolbarSection.prototype.render = function() {\n        var _this = this;\n        var children = this.props.widgetGroups.map(function(widgetGroup) {\n            return _this.renderWidgetGroup(widgetGroup);\n        });\n        return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"div\",\n            {\n                className: \"fc-toolbar-chunk\"\n            }\n        ], children));\n    };\n    ToolbarSection.prototype.renderWidgetGroup = function(widgetGroup) {\n        var props = this.props;\n        var theme = this.context.theme;\n        var children = [];\n        var isOnlyButtons = true;\n        for(var _i = 0, widgetGroup_1 = widgetGroup; _i < widgetGroup_1.length; _i++){\n            var widget = widgetGroup_1[_i];\n            var buttonName = widget.buttonName, buttonClick = widget.buttonClick, buttonText = widget.buttonText, buttonIcon = widget.buttonIcon, buttonHint = widget.buttonHint;\n            if (buttonName === \"title\") {\n                isOnlyButtons = false;\n                children.push(vdom_cjs.createElement(\"h2\", {\n                    className: \"fc-toolbar-title\",\n                    id: props.titleId\n                }, props.title));\n            } else {\n                var isPressed = buttonName === props.activeButton;\n                var isDisabled = !props.isTodayEnabled && buttonName === \"today\" || !props.isPrevEnabled && buttonName === \"prev\" || !props.isNextEnabled && buttonName === \"next\";\n                var buttonClasses = [\n                    \"fc-\" + buttonName + \"-button\",\n                    theme.getClass(\"button\")\n                ];\n                if (isPressed) {\n                    buttonClasses.push(theme.getClass(\"buttonActive\"));\n                }\n                children.push(vdom_cjs.createElement(\"button\", {\n                    type: \"button\",\n                    title: typeof buttonHint === \"function\" ? buttonHint(props.navUnit) : buttonHint,\n                    disabled: isDisabled,\n                    \"aria-pressed\": isPressed,\n                    className: buttonClasses.join(\" \"),\n                    onClick: buttonClick\n                }, buttonText || (buttonIcon ? vdom_cjs.createElement(\"span\", {\n                    className: buttonIcon\n                }) : \"\")));\n            }\n        }\n        if (children.length > 1) {\n            var groupClassName = isOnlyButtons && theme.getClass(\"buttonGroup\") || \"\";\n            return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n                \"div\",\n                {\n                    className: groupClassName\n                }\n            ], children));\n        }\n        return children[0];\n    };\n    return ToolbarSection;\n}(BaseComponent);\nvar Toolbar = /** @class */ function(_super) {\n    tslib.__extends(Toolbar, _super);\n    function Toolbar() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    Toolbar.prototype.render = function() {\n        var _a = this.props, model = _a.model, extraClassName = _a.extraClassName;\n        var forceLtr = false;\n        var startContent;\n        var endContent;\n        var sectionWidgets = model.sectionWidgets;\n        var centerContent = sectionWidgets.center;\n        if (sectionWidgets.left) {\n            forceLtr = true;\n            startContent = sectionWidgets.left;\n        } else {\n            startContent = sectionWidgets.start;\n        }\n        if (sectionWidgets.right) {\n            forceLtr = true;\n            endContent = sectionWidgets.right;\n        } else {\n            endContent = sectionWidgets.end;\n        }\n        var classNames = [\n            extraClassName || \"\",\n            \"fc-toolbar\",\n            forceLtr ? \"fc-toolbar-ltr\" : \"\"\n        ];\n        return vdom_cjs.createElement(\"div\", {\n            className: classNames.join(\" \")\n        }, this.renderSection(\"start\", startContent || []), this.renderSection(\"center\", centerContent || []), this.renderSection(\"end\", endContent || []));\n    };\n    Toolbar.prototype.renderSection = function(key, widgetGroups) {\n        var props = this.props;\n        return vdom_cjs.createElement(ToolbarSection, {\n            key: key,\n            widgetGroups: widgetGroups,\n            title: props.title,\n            navUnit: props.navUnit,\n            activeButton: props.activeButton,\n            isTodayEnabled: props.isTodayEnabled,\n            isPrevEnabled: props.isPrevEnabled,\n            isNextEnabled: props.isNextEnabled,\n            titleId: props.titleId\n        });\n    };\n    return Toolbar;\n}(BaseComponent);\n// TODO: do function component?\nvar ViewContainer = /** @class */ function(_super) {\n    tslib.__extends(ViewContainer, _super);\n    function ViewContainer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            availableWidth: null\n        };\n        _this.handleEl = function(el) {\n            _this.el = el;\n            setRef(_this.props.elRef, el);\n            _this.updateAvailableWidth();\n        };\n        _this.handleResize = function() {\n            _this.updateAvailableWidth();\n        };\n        return _this;\n    }\n    ViewContainer.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        var aspectRatio = props.aspectRatio;\n        var classNames = [\n            \"fc-view-harness\",\n            aspectRatio || props.liquid || props.height ? \"fc-view-harness-active\" // harness controls the height\n             : \"fc-view-harness-passive\"\n        ];\n        var height = \"\";\n        var paddingBottom = \"\";\n        if (aspectRatio) {\n            if (state.availableWidth !== null) {\n                height = state.availableWidth / aspectRatio;\n            } else {\n                // while waiting to know availableWidth, we can't set height to *zero*\n                // because will cause lots of unnecessary scrollbars within scrollgrid.\n                // BETTER: don't start rendering ANYTHING yet until we know container width\n                // NOTE: why not always use paddingBottom? Causes height oscillation (issue 5606)\n                paddingBottom = 1 / aspectRatio * 100 + \"%\";\n            }\n        } else {\n            height = props.height || \"\";\n        }\n        return vdom_cjs.createElement(\"div\", {\n            \"aria-labelledby\": props.labeledById,\n            ref: this.handleEl,\n            className: classNames.join(\" \"),\n            style: {\n                height: height,\n                paddingBottom: paddingBottom\n            }\n        }, props.children);\n    };\n    ViewContainer.prototype.componentDidMount = function() {\n        this.context.addResizeHandler(this.handleResize);\n    };\n    ViewContainer.prototype.componentWillUnmount = function() {\n        this.context.removeResizeHandler(this.handleResize);\n    };\n    ViewContainer.prototype.updateAvailableWidth = function() {\n        if (this.el && // needed. but why?\n        this.props.aspectRatio // aspectRatio is the only height setting that needs availableWidth\n        ) {\n            this.setState({\n                availableWidth: this.el.offsetWidth\n            });\n        }\n    };\n    return ViewContainer;\n}(BaseComponent);\n/*\nDetects when the user clicks on an event within a DateComponent\n*/ var EventClicking = /** @class */ function(_super) {\n    tslib.__extends(EventClicking, _super);\n    function EventClicking(settings) {\n        var _this = _super.call(this, settings) || this;\n        _this.handleSegClick = function(ev, segEl) {\n            var component = _this.component;\n            var context = component.context;\n            var seg = getElSeg(segEl);\n            if (seg && // might be the <div> surrounding the more link\n            component.isValidSegDownEl(ev.target)) {\n                // our way to simulate a link click for elements that can't be <a> tags\n                // grab before trigger fired in case trigger trashes DOM thru rerendering\n                var hasUrlContainer = elementClosest(ev.target, \".fc-event-forced-url\");\n                var url = hasUrlContainer ? hasUrlContainer.querySelector(\"a[href]\").href : \"\";\n                context.emitter.trigger(\"eventClick\", {\n                    el: segEl,\n                    event: new EventApi(component.context, seg.eventRange.def, seg.eventRange.instance),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n                if (url && !ev.defaultPrevented) {\n                    window.location.href = url;\n                }\n            }\n        };\n        _this.destroy = listenBySelector(settings.el, \"click\", \".fc-event\", _this.handleSegClick);\n        return _this;\n    }\n    return EventClicking;\n}(Interaction);\n/*\nTriggers events and adds/removes core classNames when the user's pointer\nenters/leaves event-elements of a component.\n*/ var EventHovering = /** @class */ function(_super) {\n    tslib.__extends(EventHovering, _super);\n    function EventHovering(settings) {\n        var _this = _super.call(this, settings) || this;\n        // for simulating an eventMouseLeave when the event el is destroyed while mouse is over it\n        _this.handleEventElRemove = function(el) {\n            if (el === _this.currentSegEl) {\n                _this.handleSegLeave(null, _this.currentSegEl);\n            }\n        };\n        _this.handleSegEnter = function(ev, segEl) {\n            if (getElSeg(segEl)) {\n                _this.currentSegEl = segEl;\n                _this.triggerEvent(\"eventMouseEnter\", ev, segEl);\n            }\n        };\n        _this.handleSegLeave = function(ev, segEl) {\n            if (_this.currentSegEl) {\n                _this.currentSegEl = null;\n                _this.triggerEvent(\"eventMouseLeave\", ev, segEl);\n            }\n        };\n        _this.removeHoverListeners = listenToHoverBySelector(settings.el, \".fc-event\", _this.handleSegEnter, _this.handleSegLeave);\n        return _this;\n    }\n    EventHovering.prototype.destroy = function() {\n        this.removeHoverListeners();\n    };\n    EventHovering.prototype.triggerEvent = function(publicEvName, ev, segEl) {\n        var component = this.component;\n        var context = component.context;\n        var seg = getElSeg(segEl);\n        if (!ev || component.isValidSegDownEl(ev.target)) {\n            context.emitter.trigger(publicEvName, {\n                el: segEl,\n                event: new EventApi(context, seg.eventRange.def, seg.eventRange.instance),\n                jsEvent: ev,\n                view: context.viewApi\n            });\n        }\n    };\n    return EventHovering;\n}(Interaction);\nvar CalendarContent = /** @class */ function(_super) {\n    tslib.__extends(CalendarContent, _super);\n    function CalendarContent() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildViewContext = memoize(buildViewContext);\n        _this.buildViewPropTransformers = memoize(buildViewPropTransformers);\n        _this.buildToolbarProps = memoize(buildToolbarProps);\n        _this.headerRef = vdom_cjs.createRef();\n        _this.footerRef = vdom_cjs.createRef();\n        _this.interactionsStore = {};\n        // eslint-disable-next-line\n        _this.state = {\n            viewLabelId: getUniqueDomId()\n        };\n        // Component Registration\n        // -----------------------------------------------------------------------------------------------------------------\n        _this.registerInteractiveComponent = function(component, settingsInput) {\n            var settings = parseInteractionSettings(component, settingsInput);\n            var DEFAULT_INTERACTIONS = [\n                EventClicking,\n                EventHovering\n            ];\n            var interactionClasses = DEFAULT_INTERACTIONS.concat(_this.props.pluginHooks.componentInteractions);\n            var interactions = interactionClasses.map(function(TheInteractionClass) {\n                return new TheInteractionClass(settings);\n            });\n            _this.interactionsStore[component.uid] = interactions;\n            interactionSettingsStore[component.uid] = settings;\n        };\n        _this.unregisterInteractiveComponent = function(component) {\n            var listeners = _this.interactionsStore[component.uid];\n            if (listeners) {\n                for(var _i = 0, listeners_1 = listeners; _i < listeners_1.length; _i++){\n                    var listener = listeners_1[_i];\n                    listener.destroy();\n                }\n                delete _this.interactionsStore[component.uid];\n            }\n            delete interactionSettingsStore[component.uid];\n        };\n        // Resizing\n        // -----------------------------------------------------------------------------------------------------------------\n        _this.resizeRunner = new DelayedRunner(function() {\n            _this.props.emitter.trigger(\"_resize\", true); // should window resizes be considered \"forced\" ?\n            _this.props.emitter.trigger(\"windowResize\", {\n                view: _this.props.viewApi\n            });\n        });\n        _this.handleWindowResize = function(ev) {\n            var options = _this.props.options;\n            if (options.handleWindowResize && ev.target === window // avoid jqui events\n            ) {\n                _this.resizeRunner.request(options.windowResizeDelay);\n            }\n        };\n        return _this;\n    }\n    /*\n    renders INSIDE of an outer div\n    */ CalendarContent.prototype.render = function() {\n        var props = this.props;\n        var toolbarConfig = props.toolbarConfig, options = props.options;\n        var toolbarProps = this.buildToolbarProps(props.viewSpec, props.dateProfile, props.dateProfileGenerator, props.currentDate, getNow(props.options.now, props.dateEnv), props.viewTitle);\n        var viewVGrow = false;\n        var viewHeight = \"\";\n        var viewAspectRatio;\n        if (props.isHeightAuto || props.forPrint) {\n            viewHeight = \"\";\n        } else if (options.height != null) {\n            viewVGrow = true;\n        } else if (options.contentHeight != null) {\n            viewHeight = options.contentHeight;\n        } else {\n            viewAspectRatio = Math.max(options.aspectRatio, 0.5); // prevent from getting too tall\n        }\n        var viewContext = this.buildViewContext(props.viewSpec, props.viewApi, props.options, props.dateProfileGenerator, props.dateEnv, props.theme, props.pluginHooks, props.dispatch, props.getCurrentData, props.emitter, props.calendarApi, this.registerInteractiveComponent, this.unregisterInteractiveComponent);\n        var viewLabelId = toolbarConfig.header && toolbarConfig.header.hasTitle ? this.state.viewLabelId : \"\";\n        return vdom_cjs.createElement(ViewContextType.Provider, {\n            value: viewContext\n        }, toolbarConfig.header && vdom_cjs.createElement(Toolbar, tslib.__assign({\n            ref: this.headerRef,\n            extraClassName: \"fc-header-toolbar\",\n            model: toolbarConfig.header,\n            titleId: viewLabelId\n        }, toolbarProps)), vdom_cjs.createElement(ViewContainer, {\n            liquid: viewVGrow,\n            height: viewHeight,\n            aspectRatio: viewAspectRatio,\n            labeledById: viewLabelId\n        }, this.renderView(props), this.buildAppendContent()), toolbarConfig.footer && vdom_cjs.createElement(Toolbar, tslib.__assign({\n            ref: this.footerRef,\n            extraClassName: \"fc-footer-toolbar\",\n            model: toolbarConfig.footer,\n            titleId: \"\"\n        }, toolbarProps)));\n    };\n    CalendarContent.prototype.componentDidMount = function() {\n        var props = this.props;\n        this.calendarInteractions = props.pluginHooks.calendarInteractions.map(function(CalendarInteractionClass) {\n            return new CalendarInteractionClass(props);\n        });\n        window.addEventListener(\"resize\", this.handleWindowResize);\n        var propSetHandlers = props.pluginHooks.propSetHandlers;\n        for(var propName in propSetHandlers){\n            propSetHandlers[propName](props[propName], props);\n        }\n    };\n    CalendarContent.prototype.componentDidUpdate = function(prevProps) {\n        var props = this.props;\n        var propSetHandlers = props.pluginHooks.propSetHandlers;\n        for(var propName in propSetHandlers){\n            if (props[propName] !== prevProps[propName]) {\n                propSetHandlers[propName](props[propName], props);\n            }\n        }\n    };\n    CalendarContent.prototype.componentWillUnmount = function() {\n        window.removeEventListener(\"resize\", this.handleWindowResize);\n        this.resizeRunner.clear();\n        for(var _i = 0, _a = this.calendarInteractions; _i < _a.length; _i++){\n            var interaction = _a[_i];\n            interaction.destroy();\n        }\n        this.props.emitter.trigger(\"_unmount\");\n    };\n    CalendarContent.prototype.buildAppendContent = function() {\n        var props = this.props;\n        var children = props.pluginHooks.viewContainerAppends.map(function(buildAppendContent) {\n            return buildAppendContent(props);\n        });\n        return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            vdom_cjs.Fragment,\n            {}\n        ], children));\n    };\n    CalendarContent.prototype.renderView = function(props) {\n        var pluginHooks = props.pluginHooks;\n        var viewSpec = props.viewSpec;\n        var viewProps = {\n            dateProfile: props.dateProfile,\n            businessHours: props.businessHours,\n            eventStore: props.renderableEventStore,\n            eventUiBases: props.eventUiBases,\n            dateSelection: props.dateSelection,\n            eventSelection: props.eventSelection,\n            eventDrag: props.eventDrag,\n            eventResize: props.eventResize,\n            isHeightAuto: props.isHeightAuto,\n            forPrint: props.forPrint\n        };\n        var transformers = this.buildViewPropTransformers(pluginHooks.viewPropsTransformers);\n        for(var _i = 0, transformers_1 = transformers; _i < transformers_1.length; _i++){\n            var transformer = transformers_1[_i];\n            tslib.__assign(viewProps, transformer.transform(viewProps, props));\n        }\n        var ViewComponent = viewSpec.component;\n        return vdom_cjs.createElement(ViewComponent, tslib.__assign({}, viewProps));\n    };\n    return CalendarContent;\n}(PureComponent);\nfunction buildToolbarProps(viewSpec, dateProfile, dateProfileGenerator, currentDate, now, title) {\n    // don't force any date-profiles to valid date profiles (the `false`) so that we can tell if it's invalid\n    var todayInfo = dateProfileGenerator.build(now, undefined, false); // TODO: need `undefined` or else INFINITE LOOP for some reason\n    var prevInfo = dateProfileGenerator.buildPrev(dateProfile, currentDate, false);\n    var nextInfo = dateProfileGenerator.buildNext(dateProfile, currentDate, false);\n    return {\n        title: title,\n        activeButton: viewSpec.type,\n        navUnit: viewSpec.singleUnit,\n        isTodayEnabled: todayInfo.isValid && !rangeContainsMarker(dateProfile.currentRange, now),\n        isPrevEnabled: prevInfo.isValid,\n        isNextEnabled: nextInfo.isValid\n    };\n}\n// Plugin\n// -----------------------------------------------------------------------------------------------------------------\nfunction buildViewPropTransformers(theClasses) {\n    return theClasses.map(function(TheClass) {\n        return new TheClass();\n    });\n}\nvar CalendarRoot = /** @class */ function(_super) {\n    tslib.__extends(CalendarRoot, _super);\n    function CalendarRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            forPrint: false\n        };\n        _this.handleBeforePrint = function() {\n            _this.setState({\n                forPrint: true\n            });\n        };\n        _this.handleAfterPrint = function() {\n            _this.setState({\n                forPrint: false\n            });\n        };\n        return _this;\n    }\n    CalendarRoot.prototype.render = function() {\n        var props = this.props;\n        var options = props.options;\n        var forPrint = this.state.forPrint;\n        var isHeightAuto = forPrint || options.height === \"auto\" || options.contentHeight === \"auto\";\n        var height = !isHeightAuto && options.height != null ? options.height : \"\";\n        var classNames = [\n            \"fc\",\n            forPrint ? \"fc-media-print\" : \"fc-media-screen\",\n            \"fc-direction-\" + options.direction,\n            props.theme.getClass(\"root\")\n        ];\n        if (!getCanVGrowWithinCell()) {\n            classNames.push(\"fc-liquid-hack\");\n        }\n        return props.children(classNames, height, isHeightAuto, forPrint);\n    };\n    CalendarRoot.prototype.componentDidMount = function() {\n        var emitter = this.props.emitter;\n        emitter.on(\"_beforeprint\", this.handleBeforePrint);\n        emitter.on(\"_afterprint\", this.handleAfterPrint);\n    };\n    CalendarRoot.prototype.componentWillUnmount = function() {\n        var emitter = this.props.emitter;\n        emitter.off(\"_beforeprint\", this.handleBeforePrint);\n        emitter.off(\"_afterprint\", this.handleAfterPrint);\n    };\n    return CalendarRoot;\n}(BaseComponent);\n// Computes a default column header formatting string if `colFormat` is not explicitly defined\nfunction computeFallbackHeaderFormat(datesRepDistinctDays, dayCnt) {\n    // if more than one week row, or if there are a lot of columns with not much space,\n    // put just the day numbers will be in each cell\n    if (!datesRepDistinctDays || dayCnt > 10) {\n        return createFormatter({\n            weekday: \"short\"\n        }); // \"Sat\"\n    }\n    if (dayCnt > 1) {\n        return createFormatter({\n            weekday: \"short\",\n            month: \"numeric\",\n            day: \"numeric\",\n            omitCommas: true\n        }); // \"Sat 11/12\"\n    }\n    return createFormatter({\n        weekday: \"long\"\n    }); // \"Saturday\"\n}\nvar CLASS_NAME = \"fc-col-header-cell\"; // do the cushion too? no\nfunction renderInner$1(hookProps) {\n    return hookProps.text;\n}\nvar TableDateCell = /** @class */ function(_super) {\n    tslib.__extends(TableDateCell, _super);\n    function TableDateCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableDateCell.prototype.render = function() {\n        var _a = this.context, dateEnv = _a.dateEnv, options = _a.options, theme = _a.theme, viewApi = _a.viewApi;\n        var props = this.props;\n        var date = props.date, dateProfile = props.dateProfile;\n        var dayMeta = getDateMeta(date, props.todayRange, null, dateProfile);\n        var classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dayMeta, theme));\n        var text = dateEnv.format(date, props.dayHeaderFormat);\n        // if colCnt is 1, we are already in a day-view and don't need a navlink\n        var navLinkAttrs = !dayMeta.isDisabled && props.colCnt > 1 ? buildNavLinkAttrs(this.context, date) : {};\n        var hookProps = tslib.__assign(tslib.__assign(tslib.__assign({\n            date: dateEnv.toDate(date),\n            view: viewApi\n        }, props.extraHookProps), {\n            text: text\n        }), dayMeta);\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.dayHeaderClassNames,\n            content: options.dayHeaderContent,\n            defaultContent: renderInner$1,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return vdom_cjs.createElement(\"th\", tslib.__assign({\n                ref: rootElRef,\n                role: \"columnheader\",\n                className: classNames.concat(customClassNames).join(\" \"),\n                \"data-date\": !dayMeta.isDisabled ? formatDayString(date) : undefined,\n                colSpan: props.colSpan\n            }, props.extraDataAttrs), vdom_cjs.createElement(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, !dayMeta.isDisabled && vdom_cjs.createElement(\"a\", tslib.__assign({\n                ref: innerElRef,\n                className: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky ? \"fc-sticky\" : \"\"\n                ].join(\" \")\n            }, navLinkAttrs), innerContent)));\n        });\n    };\n    return TableDateCell;\n}(BaseComponent);\nvar WEEKDAY_FORMAT = createFormatter({\n    weekday: \"long\"\n});\nvar TableDowCell = /** @class */ function(_super) {\n    tslib.__extends(TableDowCell, _super);\n    function TableDowCell() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableDowCell.prototype.render = function() {\n        var props = this.props;\n        var _a = this.context, dateEnv = _a.dateEnv, theme = _a.theme, viewApi = _a.viewApi, options = _a.options;\n        var date = addDays(new Date(259200000), props.dow); // start with Sun, 04 Jan 1970 00:00:00 GMT\n        var dateMeta = {\n            dow: props.dow,\n            isDisabled: false,\n            isFuture: false,\n            isPast: false,\n            isToday: false,\n            isOther: false\n        };\n        var classNames = [\n            CLASS_NAME\n        ].concat(getDayClassNames(dateMeta, theme), props.extraClassNames || []);\n        var text = dateEnv.format(date, props.dayHeaderFormat);\n        var hookProps = tslib.__assign(tslib.__assign(tslib.__assign(tslib.__assign({\n            date: date\n        }, dateMeta), {\n            view: viewApi\n        }), props.extraHookProps), {\n            text: text\n        });\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.dayHeaderClassNames,\n            content: options.dayHeaderContent,\n            defaultContent: renderInner$1,\n            didMount: options.dayHeaderDidMount,\n            willUnmount: options.dayHeaderWillUnmount\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return vdom_cjs.createElement(\"th\", tslib.__assign({\n                ref: rootElRef,\n                role: \"columnheader\",\n                className: classNames.concat(customClassNames).join(\" \"),\n                colSpan: props.colSpan\n            }, props.extraDataAttrs), vdom_cjs.createElement(\"div\", {\n                className: \"fc-scrollgrid-sync-inner\"\n            }, vdom_cjs.createElement(\"a\", {\n                \"aria-label\": dateEnv.format(date, WEEKDAY_FORMAT),\n                className: [\n                    \"fc-col-header-cell-cushion\",\n                    props.isSticky ? \"fc-sticky\" : \"\"\n                ].join(\" \"),\n                ref: innerElRef\n            }, innerContent)));\n        });\n    };\n    return TableDowCell;\n}(BaseComponent);\nvar NowTimer = /** @class */ function(_super) {\n    tslib.__extends(NowTimer, _super);\n    function NowTimer(props, context) {\n        var _this = _super.call(this, props, context) || this;\n        _this.initialNowDate = getNow(context.options.now, context.dateEnv);\n        _this.initialNowQueriedMs = new Date().valueOf();\n        _this.state = _this.computeTiming().currentState;\n        return _this;\n    }\n    NowTimer.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state;\n        return props.children(state.nowDate, state.todayRange);\n    };\n    NowTimer.prototype.componentDidMount = function() {\n        this.setTimeout();\n    };\n    NowTimer.prototype.componentDidUpdate = function(prevProps) {\n        if (prevProps.unit !== this.props.unit) {\n            this.clearTimeout();\n            this.setTimeout();\n        }\n    };\n    NowTimer.prototype.componentWillUnmount = function() {\n        this.clearTimeout();\n    };\n    NowTimer.prototype.computeTiming = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var unroundedNow = addMs(this.initialNowDate, new Date().valueOf() - this.initialNowQueriedMs);\n        var currentUnitStart = context.dateEnv.startOf(unroundedNow, props.unit);\n        var nextUnitStart = context.dateEnv.add(currentUnitStart, createDuration(1, props.unit));\n        var waitMs = nextUnitStart.valueOf() - unroundedNow.valueOf();\n        // there is a max setTimeout ms value (https://stackoverflow.com/a/3468650/96342)\n        // ensure no longer than a day\n        waitMs = Math.min(1000 * 60 * 60 * 24, waitMs);\n        return {\n            currentState: {\n                nowDate: currentUnitStart,\n                todayRange: buildDayRange(currentUnitStart)\n            },\n            nextState: {\n                nowDate: nextUnitStart,\n                todayRange: buildDayRange(nextUnitStart)\n            },\n            waitMs: waitMs\n        };\n    };\n    NowTimer.prototype.setTimeout = function() {\n        var _this = this;\n        var _a = this.computeTiming(), nextState = _a.nextState, waitMs = _a.waitMs;\n        this.timeoutId = setTimeout(function() {\n            _this.setState(nextState, function() {\n                _this.setTimeout();\n            });\n        }, waitMs);\n    };\n    NowTimer.prototype.clearTimeout = function() {\n        if (this.timeoutId) {\n            clearTimeout(this.timeoutId);\n        }\n    };\n    NowTimer.contextType = ViewContextType;\n    return NowTimer;\n}(vdom_cjs.Component);\nfunction buildDayRange(date) {\n    var start = startOfDay(date);\n    var end = addDays(start, 1);\n    return {\n        start: start,\n        end: end\n    };\n}\nvar DayHeader = /** @class */ function(_super) {\n    tslib.__extends(DayHeader, _super);\n    function DayHeader() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.createDayHeaderFormatter = memoize(createDayHeaderFormatter);\n        return _this;\n    }\n    DayHeader.prototype.render = function() {\n        var context = this.context;\n        var _a = this.props, dates = _a.dates, dateProfile = _a.dateProfile, datesRepDistinctDays = _a.datesRepDistinctDays, renderIntro = _a.renderIntro;\n        var dayHeaderFormat = this.createDayHeaderFormatter(context.options.dayHeaderFormat, datesRepDistinctDays, dates.length);\n        return vdom_cjs.createElement(NowTimer, {\n            unit: \"day\"\n        }, function(nowDate, todayRange) {\n            return vdom_cjs.createElement(\"tr\", {\n                role: \"row\"\n            }, renderIntro && renderIntro(\"day\"), dates.map(function(date) {\n                return datesRepDistinctDays ? vdom_cjs.createElement(TableDateCell, {\n                    key: date.toISOString(),\n                    date: date,\n                    dateProfile: dateProfile,\n                    todayRange: todayRange,\n                    colCnt: dates.length,\n                    dayHeaderFormat: dayHeaderFormat\n                }) : vdom_cjs.createElement(TableDowCell, {\n                    key: date.getUTCDay(),\n                    dow: date.getUTCDay(),\n                    dayHeaderFormat: dayHeaderFormat\n                });\n            }));\n        });\n    };\n    return DayHeader;\n}(BaseComponent);\nfunction createDayHeaderFormatter(explicitFormat, datesRepDistinctDays, dateCnt) {\n    return explicitFormat || computeFallbackHeaderFormat(datesRepDistinctDays, dateCnt);\n}\nvar DaySeriesModel = /** @class */ function() {\n    function DaySeriesModel(range, dateProfileGenerator) {\n        var date = range.start;\n        var end = range.end;\n        var indices = [];\n        var dates = [];\n        var dayIndex = -1;\n        while(date < end){\n            if (dateProfileGenerator.isHiddenDay(date)) {\n                indices.push(dayIndex + 0.5); // mark that it's between indices\n            } else {\n                dayIndex += 1;\n                indices.push(dayIndex);\n                dates.push(date);\n            }\n            date = addDays(date, 1);\n        }\n        this.dates = dates;\n        this.indices = indices;\n        this.cnt = dates.length;\n    }\n    DaySeriesModel.prototype.sliceRange = function(range) {\n        var firstIndex = this.getDateDayIndex(range.start); // inclusive first index\n        var lastIndex = this.getDateDayIndex(addDays(range.end, -1)); // inclusive last index\n        var clippedFirstIndex = Math.max(0, firstIndex);\n        var clippedLastIndex = Math.min(this.cnt - 1, lastIndex);\n        // deal with in-between indices\n        clippedFirstIndex = Math.ceil(clippedFirstIndex); // in-between starts round to next cell\n        clippedLastIndex = Math.floor(clippedLastIndex); // in-between ends round to prev cell\n        if (clippedFirstIndex <= clippedLastIndex) {\n            return {\n                firstIndex: clippedFirstIndex,\n                lastIndex: clippedLastIndex,\n                isStart: firstIndex === clippedFirstIndex,\n                isEnd: lastIndex === clippedLastIndex\n            };\n        }\n        return null;\n    };\n    // Given a date, returns its chronolocial cell-index from the first cell of the grid.\n    // If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.\n    // If before the first offset, returns a negative number.\n    // If after the last offset, returns an offset past the last cell offset.\n    // Only works for *start* dates of cells. Will not work for exclusive end dates for cells.\n    DaySeriesModel.prototype.getDateDayIndex = function(date) {\n        var indices = this.indices;\n        var dayOffset = Math.floor(diffDays(this.dates[0], date));\n        if (dayOffset < 0) {\n            return indices[0] - 1;\n        }\n        if (dayOffset >= indices.length) {\n            return indices[indices.length - 1] + 1;\n        }\n        return indices[dayOffset];\n    };\n    return DaySeriesModel;\n}();\nvar DayTableModel = /** @class */ function() {\n    function DayTableModel(daySeries, breakOnWeeks) {\n        var dates = daySeries.dates;\n        var daysPerRow;\n        var firstDay;\n        var rowCnt;\n        if (breakOnWeeks) {\n            // count columns until the day-of-week repeats\n            firstDay = dates[0].getUTCDay();\n            for(daysPerRow = 1; daysPerRow < dates.length; daysPerRow += 1){\n                if (dates[daysPerRow].getUTCDay() === firstDay) {\n                    break;\n                }\n            }\n            rowCnt = Math.ceil(dates.length / daysPerRow);\n        } else {\n            rowCnt = 1;\n            daysPerRow = dates.length;\n        }\n        this.rowCnt = rowCnt;\n        this.colCnt = daysPerRow;\n        this.daySeries = daySeries;\n        this.cells = this.buildCells();\n        this.headerDates = this.buildHeaderDates();\n    }\n    DayTableModel.prototype.buildCells = function() {\n        var rows = [];\n        for(var row = 0; row < this.rowCnt; row += 1){\n            var cells = [];\n            for(var col = 0; col < this.colCnt; col += 1){\n                cells.push(this.buildCell(row, col));\n            }\n            rows.push(cells);\n        }\n        return rows;\n    };\n    DayTableModel.prototype.buildCell = function(row, col) {\n        var date = this.daySeries.dates[row * this.colCnt + col];\n        return {\n            key: date.toISOString(),\n            date: date\n        };\n    };\n    DayTableModel.prototype.buildHeaderDates = function() {\n        var dates = [];\n        for(var col = 0; col < this.colCnt; col += 1){\n            dates.push(this.cells[0][col].date);\n        }\n        return dates;\n    };\n    DayTableModel.prototype.sliceRange = function(range) {\n        var colCnt = this.colCnt;\n        var seriesSeg = this.daySeries.sliceRange(range);\n        var segs = [];\n        if (seriesSeg) {\n            var firstIndex = seriesSeg.firstIndex, lastIndex = seriesSeg.lastIndex;\n            var index = firstIndex;\n            while(index <= lastIndex){\n                var row = Math.floor(index / colCnt);\n                var nextIndex = Math.min((row + 1) * colCnt, lastIndex + 1);\n                segs.push({\n                    row: row,\n                    firstCol: index % colCnt,\n                    lastCol: (nextIndex - 1) % colCnt,\n                    isStart: seriesSeg.isStart && index === firstIndex,\n                    isEnd: seriesSeg.isEnd && nextIndex - 1 === lastIndex\n                });\n                index = nextIndex;\n            }\n        }\n        return segs;\n    };\n    return DayTableModel;\n}();\nvar Slicer = /** @class */ function() {\n    function Slicer() {\n        this.sliceBusinessHours = memoize(this._sliceBusinessHours);\n        this.sliceDateSelection = memoize(this._sliceDateSpan);\n        this.sliceEventStore = memoize(this._sliceEventStore);\n        this.sliceEventDrag = memoize(this._sliceInteraction);\n        this.sliceEventResize = memoize(this._sliceInteraction);\n        this.forceDayIfListItem = false; // hack\n    }\n    Slicer.prototype.sliceProps = function(props, dateProfile, nextDayThreshold, context) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        var eventUiBases = props.eventUiBases;\n        var eventSegs = this.sliceEventStore.apply(this, tslib.__spreadArray([\n            props.eventStore,\n            eventUiBases,\n            dateProfile,\n            nextDayThreshold\n        ], extraArgs));\n        return {\n            dateSelectionSegs: this.sliceDateSelection.apply(this, tslib.__spreadArray([\n                props.dateSelection,\n                eventUiBases,\n                context\n            ], extraArgs)),\n            businessHourSegs: this.sliceBusinessHours.apply(this, tslib.__spreadArray([\n                props.businessHours,\n                dateProfile,\n                nextDayThreshold,\n                context\n            ], extraArgs)),\n            fgEventSegs: eventSegs.fg,\n            bgEventSegs: eventSegs.bg,\n            eventDrag: this.sliceEventDrag.apply(this, tslib.__spreadArray([\n                props.eventDrag,\n                eventUiBases,\n                dateProfile,\n                nextDayThreshold\n            ], extraArgs)),\n            eventResize: this.sliceEventResize.apply(this, tslib.__spreadArray([\n                props.eventResize,\n                eventUiBases,\n                dateProfile,\n                nextDayThreshold\n            ], extraArgs)),\n            eventSelection: props.eventSelection\n        }; // TODO: give interactionSegs?\n    };\n    Slicer.prototype.sliceNowDate = function(date, context) {\n        var extraArgs = [];\n        for(var _i = 2; _i < arguments.length; _i++){\n            extraArgs[_i - 2] = arguments[_i];\n        }\n        return this._sliceDateSpan.apply(this, tslib.__spreadArray([\n            {\n                range: {\n                    start: date,\n                    end: addMs(date, 1)\n                },\n                allDay: false\n            },\n            {},\n            context\n        ], extraArgs));\n    };\n    Slicer.prototype._sliceBusinessHours = function(businessHours, dateProfile, nextDayThreshold, context) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (!businessHours) {\n            return [];\n        }\n        return this._sliceEventStore.apply(this, tslib.__spreadArray([\n            expandRecurring(businessHours, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), context),\n            {},\n            dateProfile,\n            nextDayThreshold\n        ], extraArgs)).bg;\n    };\n    Slicer.prototype._sliceEventStore = function(eventStore, eventUiBases, dateProfile, nextDayThreshold) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (eventStore) {\n            var rangeRes = sliceEventStore(eventStore, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n            return {\n                bg: this.sliceEventRanges(rangeRes.bg, extraArgs),\n                fg: this.sliceEventRanges(rangeRes.fg, extraArgs)\n            };\n        }\n        return {\n            bg: [],\n            fg: []\n        };\n    };\n    Slicer.prototype._sliceInteraction = function(interaction, eventUiBases, dateProfile, nextDayThreshold) {\n        var extraArgs = [];\n        for(var _i = 4; _i < arguments.length; _i++){\n            extraArgs[_i - 4] = arguments[_i];\n        }\n        if (!interaction) {\n            return null;\n        }\n        var rangeRes = sliceEventStore(interaction.mutatedEvents, eventUiBases, computeActiveRange(dateProfile, Boolean(nextDayThreshold)), nextDayThreshold);\n        return {\n            segs: this.sliceEventRanges(rangeRes.fg, extraArgs),\n            affectedInstances: interaction.affectedEvents.instances,\n            isEvent: interaction.isEvent\n        };\n    };\n    Slicer.prototype._sliceDateSpan = function(dateSpan, eventUiBases, context) {\n        var extraArgs = [];\n        for(var _i = 3; _i < arguments.length; _i++){\n            extraArgs[_i - 3] = arguments[_i];\n        }\n        if (!dateSpan) {\n            return [];\n        }\n        var eventRange = fabricateEventRange(dateSpan, eventUiBases, context);\n        var segs = this.sliceRange.apply(this, tslib.__spreadArray([\n            dateSpan.range\n        ], extraArgs));\n        for(var _a = 0, segs_1 = segs; _a < segs_1.length; _a++){\n            var seg = segs_1[_a];\n            seg.eventRange = eventRange;\n        }\n        return segs;\n    };\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ Slicer.prototype.sliceEventRanges = function(eventRanges, extraArgs) {\n        var segs = [];\n        for(var _i = 0, eventRanges_1 = eventRanges; _i < eventRanges_1.length; _i++){\n            var eventRange = eventRanges_1[_i];\n            segs.push.apply(segs, this.sliceEventRange(eventRange, extraArgs));\n        }\n        return segs;\n    };\n    /*\n    \"complete\" seg means it has component and eventRange\n    */ Slicer.prototype.sliceEventRange = function(eventRange, extraArgs) {\n        var dateRange = eventRange.range;\n        // hack to make multi-day events that are being force-displayed as list-items to take up only one day\n        if (this.forceDayIfListItem && eventRange.ui.display === \"list-item\") {\n            dateRange = {\n                start: dateRange.start,\n                end: addDays(dateRange.start, 1)\n            };\n        }\n        var segs = this.sliceRange.apply(this, tslib.__spreadArray([\n            dateRange\n        ], extraArgs));\n        for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){\n            var seg = segs_2[_i];\n            seg.eventRange = eventRange;\n            seg.isStart = eventRange.isStart && seg.isStart;\n            seg.isEnd = eventRange.isEnd && seg.isEnd;\n        }\n        return segs;\n    };\n    return Slicer;\n}();\n/*\nfor incorporating slotMinTime/slotMaxTime if appropriate\nTODO: should be part of DateProfile!\nTimelineDateProfile already does this btw\n*/ function computeActiveRange(dateProfile, isComponentAllDay) {\n    var range = dateProfile.activeRange;\n    if (isComponentAllDay) {\n        return range;\n    }\n    return {\n        start: addMs(range.start, dateProfile.slotMinTime.milliseconds),\n        end: addMs(range.end, dateProfile.slotMaxTime.milliseconds - 864e5)\n    };\n}\n// high-level segmenting-aware tester functions\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionValid(interaction, dateProfile, context) {\n    var instances = interaction.mutatedEvents.instances;\n    for(var instanceId in instances){\n        if (!rangeContainsRange(dateProfile.validRange, instances[instanceId].range)) {\n            return false;\n        }\n    }\n    return isNewPropsValid({\n        eventDrag: interaction\n    }, context); // HACK: the eventDrag props is used for ALL interactions\n}\nfunction isDateSelectionValid(dateSelection, dateProfile, context) {\n    if (!rangeContainsRange(dateProfile.validRange, dateSelection.range)) {\n        return false;\n    }\n    return isNewPropsValid({\n        dateSelection: dateSelection\n    }, context);\n}\nfunction isNewPropsValid(newProps, context) {\n    var calendarState = context.getCurrentData();\n    var props = tslib.__assign({\n        businessHours: calendarState.businessHours,\n        dateSelection: \"\",\n        eventStore: calendarState.eventStore,\n        eventUiBases: calendarState.eventUiBases,\n        eventSelection: \"\",\n        eventDrag: null,\n        eventResize: null\n    }, newProps);\n    return (context.pluginHooks.isPropsValid || isPropsValid)(props, context);\n}\nfunction isPropsValid(state, context, dateSpanMeta, filterConfig) {\n    if (dateSpanMeta === void 0) {\n        dateSpanMeta = {};\n    }\n    if (state.eventDrag && !isInteractionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    if (state.dateSelection && !isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig)) {\n        return false;\n    }\n    return true;\n}\n// Moving Event Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isInteractionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    var currentState = context.getCurrentData();\n    var interaction = state.eventDrag; // HACK: the eventDrag props is used for ALL interactions\n    var subjectEventStore = interaction.mutatedEvents;\n    var subjectDefs = subjectEventStore.defs;\n    var subjectInstances = subjectEventStore.instances;\n    var subjectConfigs = compileEventUis(subjectDefs, interaction.isEvent ? state.eventUiBases : {\n        \"\": currentState.selectionConfig\n    });\n    if (filterConfig) {\n        subjectConfigs = mapHash(subjectConfigs, filterConfig);\n    }\n    // exclude the subject events. TODO: exclude defs too?\n    var otherEventStore = excludeInstances(state.eventStore, interaction.affectedEvents.instances);\n    var otherDefs = otherEventStore.defs;\n    var otherInstances = otherEventStore.instances;\n    var otherConfigs = compileEventUis(otherDefs, state.eventUiBases);\n    for(var subjectInstanceId in subjectInstances){\n        var subjectInstance = subjectInstances[subjectInstanceId];\n        var subjectRange = subjectInstance.range;\n        var subjectConfig = subjectConfigs[subjectInstance.defId];\n        var subjectDef = subjectDefs[subjectInstance.defId];\n        // constraint\n        if (!allConstraintsPass(subjectConfig.constraints, subjectRange, otherEventStore, state.businessHours, context)) {\n            return false;\n        }\n        // overlap\n        var eventOverlap = context.options.eventOverlap;\n        var eventOverlapFunc = typeof eventOverlap === \"function\" ? eventOverlap : null;\n        for(var otherInstanceId in otherInstances){\n            var otherInstance = otherInstances[otherInstanceId];\n            // intersect! evaluate\n            if (rangesIntersect(subjectRange, otherInstance.range)) {\n                var otherOverlap = otherConfigs[otherInstance.defId].overlap;\n                // consider the other event's overlap. only do this if the subject event is a \"real\" event\n                if (otherOverlap === false && interaction.isEvent) {\n                    return false;\n                }\n                if (subjectConfig.overlap === false) {\n                    return false;\n                }\n                if (eventOverlapFunc && !eventOverlapFunc(new EventApi(context, otherDefs[otherInstance.defId], otherInstance), new EventApi(context, subjectDef, subjectInstance))) {\n                    return false;\n                }\n            }\n        }\n        // allow (a function)\n        var calendarEventStore = currentState.eventStore; // need global-to-calendar, not local to component (splittable)state\n        for(var _i = 0, _a = subjectConfig.allows; _i < _a.length; _i++){\n            var subjectAllow = _a[_i];\n            var subjectDateSpan = tslib.__assign(tslib.__assign({}, dateSpanMeta), {\n                range: subjectInstance.range,\n                allDay: subjectDef.allDay\n            });\n            var origDef = calendarEventStore.defs[subjectDef.defId];\n            var origInstance = calendarEventStore.instances[subjectInstanceId];\n            var eventApi = void 0;\n            if (origDef) {\n                eventApi = new EventApi(context, origDef, origInstance);\n            } else {\n                eventApi = new EventApi(context, subjectDef); // no instance, because had no dates\n            }\n            if (!subjectAllow(buildDateSpanApiWithContext(subjectDateSpan, context), eventApi)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n// Date Selection Validation\n// ------------------------------------------------------------------------------------------------------------------------\nfunction isDateSelectionPropsValid(state, context, dateSpanMeta, filterConfig) {\n    var relevantEventStore = state.eventStore;\n    var relevantDefs = relevantEventStore.defs;\n    var relevantInstances = relevantEventStore.instances;\n    var selection = state.dateSelection;\n    var selectionRange = selection.range;\n    var selectionConfig = context.getCurrentData().selectionConfig;\n    if (filterConfig) {\n        selectionConfig = filterConfig(selectionConfig);\n    }\n    // constraint\n    if (!allConstraintsPass(selectionConfig.constraints, selectionRange, relevantEventStore, state.businessHours, context)) {\n        return false;\n    }\n    // overlap\n    var selectOverlap = context.options.selectOverlap;\n    var selectOverlapFunc = typeof selectOverlap === \"function\" ? selectOverlap : null;\n    for(var relevantInstanceId in relevantInstances){\n        var relevantInstance = relevantInstances[relevantInstanceId];\n        // intersect! evaluate\n        if (rangesIntersect(selectionRange, relevantInstance.range)) {\n            if (selectionConfig.overlap === false) {\n                return false;\n            }\n            if (selectOverlapFunc && !selectOverlapFunc(new EventApi(context, relevantDefs[relevantInstance.defId], relevantInstance), null)) {\n                return false;\n            }\n        }\n    }\n    // allow (a function)\n    for(var _i = 0, _a = selectionConfig.allows; _i < _a.length; _i++){\n        var selectionAllow = _a[_i];\n        var fullDateSpan = tslib.__assign(tslib.__assign({}, dateSpanMeta), selection);\n        if (!selectionAllow(buildDateSpanApiWithContext(fullDateSpan, context), null)) {\n            return false;\n        }\n    }\n    return true;\n}\n// Constraint Utils\n// ------------------------------------------------------------------------------------------------------------------------\nfunction allConstraintsPass(constraints, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    for(var _i = 0, constraints_1 = constraints; _i < constraints_1.length; _i++){\n        var constraint = constraints_1[_i];\n        if (!anyRangesContainRange(constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context), subjectRange)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction constraintToRanges(constraint, subjectRange, otherEventStore, businessHoursUnexpanded, context) {\n    if (constraint === \"businessHours\") {\n        return eventStoreToRanges(expandRecurring(businessHoursUnexpanded, subjectRange, context));\n    }\n    if (typeof constraint === \"string\") {\n        return eventStoreToRanges(filterEventStoreDefs(otherEventStore, function(eventDef) {\n            return eventDef.groupId === constraint;\n        }));\n    }\n    if (typeof constraint === \"object\" && constraint) {\n        return eventStoreToRanges(expandRecurring(constraint, subjectRange, context));\n    }\n    return []; // if it's false\n}\n// TODO: move to event-store file?\nfunction eventStoreToRanges(eventStore) {\n    var instances = eventStore.instances;\n    var ranges = [];\n    for(var instanceId in instances){\n        ranges.push(instances[instanceId].range);\n    }\n    return ranges;\n}\n// TODO: move to geom file?\nfunction anyRangesContainRange(outerRanges, innerRange) {\n    for(var _i = 0, outerRanges_1 = outerRanges; _i < outerRanges_1.length; _i++){\n        var outerRange = outerRanges_1[_i];\n        if (rangeContainsRange(outerRange, innerRange)) {\n            return true;\n        }\n    }\n    return false;\n}\nvar VISIBLE_HIDDEN_RE = /^(visible|hidden)$/;\nvar Scroller = /** @class */ function(_super) {\n    tslib.__extends(Scroller, _super);\n    function Scroller() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleEl = function(el) {\n            _this.el = el;\n            setRef(_this.props.elRef, el);\n        };\n        return _this;\n    }\n    Scroller.prototype.render = function() {\n        var props = this.props;\n        var liquid = props.liquid, liquidIsAbsolute = props.liquidIsAbsolute;\n        var isAbsolute = liquid && liquidIsAbsolute;\n        var className = [\n            \"fc-scroller\"\n        ];\n        if (liquid) {\n            if (liquidIsAbsolute) {\n                className.push(\"fc-scroller-liquid-absolute\");\n            } else {\n                className.push(\"fc-scroller-liquid\");\n            }\n        }\n        return vdom_cjs.createElement(\"div\", {\n            ref: this.handleEl,\n            className: className.join(\" \"),\n            style: {\n                overflowX: props.overflowX,\n                overflowY: props.overflowY,\n                left: isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                right: isAbsolute && -(props.overcomeRight || 0) || \"\",\n                bottom: isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                marginLeft: !isAbsolute && -(props.overcomeLeft || 0) || \"\",\n                marginRight: !isAbsolute && -(props.overcomeRight || 0) || \"\",\n                marginBottom: !isAbsolute && -(props.overcomeBottom || 0) || \"\",\n                maxHeight: props.maxHeight || \"\"\n            }\n        }, props.children);\n    };\n    Scroller.prototype.needsXScrolling = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return false;\n        }\n        // testing scrollWidth>clientWidth is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        var el = this.el;\n        var realClientWidth = this.el.getBoundingClientRect().width - this.getYScrollbarWidth();\n        var children = el.children;\n        for(var i = 0; i < children.length; i += 1){\n            var childEl = children[i];\n            if (childEl.getBoundingClientRect().width > realClientWidth) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Scroller.prototype.needsYScrolling = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return false;\n        }\n        // testing scrollHeight>clientHeight is unreliable cross-browser when pixel heights aren't integers.\n        // much more reliable to see if children are taller than the scroller, even tho doesn't account for\n        // inner-child margins and absolute positioning\n        var el = this.el;\n        var realClientHeight = this.el.getBoundingClientRect().height - this.getXScrollbarWidth();\n        var children = el.children;\n        for(var i = 0; i < children.length; i += 1){\n            var childEl = children[i];\n            if (childEl.getBoundingClientRect().height > realClientHeight) {\n                return true;\n            }\n        }\n        return false;\n    };\n    Scroller.prototype.getXScrollbarWidth = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowX)) {\n            return 0;\n        }\n        return this.el.offsetHeight - this.el.clientHeight; // only works because we guarantee no borders. TODO: add to CSS with important?\n    };\n    Scroller.prototype.getYScrollbarWidth = function() {\n        if (VISIBLE_HIDDEN_RE.test(this.props.overflowY)) {\n            return 0;\n        }\n        return this.el.offsetWidth - this.el.clientWidth; // only works because we guarantee no borders. TODO: add to CSS with important?\n    };\n    return Scroller;\n}(BaseComponent);\n/*\nTODO: somehow infer OtherArgs from masterCallback?\nTODO: infer RefType from masterCallback if provided\n*/ var RefMap = /** @class */ function() {\n    function RefMap(masterCallback) {\n        var _this = this;\n        this.masterCallback = masterCallback;\n        this.currentMap = {};\n        this.depths = {};\n        this.callbackMap = {};\n        this.handleValue = function(val, key) {\n            var _a = _this, depths = _a.depths, currentMap = _a.currentMap;\n            var removed = false;\n            var added = false;\n            if (val !== null) {\n                // for bug... ACTUALLY: can probably do away with this now that callers don't share numeric indices anymore\n                removed = key in currentMap;\n                currentMap[key] = val;\n                depths[key] = (depths[key] || 0) + 1;\n                added = true;\n            } else {\n                depths[key] -= 1;\n                if (!depths[key]) {\n                    delete currentMap[key];\n                    delete _this.callbackMap[key];\n                    removed = true;\n                }\n            }\n            if (_this.masterCallback) {\n                if (removed) {\n                    _this.masterCallback(null, String(key));\n                }\n                if (added) {\n                    _this.masterCallback(val, String(key));\n                }\n            }\n        };\n    }\n    RefMap.prototype.createRef = function(key) {\n        var _this = this;\n        var refCallback = this.callbackMap[key];\n        if (!refCallback) {\n            refCallback = this.callbackMap[key] = function(val) {\n                _this.handleValue(val, String(key));\n            };\n        }\n        return refCallback;\n    };\n    // TODO: check callers that don't care about order. should use getAll instead\n    // NOTE: this method has become less valuable now that we are encouraged to map order by some other index\n    // TODO: provide ONE array-export function, buildArray, which fails on non-numeric indexes. caller can manipulate and \"collect\"\n    RefMap.prototype.collect = function(startIndex, endIndex, step) {\n        return collectFromHash(this.currentMap, startIndex, endIndex, step);\n    };\n    RefMap.prototype.getAll = function() {\n        return hashValuesToArray(this.currentMap);\n    };\n    return RefMap;\n}();\nfunction computeShrinkWidth(chunkEls) {\n    var shrinkCells = findElements(chunkEls, \".fc-scrollgrid-shrink\");\n    var largestWidth = 0;\n    for(var _i = 0, shrinkCells_1 = shrinkCells; _i < shrinkCells_1.length; _i++){\n        var shrinkCell = shrinkCells_1[_i];\n        largestWidth = Math.max(largestWidth, computeSmallestCellWidth(shrinkCell));\n    }\n    return Math.ceil(largestWidth); // <table> elements work best with integers. round up to ensure contents fits\n}\nfunction getSectionHasLiquidHeight(props, sectionConfig) {\n    return props.liquid && sectionConfig.liquid; // does the section do liquid-height? (need to have whole scrollgrid liquid-height as well)\n}\nfunction getAllowYScrolling(props, sectionConfig) {\n    return sectionConfig.maxHeight != null || // if its possible for the height to max out, we might need scrollbars\n    getSectionHasLiquidHeight(props, sectionConfig); // if the section is liquid height, it might condense enough to require scrollbars\n}\n// TODO: ONLY use `arg`. force out internal function to use same API\nfunction renderChunkContent(sectionConfig, chunkConfig, arg, isHeader) {\n    var expandRows = arg.expandRows;\n    var content = typeof chunkConfig.content === \"function\" ? chunkConfig.content(arg) : vdom_cjs.createElement(\"table\", {\n        role: \"presentation\",\n        className: [\n            chunkConfig.tableClassName,\n            sectionConfig.syncRowHeights ? \"fc-scrollgrid-sync-table\" : \"\"\n        ].join(\" \"),\n        style: {\n            minWidth: arg.tableMinWidth,\n            width: arg.clientWidth,\n            height: expandRows ? arg.clientHeight : \"\"\n        }\n    }, arg.tableColGroupNode, vdom_cjs.createElement(isHeader ? \"thead\" : \"tbody\", {\n        role: \"presentation\"\n    }, typeof chunkConfig.rowContent === \"function\" ? chunkConfig.rowContent(arg) : chunkConfig.rowContent));\n    return content;\n}\nfunction isColPropsEqual(cols0, cols1) {\n    return isArraysEqual(cols0, cols1, isPropsEqual);\n}\nfunction renderMicroColGroup(cols, shrinkWidth) {\n    var colNodes = [];\n    /*\n    for ColProps with spans, it would have been great to make a single <col span=\"\">\n    HOWEVER, Chrome was getting messing up distributing the width to <td>/<th> elements with colspans.\n    SOLUTION: making individual <col> elements makes Chrome behave.\n    */ for(var _i = 0, cols_1 = cols; _i < cols_1.length; _i++){\n        var colProps = cols_1[_i];\n        var span = colProps.span || 1;\n        for(var i = 0; i < span; i += 1){\n            colNodes.push(vdom_cjs.createElement(\"col\", {\n                style: {\n                    width: colProps.width === \"shrink\" ? sanitizeShrinkWidth(shrinkWidth) : colProps.width || \"\",\n                    minWidth: colProps.minWidth || \"\"\n                }\n            }));\n        }\n    }\n    return vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n        \"colgroup\",\n        {}\n    ], colNodes));\n}\nfunction sanitizeShrinkWidth(shrinkWidth) {\n    /* why 4? if we do 0, it will kill any border, which are needed for computeSmallestCellWidth\n    4 accounts for 2 2-pixel borders. TODO: better solution? */ return shrinkWidth == null ? 4 : shrinkWidth;\n}\nfunction hasShrinkWidth(cols) {\n    for(var _i = 0, cols_2 = cols; _i < cols_2.length; _i++){\n        var col = cols_2[_i];\n        if (col.width === \"shrink\") {\n            return true;\n        }\n    }\n    return false;\n}\nfunction getScrollGridClassNames(liquid, context) {\n    var classNames = [\n        \"fc-scrollgrid\",\n        context.theme.getClass(\"table\")\n    ];\n    if (liquid) {\n        classNames.push(\"fc-scrollgrid-liquid\");\n    }\n    return classNames;\n}\nfunction getSectionClassNames(sectionConfig, wholeTableVGrow) {\n    var classNames = [\n        \"fc-scrollgrid-section\",\n        \"fc-scrollgrid-section-\" + sectionConfig.type,\n        sectionConfig.className\n    ];\n    if (wholeTableVGrow && sectionConfig.liquid && sectionConfig.maxHeight == null) {\n        classNames.push(\"fc-scrollgrid-section-liquid\");\n    }\n    if (sectionConfig.isSticky) {\n        classNames.push(\"fc-scrollgrid-section-sticky\");\n    }\n    return classNames;\n}\nfunction renderScrollShim(arg) {\n    return vdom_cjs.createElement(\"div\", {\n        className: \"fc-scrollgrid-sticky-shim\",\n        style: {\n            width: arg.clientWidth,\n            minWidth: arg.tableMinWidth\n        }\n    });\n}\nfunction getStickyHeaderDates(options) {\n    var stickyHeaderDates = options.stickyHeaderDates;\n    if (stickyHeaderDates == null || stickyHeaderDates === \"auto\") {\n        stickyHeaderDates = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyHeaderDates;\n}\nfunction getStickyFooterScrollbar(options) {\n    var stickyFooterScrollbar = options.stickyFooterScrollbar;\n    if (stickyFooterScrollbar == null || stickyFooterScrollbar === \"auto\") {\n        stickyFooterScrollbar = options.height === \"auto\" || options.viewHeight === \"auto\";\n    }\n    return stickyFooterScrollbar;\n}\nvar SimpleScrollGrid = /** @class */ function(_super) {\n    tslib.__extends(SimpleScrollGrid, _super);\n    function SimpleScrollGrid() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.processCols = memoize(function(a) {\n            return a;\n        }, isColPropsEqual); // so we get same `cols` props every time\n        // yucky to memoize VNodes, but much more efficient for consumers\n        _this.renderMicroColGroup = memoize(renderMicroColGroup);\n        _this.scrollerRefs = new RefMap();\n        _this.scrollerElRefs = new RefMap(_this._handleScrollerEl.bind(_this));\n        _this.state = {\n            shrinkWidth: null,\n            forceYScrollbars: false,\n            scrollerClientWidths: {},\n            scrollerClientHeights: {}\n        };\n        // TODO: can do a really simple print-view. dont need to join rows\n        _this.handleSizing = function() {\n            _this.safeSetState(tslib.__assign({\n                shrinkWidth: _this.computeShrinkWidth()\n            }, _this.computeScrollerDims()));\n        };\n        return _this;\n    }\n    SimpleScrollGrid.prototype.render = function() {\n        var _a = this, props = _a.props, state = _a.state, context = _a.context;\n        var sectionConfigs = props.sections || [];\n        var cols = this.processCols(props.cols);\n        var microColGroupNode = this.renderMicroColGroup(cols, state.shrinkWidth);\n        var classNames = getScrollGridClassNames(props.liquid, context);\n        if (props.collapsibleWidth) {\n            classNames.push(\"fc-scrollgrid-collapsible\");\n        }\n        // TODO: make DRY\n        var configCnt = sectionConfigs.length;\n        var configI = 0;\n        var currentConfig;\n        var headSectionNodes = [];\n        var bodySectionNodes = [];\n        var footSectionNodes = [];\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"header\"){\n            headSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"body\"){\n            bodySectionNodes.push(this.renderSection(currentConfig, microColGroupNode, false));\n            configI += 1;\n        }\n        while(configI < configCnt && (currentConfig = sectionConfigs[configI]).type === \"footer\"){\n            footSectionNodes.push(this.renderSection(currentConfig, microColGroupNode, true));\n            configI += 1;\n        }\n        // firefox bug: when setting height on table and there is a thead or tfoot,\n        // the necessary height:100% on the liquid-height body section forces the *whole* table to be taller. (bug #5524)\n        // use getCanVGrowWithinCell as a way to detect table-stupid firefox.\n        // if so, use a simpler dom structure, jam everything into a lone tbody.\n        var isBuggy = !getCanVGrowWithinCell();\n        var roleAttrs = {\n            role: \"rowgroup\"\n        };\n        return vdom_cjs.createElement(\"table\", {\n            role: \"grid\",\n            className: classNames.join(\" \"),\n            style: {\n                height: props.height\n            }\n        }, Boolean(!isBuggy && headSectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"thead\",\n            roleAttrs\n        ], headSectionNodes)), Boolean(!isBuggy && bodySectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"tbody\",\n            roleAttrs\n        ], bodySectionNodes)), Boolean(!isBuggy && footSectionNodes.length) && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray([\n            \"tfoot\",\n            roleAttrs\n        ], footSectionNodes)), isBuggy && vdom_cjs.createElement.apply(void 0, tslib.__spreadArray(tslib.__spreadArray(tslib.__spreadArray([\n            \"tbody\",\n            roleAttrs\n        ], headSectionNodes), bodySectionNodes), footSectionNodes)));\n    };\n    SimpleScrollGrid.prototype.renderSection = function(sectionConfig, microColGroupNode, isHeader) {\n        if (\"outerContent\" in sectionConfig) {\n            return vdom_cjs.createElement(vdom_cjs.Fragment, {\n                key: sectionConfig.key\n            }, sectionConfig.outerContent);\n        }\n        return vdom_cjs.createElement(\"tr\", {\n            key: sectionConfig.key,\n            role: \"presentation\",\n            className: getSectionClassNames(sectionConfig, this.props.liquid).join(\" \")\n        }, this.renderChunkTd(sectionConfig, microColGroupNode, sectionConfig.chunk, isHeader));\n    };\n    SimpleScrollGrid.prototype.renderChunkTd = function(sectionConfig, microColGroupNode, chunkConfig, isHeader) {\n        if (\"outerContent\" in chunkConfig) {\n            return chunkConfig.outerContent;\n        }\n        var props = this.props;\n        var _a = this.state, forceYScrollbars = _a.forceYScrollbars, scrollerClientWidths = _a.scrollerClientWidths, scrollerClientHeights = _a.scrollerClientHeights;\n        var needsYScrolling = getAllowYScrolling(props, sectionConfig); // TODO: do lazily. do in section config?\n        var isLiquid = getSectionHasLiquidHeight(props, sectionConfig);\n        // for `!props.liquid` - is WHOLE scrollgrid natural height?\n        // TODO: do same thing in advanced scrollgrid? prolly not b/c always has horizontal scrollbars\n        var overflowY = !props.liquid ? \"visible\" : forceYScrollbars ? \"scroll\" : !needsYScrolling ? \"hidden\" : \"auto\";\n        var sectionKey = sectionConfig.key;\n        var content = renderChunkContent(sectionConfig, chunkConfig, {\n            tableColGroupNode: microColGroupNode,\n            tableMinWidth: \"\",\n            clientWidth: !props.collapsibleWidth && scrollerClientWidths[sectionKey] !== undefined ? scrollerClientWidths[sectionKey] : null,\n            clientHeight: scrollerClientHeights[sectionKey] !== undefined ? scrollerClientHeights[sectionKey] : null,\n            expandRows: sectionConfig.expandRows,\n            syncRowHeights: false,\n            rowSyncHeights: [],\n            reportRowHeightChange: function() {}\n        }, isHeader);\n        return vdom_cjs.createElement(isHeader ? \"th\" : \"td\", {\n            ref: chunkConfig.elRef,\n            role: \"presentation\"\n        }, vdom_cjs.createElement(\"div\", {\n            className: \"fc-scroller-harness\" + (isLiquid ? \" fc-scroller-harness-liquid\" : \"\")\n        }, vdom_cjs.createElement(Scroller, {\n            ref: this.scrollerRefs.createRef(sectionKey),\n            elRef: this.scrollerElRefs.createRef(sectionKey),\n            overflowY: overflowY,\n            overflowX: !props.liquid ? \"visible\" : \"hidden\" /* natural height? */ ,\n            maxHeight: sectionConfig.maxHeight,\n            liquid: isLiquid,\n            liquidIsAbsolute: true\n        }, content)));\n    };\n    SimpleScrollGrid.prototype._handleScrollerEl = function(scrollerEl, key) {\n        var section = getSectionByKey(this.props.sections, key);\n        if (section) {\n            setRef(section.chunk.scrollerElRef, scrollerEl);\n        }\n    };\n    SimpleScrollGrid.prototype.componentDidMount = function() {\n        this.handleSizing();\n        this.context.addResizeHandler(this.handleSizing);\n    };\n    SimpleScrollGrid.prototype.componentDidUpdate = function() {\n        // TODO: need better solution when state contains non-sizing things\n        this.handleSizing();\n    };\n    SimpleScrollGrid.prototype.componentWillUnmount = function() {\n        this.context.removeResizeHandler(this.handleSizing);\n    };\n    SimpleScrollGrid.prototype.computeShrinkWidth = function() {\n        return hasShrinkWidth(this.props.cols) ? computeShrinkWidth(this.scrollerElRefs.getAll()) : 0;\n    };\n    SimpleScrollGrid.prototype.computeScrollerDims = function() {\n        var scrollbarWidth = getScrollbarWidths();\n        var _a = this, scrollerRefs = _a.scrollerRefs, scrollerElRefs = _a.scrollerElRefs;\n        var forceYScrollbars = false;\n        var scrollerClientWidths = {};\n        var scrollerClientHeights = {};\n        for(var sectionKey in scrollerRefs.currentMap){\n            var scroller = scrollerRefs.currentMap[sectionKey];\n            if (scroller && scroller.needsYScrolling()) {\n                forceYScrollbars = true;\n                break;\n            }\n        }\n        for(var _i = 0, _b = this.props.sections; _i < _b.length; _i++){\n            var section = _b[_i];\n            var sectionKey = section.key;\n            var scrollerEl = scrollerElRefs.currentMap[sectionKey];\n            if (scrollerEl) {\n                var harnessEl = scrollerEl.parentNode; // TODO: weird way to get this. need harness b/c doesn't include table borders\n                scrollerClientWidths[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().width - (forceYScrollbars ? scrollbarWidth.y // use global because scroller might not have scrollbars yet but will need them in future\n                 : 0));\n                scrollerClientHeights[sectionKey] = Math.floor(harnessEl.getBoundingClientRect().height);\n            }\n        }\n        return {\n            forceYScrollbars: forceYScrollbars,\n            scrollerClientWidths: scrollerClientWidths,\n            scrollerClientHeights: scrollerClientHeights\n        };\n    };\n    return SimpleScrollGrid;\n}(BaseComponent);\nSimpleScrollGrid.addStateEquality({\n    scrollerClientWidths: isPropsEqual,\n    scrollerClientHeights: isPropsEqual\n});\nfunction getSectionByKey(sections, key) {\n    for(var _i = 0, sections_1 = sections; _i < sections_1.length; _i++){\n        var section = sections_1[_i];\n        if (section.key === key) {\n            return section;\n        }\n    }\n    return null;\n}\nvar EventRoot = /** @class */ function(_super) {\n    tslib.__extends(EventRoot, _super);\n    function EventRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.elRef = vdom_cjs.createRef();\n        return _this;\n    }\n    EventRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var seg = props.seg;\n        var eventRange = seg.eventRange;\n        var ui = eventRange.ui;\n        var hookProps = {\n            event: new EventApi(context, eventRange.def, eventRange.instance),\n            view: context.viewApi,\n            timeText: props.timeText,\n            textColor: ui.textColor,\n            backgroundColor: ui.backgroundColor,\n            borderColor: ui.borderColor,\n            isDraggable: !props.disableDragging && computeSegDraggable(seg, context),\n            isStartResizable: !props.disableResizing && computeSegStartResizable(seg, context),\n            isEndResizable: !props.disableResizing && computeSegEndResizable(seg),\n            isMirror: Boolean(props.isDragging || props.isResizing || props.isDateSelecting),\n            isStart: Boolean(seg.isStart),\n            isEnd: Boolean(seg.isEnd),\n            isPast: Boolean(props.isPast),\n            isFuture: Boolean(props.isFuture),\n            isToday: Boolean(props.isToday),\n            isSelected: Boolean(props.isSelected),\n            isDragging: Boolean(props.isDragging),\n            isResizing: Boolean(props.isResizing)\n        };\n        var standardClassNames = getEventClassNames(hookProps).concat(ui.classNames);\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.eventClassNames,\n            content: options.eventContent,\n            defaultContent: props.defaultContent,\n            didMount: options.eventDidMount,\n            willUnmount: options.eventWillUnmount,\n            elRef: this.elRef\n        }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n            return props.children(rootElRef, standardClassNames.concat(customClassNames), innerElRef, innerContent, hookProps);\n        });\n    };\n    EventRoot.prototype.componentDidMount = function() {\n        setElSeg(this.elRef.current, this.props.seg);\n    };\n    /*\n    need to re-assign seg to the element if seg changes, even if the element is the same\n    */ EventRoot.prototype.componentDidUpdate = function(prevProps) {\n        var seg = this.props.seg;\n        if (seg !== prevProps.seg) {\n            setElSeg(this.elRef.current, seg);\n        }\n    };\n    return EventRoot;\n}(BaseComponent);\n// should not be a purecomponent\nvar StandardEvent = /** @class */ function(_super) {\n    tslib.__extends(StandardEvent, _super);\n    function StandardEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    StandardEvent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var seg = props.seg;\n        var timeFormat = context.options.eventTimeFormat || props.defaultTimeFormat;\n        var timeText = buildSegTimeText(seg, timeFormat, context, props.defaultDisplayEventTime, props.defaultDisplayEventEnd);\n        return vdom_cjs.createElement(EventRoot, {\n            seg: seg,\n            timeText: timeText,\n            disableDragging: props.disableDragging,\n            disableResizing: props.disableResizing,\n            defaultContent: props.defaultContent || renderInnerContent$1,\n            isDragging: props.isDragging,\n            isResizing: props.isResizing,\n            isDateSelecting: props.isDateSelecting,\n            isSelected: props.isSelected,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday\n        }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {\n            return vdom_cjs.createElement(\"a\", tslib.__assign({\n                className: props.extraClassNames.concat(classNames).join(\" \"),\n                style: {\n                    borderColor: hookProps.borderColor,\n                    backgroundColor: hookProps.backgroundColor\n                },\n                ref: rootElRef\n            }, getSegAnchorAttrs(seg, context)), vdom_cjs.createElement(\"div\", {\n                className: \"fc-event-main\",\n                ref: innerElRef,\n                style: {\n                    color: hookProps.textColor\n                }\n            }, innerContent), hookProps.isStartResizable && vdom_cjs.createElement(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-start\"\n            }), hookProps.isEndResizable && vdom_cjs.createElement(\"div\", {\n                className: \"fc-event-resizer fc-event-resizer-end\"\n            }));\n        });\n    };\n    return StandardEvent;\n}(BaseComponent);\nfunction renderInnerContent$1(innerProps) {\n    return vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-main-frame\"\n    }, innerProps.timeText && vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-title-container\"\n    }, vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-title fc-sticky\"\n    }, innerProps.event.title || vdom_cjs.createElement(vdom_cjs.Fragment, null, \"\\xa0\"))));\n}\nvar NowIndicatorRoot = function(props) {\n    return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n        var options = context.options;\n        var hookProps = {\n            isAxis: props.isAxis,\n            date: context.dateEnv.toDate(props.date),\n            view: context.viewApi\n        };\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.nowIndicatorClassNames,\n            content: options.nowIndicatorContent,\n            didMount: options.nowIndicatorDidMount,\n            willUnmount: options.nowIndicatorWillUnmount\n        }, props.children);\n    });\n};\nvar DAY_NUM_FORMAT = createFormatter({\n    day: \"numeric\"\n});\nvar DayCellContent = /** @class */ function(_super) {\n    tslib.__extends(DayCellContent, _super);\n    function DayCellContent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    DayCellContent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = refineDayCellHookProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraProps: props.extraHookProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv\n        });\n        return vdom_cjs.createElement(ContentHook, {\n            hookProps: hookProps,\n            content: options.dayCellContent,\n            defaultContent: props.defaultContent\n        }, props.children);\n    };\n    return DayCellContent;\n}(BaseComponent);\nfunction refineDayCellHookProps(raw) {\n    var date = raw.date, dateEnv = raw.dateEnv;\n    var dayMeta = getDateMeta(date, raw.todayRange, null, raw.dateProfile);\n    return tslib.__assign(tslib.__assign(tslib.__assign({\n        date: dateEnv.toDate(date),\n        view: raw.viewApi\n    }, dayMeta), {\n        dayNumberText: raw.showDayNumber ? dateEnv.format(date, DAY_NUM_FORMAT) : \"\"\n    }), raw.extraProps);\n}\nvar DayCellRoot = /** @class */ function(_super) {\n    tslib.__extends(DayCellRoot, _super);\n    function DayCellRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.refineHookProps = memoizeObjArg(refineDayCellHookProps);\n        _this.normalizeClassNames = buildClassNameNormalizer();\n        return _this;\n    }\n    DayCellRoot.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var options = context.options;\n        var hookProps = this.refineHookProps({\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraProps: props.extraHookProps,\n            viewApi: context.viewApi,\n            dateEnv: context.dateEnv\n        });\n        var classNames = getDayClassNames(hookProps, context.theme).concat(hookProps.isDisabled ? [] // don't use custom classNames if disabled\n         : this.normalizeClassNames(options.dayCellClassNames, hookProps));\n        var dataAttrs = hookProps.isDisabled ? {} : {\n            \"data-date\": formatDayString(props.date)\n        };\n        return vdom_cjs.createElement(MountHook, {\n            hookProps: hookProps,\n            didMount: options.dayCellDidMount,\n            willUnmount: options.dayCellWillUnmount,\n            elRef: props.elRef\n        }, function(rootElRef) {\n            return props.children(rootElRef, classNames, dataAttrs, hookProps.isDisabled);\n        });\n    };\n    return DayCellRoot;\n}(BaseComponent);\nfunction renderFill(fillType) {\n    return vdom_cjs.createElement(\"div\", {\n        className: \"fc-\" + fillType\n    });\n}\nvar BgEvent = function(props) {\n    return vdom_cjs.createElement(EventRoot, {\n        defaultContent: renderInnerContent,\n        seg: props.seg /* uselesss i think */ ,\n        timeText: \"\",\n        disableDragging: true,\n        disableResizing: true,\n        isDragging: false,\n        isResizing: false,\n        isDateSelecting: false,\n        isSelected: false,\n        isPast: props.isPast,\n        isFuture: props.isFuture,\n        isToday: props.isToday\n    }, function(rootElRef, classNames, innerElRef, innerContent, hookProps) {\n        return vdom_cjs.createElement(\"div\", {\n            ref: rootElRef,\n            className: [\n                \"fc-bg-event\"\n            ].concat(classNames).join(\" \"),\n            style: {\n                backgroundColor: hookProps.backgroundColor\n            }\n        }, innerContent);\n    });\n};\nfunction renderInnerContent(props) {\n    var title = props.event.title;\n    return title && vdom_cjs.createElement(\"div\", {\n        className: \"fc-event-title\"\n    }, props.event.title);\n}\nvar WeekNumberRoot = function(props) {\n    return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n        var dateEnv = context.dateEnv, options = context.options;\n        var date = props.date;\n        var format = options.weekNumberFormat || props.defaultFormat;\n        var num = dateEnv.computeWeekNumber(date); // TODO: somehow use for formatting as well?\n        var text = dateEnv.format(date, format);\n        var hookProps = {\n            num: num,\n            text: text,\n            date: date\n        };\n        return vdom_cjs.createElement(RenderHook, {\n            hookProps: hookProps,\n            classNames: options.weekNumberClassNames,\n            content: options.weekNumberContent,\n            defaultContent: renderInner,\n            didMount: options.weekNumberDidMount,\n            willUnmount: options.weekNumberWillUnmount\n        }, props.children);\n    });\n};\nfunction renderInner(innerProps) {\n    return innerProps.text;\n}\nvar PADDING_FROM_VIEWPORT = 10;\nvar Popover = /** @class */ function(_super) {\n    tslib.__extends(Popover, _super);\n    function Popover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            titleId: getUniqueDomId()\n        };\n        _this.handleRootEl = function(el) {\n            _this.rootEl = el;\n            if (_this.props.elRef) {\n                setRef(_this.props.elRef, el);\n            }\n        };\n        // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n        _this.handleDocumentMouseDown = function(ev) {\n            // only hide the popover if the click happened outside the popover\n            var target = getEventTargetViaRoot(ev);\n            if (!_this.rootEl.contains(target)) {\n                _this.handleCloseClick();\n            }\n        };\n        _this.handleDocumentKeyDown = function(ev) {\n            if (ev.key === \"Escape\") {\n                _this.handleCloseClick();\n            }\n        };\n        _this.handleCloseClick = function() {\n            var onClose = _this.props.onClose;\n            if (onClose) {\n                onClose();\n            }\n        };\n        return _this;\n    }\n    Popover.prototype.render = function() {\n        var _a = this.context, theme = _a.theme, options = _a.options;\n        var _b = this, props = _b.props, state = _b.state;\n        var classNames = [\n            \"fc-popover\",\n            theme.getClass(\"popover\")\n        ].concat(props.extraClassNames || []);\n        return vdom_cjs.createPortal(vdom_cjs.createElement(\"div\", tslib.__assign({\n            id: props.id,\n            className: classNames.join(\" \"),\n            \"aria-labelledby\": state.titleId\n        }, props.extraAttrs, {\n            ref: this.handleRootEl\n        }), vdom_cjs.createElement(\"div\", {\n            className: \"fc-popover-header \" + theme.getClass(\"popoverHeader\")\n        }, vdom_cjs.createElement(\"span\", {\n            className: \"fc-popover-title\",\n            id: state.titleId\n        }, props.title), vdom_cjs.createElement(\"span\", {\n            className: \"fc-popover-close \" + theme.getIconClass(\"close\"),\n            title: options.closeHint,\n            onClick: this.handleCloseClick\n        })), vdom_cjs.createElement(\"div\", {\n            className: \"fc-popover-body \" + theme.getClass(\"popoverContent\")\n        }, props.children)), props.parentEl);\n    };\n    Popover.prototype.componentDidMount = function() {\n        document.addEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.addEventListener(\"keydown\", this.handleDocumentKeyDown);\n        this.updateSize();\n    };\n    Popover.prototype.componentWillUnmount = function() {\n        document.removeEventListener(\"mousedown\", this.handleDocumentMouseDown);\n        document.removeEventListener(\"keydown\", this.handleDocumentKeyDown);\n    };\n    Popover.prototype.updateSize = function() {\n        var isRtl = this.context.isRtl;\n        var _a = this.props, alignmentEl = _a.alignmentEl, alignGridTop = _a.alignGridTop;\n        var rootEl = this.rootEl;\n        var alignmentRect = computeClippedClientRect(alignmentEl);\n        if (alignmentRect) {\n            var popoverDims = rootEl.getBoundingClientRect();\n            // position relative to viewport\n            var popoverTop = alignGridTop ? elementClosest(alignmentEl, \".fc-scrollgrid\").getBoundingClientRect().top : alignmentRect.top;\n            var popoverLeft = isRtl ? alignmentRect.right - popoverDims.width : alignmentRect.left;\n            // constrain\n            popoverTop = Math.max(popoverTop, PADDING_FROM_VIEWPORT);\n            popoverLeft = Math.min(popoverLeft, document.documentElement.clientWidth - PADDING_FROM_VIEWPORT - popoverDims.width);\n            popoverLeft = Math.max(popoverLeft, PADDING_FROM_VIEWPORT);\n            var origin_1 = rootEl.offsetParent.getBoundingClientRect();\n            applyStyle(rootEl, {\n                top: popoverTop - origin_1.top,\n                left: popoverLeft - origin_1.left\n            });\n        }\n    };\n    return Popover;\n}(BaseComponent);\nvar MorePopover = /** @class */ function(_super) {\n    tslib.__extends(MorePopover, _super);\n    function MorePopover() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (rootEl) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: rootEl,\n                    useEventCenter: false\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        return _this;\n    }\n    MorePopover.prototype.render = function() {\n        var _a = this.context, options = _a.options, dateEnv = _a.dateEnv;\n        var props = this.props;\n        var startDate = props.startDate, todayRange = props.todayRange, dateProfile = props.dateProfile;\n        var title = dateEnv.format(startDate, options.dayPopoverFormat);\n        return vdom_cjs.createElement(DayCellRoot, {\n            date: startDate,\n            dateProfile: dateProfile,\n            todayRange: todayRange,\n            elRef: this.handleRootEl\n        }, function(rootElRef, dayClassNames, dataAttrs) {\n            return vdom_cjs.createElement(Popover, {\n                elRef: rootElRef,\n                id: props.id,\n                title: title,\n                extraClassNames: [\n                    \"fc-more-popover\"\n                ].concat(dayClassNames),\n                extraAttrs: dataAttrs /* TODO: make these time-based when not whole-day? */ ,\n                parentEl: props.parentEl,\n                alignmentEl: props.alignmentEl,\n                alignGridTop: props.alignGridTop,\n                onClose: props.onClose\n            }, vdom_cjs.createElement(DayCellContent, {\n                date: startDate,\n                dateProfile: dateProfile,\n                todayRange: todayRange\n            }, function(innerElRef, innerContent) {\n                return innerContent && vdom_cjs.createElement(\"div\", {\n                    className: \"fc-more-popover-misc\",\n                    ref: innerElRef\n                }, innerContent);\n            }), props.children);\n        });\n    };\n    MorePopover.prototype.queryHit = function(positionLeft, positionTop, elWidth, elHeight) {\n        var _a = this, rootEl = _a.rootEl, props = _a.props;\n        if (positionLeft >= 0 && positionLeft < elWidth && positionTop >= 0 && positionTop < elHeight) {\n            return {\n                dateProfile: props.dateProfile,\n                dateSpan: tslib.__assign({\n                    allDay: true,\n                    range: {\n                        start: props.startDate,\n                        end: props.endDate\n                    }\n                }, props.extraDateSpan),\n                dayEl: rootEl,\n                rect: {\n                    left: 0,\n                    top: 0,\n                    right: elWidth,\n                    bottom: elHeight\n                },\n                layer: 1\n            };\n        }\n        return null;\n    };\n    return MorePopover;\n}(DateComponent);\nvar MoreLinkRoot = /** @class */ function(_super) {\n    tslib.__extends(MoreLinkRoot, _super);\n    function MoreLinkRoot() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.linkElRef = vdom_cjs.createRef();\n        _this.state = {\n            isPopoverOpen: false,\n            popoverId: getUniqueDomId()\n        };\n        _this.handleClick = function(ev) {\n            var _a = _this, props = _a.props, context = _a.context;\n            var moreLinkClick = context.options.moreLinkClick;\n            var date = computeRange(props).start;\n            function buildPublicSeg(seg) {\n                var _a = seg.eventRange, def = _a.def, instance = _a.instance, range = _a.range;\n                return {\n                    event: new EventApi(context, def, instance),\n                    start: context.dateEnv.toDate(range.start),\n                    end: context.dateEnv.toDate(range.end),\n                    isStart: seg.isStart,\n                    isEnd: seg.isEnd\n                };\n            }\n            if (typeof moreLinkClick === \"function\") {\n                moreLinkClick = moreLinkClick({\n                    date: date,\n                    allDay: Boolean(props.allDayDate),\n                    allSegs: props.allSegs.map(buildPublicSeg),\n                    hiddenSegs: props.hiddenSegs.map(buildPublicSeg),\n                    jsEvent: ev,\n                    view: context.viewApi\n                });\n            }\n            if (!moreLinkClick || moreLinkClick === \"popover\") {\n                _this.setState({\n                    isPopoverOpen: true\n                });\n            } else if (typeof moreLinkClick === \"string\") {\n                context.calendarApi.zoomTo(date, moreLinkClick);\n            }\n        };\n        _this.handlePopoverClose = function() {\n            _this.setState({\n                isPopoverOpen: false\n            });\n        };\n        return _this;\n    }\n    MoreLinkRoot.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, state = _a.state;\n        return vdom_cjs.createElement(ViewContextType.Consumer, null, function(context) {\n            var viewApi = context.viewApi, options = context.options, calendarApi = context.calendarApi;\n            var moreLinkText = options.moreLinkText;\n            var moreCnt = props.moreCnt;\n            var range = computeRange(props);\n            var text = typeof moreLinkText === \"function\" // TODO: eventually use formatWithOrdinals\n             ? moreLinkText.call(calendarApi, moreCnt) : \"+\" + moreCnt + \" \" + moreLinkText;\n            var title = formatWithOrdinals(options.moreLinkHint, [\n                moreCnt\n            ], text);\n            var hookProps = {\n                num: moreCnt,\n                shortText: \"+\" + moreCnt,\n                text: text,\n                view: viewApi\n            };\n            return vdom_cjs.createElement(vdom_cjs.Fragment, null, Boolean(props.moreCnt) && vdom_cjs.createElement(RenderHook, {\n                elRef: _this.linkElRef,\n                hookProps: hookProps,\n                classNames: options.moreLinkClassNames,\n                content: options.moreLinkContent,\n                defaultContent: props.defaultContent || renderMoreLinkInner,\n                didMount: options.moreLinkDidMount,\n                willUnmount: options.moreLinkWillUnmount\n            }, function(rootElRef, customClassNames, innerElRef, innerContent) {\n                return props.children(rootElRef, [\n                    \"fc-more-link\"\n                ].concat(customClassNames), innerElRef, innerContent, _this.handleClick, title, state.isPopoverOpen, state.isPopoverOpen ? state.popoverId : \"\");\n            }), state.isPopoverOpen && vdom_cjs.createElement(MorePopover, {\n                id: state.popoverId,\n                startDate: range.start,\n                endDate: range.end,\n                dateProfile: props.dateProfile,\n                todayRange: props.todayRange,\n                extraDateSpan: props.extraDateSpan,\n                parentEl: _this.parentEl,\n                alignmentEl: props.alignmentElRef.current,\n                alignGridTop: props.alignGridTop,\n                onClose: _this.handlePopoverClose\n            }, props.popoverContent()));\n        });\n    };\n    MoreLinkRoot.prototype.componentDidMount = function() {\n        this.updateParentEl();\n    };\n    MoreLinkRoot.prototype.componentDidUpdate = function() {\n        this.updateParentEl();\n    };\n    MoreLinkRoot.prototype.updateParentEl = function() {\n        if (this.linkElRef.current) {\n            this.parentEl = elementClosest(this.linkElRef.current, \".fc-view-harness\");\n        }\n    };\n    return MoreLinkRoot;\n}(BaseComponent);\nfunction renderMoreLinkInner(props) {\n    return props.text;\n}\nfunction computeRange(props) {\n    if (props.allDayDate) {\n        return {\n            start: props.allDayDate,\n            end: addDays(props.allDayDate, 1)\n        };\n    }\n    var hiddenSegs = props.hiddenSegs;\n    return {\n        start: computeEarliestSegStart(hiddenSegs),\n        end: computeLatestSegEnd(hiddenSegs)\n    };\n}\nfunction computeEarliestSegStart(segs) {\n    return segs.reduce(pickEarliestStart).eventRange.range.start;\n}\nfunction pickEarliestStart(seg0, seg1) {\n    return seg0.eventRange.range.start < seg1.eventRange.range.start ? seg0 : seg1;\n}\nfunction computeLatestSegEnd(segs) {\n    return segs.reduce(pickLatestEnd).eventRange.range.end;\n}\nfunction pickLatestEnd(seg0, seg1) {\n    return seg0.eventRange.range.end > seg1.eventRange.range.end ? seg0 : seg1;\n}\n// exports\n// --------------------------------------------------------------------------------------------------\nvar version = \"5.11.3\"; // important to type it, so .d.ts has generic string\nexports.BASE_OPTION_DEFAULTS = BASE_OPTION_DEFAULTS;\nexports.BASE_OPTION_REFINERS = BASE_OPTION_REFINERS;\nexports.BaseComponent = BaseComponent;\nexports.BgEvent = BgEvent;\nexports.CalendarApi = CalendarApi;\nexports.CalendarContent = CalendarContent;\nexports.CalendarDataManager = CalendarDataManager;\nexports.CalendarDataProvider = CalendarDataProvider;\nexports.CalendarRoot = CalendarRoot;\nexports.ContentHook = ContentHook;\nexports.CustomContentRenderContext = CustomContentRenderContext;\nexports.DateComponent = DateComponent;\nexports.DateEnv = DateEnv;\nexports.DateProfileGenerator = DateProfileGenerator;\nexports.DayCellContent = DayCellContent;\nexports.DayCellRoot = DayCellRoot;\nexports.DayHeader = DayHeader;\nexports.DaySeriesModel = DaySeriesModel;\nexports.DayTableModel = DayTableModel;\nexports.DelayedRunner = DelayedRunner;\nexports.ElementDragging = ElementDragging;\nexports.ElementScrollController = ElementScrollController;\nexports.Emitter = Emitter;\nexports.EventApi = EventApi;\nexports.EventRoot = EventRoot;\nexports.EventSourceApi = EventSourceApi;\nexports.Interaction = Interaction;\nexports.MoreLinkRoot = MoreLinkRoot;\nexports.MountHook = MountHook;\nexports.NamedTimeZoneImpl = NamedTimeZoneImpl;\nexports.NowIndicatorRoot = NowIndicatorRoot;\nexports.NowTimer = NowTimer;\nexports.PositionCache = PositionCache;\nexports.RefMap = RefMap;\nexports.RenderHook = RenderHook;\nexports.ScrollController = ScrollController;\nexports.ScrollResponder = ScrollResponder;\nexports.Scroller = Scroller;\nexports.SegHierarchy = SegHierarchy;\nexports.SimpleScrollGrid = SimpleScrollGrid;\nexports.Slicer = Slicer;\nexports.Splitter = Splitter;\nexports.StandardEvent = StandardEvent;\nexports.TableDateCell = TableDateCell;\nexports.TableDowCell = TableDowCell;\nexports.Theme = Theme;\nexports.ViewApi = ViewApi;\nexports.ViewContextType = ViewContextType;\nexports.ViewRoot = ViewRoot;\nexports.WeekNumberRoot = WeekNumberRoot;\nexports.WindowScrollController = WindowScrollController;\nexports.addDays = addDays;\nexports.addDurations = addDurations;\nexports.addMs = addMs;\nexports.addWeeks = addWeeks;\nexports.allowContextMenu = allowContextMenu;\nexports.allowSelection = allowSelection;\nexports.applyMutationToEventStore = applyMutationToEventStore;\nexports.applyStyle = applyStyle;\nexports.applyStyleProp = applyStyleProp;\nexports.asCleanDays = asCleanDays;\nexports.asRoughMinutes = asRoughMinutes;\nexports.asRoughMs = asRoughMs;\nexports.asRoughSeconds = asRoughSeconds;\nexports.binarySearch = binarySearch;\nexports.buildClassNameNormalizer = buildClassNameNormalizer;\nexports.buildEntryKey = buildEntryKey;\nexports.buildEventApis = buildEventApis;\nexports.buildEventRangeKey = buildEventRangeKey;\nexports.buildHashFromArray = buildHashFromArray;\nexports.buildIsoString = buildIsoString;\nexports.buildNavLinkAttrs = buildNavLinkAttrs;\nexports.buildSegCompareObj = buildSegCompareObj;\nexports.buildSegTimeText = buildSegTimeText;\nexports.collectFromHash = collectFromHash;\nexports.combineEventUis = combineEventUis;\nexports.compareByFieldSpec = compareByFieldSpec;\nexports.compareByFieldSpecs = compareByFieldSpecs;\nexports.compareNumbers = compareNumbers;\nexports.compareObjs = compareObjs;\nexports.computeEarliestSegStart = computeEarliestSegStart;\nexports.computeEdges = computeEdges;\nexports.computeFallbackHeaderFormat = computeFallbackHeaderFormat;\nexports.computeHeightAndMargins = computeHeightAndMargins;\nexports.computeInnerRect = computeInnerRect;\nexports.computeRect = computeRect;\nexports.computeSegDraggable = computeSegDraggable;\nexports.computeSegEndResizable = computeSegEndResizable;\nexports.computeSegStartResizable = computeSegStartResizable;\nexports.computeShrinkWidth = computeShrinkWidth;\nexports.computeSmallestCellWidth = computeSmallestCellWidth;\nexports.computeVisibleDayRange = computeVisibleDayRange;\nexports.config = config;\nexports.constrainPoint = constrainPoint;\nexports.createAriaClickAttrs = createAriaClickAttrs;\nexports.createDuration = createDuration;\nexports.createEmptyEventStore = createEmptyEventStore;\nexports.createEventInstance = createEventInstance;\nexports.createEventUi = createEventUi;\nexports.createFormatter = createFormatter;\nexports.createPlugin = createPlugin;\nexports.diffDates = diffDates;\nexports.diffDayAndTime = diffDayAndTime;\nexports.diffDays = diffDays;\nexports.diffPoints = diffPoints;\nexports.diffWeeks = diffWeeks;\nexports.diffWholeDays = diffWholeDays;\nexports.diffWholeWeeks = diffWholeWeeks;\nexports.disableCursor = disableCursor;\nexports.elementClosest = elementClosest;\nexports.elementMatches = elementMatches;\nexports.enableCursor = enableCursor;\nexports.eventTupleToStore = eventTupleToStore;\nexports.filterEventStoreDefs = filterEventStoreDefs;\nexports.filterHash = filterHash;\nexports.findDirectChildren = findDirectChildren;\nexports.findElements = findElements;\nexports.flexibleCompare = flexibleCompare;\nexports.formatDate = formatDate;\nexports.formatDayString = formatDayString;\nexports.formatIsoTimeString = formatIsoTimeString;\nexports.formatRange = formatRange;\nexports.getAllowYScrolling = getAllowYScrolling;\nexports.getCanVGrowWithinCell = getCanVGrowWithinCell;\nexports.getClippingParents = getClippingParents;\nexports.getDateMeta = getDateMeta;\nexports.getDayClassNames = getDayClassNames;\nexports.getDefaultEventEnd = getDefaultEventEnd;\nexports.getElRoot = getElRoot;\nexports.getElSeg = getElSeg;\nexports.getEntrySpanEnd = getEntrySpanEnd;\nexports.getEventClassNames = getEventClassNames;\nexports.getEventTargetViaRoot = getEventTargetViaRoot;\nexports.getIsRtlScrollbarOnLeft = getIsRtlScrollbarOnLeft;\nexports.getRectCenter = getRectCenter;\nexports.getRelevantEvents = getRelevantEvents;\nexports.getScrollGridClassNames = getScrollGridClassNames;\nexports.getScrollbarWidths = getScrollbarWidths;\nexports.getSectionClassNames = getSectionClassNames;\nexports.getSectionHasLiquidHeight = getSectionHasLiquidHeight;\nexports.getSegAnchorAttrs = getSegAnchorAttrs;\nexports.getSegMeta = getSegMeta;\nexports.getSlotClassNames = getSlotClassNames;\nexports.getStickyFooterScrollbar = getStickyFooterScrollbar;\nexports.getStickyHeaderDates = getStickyHeaderDates;\nexports.getUnequalProps = getUnequalProps;\nexports.getUniqueDomId = getUniqueDomId;\nexports.globalLocales = globalLocales;\nexports.globalPlugins = globalPlugins;\nexports.greatestDurationDenominator = greatestDurationDenominator;\nexports.groupIntersectingEntries = groupIntersectingEntries;\nexports.guid = guid;\nexports.hasBgRendering = hasBgRendering;\nexports.hasShrinkWidth = hasShrinkWidth;\nexports.identity = identity;\nexports.interactionSettingsStore = interactionSettingsStore;\nexports.interactionSettingsToStore = interactionSettingsToStore;\nexports.intersectRanges = intersectRanges;\nexports.intersectRects = intersectRects;\nexports.intersectSpans = intersectSpans;\nexports.isArraysEqual = isArraysEqual;\nexports.isColPropsEqual = isColPropsEqual;\nexports.isDateSelectionValid = isDateSelectionValid;\nexports.isDateSpansEqual = isDateSpansEqual;\nexports.isInt = isInt;\nexports.isInteractionValid = isInteractionValid;\nexports.isMultiDayRange = isMultiDayRange;\nexports.isPropsEqual = isPropsEqual;\nexports.isPropsValid = isPropsValid;\nexports.isValidDate = isValidDate;\nexports.joinSpans = joinSpans;\nexports.listenBySelector = listenBySelector;\nexports.mapHash = mapHash;\nexports.memoize = memoize;\nexports.memoizeArraylike = memoizeArraylike;\nexports.memoizeHashlike = memoizeHashlike;\nexports.memoizeObjArg = memoizeObjArg;\nexports.mergeEventStores = mergeEventStores;\nexports.multiplyDuration = multiplyDuration;\nexports.padStart = padStart;\nexports.parseBusinessHours = parseBusinessHours;\nexports.parseClassNames = parseClassNames;\nexports.parseDragMeta = parseDragMeta;\nexports.parseEventDef = parseEventDef;\nexports.parseFieldSpecs = parseFieldSpecs;\nexports.parseMarker = parse;\nexports.pointInsideRect = pointInsideRect;\nexports.preventContextMenu = preventContextMenu;\nexports.preventDefault = preventDefault;\nexports.preventSelection = preventSelection;\nexports.rangeContainsMarker = rangeContainsMarker;\nexports.rangeContainsRange = rangeContainsRange;\nexports.rangesEqual = rangesEqual;\nexports.rangesIntersect = rangesIntersect;\nexports.refineEventDef = refineEventDef;\nexports.refineProps = refineProps;\nexports.removeElement = removeElement;\nexports.removeExact = removeExact;\nexports.renderChunkContent = renderChunkContent;\nexports.renderFill = renderFill;\nexports.renderMicroColGroup = renderMicroColGroup;\nexports.renderScrollShim = renderScrollShim;\nexports.requestJson = requestJson;\nexports.sanitizeShrinkWidth = sanitizeShrinkWidth;\nexports.setElSeg = setElSeg;\nexports.setRef = setRef;\nexports.sliceEventStore = sliceEventStore;\nexports.sliceEvents = sliceEvents;\nexports.sortEventSegs = sortEventSegs;\nexports.startOfDay = startOfDay;\nexports.translateRect = translateRect;\nexports.triggerDateSelect = triggerDateSelect;\nexports.unpromisify = unpromisify;\nexports.version = version;\nexports.whenTransitionDone = whenTransitionDone;\nexports.wholeDivideDurations = wholeDivideDurations;\nObject.keys(vdom_cjs).forEach(function(k) {\n    if (k !== \"default\" && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function() {\n            return vdom_cjs[k];\n        }\n    });\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vbWFpbi5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQSxHQUNBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPLElBQUk7QUFBQyxDQUFDLEVBQUM7O0FBRzdELElBQUlDLFFBQVFDLG1CQUFPQSxDQUFDO0FBQ3BCLElBQUlDLFdBQVdELG1CQUFPQSxDQUFDO0FBRXZCLG9EQUFvRDtBQUNwRCxtQ0FBbUM7QUFDbkMsSUFBSUUsaUJBQWlCLFdBQVcsR0FBSSxXQUFZO0lBQzVDLFNBQVNBLGVBQWVDLE9BQU8sRUFBRUMsbUJBQW1CLEVBQUU7UUFDbEQsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxtQkFBbUIsR0FBR0E7SUFDL0I7SUFDQUYsZUFBZUcsU0FBUyxDQUFDQyxNQUFNLEdBQUcsV0FBWTtRQUMxQyxJQUFJLENBQUNILE9BQU8sQ0FBQ0ksUUFBUSxDQUFDO1lBQ2xCQyxNQUFNO1lBQ05DLFVBQVUsSUFBSSxDQUFDTCxtQkFBbUIsQ0FBQ0ssUUFBUTtRQUMvQztJQUNKO0lBQ0FQLGVBQWVHLFNBQVMsQ0FBQ0ssT0FBTyxHQUFHLFdBQVk7UUFDM0MsSUFBSSxDQUFDUCxPQUFPLENBQUNJLFFBQVEsQ0FBQztZQUNsQkMsTUFBTTtZQUNORyxXQUFXO2dCQUFDLElBQUksQ0FBQ1AsbUJBQW1CLENBQUNLLFFBQVE7YUFBQztZQUM5Q0csV0FBVyxJQUFJO1FBQ25CO0lBQ0o7SUFDQWpCLE9BQU9DLGNBQWMsQ0FBQ00sZUFBZUcsU0FBUyxFQUFFLE1BQU07UUFDbERRLEtBQUssV0FBWTtZQUNiLE9BQU8sSUFBSSxDQUFDVCxtQkFBbUIsQ0FBQ1UsUUFBUTtRQUM1QztRQUNBQyxZQUFZLEtBQUs7UUFDakJDLGNBQWMsSUFBSTtJQUN0QjtJQUNBckIsT0FBT0MsY0FBYyxDQUFDTSxlQUFlRyxTQUFTLEVBQUUsT0FBTztRQUNuRFEsS0FBSyxXQUFZO1lBQ2IsT0FBTyxJQUFJ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MEIsR0FBRzZGO0FBQzdCN0YsNEJBQTRCLEdBQUdpVztBQUMvQm5XLE9BQU84USxJQUFJLENBQUN4USxVQUFVNEYsT0FBTyxDQUFDLFNBQVU2cUUsQ0FBQyxFQUFFO0lBQ3ZDLElBQUlBLE1BQU0sYUFBYSxDQUFDN3dFLFFBQVFtUCxjQUFjLENBQUMwaEUsSUFBSS93RSxPQUFPQyxjQUFjLENBQUNDLFNBQVM2d0UsR0FBRztRQUNqRjN2RSxZQUFZLElBQUk7UUFDaEJGLEtBQUssV0FBWTtZQUNiLE9BQU9aLFFBQVEsQ0FBQ3l3RSxFQUFFO1FBQ3RCO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL3R5cGVzY3JpcHQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvY29tbW9uL21haW4uY2pzLmpzP2QwNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5GdWxsQ2FsZW5kYXIgdjUuMTEuM1xuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuKGMpIDIwMjIgQWRhbSBTaGF3XG4qL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG47XG52YXIgdHNsaWIgPSByZXF1aXJlKCd0c2xpYicpO1xudmFyIHZkb21fY2pzID0gcmVxdWlyZSgnLi92ZG9tLmNqcycpO1xuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xudmFyIEV2ZW50U291cmNlQXBpID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50U291cmNlQXBpKGNvbnRleHQsIGludGVybmFsRXZlbnRTb3VyY2UpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlID0gaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICB9XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRfU09VUkNFJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLnJlZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnRkVUQ0hfRVZFTlRfU09VUkNFUycsXG4gICAgICAgICAgICBzb3VyY2VJZHM6IFt0aGlzLmludGVybmFsRXZlbnRTb3VyY2Uuc291cmNlSWRdLFxuICAgICAgICAgICAgaXNSZWZldGNoOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiaWRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmludGVybmFsRXZlbnRTb3VyY2UucHVibGljSWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRTb3VyY2VBcGkucHJvdG90eXBlLCBcInVybFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJuYWxFdmVudFNvdXJjZS5tZXRhLnVybDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudFNvdXJjZUFwaS5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnRlcm5hbEV2ZW50U291cmNlLm1ldGEuZm9ybWF0OyAvLyBUT0RPOiBiYWQuIG5vdCBndWFyYW50ZWVkXG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gRXZlbnRTb3VyY2VBcGk7XG59KCkpO1xuXG5mdW5jdGlvbiByZW1vdmVFbGVtZW50KGVsKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgfVxufVxuLy8gUXVlcnlpbmdcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGVsZW1lbnRDbG9zZXN0KGVsLCBzZWxlY3Rvcikge1xuICAgIGlmIChlbC5jbG9zZXN0KSB7XG4gICAgICAgIHJldHVybiBlbC5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgICAgLy8gcmVhbGx5IGJhZCBmYWxsYmFjayBmb3IgSUVcbiAgICAgICAgLy8gZnJvbSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9jbG9zZXN0XG4gICAgfVxuICAgIGlmICghZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNvbnRhaW5zKGVsKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZG8ge1xuICAgICAgICBpZiAoZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG4gICAgICAgIGVsID0gKGVsLnBhcmVudEVsZW1lbnQgfHwgZWwucGFyZW50Tm9kZSk7XG4gICAgfSB3aGlsZSAoZWwgIT09IG51bGwgJiYgZWwubm9kZVR5cGUgPT09IDEpO1xuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZWxlbWVudE1hdGNoZXMoZWwsIHNlbGVjdG9yKSB7XG4gICAgdmFyIG1ldGhvZCA9IGVsLm1hdGNoZXMgfHwgZWwubWF0Y2hlc1NlbGVjdG9yIHx8IGVsLm1zTWF0Y2hlc1NlbGVjdG9yO1xuICAgIHJldHVybiBtZXRob2QuY2FsbChlbCwgc2VsZWN0b3IpO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gcmV0dXJucyBhIHJlYWwgYXJyYXkuIGdvb2QgZm9yIG1ldGhvZHMgbGlrZSBmb3JFYWNoXG4vLyBUT0RPOiBhY2NlcHQgdGhlIGRvY3VtZW50XG5mdW5jdGlvbiBmaW5kRWxlbWVudHMoY29udGFpbmVyLCBzZWxlY3Rvcikge1xuICAgIHZhciBjb250YWluZXJzID0gY29udGFpbmVyIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQgPyBbY29udGFpbmVyXSA6IGNvbnRhaW5lcjtcbiAgICB2YXIgYWxsTWF0Y2hlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29udGFpbmVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IGNvbnRhaW5lcnNbaV0ucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWF0Y2hlcy5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgICAgYWxsTWF0Y2hlcy5wdXNoKG1hdGNoZXNbal0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbGxNYXRjaGVzO1xufVxuLy8gYWNjZXB0cyBtdWx0aXBsZSBzdWJqZWN0IGVsc1xuLy8gb25seSBxdWVyaWVzIGRpcmVjdCBjaGlsZCBlbGVtZW50cyAvLyBUT0RPOiByZW5hbWUgdG8gZmluZERpcmVjdENoaWxkcmVuIVxuZnVuY3Rpb24gZmluZERpcmVjdENoaWxkcmVuKHBhcmVudCwgc2VsZWN0b3IpIHtcbiAgICB2YXIgcGFyZW50cyA9IHBhcmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ID8gW3BhcmVudF0gOiBwYXJlbnQ7XG4gICAgdmFyIGFsbE1hdGNoZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBwYXJlbnRzW2ldLmNoaWxkcmVuOyAvLyBvbmx5IGV2ZXIgZWxlbWVudHNcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjaGlsZE5vZGVzLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGROb2RlID0gY2hpbGROb2Rlc1tqXTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0b3IgfHwgZWxlbWVudE1hdGNoZXMoY2hpbGROb2RlLCBzZWxlY3RvcikpIHtcbiAgICAgICAgICAgICAgICBhbGxNYXRjaGVzLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWxsTWF0Y2hlcztcbn1cbi8vIFN0eWxlXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgUElYRUxfUFJPUF9SRSA9IC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tfHdpZHRofGhlaWdodCkkL2k7XG5mdW5jdGlvbiBhcHBseVN0eWxlKGVsLCBwcm9wcykge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgICAgIGFwcGx5U3R5bGVQcm9wKGVsLCBwcm9wTmFtZSwgcHJvcHNbcHJvcE5hbWVdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBseVN0eWxlUHJvcChlbCwgbmFtZSwgdmFsKSB7XG4gICAgaWYgKHZhbCA9PSBudWxsKSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gJyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmIFBJWEVMX1BST1BfUkUudGVzdChuYW1lKSkge1xuICAgICAgICBlbC5zdHlsZVtuYW1lXSA9IHZhbCArIFwicHhcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlW25hbWVdID0gdmFsO1xuICAgIH1cbn1cbi8vIEV2ZW50IEhhbmRsaW5nXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBpZiBpbnRlcmNlcHRpbmcgYnViYmxlZCBldmVudHMgYXQgdGhlIGRvY3VtZW50L3dpbmRvdy9ib2R5IGxldmVsLFxuLy8gYW5kIHdhbnQgdG8gc2VlIG9yaWdpbmF0aW5nIGVsZW1lbnQgKHRoZSAndGFyZ2V0JyksIHVzZSB0aGlzIHV0aWwgaW5zdGVhZFxuLy8gb2YgYGV2LnRhcmdldGAgYmVjYXVzZSBpdCBnb2VzIHdpdGhpbiB3ZWItY29tcG9uZW50IGJvdW5kYXJpZXMuXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldFZpYVJvb3QoZXYpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSBldi5jb21wb3NlZFBhdGgpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGV2KVswXSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZXYudGFyZ2V0O1xufVxuLy8gU2hhZG93IERPTSBjb25zdWRlcmF0aW9uc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gZ2V0RWxSb290KGVsKSB7XG4gICAgcmV0dXJuIGVsLmdldFJvb3ROb2RlID8gZWwuZ2V0Um9vdE5vZGUoKSA6IGRvY3VtZW50O1xufVxuLy8gVW5pcXVlIElEIGZvciBET00gYXR0cmlidXRlXG52YXIgZ3VpZCQxID0gMDtcbmZ1bmN0aW9uIGdldFVuaXF1ZURvbUlkKCkge1xuICAgIGd1aWQkMSArPSAxO1xuICAgIHJldHVybiAnZmMtZG9tLScgKyBndWlkJDE7XG59XG5cbi8vIFN0b3BzIGEgbW91c2UvdG91Y2ggZXZlbnQgZnJvbSBkb2luZyBpdCdzIG5hdGl2ZSBicm93c2VyIGFjdGlvblxuZnVuY3Rpb24gcHJldmVudERlZmF1bHQoZXYpIHtcbiAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xufVxuLy8gRXZlbnQgRGVsZWdhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGREZWxlZ2F0aW9uSGFuZGxlcihzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIG1hdGNoZWRDaGlsZCA9IGVsZW1lbnRDbG9zZXN0KGV2LnRhcmdldCwgc2VsZWN0b3IpO1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBoYW5kbGVyLmNhbGwobWF0Y2hlZENoaWxkLCBldiwgbWF0Y2hlZENoaWxkKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgZXZlbnRUeXBlLCBzZWxlY3RvciwgaGFuZGxlcikge1xuICAgIHZhciBhdHRhY2hlZEhhbmRsZXIgPSBidWlsZERlbGVnYXRpb25IYW5kbGVyKHNlbGVjdG9yLCBoYW5kbGVyKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGF0dGFjaGVkSGFuZGxlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBhdHRhY2hlZEhhbmRsZXIpO1xuICAgIH07XG59XG5mdW5jdGlvbiBsaXN0ZW5Ub0hvdmVyQnlTZWxlY3Rvcihjb250YWluZXIsIHNlbGVjdG9yLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VMZWF2ZSkge1xuICAgIHZhciBjdXJyZW50TWF0Y2hlZENoaWxkO1xuICAgIHJldHVybiBsaXN0ZW5CeVNlbGVjdG9yKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHNlbGVjdG9yLCBmdW5jdGlvbiAobW91c2VPdmVyRXYsIG1hdGNoZWRDaGlsZCkge1xuICAgICAgICBpZiAobWF0Y2hlZENoaWxkICE9PSBjdXJyZW50TWF0Y2hlZENoaWxkKSB7XG4gICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbWF0Y2hlZENoaWxkO1xuICAgICAgICAgICAgb25Nb3VzZUVudGVyKG1vdXNlT3ZlckV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgdmFyIHJlYWxPbk1vdXNlTGVhdmVfMSA9IGZ1bmN0aW9uIChtb3VzZUxlYXZlRXYpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWF0Y2hlZENoaWxkID0gbnVsbDtcbiAgICAgICAgICAgICAgICBvbk1vdXNlTGVhdmUobW91c2VMZWF2ZUV2LCBtYXRjaGVkQ2hpbGQpO1xuICAgICAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBsaXN0ZW4gdG8gdGhlIG5leHQgbW91c2VsZWF2ZSwgYW5kIHRoZW4gdW5hdHRhY2hcbiAgICAgICAgICAgIG1hdGNoZWRDaGlsZC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgcmVhbE9uTW91c2VMZWF2ZV8xKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuLy8gQW5pbWF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgdHJhbnNpdGlvbkV2ZW50TmFtZXMgPSBbXG4gICAgJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxuICAgICdvdHJhbnNpdGlvbmVuZCcsXG4gICAgJ29UcmFuc2l0aW9uRW5kJyxcbiAgICAnbXNUcmFuc2l0aW9uRW5kJyxcbiAgICAndHJhbnNpdGlvbmVuZCcsXG5dO1xuLy8gdHJpZ2dlcmVkIG9ubHkgd2hlbiB0aGUgbmV4dCBzaW5nbGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZpbmlzaGVzXG5mdW5jdGlvbiB3aGVuVHJhbnNpdGlvbkRvbmUoZWwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHJlYWxDYWxsYmFjayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICBjYWxsYmFjayhldik7XG4gICAgICAgIHRyYW5zaXRpb25FdmVudE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHJlYWxDYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdHJhbnNpdGlvbkV2ZW50TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCByZWFsQ2FsbGJhY2spOyAvLyBjcm9zcy1icm93c2VyIHdheSB0byBkZXRlcm1pbmUgd2hlbiB0aGUgdHJhbnNpdGlvbiBmaW5pc2hlc1xuICAgIH0pO1xufVxuLy8gQVJJQSB3b3JrYXJvdW5kc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gY3JlYXRlQXJpYUNsaWNrQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih7IG9uQ2xpY2s6IGhhbmRsZXIgfSwgY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikpO1xufVxuZnVuY3Rpb24gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoaGFuZGxlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRhYkluZGV4OiAwLFxuICAgICAgICBvbktleURvd246IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgaWYgKGV2LmtleSA9PT0gJ0VudGVyJyB8fCBldi5rZXkgPT09ICcgJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZXIoZXYpO1xuICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHNwYWNlLCBkb24ndCBzY3JvbGwgZG93biBwYWdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxudmFyIGd1aWROdW1iZXIgPSAwO1xuZnVuY3Rpb24gZ3VpZCgpIHtcbiAgICBndWlkTnVtYmVyICs9IDE7XG4gICAgcmV0dXJuIFN0cmluZyhndWlkTnVtYmVyKTtcbn1cbi8qIEZ1bGxDYWxlbmRhci1zcGVjaWZpYyBET00gVXRpbGl0aWVzXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIE1ha2UgdGhlIG1vdXNlIGN1cnNvciBleHByZXNzIHRoYXQgYW4gZXZlbnQgaXMgbm90IGFsbG93ZWQgaW4gdGhlIGN1cnJlbnQgYXJlYVxuZnVuY3Rpb24gZGlzYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vLyBSZXR1cm5zIHRoZSBtb3VzZSBjdXJzb3IgdG8gaXRzIG9yaWdpbmFsIGxvb2tcbmZ1bmN0aW9uIGVuYWJsZUN1cnNvcigpIHtcbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2ZjLW5vdC1hbGxvd2VkJyk7XG59XG4vKiBTZWxlY3Rpb25cbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcHJldmVudFNlbGVjdGlvbihlbCkge1xuICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2ZjLXVuc2VsZWN0YWJsZScpO1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdHN0YXJ0JywgcHJldmVudERlZmF1bHQpO1xufVxuZnVuY3Rpb24gYWxsb3dTZWxlY3Rpb24oZWwpIHtcbiAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdmYy11bnNlbGVjdGFibGUnKTtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdzZWxlY3RzdGFydCcsIHByZXZlbnREZWZhdWx0KTtcbn1cbi8qIENvbnRleHQgTWVudVxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwcmV2ZW50Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIGFsbG93Q29udGV4dE1lbnUoZWwpIHtcbiAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHByZXZlbnREZWZhdWx0KTtcbn1cbmZ1bmN0aW9uIHBhcnNlRmllbGRTcGVjcyhpbnB1dCkge1xuICAgIHZhciBzcGVjcyA9IFtdO1xuICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgdG9rZW47XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdG9rZW5zID0gW2lucHV0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgdG9rZW5zID0gaW5wdXQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHRva2VuLmNoYXJBdCgwKSA9PT0gJy0nID9cbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbi5zdWJzdHJpbmcoMSksIG9yZGVyOiAtMSB9IDpcbiAgICAgICAgICAgICAgICB7IGZpZWxkOiB0b2tlbiwgb3JkZXI6IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHRva2VuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzcGVjcy5wdXNoKHsgZnVuYzogdG9rZW4gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwZWNzO1xufVxuZnVuY3Rpb24gY29tcGFyZUJ5RmllbGRTcGVjcyhvYmowLCBvYmoxLCBmaWVsZFNwZWNzKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGNtcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmllbGRTcGVjcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBjbXAgPSBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjc1tpXSk7XG4gICAgICAgIGlmIChjbXApIHtcbiAgICAgICAgICAgIHJldHVybiBjbXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wYXJlQnlGaWVsZFNwZWMob2JqMCwgb2JqMSwgZmllbGRTcGVjKSB7XG4gICAgaWYgKGZpZWxkU3BlYy5mdW5jKSB7XG4gICAgICAgIHJldHVybiBmaWVsZFNwZWMuZnVuYyhvYmowLCBvYmoxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZsZXhpYmxlQ29tcGFyZShvYmowW2ZpZWxkU3BlYy5maWVsZF0sIG9iajFbZmllbGRTcGVjLmZpZWxkXSlcbiAgICAgICAgKiAoZmllbGRTcGVjLm9yZGVyIHx8IDEpO1xufVxuZnVuY3Rpb24gZmxleGlibGVDb21wYXJlKGEsIGIpIHtcbiAgICBpZiAoIWEgJiYgIWIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGlmIChiID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBiID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gU3RyaW5nKGEpLmxvY2FsZUNvbXBhcmUoU3RyaW5nKGIpKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgLSBiO1xufVxuLyogU3RyaW5nIFV0aWxpdGllc1xuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBwYWRTdGFydCh2YWwsIGxlbikge1xuICAgIHZhciBzID0gU3RyaW5nKHZhbCk7XG4gICAgcmV0dXJuICcwMDAnLnN1YnN0cigwLCBsZW4gLSBzLmxlbmd0aCkgKyBzO1xufVxuZnVuY3Rpb24gZm9ybWF0V2l0aE9yZGluYWxzKGZvcm1hdHRlciwgYXJncywgZmFsbGJhY2tUZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ3N0cmluZycpIHsgLy8gbm9uLWJsYW5rIHN0cmluZ1xuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoZnVuY3Rpb24gKHN0ciwgYXJnLCBpbmRleCkgeyByZXR1cm4gKHN0ci5yZXBsYWNlKCckJyArIGluZGV4LCBhcmcgfHwgJycpKTsgfSwgZm9ybWF0dGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrVGV4dDtcbn1cbi8qIE51bWJlciBVdGlsaXRpZXNcbi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICAgIHJldHVybiBhIC0gYjtcbn1cbmZ1bmN0aW9uIGlzSW50KG4pIHtcbiAgICByZXR1cm4gbiAlIDEgPT09IDA7XG59XG4vKiBGQy1zcGVjaWZpYyBET00gZGltZW5zaW9uIHN0dWZmXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChjZWxsRWwpIHtcbiAgICB2YXIgYWxsV2lkdGhFbCA9IGNlbGxFbC5xdWVyeVNlbGVjdG9yKCcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmstZnJhbWUnKTtcbiAgICB2YXIgY29udGVudFdpZHRoRWwgPSBjZWxsRWwucXVlcnlTZWxlY3RvcignLmZjLXNjcm9sbGdyaWQtc2hyaW5rLWN1c2hpb24nKTtcbiAgICBpZiAoIWFsbFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1mcmFtZSBjbGFzc05hbWUnKTsgLy8gVE9ETzogdXNlIGNvbnN0XG4gICAgfVxuICAgIGlmICghY29udGVudFdpZHRoRWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkcyBmYy1zY3JvbGxncmlkLXNocmluay1jdXNoaW9uIGNsYXNzTmFtZScpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC0gYWxsV2lkdGhFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCArIC8vIHRoZSBjZWxsIHBhZGRpbmcrYm9yZGVyXG4gICAgICAgIGNvbnRlbnRXaWR0aEVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xufVxuXG52YXIgREFZX0lEUyA9IFsnc3VuJywgJ21vbicsICd0dWUnLCAnd2VkJywgJ3RodScsICdmcmknLCAnc2F0J107XG4vLyBBZGRpbmdcbmZ1bmN0aW9uIGFkZFdlZWtzKG0sIG4pIHtcbiAgICB2YXIgYSA9IGRhdGVUb1V0Y0FycmF5KG0pO1xuICAgIGFbMl0gKz0gbiAqIDc7XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkRGF5cyhtLCBuKSB7XG4gICAgdmFyIGEgPSBkYXRlVG9VdGNBcnJheShtKTtcbiAgICBhWzJdICs9IG47XG4gICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKGEpO1xufVxuZnVuY3Rpb24gYWRkTXMobSwgbikge1xuICAgIHZhciBhID0gZGF0ZVRvVXRjQXJyYXkobSk7XG4gICAgYVs2XSArPSBuO1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhKTtcbn1cbi8vIERpZmZpbmcgKGFsbCByZXR1cm4gZmxvYXRzKVxuLy8gVE9ETzogd2h5IG5vdCB1c2UgcmFuZ2VzP1xuZnVuY3Rpb24gZGlmZldlZWtzKG0wLCBtMSkge1xuICAgIHJldHVybiBkaWZmRGF5cyhtMCwgbTEpIC8gNztcbn1cbmZ1bmN0aW9uIGRpZmZEYXlzKG0wLCBtMSkge1xuICAgIHJldHVybiAobTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpKSAvICgxMDAwICogNjAgKiA2MCAqIDI0KTtcbn1cbmZ1bmN0aW9uIGRpZmZIb3VycyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAoMTAwMCAqIDYwICogNjApO1xufVxuZnVuY3Rpb24gZGlmZk1pbnV0ZXMobTAsIG0xKSB7XG4gICAgcmV0dXJuIChtMS52YWx1ZU9mKCkgLSBtMC52YWx1ZU9mKCkpIC8gKDEwMDAgKiA2MCk7XG59XG5mdW5jdGlvbiBkaWZmU2Vjb25kcyhtMCwgbTEpIHtcbiAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyAxMDAwO1xufVxuZnVuY3Rpb24gZGlmZkRheUFuZFRpbWUobTAsIG0xKSB7XG4gICAgdmFyIG0wZGF5ID0gc3RhcnRPZkRheShtMCk7XG4gICAgdmFyIG0xZGF5ID0gc3RhcnRPZkRheShtMSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IDAsXG4gICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgZGF5czogTWF0aC5yb3VuZChkaWZmRGF5cyhtMGRheSwgbTFkYXkpKSxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAobTEudmFsdWVPZigpIC0gbTFkYXkudmFsdWVPZigpKSAtIChtMC52YWx1ZU9mKCkgLSBtMGRheS52YWx1ZU9mKCkpLFxuICAgIH07XG59XG4vLyBEaWZmaW5nIFdob2xlIFVuaXRzXG5mdW5jdGlvbiBkaWZmV2hvbGVXZWVrcyhtMCwgbTEpIHtcbiAgICB2YXIgZCA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICBpZiAoZCAhPT0gbnVsbCAmJiBkICUgNyA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZCAvIDc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZGlmZldob2xlRGF5cyhtMCwgbTEpIHtcbiAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZGlmZkRheXMobTAsIG0xKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gU3RhcnQtT2ZcbmZ1bmN0aW9uIHN0YXJ0T2ZEYXkobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZIb3VyKG0pIHtcbiAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoW1xuICAgICAgICBtLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIG0uZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgbS5nZXRVVENEYXRlKCksXG4gICAgICAgIG0uZ2V0VVRDSG91cnMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZNaW51dGUobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICBdKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T2ZTZWNvbmQobSkge1xuICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShbXG4gICAgICAgIG0uZ2V0VVRDRnVsbFllYXIoKSxcbiAgICAgICAgbS5nZXRVVENNb250aCgpLFxuICAgICAgICBtLmdldFVUQ0RhdGUoKSxcbiAgICAgICAgbS5nZXRVVENIb3VycygpLFxuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSxcbiAgICAgICAgbS5nZXRVVENTZWNvbmRzKCksXG4gICAgXSk7XG59XG4vLyBXZWVrIENvbXB1dGF0aW9uXG5mdW5jdGlvbiB3ZWVrT2ZZZWFyKG1hcmtlciwgZG93LCBkb3kpIHtcbiAgICB2YXIgeSA9IG1hcmtlci5nZXRVVENGdWxsWWVhcigpO1xuICAgIHZhciB3ID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSwgZG93LCBkb3kpO1xuICAgIGlmICh3IDwgMSkge1xuICAgICAgICByZXR1cm4gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSAtIDEsIGRvdywgZG95KTtcbiAgICB9XG4gICAgdmFyIG5leHRXID0gd2Vla09mR2l2ZW5ZZWFyKG1hcmtlciwgeSArIDEsIGRvdywgZG95KTtcbiAgICBpZiAobmV4dFcgPj0gMSkge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4odywgbmV4dFcpO1xuICAgIH1cbiAgICByZXR1cm4gdztcbn1cbmZ1bmN0aW9uIHdlZWtPZkdpdmVuWWVhcihtYXJrZXIsIHllYXIsIGRvdywgZG95KSB7XG4gICAgdmFyIGZpcnN0V2Vla1N0YXJ0ID0gYXJyYXlUb1V0Y0RhdGUoW3llYXIsIDAsIDEgKyBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpXSk7XG4gICAgdmFyIGRheVN0YXJ0ID0gc3RhcnRPZkRheShtYXJrZXIpO1xuICAgIHZhciBkYXlzID0gTWF0aC5yb3VuZChkaWZmRGF5cyhmaXJzdFdlZWtTdGFydCwgZGF5U3RhcnQpKTtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihkYXlzIC8gNykgKyAxOyAvLyB6ZXJvLWluZGV4ZWRcbn1cbi8vIHN0YXJ0LW9mLWZpcnN0LXdlZWsgLSBzdGFydC1vZi15ZWFyXG5mdW5jdGlvbiBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpIHtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSAtLSB3aGljaCBqYW51YXJ5IGlzIGFsd2F5cyBpbiB0aGUgZmlyc3Qgd2VlayAoNCBmb3IgaXNvLCAxIGZvciBvdGhlcilcbiAgICB2YXIgZndkID0gNyArIGRvdyAtIGRveTtcbiAgICAvLyBmaXJzdC13ZWVrIGRheSBsb2NhbCB3ZWVrZGF5IC0tIHdoaWNoIGxvY2FsIHdlZWtkYXkgaXMgZndkXG4gICAgdmFyIGZ3ZGx3ID0gKDcgKyBhcnJheVRvVXRjRGF0ZShbeWVhciwgMCwgZndkXSkuZ2V0VVRDRGF5KCkgLSBkb3cpICUgNztcbiAgICByZXR1cm4gLWZ3ZGx3ICsgZndkIC0gMTtcbn1cbi8vIEFycmF5IENvbnZlcnNpb25cbmZ1bmN0aW9uIGRhdGVUb0xvY2FsQXJyYXkoZGF0ZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIGRhdGUuZ2V0RnVsbFllYXIoKSxcbiAgICAgICAgZGF0ZS5nZXRNb250aCgpLFxuICAgICAgICBkYXRlLmdldERhdGUoKSxcbiAgICAgICAgZGF0ZS5nZXRIb3VycygpLFxuICAgICAgICBkYXRlLmdldE1pbnV0ZXMoKSxcbiAgICAgICAgZGF0ZS5nZXRTZWNvbmRzKCksXG4gICAgICAgIGRhdGUuZ2V0TWlsbGlzZWNvbmRzKCksXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGFycmF5VG9Mb2NhbERhdGUoYSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShhWzBdLCBhWzFdIHx8IDAsIGFbMl0gPT0gbnVsbCA/IDEgOiBhWzJdLCAvLyBkYXkgb2YgbW9udGhcbiAgICBhWzNdIHx8IDAsIGFbNF0gfHwgMCwgYVs1XSB8fCAwKTtcbn1cbmZ1bmN0aW9uIGRhdGVUb1V0Y0FycmF5KGRhdGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICBkYXRlLmdldFVUQ0Z1bGxZZWFyKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDTW9udGgoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENEYXRlKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDSG91cnMoKSxcbiAgICAgICAgZGF0ZS5nZXRVVENNaW51dGVzKCksXG4gICAgICAgIGRhdGUuZ2V0VVRDU2Vjb25kcygpLFxuICAgICAgICBkYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICAgIF07XG59XG5mdW5jdGlvbiBhcnJheVRvVXRjRGF0ZShhKSB7XG4gICAgLy8gYWNjb3JkaW5nIHRvIHdlYiBzdGFuZGFyZHMgKGFuZCBTYWZhcmkpLCBhIG1vbnRoIGluZGV4IGlzIHJlcXVpcmVkLlxuICAgIC8vIG1hc3NhZ2UgaWYgb25seSBnaXZlbiBhIHllYXIuXG4gICAgaWYgKGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGEgPSBhLmNvbmNhdChbMF0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkoRGF0ZSwgYSkpO1xufVxuLy8gT3RoZXIgVXRpbHNcbmZ1bmN0aW9uIGlzVmFsaWREYXRlKG0pIHtcbiAgICByZXR1cm4gIWlzTmFOKG0udmFsdWVPZigpKTtcbn1cbmZ1bmN0aW9uIHRpbWVBc01zKG0pIHtcbiAgICByZXR1cm4gbS5nZXRVVENIb3VycygpICogMTAwMCAqIDYwICogNjAgK1xuICAgICAgICBtLmdldFVUQ01pbnV0ZXMoKSAqIDEwMDAgKiA2MCArXG4gICAgICAgIG0uZ2V0VVRDU2Vjb25kcygpICogMTAwMCArXG4gICAgICAgIG0uZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmSWQsIHJhbmdlLCBmb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFuY2VJZDogZ3VpZCgpLFxuICAgICAgICBkZWZJZDogZGVmSWQsXG4gICAgICAgIHJhbmdlOiByYW5nZSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IGZvcmNlZFN0YXJ0VHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkU3RhcnRUem8sXG4gICAgICAgIGZvcmNlZEVuZFR6bzogZm9yY2VkRW5kVHpvID09IG51bGwgPyBudWxsIDogZm9yY2VkRW5kVHpvLFxuICAgIH07XG59XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4vLyBNZXJnZXMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBpbnRvIGEgc2luZ2xlIG9iamVjdC5cbi8vIFRoZSBzZWNvbmQgYXJndW1lbnQgYWxsb3dzIGZvciBhbiBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB3aG8ncyBvYmplY3QgdmFsdWVzIHdpbGwgYmUgbWVyZ2VkIHRvZ2V0aGVyLlxuZnVuY3Rpb24gbWVyZ2VQcm9wcyhwcm9wT2JqcywgY29tcGxleFByb3BzTWFwKSB7XG4gICAgdmFyIGRlc3QgPSB7fTtcbiAgICBpZiAoY29tcGxleFByb3BzTWFwKSB7XG4gICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiBjb21wbGV4UHJvcHNNYXApIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV4T2JqcyA9IFtdO1xuICAgICAgICAgICAgLy8gY29sbGVjdCB0aGUgdHJhaWxpbmcgb2JqZWN0IHZhbHVlcywgc3RvcHBpbmcgd2hlbiBhIG5vbi1vYmplY3QgaXMgZGlzY292ZXJlZFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHByb3BPYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IHByb3BPYmpzW2ldW25hbWVfMV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCkgeyAvLyBub24tbnVsbCBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgY29tcGxleE9ianMudW5zaGlmdCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBkZXN0W25hbWVfMV0gPSB2YWw7IC8vIGlmIHRoZXJlIHdlcmUgbm8gb2JqZWN0cywgdGhpcyB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgdGhlIHRyYWlsaW5nIHZhbHVlcyB3ZXJlIG9iamVjdHMsIHVzZSB0aGUgbWVyZ2VkIHZhbHVlXG4gICAgICAgICAgICBpZiAoY29tcGxleE9ianMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZGVzdFtuYW1lXzFdID0gbWVyZ2VQcm9wcyhjb21wbGV4T2Jqcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29weSB2YWx1ZXMgaW50byB0aGUgZGVzdGluYXRpb24sIGdvaW5nIGZyb20gbGFzdCB0byBmaXJzdFxuICAgIGZvciAodmFyIGkgPSBwcm9wT2Jqcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICB2YXIgcHJvcHMgPSBwcm9wT2Jqc1tpXTtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8yIGluIHByb3BzKSB7XG4gICAgICAgICAgICBpZiAoIShuYW1lXzIgaW4gZGVzdCkpIHsgLy8gaWYgYWxyZWFkeSBhc3NpZ25lZCBieSBwcmV2aW91cyBwcm9wcyBvciBjb21wbGV4IHByb3BzLCBkb24ndCByZWFzc2lnblxuICAgICAgICAgICAgICAgIGRlc3RbbmFtZV8yXSA9IHByb3BzW25hbWVfMl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG59XG5mdW5jdGlvbiBmaWx0ZXJIYXNoKGhhc2gsIGZ1bmMpIHtcbiAgICB2YXIgZmlsdGVyZWQgPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBpZiAoZnVuYyhoYXNoW2tleV0sIGtleSkpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tleV0gPSBoYXNoW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuZnVuY3Rpb24gbWFwSGFzaChoYXNoLCBmdW5jKSB7XG4gICAgdmFyIG5ld0hhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFzaCkge1xuICAgICAgICBuZXdIYXNoW2tleV0gPSBmdW5jKGhhc2hba2V5XSwga2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0hhc2g7XG59XG5mdW5jdGlvbiBhcnJheVRvSGFzaChhKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFfMSA9IGE7IF9pIDwgYV8xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXRlbSA9IGFfMVtfaV07XG4gICAgICAgIGhhc2hbaXRlbV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn1cbmZ1bmN0aW9uIGJ1aWxkSGFzaEZyb21BcnJheShhLCBmdW5jKSB7XG4gICAgdmFyIGhhc2ggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHR1cGxlID0gZnVuYyhhW2ldLCBpKTtcbiAgICAgICAgaGFzaFt0dXBsZVswXV0gPSB0dXBsZVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBoYXNoVmFsdWVzVG9BcnJheShvYmopIHtcbiAgICB2YXIgYSA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgYS5wdXNoKG9ialtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBpc1Byb3BzRXF1YWwob2JqMCwgb2JqMSkge1xuICAgIGlmIChvYmowID09PSBvYmoxKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqMCkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmowLCBrZXkpKSB7XG4gICAgICAgICAgICBpZiAoIShrZXkgaW4gb2JqMSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIG9iajEpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqMSwga2V5KSkge1xuICAgICAgICAgICAgaWYgKG9iajBba2V5XSAhPT0gb2JqMVtrZXldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZ2V0VW5lcXVhbFByb3BzKG9iajAsIG9iajEpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmowKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajAsIGtleSkpIHtcbiAgICAgICAgICAgIGlmICghKGtleSBpbiBvYmoxKSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGtleSBpbiBvYmoxKSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iajEsIGtleSkpIHtcbiAgICAgICAgICAgIGlmIChvYmowW2tleV0gIT09IG9iajFba2V5XSkge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuZnVuY3Rpb24gY29tcGFyZU9ianMob2xkUHJvcHMsIG5ld1Byb3BzLCBlcXVhbGl0eUZ1bmNzKSB7XG4gICAgaWYgKGVxdWFsaXR5RnVuY3MgPT09IHZvaWQgMCkgeyBlcXVhbGl0eUZ1bmNzID0ge307IH1cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gbmV3UHJvcHMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBvbGRQcm9wcyAmJiBpc09ialZhbHNFcXVhbChvbGRQcm9wc1trZXldLCBuZXdQcm9wc1trZXldLCBlcXVhbGl0eUZ1bmNzW2tleV0pKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGNoZWNrIGZvciBwcm9wcyB0aGF0IHdlcmUgb21pdHRlZCBpbiB0aGUgbmV3XG4gICAgZm9yICh2YXIga2V5IGluIG9sZFByb3BzKSB7XG4gICAgICAgIGlmICghKGtleSBpbiBuZXdQcm9wcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qXG5hc3N1bWVkIFwidHJ1ZVwiIGVxdWFsaXR5IGZvciBoYW5kbGVyIG5hbWVzIGxpa2UgXCJvblJlY2VpdmVTb21ldGhpbmdcIlxuKi9cbmZ1bmN0aW9uIGlzT2JqVmFsc0VxdWFsKHZhbDAsIHZhbDEsIGNvbXBhcmF0b3IpIHtcbiAgICBpZiAodmFsMCA9PT0gdmFsMSB8fCBjb21wYXJhdG9yID09PSB0cnVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gY29tcGFyYXRvcih2YWwwLCB2YWwxKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY29sbGVjdEZyb21IYXNoKGhhc2gsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKSB7XG4gICAgaWYgKHN0YXJ0SW5kZXggPT09IHZvaWQgMCkgeyBzdGFydEluZGV4ID0gMDsgfVxuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHsgc3RlcCA9IDE7IH1cbiAgICB2YXIgcmVzID0gW107XG4gICAgaWYgKGVuZEluZGV4ID09IG51bGwpIHtcbiAgICAgICAgZW5kSW5kZXggPSBPYmplY3Qua2V5cyhoYXNoKS5sZW5ndGg7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSBzdGFydEluZGV4OyBpIDwgZW5kSW5kZXg7IGkgKz0gc3RlcCkge1xuICAgICAgICB2YXIgdmFsID0gaGFzaFtpXTtcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7IC8vIHdpbGwgZGlzcmVnYXJkIHVuZGVmaW5lZCBmb3Igc3BhcnNlIGFycmF5c1xuICAgICAgICAgICAgcmVzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG5mdW5jdGlvbiBwYXJzZVJlY3VycmluZyhyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBkYXRlRW52LCByZWN1cnJpbmdUeXBlcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjdXJyaW5nVHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9IHJlY3VycmluZ1R5cGVzW2ldLnBhcnNlKHJlZmluZWQsIGRhdGVFbnYpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB2YXIgYWxsRGF5ID0gcmVmaW5lZC5hbGxEYXk7XG4gICAgICAgICAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxEYXkgPSBkZWZhdWx0QWxsRGF5O1xuICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbGxEYXkgPSBwYXJzZWQuYWxsRGF5R3Vlc3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbGxEYXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsRGF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFsbERheTogYWxsRGF5LFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBwYXJzZWQuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZURhdGE6IHBhcnNlZC50eXBlRGF0YSxcbiAgICAgICAgICAgICAgICB0eXBlSWQ6IGksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZXhwYW5kUmVjdXJyaW5nKGV2ZW50U3RvcmUsIGZyYW1pbmdSYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBwbHVnaW5Ib29rcyA9IGNvbnRleHQucGx1Z2luSG9va3MsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIC8vIHJlbW92ZSBleGlzdGluZyByZWN1cnJpbmcgaW5zdGFuY2VzXG4gICAgLy8gVE9ETzogYmFkLiBhbHdheXMgZXhwYW5kIGV2ZW50cyBhcyBhIHNlY29uZCBzdGVwXG4gICAgaW5zdGFuY2VzID0gZmlsdGVySGFzaChpbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gIWRlZnNbaW5zdGFuY2UuZGVmSWRdLnJlY3VycmluZ0RlZjsgfSk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSBkZWYucmVjdXJyaW5nRGVmLmR1cmF0aW9uO1xuICAgICAgICAgICAgaWYgKCFkdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gZGVmLmFsbERheSA/XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnRzID0gZXhwYW5kUmVjdXJyaW5nUmFuZ2VzKGRlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcGx1Z2luSG9va3MucmVjdXJyaW5nVHlwZXMpO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzdGFydHNfMSA9IHN0YXJ0czsgX2kgPCBzdGFydHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnQgPSBzdGFydHNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRXZlbnRJbnN0YW5jZShkZWZJZCwge1xuICAgICAgICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoc3RhcnQsIGR1cmF0aW9uKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuLypcbkV2ZW50IE1VU1QgaGF2ZSBhIHJlY3VycmluZ0RlZlxuKi9cbmZ1bmN0aW9uIGV4cGFuZFJlY3VycmluZ1JhbmdlcyhldmVudERlZiwgZHVyYXRpb24sIGZyYW1pbmdSYW5nZSwgZGF0ZUVudiwgcmVjdXJyaW5nVHlwZXMpIHtcbiAgICB2YXIgdHlwZURlZiA9IHJlY3VycmluZ1R5cGVzW2V2ZW50RGVmLnJlY3VycmluZ0RlZi50eXBlSWRdO1xuICAgIHZhciBtYXJrZXJzID0gdHlwZURlZi5leHBhbmQoZXZlbnREZWYucmVjdXJyaW5nRGVmLnR5cGVEYXRhLCB7XG4gICAgICAgIHN0YXJ0OiBkYXRlRW52LnN1YnRyYWN0KGZyYW1pbmdSYW5nZS5zdGFydCwgZHVyYXRpb24pLFxuICAgICAgICBlbmQ6IGZyYW1pbmdSYW5nZS5lbmQsXG4gICAgfSwgZGF0ZUVudik7XG4gICAgLy8gdGhlIHJlY3VycmVuY2UgcGx1Z2lucyBkb24ndCBndWFyYW50ZWUgdGhhdCBhbGwtZGF5IGV2ZW50cyBhcmUgc3RhcnQtb2YtZGF5LCBzbyB3ZSBoYXZlIHRvXG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBtYXJrZXJzID0gbWFya2Vycy5tYXAoc3RhcnRPZkRheSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrZXJzO1xufVxuXG52YXIgSU5URVJOQUxfVU5JVFMgPSBbJ3llYXJzJywgJ21vbnRocycsICdkYXlzJywgJ21pbGxpc2Vjb25kcyddO1xudmFyIFBBUlNFX1JFID0gL14oLT8pKD86KFxcZCspXFwuKT8oXFxkKyk6KFxcZFxcZCkoPzo6KFxcZFxcZCkoPzpcXC4oXFxkXFxkXFxkKSk/KT8vO1xuLy8gUGFyc2luZyBhbmQgQ3JlYXRpb25cbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uKGlucHV0LCB1bml0KSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoaW5wdXQpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gcGFyc2VPYmplY3QoKF9hID0ge30sIF9hW3VuaXQgfHwgJ21pbGxpc2Vjb25kcyddID0gaW5wdXQsIF9hKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VTdHJpbmcocykge1xuICAgIHZhciBtID0gUEFSU0VfUkUuZXhlYyhzKTtcbiAgICBpZiAobSkge1xuICAgICAgICB2YXIgc2lnbiA9IG1bMV0gPyAtMSA6IDE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogMCxcbiAgICAgICAgICAgIG1vbnRoczogMCxcbiAgICAgICAgICAgIGRheXM6IHNpZ24gKiAobVsyXSA/IHBhcnNlSW50KG1bMl0sIDEwKSA6IDApLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzOiBzaWduICogKChtWzNdID8gcGFyc2VJbnQobVszXSwgMTApIDogMCkgKiA2MCAqIDYwICogMTAwMCArIC8vIGhvdXJzXG4gICAgICAgICAgICAgICAgKG1bNF0gPyBwYXJzZUludChtWzRdLCAxMCkgOiAwKSAqIDYwICogMTAwMCArIC8vIG1pbnV0ZXNcbiAgICAgICAgICAgICAgICAobVs1XSA/IHBhcnNlSW50KG1bNV0sIDEwKSA6IDApICogMTAwMCArIC8vIHNlY29uZHNcbiAgICAgICAgICAgICAgICAobVs2XSA/IHBhcnNlSW50KG1bNl0sIDEwKSA6IDApIC8vIG1zXG4gICAgICAgICAgICApLFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHBhcnNlT2JqZWN0KG9iaikge1xuICAgIHZhciBkdXJhdGlvbiA9IHtcbiAgICAgICAgeWVhcnM6IG9iai55ZWFycyB8fCBvYmoueWVhciB8fCAwLFxuICAgICAgICBtb250aHM6IG9iai5tb250aHMgfHwgb2JqLm1vbnRoIHx8IDAsXG4gICAgICAgIGRheXM6IG9iai5kYXlzIHx8IG9iai5kYXkgfHwgMCxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiAob2JqLmhvdXJzIHx8IG9iai5ob3VyIHx8IDApICogNjAgKiA2MCAqIDEwMDAgKyAvLyBob3Vyc1xuICAgICAgICAgICAgKG9iai5taW51dGVzIHx8IG9iai5taW51dGUgfHwgMCkgKiA2MCAqIDEwMDAgKyAvLyBtaW51dGVzXG4gICAgICAgICAgICAob2JqLnNlY29uZHMgfHwgb2JqLnNlY29uZCB8fCAwKSAqIDEwMDAgKyAvLyBzZWNvbmRzXG4gICAgICAgICAgICAob2JqLm1pbGxpc2Vjb25kcyB8fCBvYmoubWlsbGlzZWNvbmQgfHwgb2JqLm1zIHx8IDApLCAvLyBtc1xuICAgIH07XG4gICAgdmFyIHdlZWtzID0gb2JqLndlZWtzIHx8IG9iai53ZWVrO1xuICAgIGlmICh3ZWVrcykge1xuICAgICAgICBkdXJhdGlvbi5kYXlzICs9IHdlZWtzICogNztcbiAgICAgICAgZHVyYXRpb24uc3BlY2lmaWVkV2Vla3MgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb247XG59XG4vLyBFcXVhbGl0eVxuZnVuY3Rpb24gZHVyYXRpb25zRXF1YWwoZDAsIGQxKSB7XG4gICAgcmV0dXJuIGQwLnllYXJzID09PSBkMS55ZWFycyAmJlxuICAgICAgICBkMC5tb250aHMgPT09IGQxLm1vbnRocyAmJlxuICAgICAgICBkMC5kYXlzID09PSBkMS5kYXlzICYmXG4gICAgICAgIGQwLm1pbGxpc2Vjb25kcyA9PT0gZDEubWlsbGlzZWNvbmRzO1xufVxuZnVuY3Rpb24gYXNDbGVhbkRheXMoZHVyKSB7XG4gICAgaWYgKCFkdXIueWVhcnMgJiYgIWR1ci5tb250aHMgJiYgIWR1ci5taWxsaXNlY29uZHMpIHtcbiAgICAgICAgcmV0dXJuIGR1ci5kYXlzO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbi8vIFNpbXBsZSBNYXRoXG5mdW5jdGlvbiBhZGREdXJhdGlvbnMoZDAsIGQxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeWVhcnM6IGQwLnllYXJzICsgZDEueWVhcnMsXG4gICAgICAgIG1vbnRoczogZDAubW9udGhzICsgZDEubW9udGhzLFxuICAgICAgICBkYXlzOiBkMC5kYXlzICsgZDEuZGF5cyxcbiAgICAgICAgbWlsbGlzZWNvbmRzOiBkMC5taWxsaXNlY29uZHMgKyBkMS5taWxsaXNlY29uZHMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN1YnRyYWN0RHVyYXRpb25zKGQxLCBkMCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHllYXJzOiBkMS55ZWFycyAtIGQwLnllYXJzLFxuICAgICAgICBtb250aHM6IGQxLm1vbnRocyAtIGQwLm1vbnRocyxcbiAgICAgICAgZGF5czogZDEuZGF5cyAtIGQwLmRheXMsXG4gICAgICAgIG1pbGxpc2Vjb25kczogZDEubWlsbGlzZWNvbmRzIC0gZDAubWlsbGlzZWNvbmRzLFxuICAgIH07XG59XG5mdW5jdGlvbiBtdWx0aXBseUR1cmF0aW9uKGQsIG4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB5ZWFyczogZC55ZWFycyAqIG4sXG4gICAgICAgIG1vbnRoczogZC5tb250aHMgKiBuLFxuICAgICAgICBkYXlzOiBkLmRheXMgKiBuLFxuICAgICAgICBtaWxsaXNlY29uZHM6IGQubWlsbGlzZWNvbmRzICogbixcbiAgICB9O1xufVxuLy8gQ29udmVyc2lvbnNcbi8vIFwiUm91Z2hcIiBiZWNhdXNlIHRoZXkgYXJlIGJhc2VkIG9uIGF2ZXJhZ2UtY2FzZSBHcmVnb3JpYW4gbW9udGhzL3llYXJzXG5mdW5jdGlvbiBhc1JvdWdoWWVhcnMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hEYXlzKGR1cikgLyAzNjU7XG59XG5mdW5jdGlvbiBhc1JvdWdoTW9udGhzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoRGF5cyhkdXIpIC8gMzA7XG59XG5mdW5jdGlvbiBhc1JvdWdoRGF5cyhkdXIpIHtcbiAgICByZXR1cm4gYXNSb3VnaE1zKGR1cikgLyA4NjRlNTtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNaW51dGVzKGR1cikge1xuICAgIHJldHVybiBhc1JvdWdoTXMoZHVyKSAvICgxMDAwICogNjApO1xufVxuZnVuY3Rpb24gYXNSb3VnaFNlY29uZHMoZHVyKSB7XG4gICAgcmV0dXJuIGFzUm91Z2hNcyhkdXIpIC8gMTAwMDtcbn1cbmZ1bmN0aW9uIGFzUm91Z2hNcyhkdXIpIHtcbiAgICByZXR1cm4gZHVyLnllYXJzICogKDM2NSAqIDg2NGU1KSArXG4gICAgICAgIGR1ci5tb250aHMgKiAoMzAgKiA4NjRlNSkgK1xuICAgICAgICBkdXIuZGF5cyAqIDg2NGU1ICtcbiAgICAgICAgZHVyLm1pbGxpc2Vjb25kcztcbn1cbi8vIEFkdmFuY2VkIE1hdGhcbmZ1bmN0aW9uIHdob2xlRGl2aWRlRHVyYXRpb25zKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB2YXIgcmVzID0gbnVsbDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IElOVEVSTkFMX1VOSVRTLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciB1bml0ID0gSU5URVJOQUxfVU5JVFNbaV07XG4gICAgICAgIGlmIChkZW5vbWluYXRvclt1bml0XSkge1xuICAgICAgICAgICAgdmFyIGxvY2FsUmVzID0gbnVtZXJhdG9yW3VuaXRdIC8gZGVub21pbmF0b3JbdW5pdF07XG4gICAgICAgICAgICBpZiAoIWlzSW50KGxvY2FsUmVzKSB8fCAocmVzICE9PSBudWxsICYmIHJlcyAhPT0gbG9jYWxSZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMgPSBsb2NhbFJlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChudW1lcmF0b3JbdW5pdF0pIHtcbiAgICAgICAgICAgIC8vIG5lZWRzIHRvIGRpdmlkZSBieSBzb21ldGhpbmcgYnV0IGNhbid0IVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXIpIHtcbiAgICB2YXIgbXMgPSBkdXIubWlsbGlzZWNvbmRzO1xuICAgIGlmIChtcykge1xuICAgICAgICBpZiAobXMgJSAxMDAwICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbXMgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3NlY29uZCcsIHZhbHVlOiBtcyAvIDEwMDAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMgJSAoMTAwMCAqIDYwICogNjApICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCkgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG1zIC8gKDEwMDAgKiA2MCAqIDYwKSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChkdXIuZGF5cykge1xuICAgICAgICBpZiAoZHVyLnNwZWNpZmllZFdlZWtzICYmIGR1ci5kYXlzICUgNyA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3dlZWsnLCB2YWx1ZTogZHVyLmRheXMgLyA3IH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBkdXIuZGF5cyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLm1vbnRocykge1xuICAgICAgICByZXR1cm4geyB1bml0OiAnbW9udGgnLCB2YWx1ZTogZHVyLm1vbnRocyB9O1xuICAgIH1cbiAgICBpZiAoZHVyLnllYXJzKSB7XG4gICAgICAgIHJldHVybiB7IHVuaXQ6ICd5ZWFyJywgdmFsdWU6IGR1ci55ZWFycyB9O1xuICAgIH1cbiAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogMCB9O1xufVxuXG4vLyB0aW1lWm9uZU9mZnNldCBpcyBpbiBtaW51dGVzXG5mdW5jdGlvbiBidWlsZElzb1N0cmluZyhtYXJrZXIsIHRpbWVab25lT2Zmc2V0LCBzdHJpcFplcm9UaW1lKSB7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUgPT09IHZvaWQgMCkgeyBzdHJpcFplcm9UaW1lID0gZmFsc2U7IH1cbiAgICB2YXIgcyA9IG1hcmtlci50b0lTT1N0cmluZygpO1xuICAgIHMgPSBzLnJlcGxhY2UoJy4wMDAnLCAnJyk7XG4gICAgaWYgKHN0cmlwWmVyb1RpbWUpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnVDAwOjAwOjAwWicsICcnKTtcbiAgICB9XG4gICAgaWYgKHMubGVuZ3RoID4gMTApIHsgLy8gdGltZSBwYXJ0IHdhc24ndCBzdHJpcHBlZCwgY2FuIGFkZCB0aW1lem9uZSBpbmZvXG4gICAgICAgIGlmICh0aW1lWm9uZU9mZnNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgJycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRpbWVab25lT2Zmc2V0ICE9PSAwKSB7XG4gICAgICAgICAgICBzID0gcy5yZXBsYWNlKCdaJywgZm9ybWF0VGltZVpvbmVPZmZzZXQodGltZVpvbmVPZmZzZXQsIHRydWUpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGl0cyBVVEMtMCBhbmQgd2Ugd2FudCB0byBrZWVwIHRoZSBaXG4gICAgfVxuICAgIHJldHVybiBzO1xufVxuLy8gZm9ybWF0cyB0aGUgZGF0ZSwgYnV0IHdpdGggbm8gdGltZSBwYXJ0XG4vLyBUT0RPOiBzb21laG93IG1lcmdlIHdpdGggYnVpbGRJc29TdHJpbmcgYW5kIHN0cmlwWmVyb1RpbWVcbi8vIFRPRE86IHJlbmFtZS4gb21pdCBcInN0cmluZ1wiXG5mdW5jdGlvbiBmb3JtYXREYXlTdHJpbmcobWFya2VyKSB7XG4gICAgcmV0dXJuIG1hcmtlci50b0lTT1N0cmluZygpLnJlcGxhY2UoL1QuKiQvLCAnJyk7XG59XG4vLyBUT0RPOiB1c2UgRGF0ZTo6dG9JU09TdHJpbmcgYW5kIHVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBUP1xuZnVuY3Rpb24gZm9ybWF0SXNvVGltZVN0cmluZyhtYXJrZXIpIHtcbiAgICByZXR1cm4gcGFkU3RhcnQobWFya2VyLmdldFVUQ0hvdXJzKCksIDIpICsgJzonICtcbiAgICAgICAgcGFkU3RhcnQobWFya2VyLmdldFVUQ01pbnV0ZXMoKSwgMikgKyAnOicgK1xuICAgICAgICBwYWRTdGFydChtYXJrZXIuZ2V0VVRDU2Vjb25kcygpLCAyKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdFRpbWVab25lT2Zmc2V0KG1pbnV0ZXMsIGRvSXNvKSB7XG4gICAgaWYgKGRvSXNvID09PSB2b2lkIDApIHsgZG9Jc28gPSBmYWxzZTsgfVxuICAgIHZhciBzaWduID0gbWludXRlcyA8IDAgPyAnLScgOiAnKyc7XG4gICAgdmFyIGFicyA9IE1hdGguYWJzKG1pbnV0ZXMpO1xuICAgIHZhciBob3VycyA9IE1hdGguZmxvb3IoYWJzIC8gNjApO1xuICAgIHZhciBtaW5zID0gTWF0aC5yb3VuZChhYnMgJSA2MCk7XG4gICAgaWYgKGRvSXNvKSB7XG4gICAgICAgIHJldHVybiBzaWduICsgcGFkU3RhcnQoaG91cnMsIDIpICsgXCI6XCIgKyBwYWRTdGFydChtaW5zLCAyKTtcbiAgICB9XG4gICAgcmV0dXJuIFwiR01UXCIgKyBzaWduICsgaG91cnMgKyAobWlucyA/IFwiOlwiICsgcGFkU3RhcnQobWlucywgMikgOiAnJyk7XG59XG5cbi8vIFRPRE86IG5ldyB1dGlsIGFycmF5aWZ5P1xuZnVuY3Rpb24gcmVtb3ZlRXhhY3QoYXJyYXksIGV4YWN0VmFsKSB7XG4gICAgdmFyIHJlbW92ZUNudCA9IDA7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIGlmIChhcnJheVtpXSA9PT0gZXhhY3RWYWwpIHtcbiAgICAgICAgICAgIGFycmF5LnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJlbW92ZUNudCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZW1vdmVDbnQ7XG59XG5mdW5jdGlvbiBpc0FycmF5c0VxdWFsKGEwLCBhMSwgZXF1YWxpdHlGdW5jKSB7XG4gICAgaWYgKGEwID09PSBhMSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGxlbiA9IGEwLmxlbmd0aDtcbiAgICB2YXIgaTtcbiAgICBpZiAobGVuICE9PSBhMS5sZW5ndGgpIHsgLy8gbm90IGFycmF5PyBvciBub3Qgc2FtZSBsZW5ndGg/XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghKGVxdWFsaXR5RnVuYyA/IGVxdWFsaXR5RnVuYyhhMFtpXSwgYTFbaV0pIDogYTBbaV0gPT09IGExW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBtZW1vaXplKHdvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgY3VycmVudEFyZ3M7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5ld0FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5ld0FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWN1cnJlbnRBcmdzKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaXNBcnJheXNFcXVhbChjdXJyZW50QXJncywgbmV3QXJncykpIHtcbiAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseSh0aGlzLCBuZXdBcmdzKTtcbiAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlcykpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UmVzID0gcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdzID0gbmV3QXJncztcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXM7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIG1lbW9pemVPYmpBcmcod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmc7XG4gICAgdmFyIGN1cnJlbnRSZXM7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmcpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50QXJnKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzID0gd29ya2VyRnVuYy5jYWxsKF90aGlzLCBuZXdBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpc1Byb3BzRXF1YWwoY3VycmVudEFyZywgbmV3QXJnKSkge1xuICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgIHRlYXJkb3duRnVuYyhjdXJyZW50UmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciByZXMgPSB3b3JrZXJGdW5jLmNhbGwoX3RoaXMsIG5ld0FyZyk7XG4gICAgICAgICAgICBpZiAoIXJlc0VxdWFsaXR5IHx8ICFyZXNFcXVhbGl0eShyZXMsIGN1cnJlbnRSZXMpKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFJlcyA9IHJlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnID0gbmV3QXJnO1xuICAgICAgICByZXR1cm4gY3VycmVudFJlcztcbiAgICB9O1xufVxuZnVuY3Rpb24gbWVtb2l6ZUFycmF5bGlrZSgvLyB1c2VkIGF0IGFsbD9cbndvcmtlckZ1bmMsIHJlc0VxdWFsaXR5LCB0ZWFyZG93bkZ1bmMpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBjdXJyZW50QXJnU2V0cyA9IFtdO1xuICAgIHZhciBjdXJyZW50UmVzdWx0cyA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiAobmV3QXJnU2V0cykge1xuICAgICAgICB2YXIgY3VycmVudExlbiA9IGN1cnJlbnRBcmdTZXRzLmxlbmd0aDtcbiAgICAgICAgdmFyIG5ld0xlbiA9IG5ld0FyZ1NldHMubGVuZ3RoO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgY3VycmVudExlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoIW5ld0FyZ1NldHNbaV0pIHsgLy8gb25lIG9mIHRoZSBvbGQgc2V0cyBubyBsb25nZXIgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKHRlYXJkb3duRnVuYykge1xuICAgICAgICAgICAgICAgICAgICB0ZWFyZG93bkZ1bmMoY3VycmVudFJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFpc0FycmF5c0VxdWFsKGN1cnJlbnRBcmdTZXRzW2ldLCBuZXdBcmdTZXRzW2ldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXN1bHRzW2ldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICAgICAgICAgIGlmICghcmVzRXF1YWxpdHkgfHwgIXJlc0VxdWFsaXR5KHJlcywgY3VycmVudFJlc3VsdHNbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSZXN1bHRzW2ldID0gcmVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgaSA8IG5ld0xlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBjdXJyZW50UmVzdWx0c1tpXSA9IHdvcmtlckZ1bmMuYXBwbHkoX3RoaXMsIG5ld0FyZ1NldHNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRBcmdTZXRzID0gbmV3QXJnU2V0cztcbiAgICAgICAgY3VycmVudFJlc3VsdHMuc3BsaWNlKG5ld0xlbik7IC8vIHJlbW92ZSBleGNlc3NcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXN1bHRzO1xuICAgIH07XG59XG5mdW5jdGlvbiBtZW1vaXplSGFzaGxpa2Uod29ya2VyRnVuYywgcmVzRXF1YWxpdHksIHRlYXJkb3duRnVuYykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdmFyIGN1cnJlbnRBcmdIYXNoID0ge307XG4gICAgdmFyIGN1cnJlbnRSZXNIYXNoID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChuZXdBcmdIYXNoKSB7XG4gICAgICAgIHZhciBuZXdSZXNIYXNoID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBuZXdBcmdIYXNoKSB7XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRSZXNIYXNoW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSB3b3JrZXJGdW5jLmFwcGx5KF90aGlzLCBuZXdBcmdIYXNoW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzQXJyYXlzRXF1YWwoY3VycmVudEFyZ0hhc2hba2V5XSwgbmV3QXJnSGFzaFtrZXldKSkge1xuICAgICAgICAgICAgICAgIGlmICh0ZWFyZG93bkZ1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVhcmRvd25GdW5jKGN1cnJlbnRSZXNIYXNoW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gd29ya2VyRnVuYy5hcHBseShfdGhpcywgbmV3QXJnSGFzaFtrZXldKTtcbiAgICAgICAgICAgICAgICBuZXdSZXNIYXNoW2tleV0gPSAocmVzRXF1YWxpdHkgJiYgcmVzRXF1YWxpdHkocmVzLCBjdXJyZW50UmVzSGFzaFtrZXldKSlcbiAgICAgICAgICAgICAgICAgICAgPyBjdXJyZW50UmVzSGFzaFtrZXldXG4gICAgICAgICAgICAgICAgICAgIDogcmVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3UmVzSGFzaFtrZXldID0gY3VycmVudFJlc0hhc2hba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50QXJnSGFzaCA9IG5ld0FyZ0hhc2g7XG4gICAgICAgIGN1cnJlbnRSZXNIYXNoID0gbmV3UmVzSGFzaDtcbiAgICAgICAgcmV0dXJuIG5ld1Jlc0hhc2g7XG4gICAgfTtcbn1cblxudmFyIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTID0ge1xuICAgIHdlZWs6IDMsXG4gICAgc2VwYXJhdG9yOiAwLFxuICAgIG9taXRaZXJvTWludXRlOiAwLFxuICAgIG1lcmlkaWVtOiAwLFxuICAgIG9taXRDb21tYXM6IDAsXG59O1xudmFyIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTID0ge1xuICAgIHRpbWVab25lTmFtZTogNyxcbiAgICBlcmE6IDYsXG4gICAgeWVhcjogNSxcbiAgICBtb250aDogNCxcbiAgICBkYXk6IDIsXG4gICAgd2Vla2RheTogMixcbiAgICBob3VyOiAxLFxuICAgIG1pbnV0ZTogMSxcbiAgICBzZWNvbmQ6IDEsXG59O1xudmFyIE1FUklESUVNX1JFID0gL1xccyooW2FwXSlcXC4/bVxcLj8vaTsgLy8gZWF0cyB1cCBsZWFkaW5nIHNwYWNlcyB0b29cbnZhciBDT01NQV9SRSA9IC8sL2c7IC8vIHdlIG5lZWQgcmUgZm9yIGdsb2JhbG5lc3NcbnZhciBNVUxUSV9TUEFDRV9SRSA9IC9cXHMrL2c7XG52YXIgTFRSX1JFID0gL1xcdTIwMGUvZzsgLy8gY29udHJvbCBjaGFyYWN0ZXJcbnZhciBVVENfUkUgPSAvVVRDfEdNVC87XG52YXIgTmF0aXZlRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hdGl2ZUZvcm1hdHRlcihmb3JtYXRTZXR0aW5ncykge1xuICAgICAgICB2YXIgc3RhbmRhcmREYXRlUHJvcHMgPSB7fTtcbiAgICAgICAgdmFyIGV4dGVuZGVkU2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdmFyIHNldmVyaXR5ID0gMDtcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGZvcm1hdFNldHRpbmdzKSB7XG4gICAgICAgICAgICBpZiAobmFtZV8xIGluIEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTKSB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRTZXR0aW5nc1tuYW1lXzFdID0gZm9ybWF0U2V0dGluZ3NbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBzZXZlcml0eSA9IE1hdGgubWF4KEVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTW25hbWVfMV0sIHNldmVyaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkRGF0ZVByb3BzW25hbWVfMV0gPSBmb3JtYXRTZXR0aW5nc1tuYW1lXzFdO1xuICAgICAgICAgICAgICAgIGlmIChuYW1lXzEgaW4gU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVMpIHsgLy8gVE9ETzogd2hhdCBhYm91dCBob3VyMTI/IG5vIHNldmVyaXR5XG4gICAgICAgICAgICAgICAgICAgIHNldmVyaXR5ID0gTWF0aC5tYXgoU1RBTkRBUkRfREFURV9QUk9QX1NFVkVSSVRJRVNbbmFtZV8xXSwgc2V2ZXJpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YW5kYXJkRGF0ZVByb3BzID0gc3RhbmRhcmREYXRlUHJvcHM7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncyA9IGV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHRoaXMuc2V2ZXJpdHkgPSBzZXZlcml0eTtcbiAgICAgICAgdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jID0gbWVtb2l6ZShidWlsZEZvcm1hdHRpbmdGdW5jKTtcbiAgICB9XG4gICAgTmF0aXZlRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWlsZEZvcm1hdHRpbmdGdW5jKHRoaXMuc3RhbmRhcmREYXRlUHJvcHMsIHRoaXMuZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkoZGF0ZSk7XG4gICAgfTtcbiAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgc3RhbmRhcmREYXRlUHJvcHMgPSBfYS5zdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncyA9IF9hLmV4dGVuZGVkU2V0dGluZ3M7XG4gICAgICAgIHZhciBkaWZmU2V2ZXJpdHkgPSBjb21wdXRlTWFya2VyRGlmZlNldmVyaXR5KHN0YXJ0Lm1hcmtlciwgZW5kLm1hcmtlciwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgICAgIGlmICghZGlmZlNldmVyaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiaWdnZXN0VW5pdEZvclBhcnRpYWwgPSBkaWZmU2V2ZXJpdHk7XG4gICAgICAgIGlmIChiaWdnZXN0VW5pdEZvclBhcnRpYWwgPiAxICYmIC8vIHRoZSB0d28gZGF0ZXMgYXJlIGRpZmZlcmVudCBpbiBhIHdheSB0aGF0J3MgbGFyZ2VyIHNjYWxlIHRoYW4gdGltZVxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLnllYXIgPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy55ZWFyID09PSAnMi1kaWdpdCcpICYmXG4gICAgICAgICAgICAoc3RhbmRhcmREYXRlUHJvcHMubW9udGggPT09ICdudW1lcmljJyB8fCBzdGFuZGFyZERhdGVQcm9wcy5tb250aCA9PT0gJzItZGlnaXQnKSAmJlxuICAgICAgICAgICAgKHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJ251bWVyaWMnIHx8IHN0YW5kYXJkRGF0ZVByb3BzLmRheSA9PT0gJzItZGlnaXQnKSkge1xuICAgICAgICAgICAgYmlnZ2VzdFVuaXRGb3JQYXJ0aWFsID0gMTsgLy8gbWFrZSBpdCBsb29rIGxpa2UgdGhlIGRhdGVzIGFyZSBvbmx5IGRpZmZlcmVudCBpbiB0ZXJtcyBvZiB0aW1lXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bGwwID0gdGhpcy5mb3JtYXQoc3RhcnQsIGNvbnRleHQpO1xuICAgICAgICB2YXIgZnVsbDEgPSB0aGlzLmZvcm1hdChlbmQsIGNvbnRleHQpO1xuICAgICAgICBpZiAoZnVsbDAgPT09IGZ1bGwxKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVsbDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhcnRpYWxEYXRlUHJvcHMgPSBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKHN0YW5kYXJkRGF0ZVByb3BzLCBiaWdnZXN0VW5pdEZvclBhcnRpYWwpO1xuICAgICAgICB2YXIgcGFydGlhbEZvcm1hdHRpbmdGdW5jID0gYnVpbGRGb3JtYXR0aW5nRnVuYyhwYXJ0aWFsRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIHBhcnRpYWwwID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKHN0YXJ0KTtcbiAgICAgICAgdmFyIHBhcnRpYWwxID0gcGFydGlhbEZvcm1hdHRpbmdGdW5jKGVuZCk7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSBmaW5kQ29tbW9uSW5zZXJ0aW9uKGZ1bGwwLCBwYXJ0aWFsMCwgZnVsbDEsIHBhcnRpYWwxKTtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IGV4dGVuZGVkU2V0dGluZ3Muc2VwYXJhdG9yIHx8IGJldHRlckRlZmF1bHRTZXBhcmF0b3IgfHwgY29udGV4dC5kZWZhdWx0U2VwYXJhdG9yIHx8ICcnO1xuICAgICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zZXJ0aW9uLmJlZm9yZSArIHBhcnRpYWwwICsgc2VwYXJhdG9yICsgcGFydGlhbDEgKyBpbnNlcnRpb24uYWZ0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bGwwICsgc2VwYXJhdG9yICsgZnVsbDE7XG4gICAgfTtcbiAgICBOYXRpdmVGb3JtYXR0ZXIucHJvdG90eXBlLmdldExhcmdlc3RVbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V2ZXJpdHkpIHtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3llYXInO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHJldHVybiAnbW9udGgnO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJldHVybiAnd2Vlayc7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXknO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RpbWUnOyAvLyByZWFsbHk/XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBOYXRpdmVGb3JtYXR0ZXI7XG59KCkpO1xuZnVuY3Rpb24gYnVpbGRGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHZhciBzdGFuZGFyZERhdGVQcm9wQ250ID0gT2JqZWN0LmtleXMoc3RhbmRhcmREYXRlUHJvcHMpLmxlbmd0aDtcbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMSAmJiBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdzaG9ydCcpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiAoZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpOyB9O1xuICAgIH1cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcENudCA9PT0gMCAmJiBleHRlbmRlZFNldHRpbmdzLndlZWspIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlKSB7IHJldHVybiAoZm9ybWF0V2Vla051bWJlcihjb250ZXh0LmNvbXB1dGVXZWVrTnVtYmVyKGRhdGUubWFya2VyKSwgY29udGV4dC53ZWVrVGV4dCwgY29udGV4dC53ZWVrVGV4dExvbmcsIGNvbnRleHQubG9jYWxlLCBleHRlbmRlZFNldHRpbmdzLndlZWspKTsgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1aWxkTmF0aXZlRm9ybWF0dGluZ0Z1bmMoc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gYnVpbGROYXRpdmVGb3JtYXR0aW5nRnVuYyhzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHN0YW5kYXJkRGF0ZVByb3BzID0gdHNsaWIuX19hc3NpZ24oe30sIHN0YW5kYXJkRGF0ZVByb3BzKTsgLy8gY29weVxuICAgIGV4dGVuZGVkU2V0dGluZ3MgPSB0c2xpYi5fX2Fzc2lnbih7fSwgZXh0ZW5kZWRTZXR0aW5ncyk7IC8vIGNvcHlcbiAgICBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKTtcbiAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZSA9ICdVVEMnOyAvLyB3ZSBsZXZlcmFnZSB0aGUgb25seSBndWFyYW50ZWVkIHRpbWVab25lIGZvciBvdXIgVVRDIG1hcmtlcnNcbiAgICB2YXIgbm9ybWFsRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHN0YW5kYXJkRGF0ZVByb3BzKTtcbiAgICB2YXIgemVyb0Zvcm1hdDsgLy8gbmVlZGVkP1xuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHZhciB6ZXJvUHJvcHMgPSB0c2xpYi5fX2Fzc2lnbih7fSwgc3RhbmRhcmREYXRlUHJvcHMpO1xuICAgICAgICBkZWxldGUgemVyb1Byb3BzLm1pbnV0ZTsgLy8gc2Vjb25kcyBhbmQgbXMgd2VyZSBhbHJlYWR5IGNvbnNpZGVyZWQgaW4gc2FuaXRpemVTZXR0aW5nc1xuICAgICAgICB6ZXJvRm9ybWF0ID0gbmV3IEludGwuRGF0ZVRpbWVGb3JtYXQoY29udGV4dC5sb2NhbGUuY29kZXMsIHplcm9Qcm9wcyk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoZGF0ZSkge1xuICAgICAgICB2YXIgbWFya2VyID0gZGF0ZS5tYXJrZXI7XG4gICAgICAgIHZhciBmb3JtYXQ7XG4gICAgICAgIGlmICh6ZXJvRm9ybWF0ICYmICFtYXJrZXIuZ2V0VVRDTWludXRlcygpKSB7XG4gICAgICAgICAgICBmb3JtYXQgPSB6ZXJvRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybWF0ID0gbm9ybWFsRm9ybWF0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzID0gZm9ybWF0LmZvcm1hdChtYXJrZXIpO1xuICAgICAgICByZXR1cm4gcG9zdFByb2Nlc3MocywgZGF0ZSwgc3RhbmRhcmREYXRlUHJvcHMsIGV4dGVuZGVkU2V0dGluZ3MsIGNvbnRleHQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBzYW5pdGl6ZVNldHRpbmdzKHN0YW5kYXJkRGF0ZVByb3BzLCBleHRlbmRlZFNldHRpbmdzKSB7XG4gICAgLy8gZGVhbCB3aXRoIGEgYnJvd3NlciBpbmNvbnNpc3RlbmN5IHdoZXJlIGZvcm1hdHRpbmcgdGhlIHRpbWV6b25lXG4gICAgLy8gcmVxdWlyZXMgdGhhdCB0aGUgaG91ci9taW51dGUgYmUgcHJlc2VudC5cbiAgICBpZiAoc3RhbmRhcmREYXRlUHJvcHMudGltZVpvbmVOYW1lKSB7XG4gICAgICAgIGlmICghc3RhbmRhcmREYXRlUHJvcHMuaG91cikge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMuaG91ciA9ICcyLWRpZ2l0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0YW5kYXJkRGF0ZVByb3BzLm1pbnV0ZSkge1xuICAgICAgICAgICAgc3RhbmRhcmREYXRlUHJvcHMubWludXRlID0gJzItZGlnaXQnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG9ubHkgc3VwcG9ydCBzaG9ydCB0aW1lem9uZSBuYW1lc1xuICAgIGlmIChzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPT09ICdsb25nJykge1xuICAgICAgICBzdGFuZGFyZERhdGVQcm9wcy50aW1lWm9uZU5hbWUgPSAnc2hvcnQnO1xuICAgIH1cbiAgICAvLyBpZiByZXF1ZXN0aW5nIHRvIGRpc3BsYXkgc2Vjb25kcywgTVVTVCBkaXNwbGF5IG1pbnV0ZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZSAmJiAoc3RhbmRhcmREYXRlUHJvcHMuc2Vjb25kIHx8IHN0YW5kYXJkRGF0ZVByb3BzLm1pbGxpc2Vjb25kKSkge1xuICAgICAgICBkZWxldGUgZXh0ZW5kZWRTZXR0aW5ncy5vbWl0WmVyb01pbnV0ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBwb3N0UHJvY2VzcyhzLCBkYXRlLCBzdGFuZGFyZERhdGVQcm9wcywgZXh0ZW5kZWRTZXR0aW5ncywgY29udGV4dCkge1xuICAgIHMgPSBzLnJlcGxhY2UoTFRSX1JFLCAnJyk7IC8vIHJlbW92ZSBsZWZ0LXRvLXJpZ2h0IGNvbnRyb2wgY2hhcnMuIGRvIGZpcnN0LiBnb29kIGZvciBvdGhlciByZWdleGVzXG4gICAgaWYgKHN0YW5kYXJkRGF0ZVByb3BzLnRpbWVab25lTmFtZSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBzID0gaW5qZWN0VHpvU3RyKHMsIChjb250ZXh0LnRpbWVab25lID09PSAnVVRDJyB8fCBkYXRlLnRpbWVab25lT2Zmc2V0ID09IG51bGwpID9cbiAgICAgICAgICAgICdVVEMnIDogLy8gaW1wb3J0YW50IHRvIG5vcm1hbGl6ZSBmb3IgSUUsIHdoaWNoIGRvZXMgXCJHTVRcIlxuICAgICAgICAgICAgZm9ybWF0VGltZVpvbmVPZmZzZXQoZGF0ZS50aW1lWm9uZU9mZnNldCkpO1xuICAgIH1cbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5vbWl0Q29tbWFzKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoQ09NTUFfUkUsICcnKS50cmltKCk7XG4gICAgfVxuICAgIGlmIChleHRlbmRlZFNldHRpbmdzLm9taXRaZXJvTWludXRlKSB7XG4gICAgICAgIHMgPSBzLnJlcGxhY2UoJzowMCcsICcnKTsgLy8gemVyb0Zvcm1hdCBkb2Vzbid0IGFsd2F5cyBhY2hpZXZlIHRoaXNcbiAgICB9XG4gICAgLy8gXiBkbyBhbnl0aGluZyB0aGF0IG1pZ2h0IGNyZWF0ZSBhZGphY2VudCBzcGFjZXMgYmVmb3JlIHRoaXMgcG9pbnQsXG4gICAgLy8gYmVjYXVzZSBNRVJJRElFTV9SRSBsaWtlcyB0byBlYXQgdXAgbG9hZGluZyBzcGFjZXNcbiAgICBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgJycpLnRyaW0oKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXh0ZW5kZWRTZXR0aW5ncy5tZXJpZGllbSA9PT0gJ25hcnJvdycpIHsgLy8gYS9wXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHsgcmV0dXJuIG0xLnRvTG9jYWxlTG93ZXJDYXNlKCk7IH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHRlbmRlZFNldHRpbmdzLm1lcmlkaWVtID09PSAnc2hvcnQnKSB7IC8vIGFtL3BtXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoTUVSSURJRU1fUkUsIGZ1bmN0aW9uIChtMCwgbTEpIHsgcmV0dXJuIG0xLnRvTG9jYWxlTG93ZXJDYXNlKCkgKyBcIm1cIjsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4dGVuZGVkU2V0dGluZ3MubWVyaWRpZW0gPT09ICdsb3dlcmNhc2UnKSB7IC8vIG90aGVyIG1lcmlkaWVtIHRyYW5zZm9ybWVycyBhbHJlYWR5IGNvbnZlcnRlZCB0byBsb3dlcmNhc2VcbiAgICAgICAgcyA9IHMucmVwbGFjZShNRVJJRElFTV9SRSwgZnVuY3Rpb24gKG0wKSB7IHJldHVybiBtMC50b0xvY2FsZUxvd2VyQ2FzZSgpOyB9KTtcbiAgICB9XG4gICAgcyA9IHMucmVwbGFjZShNVUxUSV9TUEFDRV9SRSwgJyAnKTtcbiAgICBzID0gcy50cmltKCk7XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBpbmplY3RUem9TdHIocywgdHpvU3RyKSB7XG4gICAgdmFyIHJlcGxhY2VkID0gZmFsc2U7XG4gICAgcyA9IHMucmVwbGFjZShVVENfUkUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVwbGFjZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHpvU3RyO1xuICAgIH0pO1xuICAgIC8vIElFMTEgZG9lc24ndCBpbmNsdWRlIFVUQy9HTVQgaW4gdGhlIG9yaWdpbmFsIHN0cmluZywgc28gYXBwZW5kIHRvIGVuZFxuICAgIGlmICghcmVwbGFjZWQpIHtcbiAgICAgICAgcyArPSBcIiBcIiArIHR6b1N0cjtcbiAgICB9XG4gICAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBmb3JtYXRXZWVrTnVtYmVyKG51bSwgd2Vla1RleHQsIHdlZWtUZXh0TG9uZywgbG9jYWxlLCBkaXNwbGF5KSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgaWYgKGRpc3BsYXkgPT09ICdsb25nJykge1xuICAgICAgICBwYXJ0cy5wdXNoKHdlZWtUZXh0TG9uZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRpc3BsYXkgPT09ICdzaG9ydCcgfHwgZGlzcGxheSA9PT0gJ25hcnJvdycpIHtcbiAgICAgICAgcGFydHMucHVzaCh3ZWVrVGV4dCk7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5ID09PSAnbG9uZycgfHwgZGlzcGxheSA9PT0gJ3Nob3J0Jykge1xuICAgICAgICBwYXJ0cy5wdXNoKCcgJyk7XG4gICAgfVxuICAgIHBhcnRzLnB1c2gobG9jYWxlLnNpbXBsZU51bWJlckZvcm1hdC5mb3JtYXQobnVtKSk7XG4gICAgaWYgKGxvY2FsZS5vcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcpIHsgLy8gVE9ETzogdXNlIGNvbnRyb2wgY2hhcmFjdGVycyBpbnN0ZWFkP1xuICAgICAgICBwYXJ0cy5yZXZlcnNlKCk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbn1cbi8vIFJhbmdlIEZvcm1hdHRpbmcgVXRpbHNcbi8vIDAgPSBleGFjdGx5IHRoZSBzYW1lXG4vLyAxID0gZGlmZmVyZW50IGJ5IHRpbWVcbi8vIGFuZCBiaWdnZXJcbmZ1bmN0aW9uIGNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkoZDAsIGQxLCBjYSkge1xuICAgIGlmIChjYS5nZXRNYXJrZXJZZWFyKGQwKSAhPT0gY2EuZ2V0TWFya2VyWWVhcihkMSkpIHtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgfVxuICAgIGlmIChjYS5nZXRNYXJrZXJNb250aChkMCkgIT09IGNhLmdldE1hcmtlck1vbnRoKGQxKSkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgaWYgKGNhLmdldE1hcmtlckRheShkMCkgIT09IGNhLmdldE1hcmtlckRheShkMSkpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgfVxuICAgIGlmICh0aW1lQXNNcyhkMCkgIT09IHRpbWVBc01zKGQxKSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59XG5mdW5jdGlvbiBjb21wdXRlUGFydGlhbEZvcm1hdHRpbmdPcHRpb25zKG9wdGlvbnMsIGJpZ2dlc3RVbml0KSB7XG4gICAgdmFyIHBhcnRpYWxPcHRpb25zID0ge307XG4gICAgZm9yICh2YXIgbmFtZV8yIGluIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCEobmFtZV8yIGluIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTKSB8fCAvLyBub3QgYSBkYXRlIHBhcnQgcHJvcCAobGlrZSB0aW1lWm9uZSlcbiAgICAgICAgICAgIFNUQU5EQVJEX0RBVEVfUFJPUF9TRVZFUklUSUVTW25hbWVfMl0gPD0gYmlnZ2VzdFVuaXQpIHtcbiAgICAgICAgICAgIHBhcnRpYWxPcHRpb25zW25hbWVfMl0gPSBvcHRpb25zW25hbWVfMl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRpYWxPcHRpb25zO1xufVxuZnVuY3Rpb24gZmluZENvbW1vbkluc2VydGlvbihmdWxsMCwgcGFydGlhbDAsIGZ1bGwxLCBwYXJ0aWFsMSkge1xuICAgIHZhciBpMCA9IDA7XG4gICAgd2hpbGUgKGkwIDwgZnVsbDAubGVuZ3RoKSB7XG4gICAgICAgIHZhciBmb3VuZDAgPSBmdWxsMC5pbmRleE9mKHBhcnRpYWwwLCBpMCk7XG4gICAgICAgIGlmIChmb3VuZDAgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgYmVmb3JlMCA9IGZ1bGwwLnN1YnN0cigwLCBmb3VuZDApO1xuICAgICAgICBpMCA9IGZvdW5kMCArIHBhcnRpYWwwLmxlbmd0aDtcbiAgICAgICAgdmFyIGFmdGVyMCA9IGZ1bGwwLnN1YnN0cihpMCk7XG4gICAgICAgIHZhciBpMSA9IDA7XG4gICAgICAgIHdoaWxlIChpMSA8IGZ1bGwxLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGZvdW5kMSA9IGZ1bGwxLmluZGV4T2YocGFydGlhbDEsIGkxKTtcbiAgICAgICAgICAgIGlmIChmb3VuZDEgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYmVmb3JlMSA9IGZ1bGwxLnN1YnN0cigwLCBmb3VuZDEpO1xuICAgICAgICAgICAgaTEgPSBmb3VuZDEgKyBwYXJ0aWFsMS5sZW5ndGg7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIxID0gZnVsbDEuc3Vic3RyKGkxKTtcbiAgICAgICAgICAgIGlmIChiZWZvcmUwID09PSBiZWZvcmUxICYmIGFmdGVyMCA9PT0gYWZ0ZXIxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlOiBiZWZvcmUwLFxuICAgICAgICAgICAgICAgICAgICBhZnRlcjogYWZ0ZXIwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZFpvbmVkTWFya2VyKGRhdGVJbmZvLCBjYWxlbmRhclN5c3RlbSkge1xuICAgIHZhciBhID0gY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShkYXRlSW5mby5tYXJrZXIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1hcmtlcjogZGF0ZUluZm8ubWFya2VyLFxuICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZUluZm8udGltZVpvbmVPZmZzZXQsXG4gICAgICAgIGFycmF5OiBhLFxuICAgICAgICB5ZWFyOiBhWzBdLFxuICAgICAgICBtb250aDogYVsxXSxcbiAgICAgICAgZGF5OiBhWzJdLFxuICAgICAgICBob3VyOiBhWzNdLFxuICAgICAgICBtaW51dGU6IGFbNF0sXG4gICAgICAgIHNlY29uZDogYVs1XSxcbiAgICAgICAgbWlsbGlzZWNvbmQ6IGFbNl0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgIHZhciBzdGFydEluZm8gPSBleHBhbmRab25lZE1hcmtlcihzdGFydCwgY29udGV4dC5jYWxlbmRhclN5c3RlbSk7XG4gICAgdmFyIGVuZEluZm8gPSBlbmQgPyBleHBhbmRab25lZE1hcmtlcihlbmQsIGNvbnRleHQuY2FsZW5kYXJTeXN0ZW0pIDogbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBkYXRlOiBzdGFydEluZm8sXG4gICAgICAgIHN0YXJ0OiBzdGFydEluZm8sXG4gICAgICAgIGVuZDogZW5kSW5mbyxcbiAgICAgICAgdGltZVpvbmU6IGNvbnRleHQudGltZVpvbmUsXG4gICAgICAgIGxvY2FsZUNvZGVzOiBjb250ZXh0LmxvY2FsZS5jb2RlcyxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogYmV0dGVyRGVmYXVsdFNlcGFyYXRvciB8fCBjb250ZXh0LmRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfTtcbn1cblxuLypcblRPRE86IGZpeCB0aGUgdGVybWlub2xvZ3kgb2YgXCJmb3JtYXR0ZXJcIiB2cyBcImZvcm1hdHRpbmcgZnVuY1wiXG4qL1xuLypcbkF0IHRoZSB0aW1lIG9mIGluc3RhbnRpYXRpb24sIHRoaXMgb2JqZWN0IGRvZXMgbm90IGtub3cgd2hpY2ggY21kLWZvcm1hdHRpbmcgc3lzdGVtIGl0IHdpbGwgdXNlLlxuSXQgcmVjZWl2ZXMgdGhpcyBhdCB0aGUgdGltZSBvZiBmb3JtYXR0aW5nLCBhcyBhIHNldHRpbmcuXG4qL1xudmFyIENtZEZvcm1hdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbWRGb3JtYXR0ZXIoY21kU3RyKSB7XG4gICAgICAgIHRoaXMuY21kU3RyID0gY21kU3RyO1xuICAgIH1cbiAgICBDbWRGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uIChkYXRlLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoZGF0ZSwgbnVsbCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgQ21kRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmNtZEZvcm1hdHRlcih0aGlzLmNtZFN0ciwgY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmcoc3RhcnQsIGVuZCwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikpO1xuICAgIH07XG4gICAgcmV0dXJuIENtZEZvcm1hdHRlcjtcbn0oKSk7XG5cbnZhciBGdW5jRm9ybWF0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZ1bmNGb3JtYXR0ZXIoZnVuYykge1xuICAgICAgICB0aGlzLmZ1bmMgPSBmdW5jO1xuICAgIH1cbiAgICBGdW5jRm9ybWF0dGVyLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAoZGF0ZSwgY29udGV4dCwgYmV0dGVyRGVmYXVsdFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5mdW5jKGNyZWF0ZVZlcmJvc2VGb3JtYXR0aW5nQXJnKGRhdGUsIG51bGwsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpKTtcbiAgICB9O1xuICAgIEZ1bmNGb3JtYXR0ZXIucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQsIGNvbnRleHQsIGJldHRlckRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnVuYyhjcmVhdGVWZXJib3NlRm9ybWF0dGluZ0FyZyhzdGFydCwgZW5kLCBjb250ZXh0LCBiZXR0ZXJEZWZhdWx0U2VwYXJhdG9yKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY0Zvcm1hdHRlcjtcbn0oKSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm1hdHRlcihpbnB1dCkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gbmV3IE5hdGl2ZUZvcm1hdHRlcihpbnB1dCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ21kRm9ybWF0dGVyKGlucHV0KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bmNGb3JtYXR0ZXIoaW5wdXQpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuLy8gYmFzZSBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS1cbnZhciBCQVNFX09QVElPTl9SRUZJTkVSUyA9IHtcbiAgICBuYXZMaW5rRGF5Q2xpY2s6IGlkZW50aXR5LFxuICAgIG5hdkxpbmtXZWVrQ2xpY2s6IGlkZW50aXR5LFxuICAgIGR1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBib290c3RyYXBGb250QXdlc29tZTogaWRlbnRpdHksXG4gICAgYnV0dG9uSWNvbnM6IGlkZW50aXR5LFxuICAgIGN1c3RvbUJ1dHRvbnM6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkZWZhdWx0VGltZWRFdmVudER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBuZXh0RGF5VGhyZXNob2xkOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IEJvb2xlYW4sXG4gICAgc2xvdE1pblRpbWU6IGNyZWF0ZUR1cmF0aW9uLFxuICAgIHNsb3RNYXhUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkYXlQb3BvdmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgc2xvdER1cmF0aW9uOiBjcmVhdGVEdXJhdGlvbixcbiAgICBzbmFwRHVyYXRpb246IGNyZWF0ZUR1cmF0aW9uLFxuICAgIGhlYWRlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGZvb3RlclRvb2xiYXI6IGlkZW50aXR5LFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogU3RyaW5nLFxuICAgIHRpdGxlUmFuZ2VTZXBhcmF0b3I6IFN0cmluZyxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IEJvb2xlYW4sXG4gICAgZGF5SGVhZGVyczogQm9vbGVhbixcbiAgICBkYXlIZWFkZXJGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICBkYXlIZWFkZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJDb250ZW50OiBpZGVudGl0eSxcbiAgICBkYXlIZWFkZXJEaWRNb3VudDogaWRlbnRpdHksXG4gICAgZGF5SGVhZGVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheUNlbGxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBkYXlDZWxsQ29udGVudDogaWRlbnRpdHksXG4gICAgZGF5Q2VsbERpZE1vdW50OiBpZGVudGl0eSxcbiAgICBkYXlDZWxsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGluaXRpYWxWaWV3OiBTdHJpbmcsXG4gICAgYXNwZWN0UmF0aW86IE51bWJlcixcbiAgICB3ZWVrZW5kczogQm9vbGVhbixcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246IGlkZW50aXR5LFxuICAgIHdlZWtOdW1iZXJzOiBCb29sZWFuLFxuICAgIHdlZWtOdW1iZXJDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyQ29udGVudDogaWRlbnRpdHksXG4gICAgd2Vla051bWJlckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICB3ZWVrTnVtYmVyV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHZpZXdDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICB2aWV3RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHZpZXdXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgbm93SW5kaWNhdG9yOiBCb29sZWFuLFxuICAgIG5vd0luZGljYXRvckNsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckNvbnRlbnQ6IGlkZW50aXR5LFxuICAgIG5vd0luZGljYXRvckRpZE1vdW50OiBpZGVudGl0eSxcbiAgICBub3dJbmRpY2F0b3JXaWxsVW5tb3VudDogaWRlbnRpdHksXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogQm9vbGVhbixcbiAgICBsYXp5RmV0Y2hpbmc6IEJvb2xlYW4sXG4gICAgc3RhcnRQYXJhbTogU3RyaW5nLFxuICAgIGVuZFBhcmFtOiBTdHJpbmcsXG4gICAgdGltZVpvbmVQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lOiBTdHJpbmcsXG4gICAgbG9jYWxlczogaWRlbnRpdHksXG4gICAgbG9jYWxlOiBpZGVudGl0eSxcbiAgICB0aGVtZVN5c3RlbTogU3RyaW5nLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogTnVtYmVyLFxuICAgIGRyYWdTY3JvbGw6IEJvb2xlYW4sXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogQm9vbGVhbixcbiAgICB1bnNlbGVjdEF1dG86IEJvb2xlYW4sXG4gICAgZHJvcEFjY2VwdDogaWRlbnRpdHksXG4gICAgZXZlbnRPcmRlcjogcGFyc2VGaWVsZFNwZWNzLFxuICAgIGV2ZW50T3JkZXJTdHJpY3Q6IEJvb2xlYW4sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiBCb29sZWFuLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiBOdW1iZXIsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBldmVudERyYWdNaW5EaXN0YW5jZTogTnVtYmVyLFxuICAgIGV4cGFuZFJvd3M6IEJvb2xlYW4sXG4gICAgaGVpZ2h0OiBpZGVudGl0eSxcbiAgICBjb250ZW50SGVpZ2h0OiBpZGVudGl0eSxcbiAgICBkaXJlY3Rpb246IFN0cmluZyxcbiAgICB3ZWVrTnVtYmVyRm9ybWF0OiBjcmVhdGVGb3JtYXR0ZXIsXG4gICAgZXZlbnRSZXNpemFibGVGcm9tU3RhcnQ6IEJvb2xlYW4sXG4gICAgZGlzcGxheUV2ZW50VGltZTogQm9vbGVhbixcbiAgICBkaXNwbGF5RXZlbnRFbmQ6IEJvb2xlYW4sXG4gICAgd2Vla1RleHQ6IFN0cmluZyxcbiAgICB3ZWVrVGV4dExvbmc6IFN0cmluZyxcbiAgICBwcm9ncmVzc2l2ZUV2ZW50UmVuZGVyaW5nOiBCb29sZWFuLFxuICAgIGJ1c2luZXNzSG91cnM6IGlkZW50aXR5LFxuICAgIGluaXRpYWxEYXRlOiBpZGVudGl0eSxcbiAgICBub3c6IGlkZW50aXR5LFxuICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogaWRlbnRpdHksXG4gICAgc3RpY2t5SGVhZGVyRGF0ZXM6IGlkZW50aXR5LFxuICAgIHN0aWNreUZvb3RlclNjcm9sbGJhcjogaWRlbnRpdHksXG4gICAgdmlld0hlaWdodDogaWRlbnRpdHksXG4gICAgZGVmYXVsdEFsbERheTogQm9vbGVhbixcbiAgICBldmVudFNvdXJjZUZhaWx1cmU6IGlkZW50aXR5LFxuICAgIGV2ZW50U291cmNlU3VjY2VzczogaWRlbnRpdHksXG4gICAgZXZlbnREaXNwbGF5OiBTdHJpbmcsXG4gICAgZXZlbnRTdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGV2ZW50RHVyYXRpb25FZGl0YWJsZTogQm9vbGVhbixcbiAgICBldmVudE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIGV2ZW50Q29uc3RyYWludDogaWRlbnRpdHksXG4gICAgZXZlbnRBbGxvdzogaWRlbnRpdHksXG4gICAgZXZlbnRCYWNrZ3JvdW5kQ29sb3I6IFN0cmluZyxcbiAgICBldmVudEJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRUZXh0Q29sb3I6IFN0cmluZyxcbiAgICBldmVudENvbG9yOiBTdHJpbmcsXG4gICAgZXZlbnRDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBldmVudENvbnRlbnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGV2ZW50V2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdENvbnN0cmFpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE92ZXJsYXA6IGlkZW50aXR5LFxuICAgIHNlbGVjdEFsbG93OiBpZGVudGl0eSxcbiAgICBkcm9wcGFibGU6IEJvb2xlYW4sXG4gICAgdW5zZWxlY3RDYW5jZWw6IFN0cmluZyxcbiAgICBzbG90TGFiZWxGb3JtYXQ6IGlkZW50aXR5LFxuICAgIHNsb3RMYW5lQ2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgc2xvdExhbmVDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZURpZE1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFuZVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDbGFzc05hbWVzOiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxDb250ZW50OiBpZGVudGl0eSxcbiAgICBzbG90TGFiZWxEaWRNb3VudDogaWRlbnRpdHksXG4gICAgc2xvdExhYmVsV2lsbFVubW91bnQ6IGlkZW50aXR5LFxuICAgIGRheU1heEV2ZW50czogaWRlbnRpdHksXG4gICAgZGF5TWF4RXZlbnRSb3dzOiBpZGVudGl0eSxcbiAgICBkYXlNaW5XaWR0aDogTnVtYmVyLFxuICAgIHNsb3RMYWJlbEludGVydmFsOiBjcmVhdGVEdXJhdGlvbixcbiAgICBhbGxEYXlUZXh0OiBTdHJpbmcsXG4gICAgYWxsRGF5Q2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgYWxsRGF5Q29udGVudDogaWRlbnRpdHksXG4gICAgYWxsRGF5RGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIGFsbERheVdpbGxVbm1vdW50OiBpZGVudGl0eSxcbiAgICBzbG90TWluV2lkdGg6IE51bWJlcixcbiAgICBuYXZMaW5rczogQm9vbGVhbixcbiAgICBldmVudFRpbWVGb3JtYXQ6IGNyZWF0ZUZvcm1hdHRlcixcbiAgICByZXJlbmRlckRlbGF5OiBOdW1iZXIsXG4gICAgbW9yZUxpbmtUZXh0OiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0hpbnQ6IGlkZW50aXR5LFxuICAgIHNlbGVjdE1pbkRpc3RhbmNlOiBOdW1iZXIsXG4gICAgc2VsZWN0YWJsZTogQm9vbGVhbixcbiAgICBzZWxlY3RMb25nUHJlc3NEZWxheTogTnVtYmVyLFxuICAgIGV2ZW50TG9uZ1ByZXNzRGVsYXk6IE51bWJlcixcbiAgICBzZWxlY3RNaXJyb3I6IEJvb2xlYW4sXG4gICAgZXZlbnRNYXhTdGFjazogTnVtYmVyLFxuICAgIGV2ZW50TWluSGVpZ2h0OiBOdW1iZXIsXG4gICAgZXZlbnRNaW5XaWR0aDogTnVtYmVyLFxuICAgIGV2ZW50U2hvcnRIZWlnaHQ6IE51bWJlcixcbiAgICBzbG90RXZlbnRPdmVybGFwOiBCb29sZWFuLFxuICAgIHBsdWdpbnM6IGlkZW50aXR5LFxuICAgIGZpcnN0RGF5OiBOdW1iZXIsXG4gICAgZGF5Q291bnQ6IE51bWJlcixcbiAgICBkYXRlQWxpZ25tZW50OiBTdHJpbmcsXG4gICAgZGF0ZUluY3JlbWVudDogY3JlYXRlRHVyYXRpb24sXG4gICAgaGlkZGVuRGF5czogaWRlbnRpdHksXG4gICAgbW9udGhNb2RlOiBCb29sZWFuLFxuICAgIGZpeGVkV2Vla0NvdW50OiBCb29sZWFuLFxuICAgIHZhbGlkUmFuZ2U6IGlkZW50aXR5LFxuICAgIHZpc2libGVSYW5nZTogaWRlbnRpdHksXG4gICAgdGl0bGVGb3JtYXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50SW50ZXJhY3RpdmU6IEJvb2xlYW4sXG4gICAgLy8gb25seSB1c2VkIGJ5IGxpc3QtdmlldywgYnV0IGxhbmd1YWdlcyBkZWZpbmUgdGhlIHZhbHVlLCBzbyB3ZSBuZWVkIGl0IGluIGJhc2Ugb3B0aW9uc1xuICAgIG5vRXZlbnRzVGV4dDogU3RyaW5nLFxuICAgIHZpZXdIaW50OiBpZGVudGl0eSxcbiAgICBuYXZMaW5rSGludDogaWRlbnRpdHksXG4gICAgY2xvc2VIaW50OiBTdHJpbmcsXG4gICAgdGltZUhpbnQ6IFN0cmluZyxcbiAgICBldmVudEhpbnQ6IFN0cmluZyxcbiAgICBtb3JlTGlua0NsaWNrOiBpZGVudGl0eSxcbiAgICBtb3JlTGlua0NsYXNzTmFtZXM6IGlkZW50aXR5LFxuICAgIG1vcmVMaW5rQ29udGVudDogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtEaWRNb3VudDogaWRlbnRpdHksXG4gICAgbW9yZUxpbmtXaWxsVW5tb3VudDogaWRlbnRpdHksXG59O1xuLy8gZG8gTk9UIGdpdmUgYSB0eXBlIGhlcmUuIG5lZWQgYHR5cGVvZiBCQVNFX09QVElPTl9ERUZBVUxUU2AgdG8gZ2l2ZSByZWFsIHJlc3VsdHMuXG4vLyByYXcgdmFsdWVzLlxudmFyIEJBU0VfT1BUSU9OX0RFRkFVTFRTID0ge1xuICAgIGV2ZW50RGlzcGxheTogJ2F1dG8nLFxuICAgIGRlZmF1bHRSYW5nZVNlcGFyYXRvcjogJyAtICcsXG4gICAgdGl0bGVSYW5nZVNlcGFyYXRvcjogJyBcXHUyMDEzICcsXG4gICAgZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbjogJzAxOjAwOjAwJyxcbiAgICBkZWZhdWx0QWxsRGF5RXZlbnREdXJhdGlvbjogeyBkYXk6IDEgfSxcbiAgICBmb3JjZUV2ZW50RHVyYXRpb246IGZhbHNlLFxuICAgIG5leHREYXlUaHJlc2hvbGQ6ICcwMDowMDowMCcsXG4gICAgZGF5SGVhZGVyczogdHJ1ZSxcbiAgICBpbml0aWFsVmlldzogJycsXG4gICAgYXNwZWN0UmF0aW86IDEuMzUsXG4gICAgaGVhZGVyVG9vbGJhcjoge1xuICAgICAgICBzdGFydDogJ3RpdGxlJyxcbiAgICAgICAgY2VudGVyOiAnJyxcbiAgICAgICAgZW5kOiAndG9kYXkgcHJldixuZXh0JyxcbiAgICB9LFxuICAgIHdlZWtlbmRzOiB0cnVlLFxuICAgIHdlZWtOdW1iZXJzOiBmYWxzZSxcbiAgICB3ZWVrTnVtYmVyQ2FsY3VsYXRpb246ICdsb2NhbCcsXG4gICAgZWRpdGFibGU6IGZhbHNlLFxuICAgIG5vd0luZGljYXRvcjogZmFsc2UsXG4gICAgc2Nyb2xsVGltZTogJzA2OjAwOjAwJyxcbiAgICBzY3JvbGxUaW1lUmVzZXQ6IHRydWUsXG4gICAgc2xvdE1pblRpbWU6ICcwMDowMDowMCcsXG4gICAgc2xvdE1heFRpbWU6ICcyNDowMDowMCcsXG4gICAgc2hvd05vbkN1cnJlbnREYXRlczogdHJ1ZSxcbiAgICBsYXp5RmV0Y2hpbmc6IHRydWUsXG4gICAgc3RhcnRQYXJhbTogJ3N0YXJ0JyxcbiAgICBlbmRQYXJhbTogJ2VuZCcsXG4gICAgdGltZVpvbmVQYXJhbTogJ3RpbWVab25lJyxcbiAgICB0aW1lWm9uZTogJ2xvY2FsJyxcbiAgICBsb2NhbGVzOiBbXSxcbiAgICBsb2NhbGU6ICcnLFxuICAgIHRoZW1lU3lzdGVtOiAnc3RhbmRhcmQnLFxuICAgIGRyYWdSZXZlcnREdXJhdGlvbjogNTAwLFxuICAgIGRyYWdTY3JvbGw6IHRydWUsXG4gICAgYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjogZmFsc2UsXG4gICAgdW5zZWxlY3RBdXRvOiB0cnVlLFxuICAgIGRyb3BBY2NlcHQ6ICcqJyxcbiAgICBldmVudE9yZGVyOiAnc3RhcnQsLWR1cmF0aW9uLGFsbERheSx0aXRsZScsXG4gICAgZGF5UG9wb3ZlckZvcm1hdDogeyBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJywgeWVhcjogJ251bWVyaWMnIH0sXG4gICAgaGFuZGxlV2luZG93UmVzaXplOiB0cnVlLFxuICAgIHdpbmRvd1Jlc2l6ZURlbGF5OiAxMDAsXG4gICAgbG9uZ1ByZXNzRGVsYXk6IDEwMDAsXG4gICAgZXZlbnREcmFnTWluRGlzdGFuY2U6IDUsXG4gICAgZXhwYW5kUm93czogZmFsc2UsXG4gICAgbmF2TGlua3M6IGZhbHNlLFxuICAgIHNlbGVjdGFibGU6IGZhbHNlLFxuICAgIGV2ZW50TWluSGVpZ2h0OiAxNSxcbiAgICBldmVudE1pbldpZHRoOiAzMCxcbiAgICBldmVudFNob3J0SGVpZ2h0OiAzMCxcbn07XG4vLyBjYWxlbmRhciBsaXN0ZW5lcnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIENBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTID0ge1xuICAgIGRhdGVzU2V0OiBpZGVudGl0eSxcbiAgICBldmVudHNTZXQ6IGlkZW50aXR5LFxuICAgIGV2ZW50QWRkOiBpZGVudGl0eSxcbiAgICBldmVudENoYW5nZTogaWRlbnRpdHksXG4gICAgZXZlbnRSZW1vdmU6IGlkZW50aXR5LFxuICAgIHdpbmRvd1Jlc2l6ZTogaWRlbnRpdHksXG4gICAgZXZlbnRDbGljazogaWRlbnRpdHksXG4gICAgZXZlbnRNb3VzZUVudGVyOiBpZGVudGl0eSxcbiAgICBldmVudE1vdXNlTGVhdmU6IGlkZW50aXR5LFxuICAgIHNlbGVjdDogaWRlbnRpdHksXG4gICAgdW5zZWxlY3Q6IGlkZW50aXR5LFxuICAgIGxvYWRpbmc6IGlkZW50aXR5LFxuICAgIC8vIGludGVybmFsXG4gICAgX3VubW91bnQ6IGlkZW50aXR5LFxuICAgIF9iZWZvcmVwcmludDogaWRlbnRpdHksXG4gICAgX2FmdGVycHJpbnQ6IGlkZW50aXR5LFxuICAgIF9ub0V2ZW50RHJvcDogaWRlbnRpdHksXG4gICAgX25vRXZlbnRSZXNpemU6IGlkZW50aXR5LFxuICAgIF9yZXNpemU6IGlkZW50aXR5LFxuICAgIF9zY3JvbGxSZXF1ZXN0OiBpZGVudGl0eSxcbn07XG4vLyBjYWxlbmRhci1zcGVjaWZpYyBvcHRpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG52YXIgQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIGJ1dHRvblRleHQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvbkhpbnRzOiBpZGVudGl0eSxcbiAgICB2aWV3czogaWRlbnRpdHksXG4gICAgcGx1Z2luczogaWRlbnRpdHksXG4gICAgaW5pdGlhbEV2ZW50czogaWRlbnRpdHksXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudFNvdXJjZXM6IGlkZW50aXR5LFxufTtcbnZhciBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SUyA9IHtcbiAgICBoZWFkZXJUb29sYmFyOiBpc01heWJlT2JqZWN0c0VxdWFsLFxuICAgIGZvb3RlclRvb2xiYXI6IGlzTWF5YmVPYmplY3RzRXF1YWwsXG4gICAgYnV0dG9uVGV4dDogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25IaW50czogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBidXR0b25JY29uczogaXNNYXliZU9iamVjdHNFcXVhbCxcbiAgICBkYXRlSW5jcmVtZW50OiBpc01heWJlT2JqZWN0c0VxdWFsLFxufTtcbmZ1bmN0aW9uIGlzTWF5YmVPYmplY3RzRXF1YWwoYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmIGEgJiYgYikgeyAvLyBib3RoIG5vbi1udWxsIG9iamVjdHNcbiAgICAgICAgcmV0dXJuIGlzUHJvcHNFcXVhbChhLCBiKTtcbiAgICB9XG4gICAgcmV0dXJuIGEgPT09IGI7XG59XG4vLyB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLVxudmFyIFZJRVdfT1BUSU9OX1JFRklORVJTID0ge1xuICAgIHR5cGU6IFN0cmluZyxcbiAgICBjb21wb25lbnQ6IGlkZW50aXR5LFxuICAgIGJ1dHRvblRleHQ6IFN0cmluZyxcbiAgICBidXR0b25UZXh0S2V5OiBTdHJpbmcsXG4gICAgZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzczogaWRlbnRpdHksXG4gICAgdXNlc01pbk1heFRpbWU6IEJvb2xlYW4sXG4gICAgY2xhc3NOYW1lczogaWRlbnRpdHksXG4gICAgY29udGVudDogaWRlbnRpdHksXG4gICAgZGlkTW91bnQ6IGlkZW50aXR5LFxuICAgIHdpbGxVbm1vdW50OiBpZGVudGl0eSxcbn07XG4vLyB1dGlsIGZ1bmNzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBtZXJnZVJhd09wdGlvbnMob3B0aW9uU2V0cykge1xuICAgIHJldHVybiBtZXJnZVByb3BzKG9wdGlvblNldHMsIENPTVBMRVhfT1BUSU9OX0NPTVBBUkFUT1JTKTtcbn1cbmZ1bmN0aW9uIHJlZmluZVByb3BzKGlucHV0LCByZWZpbmVycykge1xuICAgIHZhciByZWZpbmVkID0ge307XG4gICAgdmFyIGV4dHJhID0ge307XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcmVmaW5lcnMpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgICAgICByZWZpbmVkW3Byb3BOYW1lXSA9IHJlZmluZXJzW3Byb3BOYW1lXShpbnB1dFtwcm9wTmFtZV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGlucHV0KSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHJlZmluZXJzKSkge1xuICAgICAgICAgICAgZXh0cmFbcHJvcE5hbWVdID0gaW5wdXRbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHJlZmluZWQ6IHJlZmluZWQsIGV4dHJhOiBleHRyYSB9O1xufVxuZnVuY3Rpb24gaWRlbnRpdHkocmF3KSB7XG4gICAgcmV0dXJuIHJhdztcbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpIHtcbiAgICB2YXIgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgIHZhciBldmVudFJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpO1xuICAgIGZvciAodmFyIF9pID0gMCwgcmF3RXZlbnRzXzEgPSByYXdFdmVudHM7IF9pIDwgcmF3RXZlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByYXdFdmVudCA9IHJhd0V2ZW50c18xW19pXTtcbiAgICAgICAgdmFyIHR1cGxlID0gcGFyc2VFdmVudChyYXdFdmVudCwgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCBldmVudFJlZmluZXJzKTtcbiAgICAgICAgaWYgKHR1cGxlKSB7XG4gICAgICAgICAgICBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiBldmVudFR1cGxlVG9TdG9yZSh0dXBsZSwgZXZlbnRTdG9yZSkge1xuICAgIGlmIChldmVudFN0b3JlID09PSB2b2lkIDApIHsgZXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyB9XG4gICAgZXZlbnRTdG9yZS5kZWZzW3R1cGxlLmRlZi5kZWZJZF0gPSB0dXBsZS5kZWY7XG4gICAgaWYgKHR1cGxlLmluc3RhbmNlKSB7XG4gICAgICAgIGV2ZW50U3RvcmUuaW5zdGFuY2VzW3R1cGxlLmluc3RhbmNlLmluc3RhbmNlSWRdID0gdHVwbGUuaW5zdGFuY2U7XG4gICAgfVxuICAgIHJldHVybiBldmVudFN0b3JlO1xufVxuLy8gcmV0cmlldmVzIGV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgZ3JvdXBJZCBhcyB0aGUgaW5zdGFuY2Ugc3BlY2lmaWVkIGJ5IGBpbnN0YW5jZUlkYFxuLy8gb3IgdGhleSBhcmUgdGhlIHNhbWUgYXMgdGhlIGluc3RhbmNlLlxuLy8gd2h5IG1pZ2h0IGluc3RhbmNlSWQgbm90IGJlIGluIHRoZSBzdG9yZT8gYW4gZXZlbnQgZnJvbSBhbm90aGVyIGNhbGVuZGFyP1xuZnVuY3Rpb24gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZSwgaW5zdGFuY2VJZCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzW2luc3RhbmNlSWRdO1xuICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICB2YXIgZGVmXzEgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICAvLyBnZXQgZXZlbnRzL2luc3RhbmNlcyB3aXRoIHNhbWUgZ3JvdXBcbiAgICAgICAgdmFyIG5ld1N0b3JlID0gZmlsdGVyRXZlbnRTdG9yZURlZnMoZXZlbnRTdG9yZSwgZnVuY3Rpb24gKGxvb2tEZWYpIHsgcmV0dXJuIGlzRXZlbnREZWZzR3JvdXBlZChkZWZfMSwgbG9va0RlZik7IH0pO1xuICAgICAgICAvLyBhZGQgdGhlIG9yaWdpbmFsXG4gICAgICAgIC8vIFRPRE86IHdpc2ggd2UgY291bGQgdXNlIGV2ZW50VHVwbGVUb1N0b3JlIG9yIHNvbWV0aGluZyBsaWtlIGl0XG4gICAgICAgIG5ld1N0b3JlLmRlZnNbZGVmXzEuZGVmSWRdID0gZGVmXzE7XG4gICAgICAgIG5ld1N0b3JlLmluc3RhbmNlc1tpbnN0YW5jZS5pbnN0YW5jZUlkXSA9IGluc3RhbmNlO1xuICAgICAgICByZXR1cm4gbmV3U3RvcmU7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGlzRXZlbnREZWZzR3JvdXBlZChkZWYwLCBkZWYxKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oZGVmMC5ncm91cElkICYmIGRlZjAuZ3JvdXBJZCA9PT0gZGVmMS5ncm91cElkKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpIHtcbiAgICByZXR1cm4geyBkZWZzOiB7fSwgaW5zdGFuY2VzOiB7fSB9O1xufVxuZnVuY3Rpb24gbWVyZ2VFdmVudFN0b3JlcyhzdG9yZTAsIHN0b3JlMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlZnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBzdG9yZTAuZGVmcyksIHN0b3JlMS5kZWZzKSxcbiAgICAgICAgaW5zdGFuY2VzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc3RvcmUwLmluc3RhbmNlcyksIHN0b3JlMS5pbnN0YW5jZXMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmaWx0ZXJGdW5jKSB7XG4gICAgdmFyIGRlZnMgPSBmaWx0ZXJIYXNoKGV2ZW50U3RvcmUuZGVmcywgZmlsdGVyRnVuYyk7XG4gICAgdmFyIGluc3RhbmNlcyA9IGZpbHRlckhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gKGRlZnNbaW5zdGFuY2UuZGVmSWRdIC8vIHN0aWxsIGV4aXN0cz9cbiAgICApOyB9KTtcbiAgICByZXR1cm4geyBkZWZzOiBkZWZzLCBpbnN0YW5jZXM6IGluc3RhbmNlcyB9O1xufVxuZnVuY3Rpb24gZXhjbHVkZVN1YkV2ZW50U3RvcmUobWFzdGVyLCBzdWIpIHtcbiAgICB2YXIgZGVmcyA9IG1hc3Rlci5kZWZzLCBpbnN0YW5jZXMgPSBtYXN0ZXIuaW5zdGFuY2VzO1xuICAgIHZhciBmaWx0ZXJlZERlZnMgPSB7fTtcbiAgICB2YXIgZmlsdGVyZWRJbnN0YW5jZXMgPSB7fTtcbiAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgIGlmICghc3ViLmRlZnNbZGVmSWRdKSB7IC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbZGVmSWRdID0gZGVmc1tkZWZJZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFzdWIuaW5zdGFuY2VzW2luc3RhbmNlSWRdICYmIC8vIG5vdCBleHBsaWNpdGx5IGV4Y2x1ZGVkXG4gICAgICAgICAgICBmaWx0ZXJlZERlZnNbaW5zdGFuY2VzW2luc3RhbmNlSWRdLmRlZklkXSAvLyBkZWYgd2Fzbid0IGZpbHRlcmVkIGF3YXlcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZEluc3RhbmNlc1tpbnN0YW5jZUlkXSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBmaWx0ZXJlZERlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVyZWRJbnN0YW5jZXMsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbm9ybWFsaXplQ29uc3RyYWludChpbnB1dCwgY29udGV4dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoaW5wdXQsIG51bGwsIGNvbnRleHQsIHRydWUpOyAvLyBhbGxvd09wZW5SYW5nZT10cnVlXG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmIGlucHV0KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gcGFyc2VFdmVudHMoW2lucHV0XSwgbnVsbCwgY29udGV4dCwgdHJ1ZSk7IC8vIGFsbG93T3BlblJhbmdlPXRydWVcbiAgICB9XG4gICAgaWYgKGlucHV0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpbnB1dCk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBwYXJzZUNsYXNzTmFtZXMocmF3KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmF3KSkge1xuICAgICAgICByZXR1cm4gcmF3O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHJhdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJhdy5zcGxpdCgvXFxzKy8pO1xuICAgIH1cbiAgICByZXR1cm4gW107XG59XG5cbi8vIFRPRE86IGJldHRlciBjYWxsZWQgXCJFdmVudFNldHRpbmdzXCIgb3IgXCJFdmVudENvbmZpZ1wiXG4vLyBUT0RPOiBtb3ZlIHRoaXMgZmlsZSBpbnRvIHN0cnVjdHNcbi8vIFRPRE86IHNlcGFyYXRlIGNvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvdywgYmVjYXVzZSBzZWxlY3Rpb24gdXNlcyBvbmx5IHRoYXQsIG5vdCBvdGhlciBwcm9wc1xudmFyIEVWRU5UX1VJX1JFRklORVJTID0ge1xuICAgIGRpc3BsYXk6IFN0cmluZyxcbiAgICBlZGl0YWJsZTogQm9vbGVhbixcbiAgICBzdGFydEVkaXRhYmxlOiBCb29sZWFuLFxuICAgIGR1cmF0aW9uRWRpdGFibGU6IEJvb2xlYW4sXG4gICAgY29uc3RyYWludDogaWRlbnRpdHksXG4gICAgb3ZlcmxhcDogaWRlbnRpdHksXG4gICAgYWxsb3c6IGlkZW50aXR5LFxuICAgIGNsYXNzTmFtZTogcGFyc2VDbGFzc05hbWVzLFxuICAgIGNsYXNzTmFtZXM6IHBhcnNlQ2xhc3NOYW1lcyxcbiAgICBjb2xvcjogU3RyaW5nLFxuICAgIGJhY2tncm91bmRDb2xvcjogU3RyaW5nLFxuICAgIGJvcmRlckNvbG9yOiBTdHJpbmcsXG4gICAgdGV4dENvbG9yOiBTdHJpbmcsXG59O1xudmFyIEVNUFRZX0VWRU5UX1VJID0ge1xuICAgIGRpc3BsYXk6IG51bGwsXG4gICAgc3RhcnRFZGl0YWJsZTogbnVsbCxcbiAgICBkdXJhdGlvbkVkaXRhYmxlOiBudWxsLFxuICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICBvdmVybGFwOiBudWxsLFxuICAgIGFsbG93czogW10sXG4gICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICBib3JkZXJDb2xvcjogJycsXG4gICAgdGV4dENvbG9yOiAnJyxcbiAgICBjbGFzc05hbWVzOiBbXSxcbn07XG5mdW5jdGlvbiBjcmVhdGVFdmVudFVpKHJlZmluZWQsIGNvbnRleHQpIHtcbiAgICB2YXIgY29uc3RyYWludCA9IG5vcm1hbGl6ZUNvbnN0cmFpbnQocmVmaW5lZC5jb25zdHJhaW50LCBjb250ZXh0KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBkaXNwbGF5OiByZWZpbmVkLmRpc3BsYXkgfHwgbnVsbCxcbiAgICAgICAgc3RhcnRFZGl0YWJsZTogcmVmaW5lZC5zdGFydEVkaXRhYmxlICE9IG51bGwgPyByZWZpbmVkLnN0YXJ0RWRpdGFibGUgOiByZWZpbmVkLmVkaXRhYmxlLFxuICAgICAgICBkdXJhdGlvbkVkaXRhYmxlOiByZWZpbmVkLmR1cmF0aW9uRWRpdGFibGUgIT0gbnVsbCA/IHJlZmluZWQuZHVyYXRpb25FZGl0YWJsZSA6IHJlZmluZWQuZWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBjb25zdHJhaW50ICE9IG51bGwgPyBbY29uc3RyYWludF0gOiBbXSxcbiAgICAgICAgb3ZlcmxhcDogcmVmaW5lZC5vdmVybGFwICE9IG51bGwgPyByZWZpbmVkLm92ZXJsYXAgOiBudWxsLFxuICAgICAgICBhbGxvd3M6IHJlZmluZWQuYWxsb3cgIT0gbnVsbCA/IFtyZWZpbmVkLmFsbG93XSA6IFtdLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHJlZmluZWQuYmFja2dyb3VuZENvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgICAgIGJvcmRlckNvbG9yOiByZWZpbmVkLmJvcmRlckNvbG9yIHx8IHJlZmluZWQuY29sb3IgfHwgJycsXG4gICAgICAgIHRleHRDb2xvcjogcmVmaW5lZC50ZXh0Q29sb3IgfHwgJycsXG4gICAgICAgIGNsYXNzTmFtZXM6IChyZWZpbmVkLmNsYXNzTmFtZSB8fCBbXSkuY29uY2F0KHJlZmluZWQuY2xhc3NOYW1lcyB8fCBbXSksIC8vIGpvaW4gc2luZ3VsYXIgYW5kIHBsdXJhbFxuICAgIH07XG59XG4vLyBUT0RPOiBwcmV2ZW50IGFnYWluc3QgcHJvYmxlbXMgd2l0aCA8MiBhcmdzIVxuZnVuY3Rpb24gY29tYmluZUV2ZW50VWlzKHVpcykge1xuICAgIHJldHVybiB1aXMucmVkdWNlKGNvbWJpbmVUd29FdmVudFVpcywgRU1QVFlfRVZFTlRfVUkpO1xufVxuZnVuY3Rpb24gY29tYmluZVR3b0V2ZW50VWlzKGl0ZW0wLCBpdGVtMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3BsYXk6IGl0ZW0xLmRpc3BsYXkgIT0gbnVsbCA/IGl0ZW0xLmRpc3BsYXkgOiBpdGVtMC5kaXNwbGF5LFxuICAgICAgICBzdGFydEVkaXRhYmxlOiBpdGVtMS5zdGFydEVkaXRhYmxlICE9IG51bGwgPyBpdGVtMS5zdGFydEVkaXRhYmxlIDogaXRlbTAuc3RhcnRFZGl0YWJsZSxcbiAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogaXRlbTEuZHVyYXRpb25FZGl0YWJsZSAhPSBudWxsID8gaXRlbTEuZHVyYXRpb25FZGl0YWJsZSA6IGl0ZW0wLmR1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgIGNvbnN0cmFpbnRzOiBpdGVtMC5jb25zdHJhaW50cy5jb25jYXQoaXRlbTEuY29uc3RyYWludHMpLFxuICAgICAgICBvdmVybGFwOiB0eXBlb2YgaXRlbTEub3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gaXRlbTEub3ZlcmxhcCA6IGl0ZW0wLm92ZXJsYXAsXG4gICAgICAgIGFsbG93czogaXRlbTAuYWxsb3dzLmNvbmNhdChpdGVtMS5hbGxvd3MpLFxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGl0ZW0xLmJhY2tncm91bmRDb2xvciB8fCBpdGVtMC5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgIGJvcmRlckNvbG9yOiBpdGVtMS5ib3JkZXJDb2xvciB8fCBpdGVtMC5ib3JkZXJDb2xvcixcbiAgICAgICAgdGV4dENvbG9yOiBpdGVtMS50ZXh0Q29sb3IgfHwgaXRlbTAudGV4dENvbG9yLFxuICAgICAgICBjbGFzc05hbWVzOiBpdGVtMC5jbGFzc05hbWVzLmNvbmNhdChpdGVtMS5jbGFzc05hbWVzKSxcbiAgICB9O1xufVxuXG52YXIgRVZFTlRfTk9OX0RBVEVfUkVGSU5FUlMgPSB7XG4gICAgaWQ6IFN0cmluZyxcbiAgICBncm91cElkOiBTdHJpbmcsXG4gICAgdGl0bGU6IFN0cmluZyxcbiAgICB1cmw6IFN0cmluZyxcbiAgICBpbnRlcmFjdGl2ZTogQm9vbGVhbixcbn07XG52YXIgRVZFTlRfREFURV9SRUZJTkVSUyA9IHtcbiAgICBzdGFydDogaWRlbnRpdHksXG4gICAgZW5kOiBpZGVudGl0eSxcbiAgICBkYXRlOiBpZGVudGl0eSxcbiAgICBhbGxEYXk6IEJvb2xlYW4sXG59O1xudmFyIEVWRU5UX1JFRklORVJTID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSwgRVZFTlRfREFURV9SRUZJTkVSUyksIHsgZXh0ZW5kZWRQcm9wczogaWRlbnRpdHkgfSk7XG5mdW5jdGlvbiBwYXJzZUV2ZW50KHJhdywgZXZlbnRTb3VyY2UsIGNvbnRleHQsIGFsbG93T3BlblJhbmdlLCByZWZpbmVycykge1xuICAgIGlmIChyZWZpbmVycyA9PT0gdm9pZCAwKSB7IHJlZmluZXJzID0gYnVpbGRFdmVudFJlZmluZXJzKGNvbnRleHQpOyB9XG4gICAgdmFyIF9hID0gcmVmaW5lRXZlbnREZWYocmF3LCBjb250ZXh0LCByZWZpbmVycyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgIHZhciBkZWZhdWx0QWxsRGF5ID0gY29tcHV0ZUlzRGVmYXVsdEFsbERheShldmVudFNvdXJjZSwgY29udGV4dCk7XG4gICAgdmFyIHJlY3VycmluZ1JlcyA9IHBhcnNlUmVjdXJyaW5nKHJlZmluZWQsIGRlZmF1bHRBbGxEYXksIGNvbnRleHQuZGF0ZUVudiwgY29udGV4dC5wbHVnaW5Ib29rcy5yZWN1cnJpbmdUeXBlcyk7XG4gICAgaWYgKHJlY3VycmluZ1Jlcykge1xuICAgICAgICB2YXIgZGVmID0gcGFyc2VFdmVudERlZihyZWZpbmVkLCBleHRyYSwgZXZlbnRTb3VyY2UgPyBldmVudFNvdXJjZS5zb3VyY2VJZCA6ICcnLCByZWN1cnJpbmdSZXMuYWxsRGF5LCBCb29sZWFuKHJlY3VycmluZ1Jlcy5kdXJhdGlvbiksIGNvbnRleHQpO1xuICAgICAgICBkZWYucmVjdXJyaW5nRGVmID0ge1xuICAgICAgICAgICAgdHlwZUlkOiByZWN1cnJpbmdSZXMudHlwZUlkLFxuICAgICAgICAgICAgdHlwZURhdGE6IHJlY3VycmluZ1Jlcy50eXBlRGF0YSxcbiAgICAgICAgICAgIGR1cmF0aW9uOiByZWN1cnJpbmdSZXMuZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRlZjogZGVmLCBpbnN0YW5jZTogbnVsbCB9O1xuICAgIH1cbiAgICB2YXIgc2luZ2xlUmVzID0gcGFyc2VTaW5nbGUocmVmaW5lZCwgZGVmYXVsdEFsbERheSwgY29udGV4dCwgYWxsb3dPcGVuUmFuZ2UpO1xuICAgIGlmIChzaW5nbGVSZXMpIHtcbiAgICAgICAgdmFyIGRlZiA9IHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2Uuc291cmNlSWQgOiAnJywgc2luZ2xlUmVzLmFsbERheSwgc2luZ2xlUmVzLmhhc0VuZCwgY29udGV4dCk7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2UoZGVmLmRlZklkLCBzaW5nbGVSZXMucmFuZ2UsIHNpbmdsZVJlcy5mb3JjZWRTdGFydFR6bywgc2luZ2xlUmVzLmZvcmNlZEVuZFR6byk7XG4gICAgICAgIHJldHVybiB7IGRlZjogZGVmLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiByZWZpbmVFdmVudERlZihyYXcsIGNvbnRleHQsIHJlZmluZXJzKSB7XG4gICAgaWYgKHJlZmluZXJzID09PSB2b2lkIDApIHsgcmVmaW5lcnMgPSBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCk7IH1cbiAgICByZXR1cm4gcmVmaW5lUHJvcHMocmF3LCByZWZpbmVycyk7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9SRUZJTkVSUyksIGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRSZWZpbmVycyk7XG59XG4vKlxuV2lsbCBOT1QgcG9wdWxhdGUgZXh0ZW5kZWRQcm9wcyB3aXRoIHRoZSBsZWZ0b3ZlciBwcm9wZXJ0aWVzLlxuV2lsbCBOT1QgcG9wdWxhdGUgZGF0ZS1yZWxhdGVkIHByb3BzLlxuKi9cbmZ1bmN0aW9uIHBhcnNlRXZlbnREZWYocmVmaW5lZCwgZXh0cmEsIHNvdXJjZUlkLCBhbGxEYXksIGhhc0VuZCwgY29udGV4dCkge1xuICAgIHZhciBkZWYgPSB7XG4gICAgICAgIHRpdGxlOiByZWZpbmVkLnRpdGxlIHx8ICcnLFxuICAgICAgICBncm91cElkOiByZWZpbmVkLmdyb3VwSWQgfHwgJycsXG4gICAgICAgIHB1YmxpY0lkOiByZWZpbmVkLmlkIHx8ICcnLFxuICAgICAgICB1cmw6IHJlZmluZWQudXJsIHx8ICcnLFxuICAgICAgICByZWN1cnJpbmdEZWY6IG51bGwsXG4gICAgICAgIGRlZklkOiBndWlkKCksXG4gICAgICAgIHNvdXJjZUlkOiBzb3VyY2VJZCxcbiAgICAgICAgYWxsRGF5OiBhbGxEYXksXG4gICAgICAgIGhhc0VuZDogaGFzRW5kLFxuICAgICAgICBpbnRlcmFjdGl2ZTogcmVmaW5lZC5pbnRlcmFjdGl2ZSxcbiAgICAgICAgdWk6IGNyZWF0ZUV2ZW50VWkocmVmaW5lZCwgY29udGV4dCksXG4gICAgICAgIGV4dGVuZGVkUHJvcHM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCAocmVmaW5lZC5leHRlbmRlZFByb3BzIHx8IHt9KSksIGV4dHJhKSxcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50RGVmTWVtYmVyQWRkZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgbWVtYmVyQWRkZXIgPSBfYVtfaV07XG4gICAgICAgIHRzbGliLl9fYXNzaWduKGRlZiwgbWVtYmVyQWRkZXIocmVmaW5lZCkpO1xuICAgIH1cbiAgICAvLyBoZWxwIG91dCBFdmVudEFwaSBmcm9tIGhhdmluZyB1c2VyIG1vZGlmeSBwcm9wc1xuICAgIE9iamVjdC5mcmVlemUoZGVmLnVpLmNsYXNzTmFtZXMpO1xuICAgIE9iamVjdC5mcmVlemUoZGVmLmV4dGVuZGVkUHJvcHMpO1xuICAgIHJldHVybiBkZWY7XG59XG5mdW5jdGlvbiBwYXJzZVNpbmdsZShyZWZpbmVkLCBkZWZhdWx0QWxsRGF5LCBjb250ZXh0LCBhbGxvd09wZW5SYW5nZSkge1xuICAgIHZhciBhbGxEYXkgPSByZWZpbmVkLmFsbERheTtcbiAgICB2YXIgc3RhcnRNZXRhO1xuICAgIHZhciBzdGFydE1hcmtlciA9IG51bGw7XG4gICAgdmFyIGhhc0VuZCA9IGZhbHNlO1xuICAgIHZhciBlbmRNZXRhO1xuICAgIHZhciBlbmRNYXJrZXIgPSBudWxsO1xuICAgIHZhciBzdGFydElucHV0ID0gcmVmaW5lZC5zdGFydCAhPSBudWxsID8gcmVmaW5lZC5zdGFydCA6IHJlZmluZWQuZGF0ZTtcbiAgICBzdGFydE1ldGEgPSBjb250ZXh0LmRhdGVFbnYuY3JlYXRlTWFya2VyTWV0YShzdGFydElucHV0KTtcbiAgICBpZiAoc3RhcnRNZXRhKSB7XG4gICAgICAgIHN0YXJ0TWFya2VyID0gc3RhcnRNZXRhLm1hcmtlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAocmVmaW5lZC5lbmQgIT0gbnVsbCkge1xuICAgICAgICBlbmRNZXRhID0gY29udGV4dC5kYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEocmVmaW5lZC5lbmQpO1xuICAgIH1cbiAgICBpZiAoYWxsRGF5ID09IG51bGwpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRBbGxEYXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgYWxsRGF5ID0gZGVmYXVsdEFsbERheTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byB0aGUgZGF0ZSBwcm9wcyBMQVNUXG4gICAgICAgICAgICBhbGxEYXkgPSAoIXN0YXJ0TWV0YSB8fCBzdGFydE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpICYmXG4gICAgICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhbGxEYXkgJiYgc3RhcnRNYXJrZXIpIHtcbiAgICAgICAgc3RhcnRNYXJrZXIgPSBzdGFydE9mRGF5KHN0YXJ0TWFya2VyKTtcbiAgICB9XG4gICAgaWYgKGVuZE1ldGEpIHtcbiAgICAgICAgZW5kTWFya2VyID0gZW5kTWV0YS5tYXJrZXI7XG4gICAgICAgIGlmIChhbGxEYXkpIHtcbiAgICAgICAgICAgIGVuZE1hcmtlciA9IHN0YXJ0T2ZEYXkoZW5kTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyIDw9IHN0YXJ0TWFya2VyKSB7XG4gICAgICAgICAgICBlbmRNYXJrZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlbmRNYXJrZXIpIHtcbiAgICAgICAgaGFzRW5kID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWFsbG93T3BlblJhbmdlKSB7XG4gICAgICAgIGhhc0VuZCA9IGNvbnRleHQub3B0aW9ucy5mb3JjZUV2ZW50RHVyYXRpb24gfHwgZmFsc2U7XG4gICAgICAgIGVuZE1hcmtlciA9IGNvbnRleHQuZGF0ZUVudi5hZGQoc3RhcnRNYXJrZXIsIGFsbERheSA/XG4gICAgICAgICAgICBjb250ZXh0Lm9wdGlvbnMuZGVmYXVsdEFsbERheUV2ZW50RHVyYXRpb24gOlxuICAgICAgICAgICAgY29udGV4dC5vcHRpb25zLmRlZmF1bHRUaW1lZEV2ZW50RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbGxEYXk6IGFsbERheSxcbiAgICAgICAgaGFzRW5kOiBoYXNFbmQsXG4gICAgICAgIHJhbmdlOiB7IHN0YXJ0OiBzdGFydE1hcmtlciwgZW5kOiBlbmRNYXJrZXIgfSxcbiAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5mb3JjZWRUem8gOiBudWxsLFxuICAgICAgICBmb3JjZWRFbmRUem86IGVuZE1ldGEgPyBlbmRNZXRhLmZvcmNlZFR6byA6IG51bGwsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc0RlZmF1bHRBbGxEYXkoZXZlbnRTb3VyY2UsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzID0gbnVsbDtcbiAgICBpZiAoZXZlbnRTb3VyY2UpIHtcbiAgICAgICAgcmVzID0gZXZlbnRTb3VyY2UuZGVmYXVsdEFsbERheTtcbiAgICB9XG4gICAgaWYgKHJlcyA9PSBudWxsKSB7XG4gICAgICAgIHJlcyA9IGNvbnRleHQub3B0aW9ucy5kZWZhdWx0QWxsRGF5O1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vKiBEYXRlIHN0dWZmIHRoYXQgZG9lc24ndCBiZWxvbmcgaW4gZGF0ZWxpYiBjb3JlXG4tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbi8vIGdpdmVuIGEgdGltZWQgcmFuZ2UsIGNvbXB1dGVzIGFuIGFsbC1kYXkgcmFuZ2UgdGhhdCBoYXMgdGhlIHNhbWUgZXhhY3QgZHVyYXRpb24sXG4vLyBidXQgd2hvc2Ugc3RhcnQgdGltZSBpcyBhbGlnbmVkIHdpdGggdGhlIHN0YXJ0IG9mIHRoZSBkYXkuXG5mdW5jdGlvbiBjb21wdXRlQWxpZ25lZERheVJhbmdlKHRpbWVkUmFuZ2UpIHtcbiAgICB2YXIgZGF5Q250ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aW1lZFJhbmdlLnN0YXJ0LCB0aW1lZFJhbmdlLmVuZCkpIHx8IDE7XG4gICAgdmFyIHN0YXJ0ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gYWRkRGF5cyhzdGFydCwgZGF5Q250KTtcbiAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG59XG4vLyBnaXZlbiBhIHRpbWVkIHJhbmdlLCBjb21wdXRlcyBhbiBhbGwtZGF5IHJhbmdlIGJhc2VkIG9uIGhvdyBmb3IgdGhlIGVuZCBkYXRlIGJsZWVkcyBpbnRvIHRoZSBuZXh0IGRheVxuLy8gVE9ETzogZ2l2ZSBuZXh0RGF5VGhyZXNob2xkIGEgZGVmYXVsdCBhcmdcbmZ1bmN0aW9uIGNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UodGltZWRSYW5nZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgIGlmIChuZXh0RGF5VGhyZXNob2xkID09PSB2b2lkIDApIHsgbmV4dERheVRocmVzaG9sZCA9IGNyZWF0ZUR1cmF0aW9uKDApOyB9XG4gICAgdmFyIHN0YXJ0RGF5ID0gbnVsbDtcbiAgICB2YXIgZW5kRGF5ID0gbnVsbDtcbiAgICBpZiAodGltZWRSYW5nZS5lbmQpIHtcbiAgICAgICAgZW5kRGF5ID0gc3RhcnRPZkRheSh0aW1lZFJhbmdlLmVuZCk7XG4gICAgICAgIHZhciBlbmRUaW1lTVMgPSB0aW1lZFJhbmdlLmVuZC52YWx1ZU9mKCkgLSBlbmREYXkudmFsdWVPZigpOyAvLyAjIG9mIG1pbGxpc2Vjb25kcyBpbnRvIGBlbmREYXlgXG4gICAgICAgIC8vIElmIHRoZSBlbmQgdGltZSBpcyBhY3R1YWxseSBpbmNsdXNpdmVseSBwYXJ0IG9mIHRoZSBuZXh0IGRheSBhbmQgaXMgZXF1YWwgdG8gb3JcbiAgICAgICAgLy8gYmV5b25kIHRoZSBuZXh0IGRheSB0aHJlc2hvbGQsIGFkanVzdCB0aGUgZW5kIHRvIGJlIHRoZSBleGNsdXNpdmUgZW5kIG9mIGBlbmREYXlgLlxuICAgICAgICAvLyBPdGhlcndpc2UsIGxlYXZpbmcgaXQgYXMgaW5jbHVzaXZlIHdpbGwgY2F1c2UgaXQgdG8gZXhjbHVkZSBgZW5kRGF5YC5cbiAgICAgICAgaWYgKGVuZFRpbWVNUyAmJiBlbmRUaW1lTVMgPj0gYXNSb3VnaE1zKG5leHREYXlUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICBlbmREYXkgPSBhZGREYXlzKGVuZERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRpbWVkUmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgc3RhcnREYXkgPSBzdGFydE9mRGF5KHRpbWVkUmFuZ2Uuc3RhcnQpOyAvLyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkYXkgdGhlIHJhbmdlIHN0YXJ0c1xuICAgICAgICAvLyBJZiBlbmQgaXMgd2l0aGluIGBzdGFydERheWAgYnV0IG5vdCBwYXN0IG5leHREYXlUaHJlc2hvbGQsIGFzc2lnbiB0aGUgZGVmYXVsdCBkdXJhdGlvbiBvZiBvbmUgZGF5LlxuICAgICAgICBpZiAoZW5kRGF5ICYmIGVuZERheSA8PSBzdGFydERheSkge1xuICAgICAgICAgICAgZW5kRGF5ID0gYWRkRGF5cyhzdGFydERheSwgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0RGF5LCBlbmQ6IGVuZERheSB9O1xufVxuLy8gc3BhbnMgZnJvbSBvbmUgZGF5IGludG8gYW5vdGhlcj9cbmZ1bmN0aW9uIGlzTXVsdGlEYXlSYW5nZShyYW5nZSkge1xuICAgIHZhciB2aXNpYmxlUmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlKHJhbmdlKTtcbiAgICByZXR1cm4gZGlmZkRheXModmlzaWJsZVJhbmdlLnN0YXJ0LCB2aXNpYmxlUmFuZ2UuZW5kKSA+IDE7XG59XG5mdW5jdGlvbiBkaWZmRGF0ZXMoZGF0ZTAsIGRhdGUxLCBkYXRlRW52LCBsYXJnZVVuaXQpIHtcbiAgICBpZiAobGFyZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUR1cmF0aW9uKGRhdGVFbnYuZGlmZldob2xlWWVhcnMoZGF0ZTAsIGRhdGUxKSwgJ3llYXInKTtcbiAgICB9XG4gICAgaWYgKGxhcmdlVW5pdCA9PT0gJ21vbnRoJykge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oZGF0ZUVudi5kaWZmV2hvbGVNb250aHMoZGF0ZTAsIGRhdGUxKSwgJ21vbnRoJyk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmRGF5QW5kVGltZShkYXRlMCwgZGF0ZTEpOyAvLyByZXR1cm5zIGEgZHVyYXRpb25cbn1cblxuZnVuY3Rpb24gcGFyc2VSYW5nZShpbnB1dCwgZGF0ZUVudikge1xuICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgdmFyIGVuZCA9IG51bGw7XG4gICAgaWYgKGlucHV0LnN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoaW5wdXQuc3RhcnQpO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuZW5kKSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGlucHV0LmVuZCk7XG4gICAgfVxuICAgIGlmICghc3RhcnQgJiYgIWVuZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHN0YXJ0ICYmIGVuZCAmJiBlbmQgPCBzdGFydCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xufVxuLy8gU0lERS1FRkZFQ1Q6IHdpbGwgbXV0YXRlIHJhbmdlcy5cbi8vIFdpbGwgcmV0dXJuIGEgbmV3IGFycmF5IHJlc3VsdC5cbmZ1bmN0aW9uIGludmVydFJhbmdlcyhyYW5nZXMsIGNvbnN0cmFpbnRSYW5nZSkge1xuICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IFtdO1xuICAgIHZhciBzdGFydCA9IGNvbnN0cmFpbnRSYW5nZS5zdGFydDsgLy8gdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgcmFuZ2UuIHRoZSBzdGFydCBvZiB0aGUgbmV3IHJhbmdlXG4gICAgdmFyIGk7XG4gICAgdmFyIGRhdGVSYW5nZTtcbiAgICAvLyByYW5nZXMgbmVlZCB0byBiZSBpbiBvcmRlci4gcmVxdWlyZWQgZm9yIG91ciBkYXRlLXdhbGtpbmcgYWxnb3JpdGhtXG4gICAgcmFuZ2VzLnNvcnQoY29tcGFyZVJhbmdlcyk7XG4gICAgZm9yIChpID0gMDsgaSA8IHJhbmdlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBkYXRlUmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIC8vIGFkZCB0aGUgc3BhbiBvZiB0aW1lIGJlZm9yZSB0aGUgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICAgICAgaWYgKGRhdGVSYW5nZS5zdGFydCA+IHN0YXJ0KSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgICAgICBpbnZlcnRlZFJhbmdlcy5wdXNoKHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGRhdGVSYW5nZS5zdGFydCB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZVJhbmdlLmVuZCA+IHN0YXJ0KSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVSYW5nZS5lbmQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBzcGFuIG9mIHRpbWUgYWZ0ZXIgdGhlIGxhc3QgZXZlbnQgKGlmIHRoZXJlIGlzIGFueSlcbiAgICBpZiAoc3RhcnQgPCBjb25zdHJhaW50UmFuZ2UuZW5kKSB7IC8vIGNvbXBhcmUgbWlsbGlzZWNvbmQgdGltZSAoc2tpcCBhbnkgYW1iaWcgbG9naWMpXG4gICAgICAgIGludmVydGVkUmFuZ2VzLnB1c2goeyBzdGFydDogc3RhcnQsIGVuZDogY29uc3RyYWludFJhbmdlLmVuZCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGludmVydGVkUmFuZ2VzO1xufVxuZnVuY3Rpb24gY29tcGFyZVJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIHJldHVybiByYW5nZTAuc3RhcnQudmFsdWVPZigpIC0gcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKTsgLy8gZWFybGllciByYW5nZXMgZ28gZmlyc3Rcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFJhbmdlcyhyYW5nZTAsIHJhbmdlMSkge1xuICAgIHZhciBzdGFydCA9IHJhbmdlMC5zdGFydCwgZW5kID0gcmFuZ2UwLmVuZDtcbiAgICB2YXIgbmV3UmFuZ2UgPSBudWxsO1xuICAgIGlmIChyYW5nZTEuc3RhcnQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBzdGFydCA9IHJhbmdlMS5zdGFydDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gbmV3IERhdGUoTWF0aC5tYXgoc3RhcnQudmFsdWVPZigpLCByYW5nZTEuc3RhcnQudmFsdWVPZigpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJhbmdlMS5lbmQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoZW5kID09PSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSByYW5nZTEuZW5kO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kID0gbmV3IERhdGUoTWF0aC5taW4oZW5kLnZhbHVlT2YoKSwgcmFuZ2UxLmVuZC52YWx1ZU9mKCkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3RhcnQgPT09IG51bGwgfHwgZW5kID09PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgIG5ld1JhbmdlID0geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBuZXdSYW5nZTtcbn1cbmZ1bmN0aW9uIHJhbmdlc0VxdWFsKHJhbmdlMCwgcmFuZ2UxKSB7XG4gICAgcmV0dXJuIChyYW5nZTAuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLnN0YXJ0LnZhbHVlT2YoKSkgPT09IChyYW5nZTEuc3RhcnQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UxLnN0YXJ0LnZhbHVlT2YoKSkgJiZcbiAgICAgICAgKHJhbmdlMC5lbmQgPT09IG51bGwgPyBudWxsIDogcmFuZ2UwLmVuZC52YWx1ZU9mKCkpID09PSAocmFuZ2UxLmVuZCA9PT0gbnVsbCA/IG51bGwgOiByYW5nZTEuZW5kLnZhbHVlT2YoKSk7XG59XG5mdW5jdGlvbiByYW5nZXNJbnRlcnNlY3QocmFuZ2UwLCByYW5nZTEpIHtcbiAgICByZXR1cm4gKHJhbmdlMC5lbmQgPT09IG51bGwgfHwgcmFuZ2UxLnN0YXJ0ID09PSBudWxsIHx8IHJhbmdlMC5lbmQgPiByYW5nZTEuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZTAuc3RhcnQgPT09IG51bGwgfHwgcmFuZ2UxLmVuZCA9PT0gbnVsbCB8fCByYW5nZTAuc3RhcnQgPCByYW5nZTEuZW5kKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSB7XG4gICAgcmV0dXJuIChvdXRlclJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IChpbm5lclJhbmdlLnN0YXJ0ICE9PSBudWxsICYmIGlubmVyUmFuZ2Uuc3RhcnQgPj0gb3V0ZXJSYW5nZS5zdGFydCkpICYmXG4gICAgICAgIChvdXRlclJhbmdlLmVuZCA9PT0gbnVsbCB8fCAoaW5uZXJSYW5nZS5lbmQgIT09IG51bGwgJiYgaW5uZXJSYW5nZS5lbmQgPD0gb3V0ZXJSYW5nZS5lbmQpKTtcbn1cbmZ1bmN0aW9uIHJhbmdlQ29udGFpbnNNYXJrZXIocmFuZ2UsIGRhdGUpIHtcbiAgICByZXR1cm4gKHJhbmdlLnN0YXJ0ID09PSBudWxsIHx8IGRhdGUgPj0gcmFuZ2Uuc3RhcnQpICYmXG4gICAgICAgIChyYW5nZS5lbmQgPT09IG51bGwgfHwgZGF0ZSA8IHJhbmdlLmVuZCk7XG59XG4vLyBJZiB0aGUgZ2l2ZW4gZGF0ZSBpcyBub3Qgd2l0aGluIHRoZSBnaXZlbiByYW5nZSwgbW92ZSBpdCBpbnNpZGUuXG4vLyAoSWYgaXQncyBwYXN0IHRoZSBlbmQsIG1ha2UgaXQgb25lIG1pbGxpc2Vjb25kIGJlZm9yZSB0aGUgZW5kKS5cbmZ1bmN0aW9uIGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoZGF0ZSwgcmFuZ2UpIHtcbiAgICBpZiAocmFuZ2Uuc3RhcnQgIT0gbnVsbCAmJiBkYXRlIDwgcmFuZ2Uuc3RhcnQpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlLnN0YXJ0O1xuICAgIH1cbiAgICBpZiAocmFuZ2UuZW5kICE9IG51bGwgJiYgZGF0ZSA+PSByYW5nZS5lbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHJhbmdlLmVuZC52YWx1ZU9mKCkgLSAxKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGU7XG59XG5cbi8qXG5TcGVjaWZ5aW5nIG5leHREYXlUaHJlc2hvbGQgc2lnbmFscyB0aGF0IGFsbC1kYXkgcmFuZ2VzIHNob3VsZCBiZSBzbGljZWQuXG4qL1xuZnVuY3Rpb24gc2xpY2VFdmVudFN0b3JlKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZnJhbWluZ1JhbmdlLCBuZXh0RGF5VGhyZXNob2xkKSB7XG4gICAgdmFyIGludmVyc2VCZ0J5R3JvdXBJZCA9IHt9O1xuICAgIHZhciBpbnZlcnNlQmdCeURlZklkID0ge307XG4gICAgdmFyIGRlZkJ5R3JvdXBJZCA9IHt9O1xuICAgIHZhciBiZ1JhbmdlcyA9IFtdO1xuICAgIHZhciBmZ1JhbmdlcyA9IFtdO1xuICAgIHZhciBldmVudFVpcyA9IGNvbXBpbGVFdmVudFVpcyhldmVudFN0b3JlLmRlZnMsIGV2ZW50VWlCYXNlcyk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICB2YXIgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICBpZiAodWkuZGlzcGxheSA9PT0gJ2ludmVyc2UtYmFja2dyb3VuZCcpIHtcbiAgICAgICAgICAgIGlmIChkZWYuZ3JvdXBJZCkge1xuICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0gPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZkJ5R3JvdXBJZFtkZWYuZ3JvdXBJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmQnlHcm91cElkW2RlZi5ncm91cElkXSA9IGRlZjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2RlZklkXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICB2YXIgdWkgPSBldmVudFVpc1tkZWYuZGVmSWRdO1xuICAgICAgICB2YXIgb3JpZ1JhbmdlID0gaW5zdGFuY2UucmFuZ2U7XG4gICAgICAgIHZhciBub3JtYWxSYW5nZSA9ICghZGVmLmFsbERheSAmJiBuZXh0RGF5VGhyZXNob2xkKSA/XG4gICAgICAgICAgICBjb21wdXRlVmlzaWJsZURheVJhbmdlKG9yaWdSYW5nZSwgbmV4dERheVRocmVzaG9sZCkgOlxuICAgICAgICAgICAgb3JpZ1JhbmdlO1xuICAgICAgICB2YXIgc2xpY2VkUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMobm9ybWFsUmFuZ2UsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGlmIChzbGljZWRSYW5nZSkge1xuICAgICAgICAgICAgaWYgKHVpLmRpc3BsYXkgPT09ICdpbnZlcnNlLWJhY2tncm91bmQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGludmVyc2VCZ0J5R3JvdXBJZFtkZWYuZ3JvdXBJZF0ucHVzaChzbGljZWRSYW5nZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbnZlcnNlQmdCeURlZklkW2luc3RhbmNlLmRlZklkXS5wdXNoKHNsaWNlZFJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1aS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgICAgICAodWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnID8gYmdSYW5nZXMgOiBmZ1JhbmdlcykucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGRlZjogZGVmLFxuICAgICAgICAgICAgICAgICAgICB1aTogdWksXG4gICAgICAgICAgICAgICAgICAgIGluc3RhbmNlOiBpbnN0YW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IHNsaWNlZFJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBpc1N0YXJ0OiBub3JtYWxSYW5nZS5zdGFydCAmJiBub3JtYWxSYW5nZS5zdGFydC52YWx1ZU9mKCkgPT09IHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICAgICAgICAgaXNFbmQ6IG5vcm1hbFJhbmdlLmVuZCAmJiBub3JtYWxSYW5nZS5lbmQudmFsdWVPZigpID09PSBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGdyb3VwSWQgaW4gaW52ZXJzZUJnQnlHcm91cElkKSB7IC8vIEJZIEdST1VQXG4gICAgICAgIHZhciByYW5nZXMgPSBpbnZlcnNlQmdCeUdyb3VwSWRbZ3JvdXBJZF07XG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgaW52ZXJ0ZWRSYW5nZXNfMSA9IGludmVydGVkUmFuZ2VzOyBfaSA8IGludmVydGVkUmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZSA9IGludmVydGVkUmFuZ2VzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIGRlZiA9IGRlZkJ5R3JvdXBJZFtncm91cElkXTtcbiAgICAgICAgICAgIHZhciB1aSA9IGV2ZW50VWlzW2RlZi5kZWZJZF07XG4gICAgICAgICAgICBiZ1Jhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBkZWY6IGRlZixcbiAgICAgICAgICAgICAgICB1aTogdWksXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gaW52ZXJzZUJnQnlEZWZJZCkge1xuICAgICAgICB2YXIgcmFuZ2VzID0gaW52ZXJzZUJnQnlEZWZJZFtkZWZJZF07XG4gICAgICAgIHZhciBpbnZlcnRlZFJhbmdlcyA9IGludmVydFJhbmdlcyhyYW5nZXMsIGZyYW1pbmdSYW5nZSk7XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgaW52ZXJ0ZWRSYW5nZXNfMiA9IGludmVydGVkUmFuZ2VzOyBfYSA8IGludmVydGVkUmFuZ2VzXzIubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgaW52ZXJ0ZWRSYW5nZSA9IGludmVydGVkUmFuZ2VzXzJbX2FdO1xuICAgICAgICAgICAgYmdSYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZGVmOiBldmVudFN0b3JlLmRlZnNbZGVmSWRdLFxuICAgICAgICAgICAgICAgIHVpOiBldmVudFVpc1tkZWZJZF0sXG4gICAgICAgICAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGludmVydGVkUmFuZ2UsXG4gICAgICAgICAgICAgICAgaXNTdGFydDogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNFbmQ6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgYmc6IGJnUmFuZ2VzLCBmZzogZmdSYW5nZXMgfTtcbn1cbmZ1bmN0aW9uIGhhc0JnUmVuZGVyaW5nKGRlZikge1xuICAgIHJldHVybiBkZWYudWkuZGlzcGxheSA9PT0gJ2JhY2tncm91bmQnIHx8IGRlZi51aS5kaXNwbGF5ID09PSAnaW52ZXJzZS1iYWNrZ3JvdW5kJztcbn1cbmZ1bmN0aW9uIHNldEVsU2VnKGVsLCBzZWcpIHtcbiAgICBlbC5mY1NlZyA9IHNlZztcbn1cbmZ1bmN0aW9uIGdldEVsU2VnKGVsKSB7XG4gICAgcmV0dXJuIGVsLmZjU2VnIHx8XG4gICAgICAgIGVsLnBhcmVudE5vZGUuZmNTZWcgfHwgLy8gZm9yIHRoZSBoYXJuZXNzXG4gICAgICAgIG51bGw7XG59XG4vLyBldmVudCB1aSBjb21wdXRhdGlvblxuZnVuY3Rpb24gY29tcGlsZUV2ZW50VWlzKGV2ZW50RGVmcywgZXZlbnRVaUJhc2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnREZWZzLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpOyB9KTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVFdmVudFVpKGV2ZW50RGVmLCBldmVudFVpQmFzZXMpIHtcbiAgICB2YXIgdWlzID0gW107XG4gICAgaWYgKGV2ZW50VWlCYXNlc1snJ10pIHtcbiAgICAgICAgdWlzLnB1c2goZXZlbnRVaUJhc2VzWycnXSk7XG4gICAgfVxuICAgIGlmIChldmVudFVpQmFzZXNbZXZlbnREZWYuZGVmSWRdKSB7XG4gICAgICAgIHVpcy5wdXNoKGV2ZW50VWlCYXNlc1tldmVudERlZi5kZWZJZF0pO1xuICAgIH1cbiAgICB1aXMucHVzaChldmVudERlZi51aSk7XG4gICAgcmV0dXJuIGNvbWJpbmVFdmVudFVpcyh1aXMpO1xufVxuZnVuY3Rpb24gc29ydEV2ZW50U2VncyhzZWdzLCBldmVudE9yZGVyU3BlY3MpIHtcbiAgICB2YXIgb2JqcyA9IHNlZ3MubWFwKGJ1aWxkU2VnQ29tcGFyZU9iaik7XG4gICAgb2Jqcy5zb3J0KGZ1bmN0aW9uIChvYmowLCBvYmoxKSB7IHJldHVybiBjb21wYXJlQnlGaWVsZFNwZWNzKG9iajAsIG9iajEsIGV2ZW50T3JkZXJTcGVjcyk7IH0pO1xuICAgIHJldHVybiBvYmpzLm1hcChmdW5jdGlvbiAoYykgeyByZXR1cm4gYy5fc2VnOyB9KTtcbn1cbi8vIHJldHVybnMgYSBvYmplY3Qgd2l0aCBhbGwgcHJpbWl0aXZlIHByb3BzIHRoYXQgY2FuIGJlIGNvbXBhcmVkXG5mdW5jdGlvbiBidWlsZFNlZ0NvbXBhcmVPYmooc2VnKSB7XG4gICAgdmFyIGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICB2YXIgZXZlbnREZWYgPSBldmVudFJhbmdlLmRlZjtcbiAgICB2YXIgcmFuZ2UgPSBldmVudFJhbmdlLmluc3RhbmNlID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5yYW5nZSA6IGV2ZW50UmFuZ2UucmFuZ2U7XG4gICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQgPyByYW5nZS5zdGFydC52YWx1ZU9mKCkgOiAwOyAvLyBUT0RPOiBiZXR0ZXIgc3VwcG9ydCBmb3Igb3Blbi1yYW5nZSBldmVudHNcbiAgICB2YXIgZW5kID0gcmFuZ2UuZW5kID8gcmFuZ2UuZW5kLnZhbHVlT2YoKSA6IDA7IC8vIFwiXG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudERlZi5leHRlbmRlZFByb3BzKSwgZXZlbnREZWYpLCB7IGlkOiBldmVudERlZi5wdWJsaWNJZCwgc3RhcnQ6IHN0YXJ0LFxuICAgICAgICBlbmQ6IGVuZCwgZHVyYXRpb246IGVuZCAtIHN0YXJ0LCBhbGxEYXk6IE51bWJlcihldmVudERlZi5hbGxEYXkpLCBfc2VnOiBzZWcgfSk7XG59XG5mdW5jdGlvbiBjb21wdXRlU2VnRHJhZ2dhYmxlKHNlZywgY29udGV4dCkge1xuICAgIHZhciBwbHVnaW5Ib29rcyA9IGNvbnRleHQucGx1Z2luSG9va3M7XG4gICAgdmFyIHRyYW5zZm9ybWVycyA9IHBsdWdpbkhvb2tzLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzO1xuICAgIHZhciBfYSA9IHNlZy5ldmVudFJhbmdlLCBkZWYgPSBfYS5kZWYsIHVpID0gX2EudWk7XG4gICAgdmFyIHZhbCA9IHVpLnN0YXJ0RWRpdGFibGU7XG4gICAgZm9yICh2YXIgX2kgPSAwLCB0cmFuc2Zvcm1lcnNfMSA9IHRyYW5zZm9ybWVyczsgX2kgPCB0cmFuc2Zvcm1lcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybWVyID0gdHJhbnNmb3JtZXJzXzFbX2ldO1xuICAgICAgICB2YWwgPSB0cmFuc2Zvcm1lcih2YWwsIGRlZiwgdWksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsO1xufVxuZnVuY3Rpb24gY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCkge1xuICAgIHJldHVybiBzZWcuaXNTdGFydCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlICYmIGNvbnRleHQub3B0aW9ucy5ldmVudFJlc2l6YWJsZUZyb21TdGFydDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTZWdFbmRSZXNpemFibGUoc2VnLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIHNlZy5pc0VuZCAmJiBzZWcuZXZlbnRSYW5nZS51aS5kdXJhdGlvbkVkaXRhYmxlO1xufVxuZnVuY3Rpb24gYnVpbGRTZWdUaW1lVGV4dChzZWcsIHRpbWVGb3JtYXQsIGNvbnRleHQsIGRlZmF1bHREaXNwbGF5RXZlbnRUaW1lLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5kZWZhdWx0RGlzcGxheUV2ZW50RW5kLCAvLyBkZWZhdWx0cyB0byB0cnVlXG5zdGFydE92ZXJyaWRlLCBlbmRPdmVycmlkZSkge1xuICAgIHZhciBkYXRlRW52ID0gY29udGV4dC5kYXRlRW52LCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgIHZhciBkaXNwbGF5RXZlbnRUaW1lID0gb3B0aW9ucy5kaXNwbGF5RXZlbnRUaW1lLCBkaXNwbGF5RXZlbnRFbmQgPSBvcHRpb25zLmRpc3BsYXlFdmVudEVuZDtcbiAgICB2YXIgZXZlbnREZWYgPSBzZWcuZXZlbnRSYW5nZS5kZWY7XG4gICAgdmFyIGV2ZW50SW5zdGFuY2UgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZTtcbiAgICBpZiAoZGlzcGxheUV2ZW50VGltZSA9PSBudWxsKSB7XG4gICAgICAgIGRpc3BsYXlFdmVudFRpbWUgPSBkZWZhdWx0RGlzcGxheUV2ZW50VGltZSAhPT0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgPT0gbnVsbCkge1xuICAgICAgICBkaXNwbGF5RXZlbnRFbmQgPSBkZWZhdWx0RGlzcGxheUV2ZW50RW5kICE9PSBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHdob2xlRXZlbnRTdGFydCA9IGV2ZW50SW5zdGFuY2UucmFuZ2Uuc3RhcnQ7XG4gICAgdmFyIHdob2xlRXZlbnRFbmQgPSBldmVudEluc3RhbmNlLnJhbmdlLmVuZDtcbiAgICB2YXIgc2VnU3RhcnQgPSBzdGFydE92ZXJyaWRlIHx8IHNlZy5zdGFydCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbiAgICB2YXIgc2VnRW5kID0gZW5kT3ZlcnJpZGUgfHwgc2VnLmVuZCB8fCBzZWcuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG4gICAgdmFyIGlzU3RhcnREYXkgPSBzdGFydE9mRGF5KHdob2xlRXZlbnRTdGFydCkudmFsdWVPZigpID09PSBzdGFydE9mRGF5KHNlZ1N0YXJ0KS52YWx1ZU9mKCk7XG4gICAgdmFyIGlzRW5kRGF5ID0gc3RhcnRPZkRheShhZGRNcyh3aG9sZUV2ZW50RW5kLCAtMSkpLnZhbHVlT2YoKSA9PT0gc3RhcnRPZkRheShhZGRNcyhzZWdFbmQsIC0xKSkudmFsdWVPZigpO1xuICAgIGlmIChkaXNwbGF5RXZlbnRUaW1lICYmICFldmVudERlZi5hbGxEYXkgJiYgKGlzU3RhcnREYXkgfHwgaXNFbmREYXkpKSB7XG4gICAgICAgIHNlZ1N0YXJ0ID0gaXNTdGFydERheSA/IHdob2xlRXZlbnRTdGFydCA6IHNlZ1N0YXJ0O1xuICAgICAgICBzZWdFbmQgPSBpc0VuZERheSA/IHdob2xlRXZlbnRFbmQgOiBzZWdFbmQ7XG4gICAgICAgIGlmIChkaXNwbGF5RXZlbnRFbmQgJiYgZXZlbnREZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShzZWdTdGFydCwgc2VnRW5kLCB0aW1lRm9ybWF0LCB7XG4gICAgICAgICAgICAgICAgZm9yY2VkU3RhcnRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgICAgICAgICBmb3JjZWRFbmRUem86IGVuZE92ZXJyaWRlID8gbnVsbCA6IGV2ZW50SW5zdGFuY2UuZm9yY2VkRW5kVHpvLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KHNlZ1N0YXJ0LCB0aW1lRm9ybWF0LCB7XG4gICAgICAgICAgICBmb3JjZWRUem86IHN0YXJ0T3ZlcnJpZGUgPyBudWxsIDogZXZlbnRJbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgLy8gbm9vb29vLCBzYW1lXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5mdW5jdGlvbiBnZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSwgbm93RGF0ZSkge1xuICAgIHZhciBzZWdSYW5nZSA9IHNlZy5ldmVudFJhbmdlLnJhbmdlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzUGFzdDogc2VnUmFuZ2UuZW5kIDwgKG5vd0RhdGUgfHwgdG9kYXlSYW5nZS5zdGFydCksXG4gICAgICAgIGlzRnV0dXJlOiBzZWdSYW5nZS5zdGFydCA+PSAobm93RGF0ZSB8fCB0b2RheVJhbmdlLmVuZCksXG4gICAgICAgIGlzVG9kYXk6IHRvZGF5UmFuZ2UgJiYgcmFuZ2VDb250YWluc01hcmtlcih0b2RheVJhbmdlLCBzZWdSYW5nZS5zdGFydCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV2ZW50Q2xhc3NOYW1lcyhwcm9wcykge1xuICAgIHZhciBjbGFzc05hbWVzID0gWydmYy1ldmVudCddO1xuICAgIGlmIChwcm9wcy5pc01pcnJvcikge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LW1pcnJvcicpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNEcmFnZ2FibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2FibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnRSZXNpemFibGUgfHwgcHJvcHMuaXNFbmRSZXNpemFibGUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1yZXNpemFibGUnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzRHJhZ2dpbmcpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1kcmFnZ2luZycpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNSZXNpemluZykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXJlc2l6aW5nJyk7XG4gICAgfVxuICAgIGlmIChwcm9wcy5pc1NlbGVjdGVkKSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZXZlbnQtc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzU3RhcnQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1zdGFydCcpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNFbmQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1lbmQnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzUGFzdCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWV2ZW50LXBhc3QnKTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmlzVG9kYXkpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC10b2RheScpO1xuICAgIH1cbiAgICBpZiAocHJvcHMuaXNGdXR1cmUpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1ldmVudC1mdXR1cmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50UmFuZ2VLZXkoZXZlbnRSYW5nZSkge1xuICAgIHJldHVybiBldmVudFJhbmdlLmluc3RhbmNlXG4gICAgICAgID8gZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXG4gICAgICAgIDogZXZlbnRSYW5nZS5kZWYuZGVmSWQgKyBcIjpcIiArIGV2ZW50UmFuZ2UucmFuZ2Uuc3RhcnQudG9JU09TdHJpbmcoKTtcbiAgICAvLyBpbnZlcnNlLWJhY2tncm91bmQgZXZlbnRzIGRvbid0IGhhdmUgc3BlY2lmaWMgaW5zdGFuY2VzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb25cbn1cbmZ1bmN0aW9uIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkge1xuICAgIHZhciBfYSA9IHNlZy5ldmVudFJhbmdlLCBkZWYgPSBfYS5kZWYsIGluc3RhbmNlID0gX2EuaW5zdGFuY2U7XG4gICAgdmFyIHVybCA9IGRlZi51cmw7XG4gICAgaWYgKHVybCkge1xuICAgICAgICByZXR1cm4geyBocmVmOiB1cmwgfTtcbiAgICB9XG4gICAgdmFyIGVtaXR0ZXIgPSBjb250ZXh0LmVtaXR0ZXIsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGV2ZW50SW50ZXJhY3RpdmUgPSBvcHRpb25zLmV2ZW50SW50ZXJhY3RpdmU7XG4gICAgaWYgKGV2ZW50SW50ZXJhY3RpdmUgPT0gbnVsbCkge1xuICAgICAgICBldmVudEludGVyYWN0aXZlID0gZGVmLmludGVyYWN0aXZlO1xuICAgICAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBldmVudEludGVyYWN0aXZlID0gQm9vbGVhbihlbWl0dGVyLmhhc0hhbmRsZXJzKCdldmVudENsaWNrJykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1vY2sgd2hhdCBoYXBwZW5zIGluIEV2ZW50Q2xpY2tpbmdcbiAgICBpZiAoZXZlbnRJbnRlcmFjdGl2ZSkge1xuICAgICAgICAvLyBvbmx5IGF0dGFjaCBrZXlib2FyZC1yZWxhdGVkIGhhbmRsZXJzIGJlY2F1c2UgY2xpY2sgaGFuZGxlciBpcyBhbHJlYWR5IGRvbmUgaW4gRXZlbnRDbGlja2luZ1xuICAgICAgICByZXR1cm4gY3JlYXRlQXJpYUtleWJvYXJkQXR0cnMoZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgZWw6IGV2LnRhcmdldCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIGRlZiwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHt9O1xufVxuXG52YXIgU1RBTkRBUkRfUFJPUFMgPSB7XG4gICAgc3RhcnQ6IGlkZW50aXR5LFxuICAgIGVuZDogaWRlbnRpdHksXG4gICAgYWxsRGF5OiBCb29sZWFuLFxufTtcbmZ1bmN0aW9uIHBhcnNlRGF0ZVNwYW4ocmF3LCBkYXRlRW52LCBkZWZhdWx0RHVyYXRpb24pIHtcbiAgICB2YXIgc3BhbiA9IHBhcnNlT3BlbkRhdGVTcGFuKHJhdywgZGF0ZUVudik7XG4gICAgdmFyIHJhbmdlID0gc3Bhbi5yYW5nZTtcbiAgICBpZiAoIXJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXJhbmdlLmVuZCkge1xuICAgICAgICBpZiAoZGVmYXVsdER1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJhbmdlLmVuZCA9IGRhdGVFbnYuYWRkKHJhbmdlLnN0YXJ0LCBkZWZhdWx0RHVyYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gc3Bhbjtcbn1cbi8qXG5UT0RPOiBzb21laG93IGNvbWJpbmUgd2l0aCBwYXJzZVJhbmdlP1xuV2lsbCByZXR1cm4gbnVsbCBpZiB0aGUgc3RhcnQvZW5kIHByb3BzIHdlcmUgcHJlc2VudCBidXQgcGFyc2VkIGludmFsaWRseS5cbiovXG5mdW5jdGlvbiBwYXJzZU9wZW5EYXRlU3BhbihyYXcsIGRhdGVFbnYpIHtcbiAgICB2YXIgX2EgPSByZWZpbmVQcm9wcyhyYXcsIFNUQU5EQVJEX1BST1BTKSwgc3RhbmRhcmRQcm9wcyA9IF9hLnJlZmluZWQsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgdmFyIHN0YXJ0TWV0YSA9IHN0YW5kYXJkUHJvcHMuc3RhcnQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5zdGFydCkgOiBudWxsO1xuICAgIHZhciBlbmRNZXRhID0gc3RhbmRhcmRQcm9wcy5lbmQgPyBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhbmRhcmRQcm9wcy5lbmQpIDogbnVsbDtcbiAgICB2YXIgYWxsRGF5ID0gc3RhbmRhcmRQcm9wcy5hbGxEYXk7XG4gICAgaWYgKGFsbERheSA9PSBudWxsKSB7XG4gICAgICAgIGFsbERheSA9IChzdGFydE1ldGEgJiYgc3RhcnRNZXRhLmlzVGltZVVuc3BlY2lmaWVkKSAmJlxuICAgICAgICAgICAgKCFlbmRNZXRhIHx8IGVuZE1ldGEuaXNUaW1lVW5zcGVjaWZpZWQpO1xuICAgIH1cbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24oeyByYW5nZToge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0TWV0YSA/IHN0YXJ0TWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICAgICAgZW5kOiBlbmRNZXRhID8gZW5kTWV0YS5tYXJrZXIgOiBudWxsLFxuICAgICAgICB9LCBhbGxEYXk6IGFsbERheSB9LCBleHRyYSk7XG59XG5mdW5jdGlvbiBpc0RhdGVTcGFuc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiByYW5nZXNFcXVhbChzcGFuMC5yYW5nZSwgc3BhbjEucmFuZ2UpICYmXG4gICAgICAgIHNwYW4wLmFsbERheSA9PT0gc3BhbjEuYWxsRGF5ICYmXG4gICAgICAgIGlzU3BhblByb3BzRXF1YWwoc3BhbjAsIHNwYW4xKTtcbn1cbi8vIHRoZSBOT04tREFURS1SRUxBVEVEIHByb3BzXG5mdW5jdGlvbiBpc1NwYW5Qcm9wc0VxdWFsKHNwYW4wLCBzcGFuMSkge1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHNwYW4xKSB7XG4gICAgICAgIGlmIChwcm9wTmFtZSAhPT0gJ3JhbmdlJyAmJiBwcm9wTmFtZSAhPT0gJ2FsbERheScpIHtcbiAgICAgICAgICAgIGlmIChzcGFuMFtwcm9wTmFtZV0gIT09IHNwYW4xW3Byb3BOYW1lXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBhcmUgdGhlcmUgYW55IHByb3BzIHRoYXQgc3BhbjAgaGFzIHRoYXQgc3BhbjEgRE9FU04nVCBoYXZlP1xuICAgIC8vIGJvdGggaGF2ZSByYW5nZS9hbGxEYXksIHNvIG5vIG5lZWQgdG8gc3BlY2lhbC1jYXNlLlxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHNwYW4wKSB7XG4gICAgICAgIGlmICghKHByb3BOYW1lIGluIHNwYW4xKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaShzcGFuLCBkYXRlRW52KSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHNwYW4ucmFuZ2UsIGRhdGVFbnYsIHNwYW4uYWxsRGF5KSksIHsgYWxsRGF5OiBzcGFuLmFsbERheSB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUocmFuZ2UsIGRhdGVFbnYsIG9taXRUaW1lKSB7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZFJhbmdlQXBpKHJhbmdlLCBkYXRlRW52LCBvbWl0VGltZSkpLCB7IHRpbWVab25lOiBkYXRlRW52LnRpbWVab25lIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRSYW5nZUFwaShyYW5nZSwgZGF0ZUVudiwgb21pdFRpbWUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICBlbmQ6IGRhdGVFbnYudG9EYXRlKHJhbmdlLmVuZCksXG4gICAgICAgIHN0YXJ0U3RyOiBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCwgeyBvbWl0VGltZTogb21pdFRpbWUgfSksXG4gICAgICAgIGVuZFN0cjogZGF0ZUVudi5mb3JtYXRJc28ocmFuZ2UuZW5kLCB7IG9taXRUaW1lOiBvbWl0VGltZSB9KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlcyA9IHJlZmluZUV2ZW50RGVmKHsgZWRpdGFibGU6IGZhbHNlIH0sIGNvbnRleHQpO1xuICAgIHZhciBkZWYgPSBwYXJzZUV2ZW50RGVmKHJlcy5yZWZpbmVkLCByZXMuZXh0cmEsICcnLCAvLyBzb3VyY2VJZFxuICAgIGRhdGVTcGFuLmFsbERheSwgdHJ1ZSwgLy8gaGFzRW5kXG4gICAgY29udGV4dCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmOiBkZWYsXG4gICAgICAgIHVpOiBjb21waWxlRXZlbnRVaShkZWYsIGV2ZW50VWlCYXNlcyksXG4gICAgICAgIGluc3RhbmNlOiBjcmVhdGVFdmVudEluc3RhbmNlKGRlZi5kZWZJZCwgZGF0ZVNwYW4ucmFuZ2UpLFxuICAgICAgICByYW5nZTogZGF0ZVNwYW4ucmFuZ2UsXG4gICAgICAgIGlzU3RhcnQ6IHRydWUsXG4gICAgICAgIGlzRW5kOiB0cnVlLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgcGV2LCBjb250ZXh0KSB7XG4gICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ3NlbGVjdCcsIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc2VsZWN0aW9uLCBjb250ZXh0KSksIHsganNFdmVudDogcGV2ID8gcGV2Lm9yaWdFdmVudCA6IG51bGwsIHZpZXc6IGNvbnRleHQudmlld0FwaSB8fCBjb250ZXh0LmNhbGVuZGFyQXBpLnZpZXcgfSkpO1xufVxuZnVuY3Rpb24gdHJpZ2dlckRhdGVVbnNlbGVjdChwZXYsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcigndW5zZWxlY3QnLCB7XG4gICAgICAgIGpzRXZlbnQ6IHBldiA/IHBldi5vcmlnRXZlbnQgOiBudWxsLFxuICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfHwgY29udGV4dC5jYWxlbmRhckFwaS52aWV3LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGREYXRlU3BhbkFwaVdpdGhDb250ZXh0KGRhdGVTcGFuLCBjb250ZXh0KSB7XG4gICAgdmFyIHByb3BzID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZGF0ZVNwYW5UcmFuc2Zvcm1zOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gX2FbX2ldO1xuICAgICAgICB0c2xpYi5fX2Fzc2lnbihwcm9wcywgdHJhbnNmb3JtKGRhdGVTcGFuLCBjb250ZXh0KSk7XG4gICAgfVxuICAgIHRzbGliLl9fYXNzaWduKHByb3BzLCBidWlsZERhdGVTcGFuQXBpKGRhdGVTcGFuLCBjb250ZXh0LmRhdGVFbnYpKTtcbiAgICByZXR1cm4gcHJvcHM7XG59XG4vLyBHaXZlbiBhbiBldmVudCdzIGFsbERheSBzdGF0dXMgYW5kIHN0YXJ0IGRhdGUsIHJldHVybiB3aGF0IGl0cyBmYWxsYmFjayBlbmQgZGF0ZSBzaG91bGQgYmUuXG4vLyBUT0RPOiByZW5hbWUgdG8gY29tcHV0ZURlZmF1bHRFdmVudEVuZFxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV2ZW50RW5kKGFsbERheSwgbWFya2VyLCBjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGVuZCA9IG1hcmtlcjtcbiAgICBpZiAoYWxsRGF5KSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0T2ZEYXkoZW5kKTtcbiAgICAgICAgZW5kID0gZGF0ZUVudi5hZGQoZW5kLCBvcHRpb25zLmRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKGVuZCwgb3B0aW9ucy5kZWZhdWx0VGltZWRFdmVudER1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZDtcbn1cblxuLy8gYXBwbGllcyB0aGUgbXV0YXRpb24gdG8gQUxMIGRlZnMvaW5zdGFuY2VzIHdpdGhpbiB0aGUgZXZlbnQgc3RvcmVcbmZ1bmN0aW9uIGFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBldmVudENvbmZpZ3MgPSBjb21waWxlRXZlbnRVaXMoZXZlbnRTdG9yZS5kZWZzLCBldmVudENvbmZpZ0Jhc2UpO1xuICAgIHZhciBkZXN0ID0gY3JlYXRlRW1wdHlFdmVudFN0b3JlKCk7XG4gICAgZm9yICh2YXIgZGVmSWQgaW4gZXZlbnRTdG9yZS5kZWZzKSB7XG4gICAgICAgIHZhciBkZWYgPSBldmVudFN0b3JlLmRlZnNbZGVmSWRdO1xuICAgICAgICBkZXN0LmRlZnNbZGVmSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZGVmLCBldmVudENvbmZpZ3NbZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gZXZlbnRTdG9yZS5pbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZXZlbnRTdG9yZS5pbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgIHZhciBkZWYgPSBkZXN0LmRlZnNbaW5zdGFuY2UuZGVmSWRdOyAvLyBpbXBvcnRhbnQgdG8gZ3JhYiB0aGUgbmV3bHkgbW9kaWZpZWQgZGVmXG4gICAgICAgIGRlc3QuaW5zdGFuY2VzW2luc3RhbmNlSWRdID0gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShpbnN0YW5jZSwgZGVmLCBldmVudENvbmZpZ3NbaW5zdGFuY2UuZGVmSWRdLCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnREZWYoZXZlbnREZWYsIGV2ZW50Q29uZmlnLCBtdXRhdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBzdGFuZGFyZFByb3BzID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyB8fCB7fTtcbiAgICAvLyBpZiBoYXNFbmQgaGFzIG5vdCBiZWVuIHNwZWNpZmllZCwgZ3Vlc3MgYSBnb29kIHZhbHVlIGJhc2VkIG9uIGRlbHRhcy5cbiAgICAvLyBpZiBkdXJhdGlvbiB3aWxsIGNoYW5nZSwgdGhlcmUncyBubyB3YXkgdGhlIGRlZmF1bHQgZHVyYXRpb24gd2lsbCBwZXJzaXN0LFxuICAgIC8vIGFuZCB0aHVzLCB3ZSBuZWVkIHRvIG1hcmsgdGhlIGV2ZW50IGFzIGhhdmluZyBhIHJlYWwgZW5kXG4gICAgaWYgKHN0YW5kYXJkUHJvcHMuaGFzRW5kID09IG51bGwgJiZcbiAgICAgICAgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSAmJlxuICAgICAgICAobXV0YXRpb24uc3RhcnREZWx0YSB8fCBtdXRhdGlvbi5lbmREZWx0YSkpIHtcbiAgICAgICAgc3RhbmRhcmRQcm9wcy5oYXNFbmQgPSB0cnVlOyAvLyBUT0RPOiBpcyB0aGlzIG11dGF0aW9uIG9rYXk/XG4gICAgfVxuICAgIHZhciBjb3B5ID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50RGVmKSwgc3RhbmRhcmRQcm9wcyksIHsgdWk6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudERlZi51aSksIHN0YW5kYXJkUHJvcHMudWkpIH0pO1xuICAgIGlmIChtdXRhdGlvbi5leHRlbmRlZFByb3BzKSB7XG4gICAgICAgIGNvcHkuZXh0ZW5kZWRQcm9wcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjb3B5LmV4dGVuZGVkUHJvcHMpLCBtdXRhdGlvbi5leHRlbmRlZFByb3BzKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnREZWZNdXRhdGlvbkFwcGxpZXJzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgYXBwbGllciA9IF9hW19pXTtcbiAgICAgICAgYXBwbGllcihjb3B5LCBtdXRhdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmICghY29weS5oYXNFbmQgJiYgY29udGV4dC5vcHRpb25zLmZvcmNlRXZlbnREdXJhdGlvbikge1xuICAgICAgICBjb3B5Lmhhc0VuZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuZnVuY3Rpb24gYXBwbHlNdXRhdGlvblRvRXZlbnRJbnN0YW5jZShldmVudEluc3RhbmNlLCBldmVudERlZiwgLy8gbXVzdCBmaXJzdCBiZSBtb2RpZmllZCBieSBhcHBseU11dGF0aW9uVG9FdmVudERlZlxuZXZlbnRDb25maWcsIG11dGF0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnY7XG4gICAgdmFyIGZvcmNlQWxsRGF5ID0gbXV0YXRpb24uc3RhbmRhcmRQcm9wcyAmJiBtdXRhdGlvbi5zdGFuZGFyZFByb3BzLmFsbERheSA9PT0gdHJ1ZTtcbiAgICB2YXIgY2xlYXJFbmQgPSBtdXRhdGlvbi5zdGFuZGFyZFByb3BzICYmIG11dGF0aW9uLnN0YW5kYXJkUHJvcHMuaGFzRW5kID09PSBmYWxzZTtcbiAgICB2YXIgY29weSA9IHRzbGliLl9fYXNzaWduKHt9LCBldmVudEluc3RhbmNlKTtcbiAgICBpZiAoZm9yY2VBbGxEYXkpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IGNvbXB1dGVBbGlnbmVkRGF5UmFuZ2UoY29weS5yYW5nZSk7XG4gICAgfVxuICAgIGlmIChtdXRhdGlvbi5kYXRlc0RlbHRhICYmIGV2ZW50Q29uZmlnLnN0YXJ0RWRpdGFibGUpIHtcbiAgICAgICAgY29weS5yYW5nZSA9IHtcbiAgICAgICAgICAgIHN0YXJ0OiBkYXRlRW52LmFkZChjb3B5LnJhbmdlLnN0YXJ0LCBtdXRhdGlvbi5kYXRlc0RlbHRhKSxcbiAgICAgICAgICAgIGVuZDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5lbmQsIG11dGF0aW9uLmRhdGVzRGVsdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uc3RhcnREZWx0YSAmJiBldmVudENvbmZpZy5kdXJhdGlvbkVkaXRhYmxlKSB7XG4gICAgICAgIGNvcHkucmFuZ2UgPSB7XG4gICAgICAgICAgICBzdGFydDogZGF0ZUVudi5hZGQoY29weS5yYW5nZS5zdGFydCwgbXV0YXRpb24uc3RhcnREZWx0YSksXG4gICAgICAgICAgICBlbmQ6IGNvcHkucmFuZ2UuZW5kLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobXV0YXRpb24uZW5kRGVsdGEgJiYgZXZlbnRDb25maWcuZHVyYXRpb25FZGl0YWJsZSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGRhdGVFbnYuYWRkKGNvcHkucmFuZ2UuZW5kLCBtdXRhdGlvbi5lbmREZWx0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChjbGVhckVuZCkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IGNvcHkucmFuZ2Uuc3RhcnQsXG4gICAgICAgICAgICBlbmQ6IGdldERlZmF1bHRFdmVudEVuZChldmVudERlZi5hbGxEYXksIGNvcHkucmFuZ2Uuc3RhcnQsIGNvbnRleHQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBpbiBjYXNlIGV2ZW50IHdhcyBhbGwtZGF5IGJ1dCB0aGUgc3VwcGxpZWQgZGVsdGFzIHdlcmUgbm90XG4gICAgLy8gYmV0dGVyIHV0aWwgZm9yIHRoaXM/XG4gICAgaWYgKGV2ZW50RGVmLmFsbERheSkge1xuICAgICAgICBjb3B5LnJhbmdlID0ge1xuICAgICAgICAgICAgc3RhcnQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5zdGFydCksXG4gICAgICAgICAgICBlbmQ6IHN0YXJ0T2ZEYXkoY29weS5yYW5nZS5lbmQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBoYW5kbGUgaW52YWxpZCBkdXJhdGlvbnNcbiAgICBpZiAoY29weS5yYW5nZS5lbmQgPCBjb3B5LnJhbmdlLnN0YXJ0KSB7XG4gICAgICAgIGNvcHkucmFuZ2UuZW5kID0gZ2V0RGVmYXVsdEV2ZW50RW5kKGV2ZW50RGVmLmFsbERheSwgY29weS5yYW5nZS5zdGFydCwgY29udGV4dCk7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG4vLyBubyBwdWJsaWMgdHlwZXMgeWV0LiB3aGVuIHRoZXJlIGFyZSwgZXhwb3J0IGZyb206XG4vLyBpbXBvcnQge30gZnJvbSAnLi9hcGktdHlwZS1kZXBzJ1xudmFyIFZpZXdBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmlld0FwaSh0eXBlLCBnZXRDdXJyZW50RGF0YSwgZGF0ZUVudikge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmdldEN1cnJlbnREYXRhID0gZ2V0Q3VycmVudERhdGE7XG4gICAgICAgIHRoaXMuZGF0ZUVudiA9IGRhdGVFbnY7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJjYWxlbmRhclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS5jYWxlbmRhckFwaTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VycmVudERhdGEoKS52aWV3VGl0bGU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiYWN0aXZlU3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5hY3RpdmVSYW5nZS5zdGFydCk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVmlld0FwaS5wcm90b3R5cGUsIFwiYWN0aXZlRW5kXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRlRW52LnRvRGF0ZSh0aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UuZW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWaWV3QXBpLnByb3RvdHlwZSwgXCJjdXJyZW50U3RhcnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQpO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFZpZXdBcGkucHJvdG90eXBlLCBcImN1cnJlbnRFbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGVFbnYudG9EYXRlKHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIFZpZXdBcGkucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkub3B0aW9uc1tuYW1lXTsgLy8gYXJlIHRoZSB2aWV3LXNwZWNpZmljIG9wdGlvbnNcbiAgICB9O1xuICAgIHJldHVybiBWaWV3QXBpO1xufSgpKTtcblxudmFyIEVWRU5UX1NPVVJDRV9SRUZJTkVSUyA9IHtcbiAgICBpZDogU3RyaW5nLFxuICAgIGRlZmF1bHRBbGxEYXk6IEJvb2xlYW4sXG4gICAgdXJsOiBTdHJpbmcsXG4gICAgZm9ybWF0OiBTdHJpbmcsXG4gICAgZXZlbnRzOiBpZGVudGl0eSxcbiAgICBldmVudERhdGFUcmFuc2Zvcm06IGlkZW50aXR5LFxuICAgIC8vIGZvciBhbnkgbmV0d29yay1yZWxhdGVkIHNvdXJjZXNcbiAgICBzdWNjZXNzOiBpZGVudGl0eSxcbiAgICBmYWlsdXJlOiBpZGVudGl0eSxcbn07XG5mdW5jdGlvbiBwYXJzZUV2ZW50U291cmNlKHJhdywgY29udGV4dCwgcmVmaW5lcnMpIHtcbiAgICBpZiAocmVmaW5lcnMgPT09IHZvaWQgMCkgeyByZWZpbmVycyA9IGJ1aWxkRXZlbnRTb3VyY2VSZWZpbmVycyhjb250ZXh0KTsgfVxuICAgIHZhciByYXdPYmo7XG4gICAgaWYgKHR5cGVvZiByYXcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJhd09iaiA9IHsgdXJsOiByYXcgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJhdyA9PT0gJ2Z1bmN0aW9uJyB8fCBBcnJheS5pc0FycmF5KHJhdykpIHtcbiAgICAgICAgcmF3T2JqID0geyBldmVudHM6IHJhdyB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmF3ID09PSAnb2JqZWN0JyAmJiByYXcpIHsgLy8gbm90IG51bGxcbiAgICAgICAgcmF3T2JqID0gcmF3O1xuICAgIH1cbiAgICBpZiAocmF3T2JqKSB7XG4gICAgICAgIHZhciBfYSA9IHJlZmluZVByb3BzKHJhd09iaiwgcmVmaW5lcnMpLCByZWZpbmVkID0gX2EucmVmaW5lZCwgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgdmFyIG1ldGFSZXMgPSBidWlsZEV2ZW50U291cmNlTWV0YShyZWZpbmVkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKG1ldGFSZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgX3JhdzogcmF3LFxuICAgICAgICAgICAgICAgIGlzRmV0Y2hpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxhdGVzdEZldGNoSWQ6ICcnLFxuICAgICAgICAgICAgICAgIGZldGNoUmFuZ2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGVmYXVsdEFsbERheTogcmVmaW5lZC5kZWZhdWx0QWxsRGF5LFxuICAgICAgICAgICAgICAgIGV2ZW50RGF0YVRyYW5zZm9ybTogcmVmaW5lZC5ldmVudERhdGFUcmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgc3VjY2VzczogcmVmaW5lZC5zdWNjZXNzLFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlZmluZWQuZmFpbHVyZSxcbiAgICAgICAgICAgICAgICBwdWJsaWNJZDogcmVmaW5lZC5pZCB8fCAnJyxcbiAgICAgICAgICAgICAgICBzb3VyY2VJZDogZ3VpZCgpLFxuICAgICAgICAgICAgICAgIHNvdXJjZURlZklkOiBtZXRhUmVzLnNvdXJjZURlZklkLFxuICAgICAgICAgICAgICAgIG1ldGE6IG1ldGFSZXMubWV0YSxcbiAgICAgICAgICAgICAgICB1aTogY3JlYXRlRXZlbnRVaShyZWZpbmVkLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICBleHRlbmRlZFByb3BzOiBleHRyYSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCkge1xuICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgRVZFTlRfVUlfUkVGSU5FUlMpLCBFVkVOVF9TT1VSQ0VfUkVGSU5FUlMpLCBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlUmVmaW5lcnMpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFNvdXJjZU1ldGEocmF3LCBjb250ZXh0KSB7XG4gICAgdmFyIGRlZnMgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmV2ZW50U291cmNlRGVmcztcbiAgICBmb3IgKHZhciBpID0gZGVmcy5sZW5ndGggLSAxOyBpID49IDA7IGkgLT0gMSkgeyAvLyBsYXRlci1hZGRlZCBwbHVnaW5zIHRha2UgcHJlY2VkZW5jZVxuICAgICAgICB2YXIgZGVmID0gZGVmc1tpXTtcbiAgICAgICAgdmFyIG1ldGEgPSBkZWYucGFyc2VNZXRhKHJhdyk7XG4gICAgICAgIGlmIChtZXRhKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzb3VyY2VEZWZJZDogaSwgbWV0YTogbWV0YSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiByZWR1Y2VDdXJyZW50RGF0ZShjdXJyZW50RGF0ZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmRhdGVNYXJrZXI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbERhdGUob3B0aW9ucywgZGF0ZUVudikge1xuICAgIHZhciBpbml0aWFsRGF0ZUlucHV0ID0gb3B0aW9ucy5pbml0aWFsRGF0ZTtcbiAgICAvLyBjb21wdXRlIHRoZSBpbml0aWFsIGFtYmlnLXRpbWV6b25lIGRhdGVcbiAgICBpZiAoaW5pdGlhbERhdGVJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU1hcmtlcihpbml0aWFsRGF0ZUlucHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vdyhvcHRpb25zLm5vdywgZGF0ZUVudik7IC8vIGdldE5vdyBhbHJlYWR5IHJldHVybnMgdW56b25lZFxufVxuZnVuY3Rpb24gZ2V0Tm93KG5vd0lucHV0LCBkYXRlRW52KSB7XG4gICAgaWYgKHR5cGVvZiBub3dJbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBub3dJbnB1dCA9IG5vd0lucHV0KCk7XG4gICAgfVxuICAgIGlmIChub3dJbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkYXRlRW52LmNyZWF0ZU5vd01hcmtlcigpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0ZUVudi5jcmVhdGVNYXJrZXIobm93SW5wdXQpO1xufVxuXG52YXIgQ2FsZW5kYXJBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJBcGkoKSB7XG4gICAgfVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmdldEN1cnJlbnREYXRhKCk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZGlzcGF0Y2ggPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5kaXNwYXRjaChhY3Rpb24pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENhbGVuZGFyQXBpLnByb3RvdHlwZSwgXCJ2aWV3XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmdldEN1cnJlbnREYXRhKCkudmlld0FwaTsgfSAvLyBmb3IgcHVibGljIEFQSVxuICAgICAgICAsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuYmF0Y2hSZW5kZXJpbmcgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS51cGRhdGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTtcbiAgICB9O1xuICAgIC8vIE9wdGlvbnNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5zZXRPcHRpb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1NFVF9PUFRJT04nLFxuICAgICAgICAgICAgb3B0aW9uTmFtZTogbmFtZSxcbiAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiB2YWwsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldE9wdGlvbiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXRbbmFtZV07XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0QXZhaWxhYmxlTG9jYWxlQ29kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmdldEN1cnJlbnREYXRhKCkuYXZhaWxhYmxlUmF3TG9jYWxlcyk7XG4gICAgfTtcbiAgICAvLyBUcmlnZ2VyXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoaGFuZGxlck5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRhTWFuYWdlciA9IHRoaXMuY3VycmVudERhdGFNYW5hZ2VyO1xuICAgICAgICBpZiAoY3VycmVudERhdGFNYW5hZ2VyLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVyc1toYW5kbGVyTmFtZV0pIHtcbiAgICAgICAgICAgIGN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9uKGhhbmRsZXJOYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gbGlzdGVuZXIgbmFtZSAnXCIgKyBoYW5kbGVyTmFtZSArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLmN1cnJlbnREYXRhTWFuYWdlci5lbWl0dGVyLm9mZihoYW5kbGVyTmFtZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICAvLyBub3QgbWVhbnQgZm9yIHB1YmxpYyB1c2VcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChoYW5kbGVyTmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMuY3VycmVudERhdGFNYW5hZ2VyLmVtaXR0ZXIpLnRyaWdnZXIuYXBwbHkoX2EsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2hhbmRsZXJOYW1lXSwgYXJncykpO1xuICAgIH07XG4gICAgLy8gVmlld1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmNoYW5nZVZpZXcgPSBmdW5jdGlvbiAodmlld1R5cGUsIGRhdGVPclJhbmdlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuYmF0Y2hSZW5kZXJpbmcoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRlT3JSYW5nZS5zdGFydCAmJiBkYXRlT3JSYW5nZS5lbmQpIHsgLy8gYSByYW5nZVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX1ZJRVdfVFlQRScsXG4gICAgICAgICAgICAgICAgICAgICAgICB2aWV3VHlwZTogdmlld1R5cGUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnU0VUX09QVElPTicsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25OYW1lOiAndmlzaWJsZVJhbmdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJhd09wdGlvblZhbHVlOiBkYXRlT3JSYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0ZUVudiA9IF90aGlzLmdldEN1cnJlbnREYXRhKCkuZGF0ZUVudjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZUVudi5jcmVhdGVNYXJrZXIoZGF0ZU9yUmFuZ2UpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdDSEFOR0VfVklFV19UWVBFJyxcbiAgICAgICAgICAgICAgICAgICAgdmlld1R5cGU6IHZpZXdUeXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8vIEZvcmNlcyBuYXZpZ2F0aW9uIHRvIGEgdmlldyBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gICAgLy8gYHZpZXdUeXBlYCBjYW4gYmUgYSBzcGVjaWZpYyB2aWV3IG5hbWUgb3IgYSBnZW5lcmljIG9uZSBsaWtlIFwid2Vla1wiIG9yIFwiZGF5XCIuXG4gICAgLy8gbmVlZHMgdG8gY2hhbmdlXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnpvb21UbyA9IGZ1bmN0aW9uIChkYXRlTWFya2VyLCB2aWV3VHlwZSkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHZhciBzcGVjO1xuICAgICAgICB2aWV3VHlwZSA9IHZpZXdUeXBlIHx8ICdkYXknOyAvLyBkYXkgaXMgZGVmYXVsdCB6b29tXG4gICAgICAgIHNwZWMgPSBzdGF0ZS52aWV3U3BlY3Nbdmlld1R5cGVdIHx8IHRoaXMuZ2V0VW5pdFZpZXdTcGVjKHZpZXdUeXBlKTtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICBpZiAoc3BlYykge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9WSUVXX1RZUEUnLFxuICAgICAgICAgICAgICAgIHZpZXdUeXBlOiBzcGVjLnR5cGUsXG4gICAgICAgICAgICAgICAgZGF0ZU1hcmtlcjogZGF0ZU1hcmtlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgICAgICBkYXRlTWFya2VyOiBkYXRlTWFya2VyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIEdpdmVuIGEgZHVyYXRpb24gc2luZ3VsYXIgdW5pdCwgbGlrZSBcIndlZWtcIiBvciBcImRheVwiLCBmaW5kcyBhIG1hdGNoaW5nIHZpZXcgc3BlYy5cbiAgICAvLyBQcmVmZXJlbmNlIGlzIGdpdmVuIHRvIHZpZXdzIHRoYXQgaGF2ZSBjb3JyZXNwb25kaW5nIGJ1dHRvbnMuXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldFVuaXRWaWV3U3BlYyA9IGZ1bmN0aW9uICh1bml0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKSwgdmlld1NwZWNzID0gX2Eudmlld1NwZWNzLCB0b29sYmFyQ29uZmlnID0gX2EudG9vbGJhckNvbmZpZztcbiAgICAgICAgdmFyIHZpZXdUeXBlcyA9IFtdLmNvbmNhdCh0b29sYmFyQ29uZmlnLmhlYWRlciA/IHRvb2xiYXJDb25maWcuaGVhZGVyLnZpZXdzV2l0aEJ1dHRvbnMgOiBbXSwgdG9vbGJhckNvbmZpZy5mb290ZXIgPyB0b29sYmFyQ29uZmlnLmZvb3Rlci52aWV3c1dpdGhCdXR0b25zIDogW10pO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIHNwZWM7XG4gICAgICAgIGZvciAodmFyIHZpZXdUeXBlIGluIHZpZXdTcGVjcykge1xuICAgICAgICAgICAgdmlld1R5cGVzLnB1c2godmlld1R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2aWV3VHlwZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHNwZWMgPSB2aWV3U3BlY3Nbdmlld1R5cGVzW2ldXTtcbiAgICAgICAgICAgIGlmIChzcGVjKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNwZWMuc2luZ2xlVW5pdCA9PT0gdW5pdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BlYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBDdXJyZW50IERhdGVcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goeyB0eXBlOiAnUFJFVicgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51bnNlbGVjdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ05FWFQnIH0pO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnByZXZZZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHRoaXMudW5zZWxlY3QoKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgZGF0ZU1hcmtlcjogc3RhdGUuZGF0ZUVudi5hZGRZZWFycyhzdGF0ZS5jdXJyZW50RGF0ZSwgLTEpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5uZXh0WWVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkWWVhcnMoc3RhdGUuY3VycmVudERhdGUsIDEpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS50b2RheSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IGdldE5vdyhzdGF0ZS5jYWxlbmRhck9wdGlvbnMubm93LCBzdGF0ZS5kYXRlRW52KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ290b0RhdGUgPSBmdW5jdGlvbiAoem9uZWREYXRlSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ0NIQU5HRV9EQVRFJyxcbiAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuY3JlYXRlTWFya2VyKHpvbmVkRGF0ZUlucHV0KSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuaW5jcmVtZW50RGF0ZSA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIGRlbHRhID0gY3JlYXRlRHVyYXRpb24oZGVsdGFJbnB1dCk7XG4gICAgICAgIGlmIChkZWx0YSkgeyAvLyBlbHNlLCB3YXJuIGFib3V0IGludmFsaWQgaW5wdXQ/XG4gICAgICAgICAgICB0aGlzLnVuc2VsZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ0hBTkdFX0RBVEUnLFxuICAgICAgICAgICAgICAgIGRhdGVNYXJrZXI6IHN0YXRlLmRhdGVFbnYuYWRkKHN0YXRlLmN1cnJlbnREYXRlLCBkZWx0YSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gZm9yIGV4dGVybmFsIEFQSVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXREYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHJldHVybiBzdGF0ZS5kYXRlRW52LnRvRGF0ZShzdGF0ZS5jdXJyZW50RGF0ZSk7XG4gICAgfTtcbiAgICAvLyBEYXRlIEZvcm1hdHRpbmcgVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5mb3JtYXREYXRlID0gZnVuY3Rpb24gKGQsIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIGNyZWF0ZUZvcm1hdHRlcihmb3JtYXR0ZXIpKTtcbiAgICB9O1xuICAgIC8vIGBzZXR0aW5nc2AgaXMgZm9yIGZvcm1hdHRlciBBTkQgaXNFbmRFeGNsdXNpdmVcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZm9ybWF0UmFuZ2UgPSBmdW5jdGlvbiAoZDAsIGQxLCBzZXR0aW5ncykge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShkYXRlRW52LmNyZWF0ZU1hcmtlcihkMCksIGRhdGVFbnYuY3JlYXRlTWFya2VyKGQxKSwgY3JlYXRlRm9ybWF0dGVyKHNldHRpbmdzKSwgc2V0dGluZ3MpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmZvcm1hdElzbyA9IGZ1bmN0aW9uIChkLCBvbWl0VGltZSkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5kYXRlRW52O1xuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRJc28oZGF0ZUVudi5jcmVhdGVNYXJrZXIoZCksIHsgb21pdFRpbWU6IG9taXRUaW1lIH0pO1xuICAgIH07XG4gICAgLy8gRGF0ZSBTZWxlY3Rpb24gLyBFdmVudCBTZWxlY3Rpb24gLyBEYXlDbGlja1xuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gdGhpcyBwdWJsaWMgbWV0aG9kIHJlY2VpdmVzIHN0YXJ0L2VuZCBkYXRlcyBpbiBhbnkgZm9ybWF0LCB3aXRoIGFueSB0aW1lem9uZVxuICAgIC8vIE5PVEU6IGFyZ3Mgd2VyZSBjaGFuZ2VkIGZyb20gdjNcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuc2VsZWN0ID0gZnVuY3Rpb24gKGRhdGVPck9iaiwgZW5kRGF0ZSkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uSW5wdXQ7XG4gICAgICAgIGlmIChlbmREYXRlID09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChkYXRlT3JPYmouc3RhcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbklucHV0ID0gZGF0ZU9yT2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBkYXRlT3JPYmosXG4gICAgICAgICAgICAgICAgICAgIGVuZDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZWN0aW9uSW5wdXQgPSB7XG4gICAgICAgICAgICAgICAgc3RhcnQ6IGRhdGVPck9iaixcbiAgICAgICAgICAgICAgICBlbmQ6IGVuZERhdGUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHBhcnNlRGF0ZVNwYW4oc2VsZWN0aW9uSW5wdXQsIHN0YXRlLmRhdGVFbnYsIGNyZWF0ZUR1cmF0aW9uKHsgZGF5czogMSB9KSk7XG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHsgLy8gdGhyb3cgcGFyc2UgZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdTRUxFQ1RfREFURVMnLCBzZWxlY3Rpb246IHNlbGVjdGlvbiB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJEYXRlU2VsZWN0KHNlbGVjdGlvbiwgbnVsbCwgc3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBwdWJsaWMgbWV0aG9kXG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnVuc2VsZWN0ID0gZnVuY3Rpb24gKHBldikge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1VOU0VMRUNUX0RBVEVTJyB9KTtcbiAgICAgICAgICAgIHRyaWdnZXJEYXRlVW5zZWxlY3QocGV2LCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFB1YmxpYyBFdmVudHMgQVBJXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuYWRkRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnRJbnB1dCwgc291cmNlSW5wdXQpIHtcbiAgICAgICAgaWYgKGV2ZW50SW5wdXQgaW5zdGFuY2VvZiBFdmVudEFwaSkge1xuICAgICAgICAgICAgdmFyIGRlZiA9IGV2ZW50SW5wdXQuX2RlZjtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGV2ZW50SW5wdXQuX2luc3RhbmNlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnREYXRhLmV2ZW50U3RvcmUuZGVmc1tkZWYuZGVmSWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdBRERfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRUdXBsZVRvU3RvcmUoeyBkZWY6IGRlZiwgaW5zdGFuY2U6IGluc3RhbmNlIH0pLCAvLyBUT0RPOiBiZXR0ZXIgdXRpbCBmb3IgdHdvIGFyZ3M/XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQoZXZlbnRJbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRJbnB1dDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHZhciBldmVudFNvdXJjZTtcbiAgICAgICAgaWYgKHNvdXJjZUlucHV0IGluc3RhbmNlb2YgRXZlbnRTb3VyY2VBcGkpIHtcbiAgICAgICAgICAgIGV2ZW50U291cmNlID0gc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc291cmNlSW5wdXQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKHNvdXJjZUlucHV0KSB7IC8vIHRydWUuIHBhcnQgb2YgdGhlIGZpcnN0IGV2ZW50IHNvdXJjZVxuICAgICAgICAgICAgICAgIGV2ZW50U291cmNlID0gaGFzaFZhbHVlc1RvQXJyYXkoc3RhdGUuZXZlbnRTb3VyY2VzKVswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzb3VyY2VJbnB1dCAhPSBudWxsKSB7IC8vIGFuIElELiBhY2NlcHRzIGEgbnVtYmVyIHRvb1xuICAgICAgICAgICAgdmFyIHNvdXJjZUFwaSA9IHRoaXMuZ2V0RXZlbnRTb3VyY2VCeUlkKHNvdXJjZUlucHV0KTsgLy8gVE9ETzogdXNlIGFuIGludGVybmFsIGZ1bmN0aW9uXG4gICAgICAgICAgICBpZiAoIXNvdXJjZUFwaSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBmaW5kIGFuIGV2ZW50IHNvdXJjZSB3aXRoIElEIFxcXCJcIiArIHNvdXJjZUlucHV0ICsgXCJcXFwiXCIpOyAvLyBUT0RPOiB0ZXN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudFNvdXJjZSA9IHNvdXJjZUFwaS5pbnRlcm5hbEV2ZW50U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0dXBsZSA9IHBhcnNlRXZlbnQoZXZlbnRJbnB1dCwgZXZlbnRTb3VyY2UsIHN0YXRlLCBmYWxzZSk7XG4gICAgICAgIGlmICh0dXBsZSkge1xuICAgICAgICAgICAgdmFyIG5ld0V2ZW50QXBpID0gbmV3IEV2ZW50QXBpKHN0YXRlLCB0dXBsZS5kZWYsIHR1cGxlLmRlZi5yZWN1cnJpbmdEZWYgPyBudWxsIDogdHVwbGUuaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0FERF9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50VHVwbGVUb1N0b3JlKHR1cGxlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnRBZGQobmV3RXZlbnRBcGkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0V2ZW50QXBpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnRyaWdnZXJFdmVudEFkZCA9IGZ1bmN0aW9uIChldmVudEFwaSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZW1pdHRlciA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKS5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2V2ZW50QWRkJywge1xuICAgICAgICAgICAgZXZlbnQ6IGV2ZW50QXBpLFxuICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogW10sXG4gICAgICAgICAgICByZXZlcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdSRU1PVkVfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gVE9ETzogb3B0aW1pemVcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuZ2V0RXZlbnRCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIF9hID0gc3RhdGUuZXZlbnRTdG9yZSwgZGVmcyA9IF9hLmRlZnMsIGluc3RhbmNlcyA9IF9hLmluc3RhbmNlcztcbiAgICAgICAgaWQgPSBTdHJpbmcoaWQpO1xuICAgICAgICBmb3IgKHZhciBkZWZJZCBpbiBkZWZzKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc1tkZWZJZF07XG4gICAgICAgICAgICBpZiAoZGVmLnB1YmxpY0lkID09PSBpZCkge1xuICAgICAgICAgICAgICAgIGlmIChkZWYucmVjdXJyaW5nRGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkoc3RhdGUsIGRlZiwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGluc3RhbmNlc1tpbnN0YW5jZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLmRlZklkID09PSBkZWYuZGVmSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRBcGkoc3RhdGUsIGRlZiwgaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRhID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICByZXR1cm4gYnVpbGRFdmVudEFwaXMoY3VycmVudERhdGEuZXZlbnRTdG9yZSwgY3VycmVudERhdGEpO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLnJlbW92ZUFsbEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdSRU1PVkVfQUxMX0VWRU5UUycgfSk7XG4gICAgfTtcbiAgICAvLyBQdWJsaWMgRXZlbnQgU291cmNlcyBBUElcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIENhbGVuZGFyQXBpLnByb3RvdHlwZS5nZXRFdmVudFNvdXJjZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0Q3VycmVudERhdGEoKTtcbiAgICAgICAgdmFyIHNvdXJjZUhhc2ggPSBzdGF0ZS5ldmVudFNvdXJjZXM7XG4gICAgICAgIHZhciBzb3VyY2VBcGlzID0gW107XG4gICAgICAgIGZvciAodmFyIGludGVybmFsSWQgaW4gc291cmNlSGFzaCkge1xuICAgICAgICAgICAgc291cmNlQXBpcy5wdXNoKG5ldyBFdmVudFNvdXJjZUFwaShzdGF0ZSwgc291cmNlSGFzaFtpbnRlcm5hbElkXSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzb3VyY2VBcGlzO1xuICAgIH07XG4gICAgQ2FsZW5kYXJBcGkucHJvdG90eXBlLmdldEV2ZW50U291cmNlQnlJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldEN1cnJlbnREYXRhKCk7XG4gICAgICAgIHZhciBzb3VyY2VIYXNoID0gc3RhdGUuZXZlbnRTb3VyY2VzO1xuICAgICAgICBpZCA9IFN0cmluZyhpZCk7XG4gICAgICAgIGZvciAodmFyIHNvdXJjZUlkIGluIHNvdXJjZUhhc2gpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VIYXNoW3NvdXJjZUlkXS5wdWJsaWNJZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBzb3VyY2VIYXNoW3NvdXJjZUlkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuYWRkRXZlbnRTb3VyY2UgPSBmdW5jdGlvbiAoc291cmNlSW5wdXQpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gdGhpcy5nZXRDdXJyZW50RGF0YSgpO1xuICAgICAgICBpZiAoc291cmNlSW5wdXQgaW5zdGFuY2VvZiBFdmVudFNvdXJjZUFwaSkge1xuICAgICAgICAgICAgLy8gbm90IGFscmVhZHkgcHJlc2VudD8gZG9uJ3Qgd2FudCB0byBhZGQgYW4gb2xkIHNuYXBzaG90XG4gICAgICAgICAgICBpZiAoIXN0YXRlLmV2ZW50U291cmNlc1tzb3VyY2VJbnB1dC5pbnRlcm5hbEV2ZW50U291cmNlLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnQUREX0VWRU5UX1NPVVJDRVMnLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VzOiBbc291cmNlSW5wdXQuaW50ZXJuYWxFdmVudFNvdXJjZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc291cmNlSW5wdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50U291cmNlID0gcGFyc2VFdmVudFNvdXJjZShzb3VyY2VJbnB1dCwgc3RhdGUpO1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2UpIHsgLy8gVE9ETzogZXJyb3Igb3RoZXJ3aXNlP1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdBRERfRVZFTlRfU09VUkNFUycsIHNvdXJjZXM6IFtldmVudFNvdXJjZV0gfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEV2ZW50U291cmNlQXBpKHN0YXRlLCBldmVudFNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVtb3ZlQWxsRXZlbnRTb3VyY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKHsgdHlwZTogJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUycgfSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUucmVmZXRjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9FVkVOVF9TT1VSQ0VTJywgaXNSZWZldGNoOiB0cnVlIH0pO1xuICAgIH07XG4gICAgLy8gU2Nyb2xsXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBDYWxlbmRhckFwaS5wcm90b3R5cGUuc2Nyb2xsVG9UaW1lID0gZnVuY3Rpb24gKHRpbWVJbnB1dCkge1xuICAgICAgICB2YXIgdGltZSA9IGNyZWF0ZUR1cmF0aW9uKHRpbWVJbnB1dCk7XG4gICAgICAgIGlmICh0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ19zY3JvbGxSZXF1ZXN0JywgeyB0aW1lOiB0aW1lIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJBcGk7XG59KCkpO1xuXG52YXIgRXZlbnRBcGkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgLy8gaW5zdGFuY2Ugd2lsbCBiZSBudWxsIGlmIGV4cHJlc3NpbmcgYSByZWN1cnJpbmcgZXZlbnQgdGhhdCBoYXMgbm8gY3VycmVudCBpbnN0YW5jZXMsXG4gICAgLy8gT1IgaWYgdHJ5aW5nIHRvIHZhbGlkYXRlIGFuIGluY29taW5nIGV4dGVybmFsIGV2ZW50IHRoYXQgaGFzIG5vIGRhdGVzIGFzc2lnbmVkXG4gICAgZnVuY3Rpb24gRXZlbnRBcGkoY29udGV4dCwgZGVmLCBpbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLl9pbnN0YW5jZSA9IGluc3RhbmNlIHx8IG51bGw7XG4gICAgfVxuICAgIC8qXG4gICAgVE9ETzogbWFrZSBldmVudCBzdHJ1Y3QgbW9yZSByZXNwb25zaWJsZSBmb3IgdGhpc1xuICAgICovXG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnNldFByb3AgPSBmdW5jdGlvbiAobmFtZSwgdmFsKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmIChuYW1lIGluIEVWRU5UX0RBVEVfUkVGSU5FUlMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHNldCBkYXRlLXJlbGF0ZWQgcHJvcCBcXCduYW1lXFwnLiBVc2Ugb25lIG9mIHRoZSBkYXRlLXJlbGF0ZWQgbWV0aG9kcyBpbnN0ZWFkLicpO1xuICAgICAgICAgICAgLy8gVE9ETzogbWFrZSBwcm9wZXIgYWxpYXNpbmcgc3lzdGVtP1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgICAgIHZhbCA9IEVWRU5UX05PTl9EQVRFX1JFRklORVJTW25hbWVdKHZhbCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7XG4gICAgICAgICAgICAgICAgc3RhbmRhcmRQcm9wczogeyBwdWJsaWNJZDogdmFsIH0sIC8vIGhhcmRjb2RlZCBpbnRlcm5hbCBuYW1lXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuYW1lIGluIEVWRU5UX05PTl9EQVRFX1JFRklORVJTKSB7XG4gICAgICAgICAgICB2YWwgPSBFVkVOVF9OT05fREFURV9SRUZJTkVSU1tuYW1lXSh2YWwpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IChfYSA9IHt9LCBfYVtuYW1lXSA9IHZhbCwgX2EpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobmFtZSBpbiBFVkVOVF9VSV9SRUZJTkVSUykge1xuICAgICAgICAgICAgdmFyIHVpID0gRVZFTlRfVUlfUkVGSU5FUlNbbmFtZV0odmFsKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnY29sb3InKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IGJhY2tncm91bmRDb2xvcjogdmFsLCBib3JkZXJDb2xvcjogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuYW1lID09PSAnZWRpdGFibGUnKSB7XG4gICAgICAgICAgICAgICAgdWkgPSB7IHN0YXJ0RWRpdGFibGU6IHZhbCwgZHVyYXRpb25FZGl0YWJsZTogdmFsIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1aSA9IChfYiA9IHt9LCBfYltuYW1lXSA9IHZhbCwgX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tdXRhdGUoe1xuICAgICAgICAgICAgICAgIHN0YW5kYXJkUHJvcHM6IHsgdWk6IHVpIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBzZXQgcHJvcCAnXCIgKyBuYW1lICsgXCInLiBVc2Ugc2V0RXh0ZW5kZWRQcm9wIGluc3RlYWQuXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0RXh0ZW5kZWRQcm9wID0gZnVuY3Rpb24gKG5hbWUsIHZhbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubXV0YXRlKHtcbiAgICAgICAgICAgIGV4dGVuZGVkUHJvcHM6IChfYSA9IHt9LCBfYVtuYW1lXSA9IHZhbCwgX2EpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRTdGFydCA9IGZ1bmN0aW9uIChzdGFydElucHV0LCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgc3RhcnQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihzdGFydElucHV0KTtcbiAgICAgICAgaWYgKHN0YXJ0ICYmIHRoaXMuX2luc3RhbmNlKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgdmFyIGluc3RhbmNlUmFuZ2UgPSB0aGlzLl9pbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgICAgIHZhciBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTsgLy8gd2hhdCBpZiBwYXJzZWQgYmFkIT9cbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1haW50YWluRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IHN0YXJ0RGVsdGEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXRFbmQgPSBmdW5jdGlvbiAoZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGRhdGVFbnYgPSB0aGlzLl9jb250ZXh0LmRhdGVFbnY7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIGlmIChlbmRJbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBlbmQgPSBkYXRlRW52LmNyZWF0ZU1hcmtlcihlbmRJbnB1dCk7XG4gICAgICAgICAgICBpZiAoIWVuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2luc3RhbmNlKSB7XG4gICAgICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZERlbHRhID0gZGlmZkRhdGVzKHRoaXMuX2luc3RhbmNlLnJhbmdlLmVuZCwgZW5kLCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBlbmREZWx0YSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgc3RhbmRhcmRQcm9wczogeyBoYXNFbmQ6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS5zZXREYXRlcyA9IGZ1bmN0aW9uIChzdGFydElucHV0LCBlbmRJbnB1dCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMuX2NvbnRleHQuZGF0ZUVudjtcbiAgICAgICAgdmFyIHN0YW5kYXJkUHJvcHMgPSB7IGFsbERheTogb3B0aW9ucy5hbGxEYXkgfTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZUVudi5jcmVhdGVNYXJrZXIoc3RhcnRJbnB1dCk7XG4gICAgICAgIHZhciBlbmQ7XG4gICAgICAgIGlmICghc3RhcnQpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZElucHV0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuY3JlYXRlTWFya2VyKGVuZElucHV0KTtcbiAgICAgICAgICAgIGlmICghZW5kKSB7IC8vIFRPRE86IHdhcm5pbmcgaWYgcGFyc2VkIGJhZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZVJhbmdlID0gdGhpcy5faW5zdGFuY2UucmFuZ2U7XG4gICAgICAgICAgICAvLyB3aGVuIGNvbXB1dGluZyB0aGUgZGlmZiBmb3IgYW4gZXZlbnQgYmVpbmcgY29udmVydGVkIHRvIGFsbC1kYXksXG4gICAgICAgICAgICAvLyBjb21wdXRlIGRpZmYgb2ZmIG9mIHRoZSBhbGwtZGF5IHZhbHVlcyB0aGUgd2F5IGV2ZW50LW11dGF0aW9uIGRvZXMuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxEYXkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVJhbmdlID0gY29tcHV0ZUFsaWduZWREYXlSYW5nZShpbnN0YW5jZVJhbmdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFydERlbHRhID0gZGlmZkRhdGVzKGluc3RhbmNlUmFuZ2Uuc3RhcnQsIHN0YXJ0LCBkYXRlRW52LCBvcHRpb25zLmdyYW51bGFyaXR5KTtcbiAgICAgICAgICAgIGlmIChlbmQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kRGVsdGEgPSBkaWZmRGF0ZXMoaW5zdGFuY2VSYW5nZS5lbmQsIGVuZCwgZGF0ZUVudiwgb3B0aW9ucy5ncmFudWxhcml0eSk7XG4gICAgICAgICAgICAgICAgaWYgKGR1cmF0aW9uc0VxdWFsKHN0YXJ0RGVsdGEsIGVuZERlbHRhKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IHN0YXJ0RGVsdGEsIHN0YW5kYXJkUHJvcHM6IHN0YW5kYXJkUHJvcHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IHN0YXJ0RGVsdGEsIGVuZERlbHRhOiBlbmREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHsgLy8gbWVhbnMgXCJjbGVhciB0aGUgZW5kXCJcbiAgICAgICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMubXV0YXRlKHsgZGF0ZXNEZWx0YTogc3RhcnREZWx0YSwgc3RhbmRhcmRQcm9wczogc3RhbmRhcmRQcm9wcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLm1vdmVTdGFydCA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IHN0YXJ0RGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubW92ZUVuZCA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGVuZERlbHRhOiBkZWx0YSB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLm1vdmVEYXRlcyA9IGZ1bmN0aW9uIChkZWx0YUlucHV0KSB7XG4gICAgICAgIHZhciBkZWx0YSA9IGNyZWF0ZUR1cmF0aW9uKGRlbHRhSW5wdXQpO1xuICAgICAgICBpZiAoZGVsdGEpIHsgLy8gVE9ETzogd2FybmluZyBpZiBwYXJzZWQgYmFkXG4gICAgICAgICAgICB0aGlzLm11dGF0ZSh7IGRhdGVzRGVsdGE6IGRlbHRhIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUuc2V0QWxsRGF5ID0gZnVuY3Rpb24gKGFsbERheSwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgc3RhbmRhcmRQcm9wcyA9IHsgYWxsRGF5OiBhbGxEYXkgfTtcbiAgICAgICAgdmFyIG1haW50YWluRHVyYXRpb24gPSBvcHRpb25zLm1haW50YWluRHVyYXRpb247XG4gICAgICAgIGlmIChtYWludGFpbkR1cmF0aW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIG1haW50YWluRHVyYXRpb24gPSB0aGlzLl9jb250ZXh0Lm9wdGlvbnMuYWxsRGF5TWFpbnRhaW5EdXJhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLmFsbERheSAhPT0gYWxsRGF5KSB7XG4gICAgICAgICAgICBzdGFuZGFyZFByb3BzLmhhc0VuZCA9IG1haW50YWluRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tdXRhdGUoeyBzdGFuZGFyZFByb3BzOiBzdGFuZGFyZFByb3BzIH0pO1xuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLmZvcm1hdFJhbmdlID0gZnVuY3Rpb24gKGZvcm1hdElucHV0KSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5fY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICAgICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihmb3JtYXRJbnB1dCk7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuaGFzRW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXRSYW5nZShpbnN0YW5jZS5yYW5nZS5zdGFydCwgaW5zdGFuY2UucmFuZ2UuZW5kLCBmb3JtYXR0ZXIsIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRTdGFydFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgZm9yY2VkRW5kVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0ZUVudi5mb3JtYXQoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGZvcm1hdHRlciwge1xuICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6byxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUubXV0YXRlID0gZnVuY3Rpb24gKG11dGF0aW9uKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICBpZiAoaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgICAgICB2YXIgY29udGV4dF8xID0gdGhpcy5fY29udGV4dDtcbiAgICAgICAgICAgIHZhciBldmVudFN0b3JlXzEgPSBjb250ZXh0XzEuZ2V0Q3VycmVudERhdGEoKS5ldmVudFN0b3JlO1xuICAgICAgICAgICAgdmFyIHJlbGV2YW50RXZlbnRzID0gZ2V0UmVsZXZhbnRFdmVudHMoZXZlbnRTdG9yZV8xLCBpbnN0YW5jZS5pbnN0YW5jZUlkKTtcbiAgICAgICAgICAgIHZhciBldmVudENvbmZpZ0Jhc2UgPSB7XG4gICAgICAgICAgICAgICAgJyc6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJycsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uRWRpdGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0Q29sb3I6ICcnLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVzOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbGV2YW50RXZlbnRzID0gYXBwbHlNdXRhdGlvblRvRXZlbnRTdG9yZShyZWxldmFudEV2ZW50cywgZXZlbnRDb25maWdCYXNlLCBtdXRhdGlvbiwgY29udGV4dF8xKTtcbiAgICAgICAgICAgIHZhciBvbGRFdmVudCA9IG5ldyBFdmVudEFwaShjb250ZXh0XzEsIGRlZiwgaW5zdGFuY2UpOyAvLyBzbmFwc2hvdFxuICAgICAgICAgICAgdGhpcy5fZGVmID0gcmVsZXZhbnRFdmVudHMuZGVmc1tkZWYuZGVmSWRdO1xuICAgICAgICAgICAgdGhpcy5faW5zdGFuY2UgPSByZWxldmFudEV2ZW50cy5pbnN0YW5jZXNbaW5zdGFuY2UuaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBjb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdNRVJHRV9FVkVOVFMnLFxuICAgICAgICAgICAgICAgIGV2ZW50U3RvcmU6IHJlbGV2YW50RXZlbnRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb250ZXh0XzEuZW1pdHRlci50cmlnZ2VyKCdldmVudENoYW5nZScsIHtcbiAgICAgICAgICAgICAgICBvbGRFdmVudDogb2xkRXZlbnQsXG4gICAgICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICAgICAgcmVsYXRlZEV2ZW50czogYnVpbGRFdmVudEFwaXMocmVsZXZhbnRFdmVudHMsIGNvbnRleHRfMSwgaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0XzEuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1JFU0VUX0VWRU5UUycsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFN0b3JlXzEsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRXZlbnRBcGkucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuICAgICAgICB2YXIgYXNTdG9yZSA9IGV2ZW50QXBpVG9TdG9yZSh0aGlzKTtcbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVNT1ZFX0VWRU5UUycsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBhc1N0b3JlLFxuICAgICAgICB9KTtcbiAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50UmVtb3ZlJywge1xuICAgICAgICAgICAgZXZlbnQ6IHRoaXMsXG4gICAgICAgICAgICByZWxhdGVkRXZlbnRzOiBbXSxcbiAgICAgICAgICAgIHJldmVydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnTUVSR0VfRVZFTlRTJyxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRTdG9yZTogYXNTdG9yZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzb3VyY2VcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzb3VyY2VJZCA9IHRoaXMuX2RlZi5zb3VyY2VJZDtcbiAgICAgICAgICAgIGlmIChzb3VyY2VJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRXZlbnRTb3VyY2VBcGkodGhpcy5fY29udGV4dCwgdGhpcy5fY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLmV2ZW50U291cmNlc1tzb3VyY2VJZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcInN0YXJ0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5faW5zdGFuY2UgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2Uuc3RhcnQpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJlbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5faW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZGF0ZUVudi50b0RhdGUodGhpcy5faW5zdGFuY2UucmFuZ2UuZW5kKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwic3RhcnRTdHJcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuX2luc3RhbmNlO1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZGF0ZUVudi5mb3JtYXRJc28oaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIHtcbiAgICAgICAgICAgICAgICAgICAgb21pdFRpbWU6IHRoaXMuX2RlZi5hbGxEYXksXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlZFR6bzogaW5zdGFuY2UuZm9yY2VkU3RhcnRUem8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImVuZFN0clwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5faW5zdGFuY2U7XG4gICAgICAgICAgICBpZiAoaW5zdGFuY2UgJiYgdGhpcy5fZGVmLmhhc0VuZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmRhdGVFbnYuZm9ybWF0SXNvKGluc3RhbmNlLnJhbmdlLmVuZCwge1xuICAgICAgICAgICAgICAgICAgICBvbWl0VGltZTogdGhpcy5fZGVmLmFsbERheSxcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VkVHpvOiBpbnN0YW5jZS5mb3JjZWRFbmRUem8sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImlkXCIsIHtcbiAgICAgICAgLy8gY29tcHV0YWJsZSBwcm9wcyB0aGF0IGFsbCBhY2Nlc3MgdGhlIGRlZlxuICAgICAgICAvLyBUT0RPOiBmaW5kIGEgVHlwZVNjcmlwdC1jb21wYXRpYmxlIHdheSB0byBkbyB0aGlzIGF0IHNjYWxlXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnB1YmxpY0lkOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJncm91cElkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYuZ3JvdXBJZDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYWxsRGF5XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYuYWxsRGF5OyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnRpdGxlOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ1cmxcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51cmw7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImRpc3BsYXlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5kaXNwbGF5IHx8ICdhdXRvJzsgfSAvLyBiYWQuIGp1c3Qgbm9ybWFsaXplIHRoZSB0eXBlIGVhcmxpZXJcbiAgICAgICAgLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJzdGFydEVkaXRhYmxlXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuc3RhcnRFZGl0YWJsZTsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiZHVyYXRpb25FZGl0YWJsZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmR1cmF0aW9uRWRpdGFibGU7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImNvbnN0cmFpbnRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jb25zdHJhaW50c1swXSB8fCBudWxsOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJvdmVybGFwXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkub3ZlcmxhcDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYWxsb3dcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5hbGxvd3NbMF0gfHwgbnVsbDsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEFwaS5wcm90b3R5cGUsIFwiYmFja2dyb3VuZENvbG9yXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYudWkuYmFja2dyb3VuZENvbG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJib3JkZXJDb2xvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGVmLnVpLmJvcmRlckNvbG9yOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJ0ZXh0Q29sb3JcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS50ZXh0Q29sb3I7IH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnRBcGkucHJvdG90eXBlLCBcImNsYXNzTmFtZXNcIiwge1xuICAgICAgICAvLyBOT1RFOiB1c2VyIGNhbid0IG1vZGlmeSB0aGVzZSBiZWNhdXNlIE9iamVjdC5mcmVlemUgd2FzIGNhbGxlZCBpbiBldmVudC1kZWYgcGFyc2luZ1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2RlZi51aS5jbGFzc05hbWVzOyB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50QXBpLnByb3RvdHlwZSwgXCJleHRlbmRlZFByb3BzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9kZWYuZXh0ZW5kZWRQcm9wczsgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEV2ZW50QXBpLnByb3RvdHlwZS50b1BsYWluT2JqZWN0ID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XG4gICAgICAgIGlmIChzZXR0aW5ncyA9PT0gdm9pZCAwKSB7IHNldHRpbmdzID0ge307IH1cbiAgICAgICAgdmFyIGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgdmFyIHVpID0gZGVmLnVpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzdGFydFN0ciA9IF9hLnN0YXJ0U3RyLCBlbmRTdHIgPSBfYS5lbmRTdHI7XG4gICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgaWYgKGRlZi50aXRsZSkge1xuICAgICAgICAgICAgcmVzLnRpdGxlID0gZGVmLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydFN0cikge1xuICAgICAgICAgICAgcmVzLnN0YXJ0ID0gc3RhcnRTdHI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVuZFN0cikge1xuICAgICAgICAgICAgcmVzLmVuZCA9IGVuZFN0cjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnB1YmxpY0lkKSB7XG4gICAgICAgICAgICByZXMuaWQgPSBkZWYucHVibGljSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5ncm91cElkKSB7XG4gICAgICAgICAgICByZXMuZ3JvdXBJZCA9IGRlZi5ncm91cElkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYudXJsKSB7XG4gICAgICAgICAgICByZXMudXJsID0gZGVmLnVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodWkuZGlzcGxheSAmJiB1aS5kaXNwbGF5ICE9PSAnYXV0bycpIHtcbiAgICAgICAgICAgIHJlcy5kaXNwbGF5ID0gdWkuZGlzcGxheTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IHJlY3VycmluZy1ldmVudCBwcm9wZXJ0aWVzPz8/XG4gICAgICAgIC8vIFRPRE86IGluY2x1ZGUgc3RhcnRFZGl0YWJsZS9kdXJhdGlvbkVkaXRhYmxlL2NvbnN0cmFpbnQvb3ZlcmxhcC9hbGxvd1xuICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VDb2xvciAmJiB1aS5iYWNrZ3JvdW5kQ29sb3IgJiYgdWkuYmFja2dyb3VuZENvbG9yID09PSB1aS5ib3JkZXJDb2xvcikge1xuICAgICAgICAgICAgcmVzLmNvbG9yID0gdWkuYmFja2dyb3VuZENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHVpLmJhY2tncm91bmRDb2xvcikge1xuICAgICAgICAgICAgICAgIHJlcy5iYWNrZ3JvdW5kQ29sb3IgPSB1aS5iYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodWkuYm9yZGVyQ29sb3IpIHtcbiAgICAgICAgICAgICAgICByZXMuYm9yZGVyQ29sb3IgPSB1aS5ib3JkZXJDb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodWkudGV4dENvbG9yKSB7XG4gICAgICAgICAgICByZXMudGV4dENvbG9yID0gdWkudGV4dENvbG9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1aS5jbGFzc05hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmVzLmNsYXNzTmFtZXMgPSB1aS5jbGFzc05hbWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWYuZXh0ZW5kZWRQcm9wcykubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoc2V0dGluZ3MuY29sbGFwc2VFeHRlbmRlZFByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHNsaWIuX19hc3NpZ24ocmVzLCBkZWYuZXh0ZW5kZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXMuZXh0ZW5kZWRQcm9wcyA9IGRlZi5leHRlbmRlZFByb3BzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBFdmVudEFwaS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b1BsYWluT2JqZWN0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRBcGk7XG59KCkpO1xuZnVuY3Rpb24gZXZlbnRBcGlUb1N0b3JlKGV2ZW50QXBpKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICB2YXIgZGVmID0gZXZlbnRBcGkuX2RlZjtcbiAgICB2YXIgaW5zdGFuY2UgPSBldmVudEFwaS5faW5zdGFuY2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVmczogKF9hID0ge30sIF9hW2RlZi5kZWZJZF0gPSBkZWYsIF9hKSxcbiAgICAgICAgaW5zdGFuY2VzOiBpbnN0YW5jZVxuICAgICAgICAgICAgPyAoX2IgPSB7fSwgX2JbaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBpbnN0YW5jZSwgX2IpIDoge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRBcGlzKGV2ZW50U3RvcmUsIGNvbnRleHQsIGV4Y2x1ZGVJbnN0YW5jZSkge1xuICAgIHZhciBkZWZzID0gZXZlbnRTdG9yZS5kZWZzLCBpbnN0YW5jZXMgPSBldmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgZXZlbnRBcGlzID0gW107XG4gICAgdmFyIGV4Y2x1ZGVJbnN0YW5jZUlkID0gZXhjbHVkZUluc3RhbmNlID8gZXhjbHVkZUluc3RhbmNlLmluc3RhbmNlSWQgOiAnJztcbiAgICBmb3IgKHZhciBpZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gaW5zdGFuY2VzW2lkXTtcbiAgICAgICAgdmFyIGRlZiA9IGRlZnNbaW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICBpZiAoaW5zdGFuY2UuaW5zdGFuY2VJZCAhPT0gZXhjbHVkZUluc3RhbmNlSWQpIHtcbiAgICAgICAgICAgIGV2ZW50QXBpcy5wdXNoKG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50QXBpcztcbn1cblxudmFyIGNhbGVuZGFyU3lzdGVtQ2xhc3NNYXAgPSB7fTtcbmZ1bmN0aW9uIHJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0obmFtZSwgdGhlQ2xhc3MpIHtcbiAgICBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdID0gdGhlQ2xhc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxlbmRhclN5c3RlbShuYW1lKSB7XG4gICAgcmV0dXJuIG5ldyBjYWxlbmRhclN5c3RlbUNsYXNzTWFwW25hbWVdKCk7XG59XG52YXIgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0oKSB7XG4gICAgfVxuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJZZWFyID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRnVsbFllYXIoKTtcbiAgICB9O1xuICAgIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtLnByb3RvdHlwZS5nZXRNYXJrZXJNb250aCA9IGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLmdldFVUQ01vbnRoKCk7XG4gICAgfTtcbiAgICBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbS5wcm90b3R5cGUuZ2V0TWFya2VyRGF5ID0gZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQuZ2V0VVRDRGF0ZSgpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLmFycmF5VG9NYXJrZXIgPSBmdW5jdGlvbiAoYXJyKSB7XG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShhcnIpO1xuICAgIH07XG4gICAgR3JlZ29yaWFuQ2FsZW5kYXJTeXN0ZW0ucHJvdG90eXBlLm1hcmtlclRvQXJyYXkgPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiBkYXRlVG9VdGNBcnJheShtYXJrZXIpO1xuICAgIH07XG4gICAgcmV0dXJuIEdyZWdvcmlhbkNhbGVuZGFyU3lzdGVtO1xufSgpKTtcbnJlZ2lzdGVyQ2FsZW5kYXJTeXN0ZW0oJ2dyZWdvcnknLCBHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSk7XG5cbnZhciBJU09fUkUgPSAvXlxccyooXFxkezR9KSgtPyhcXGR7Mn0pKC0/KFxcZHsyfSkoW1QgXShcXGR7Mn0pOj8oXFxkezJ9KSg6PyhcXGR7Mn0pKFxcLihcXGQrKSk/KT8oWnwoKFstK10pKFxcZHsyfSkoOj8oXFxkezJ9KSk/KSk/KT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICB2YXIgbSA9IElTT19SRS5leGVjKHN0cik7XG4gICAgaWYgKG0pIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBEYXRlKERhdGUuVVRDKE51bWJlcihtWzFdKSwgbVszXSA/IE51bWJlcihtWzNdKSAtIDEgOiAwLCBOdW1iZXIobVs1XSB8fCAxKSwgTnVtYmVyKG1bN10gfHwgMCksIE51bWJlcihtWzhdIHx8IDApLCBOdW1iZXIobVsxMF0gfHwgMCksIG1bMTJdID8gTnVtYmVyKFwiMC5cIiArIG1bMTJdKSAqIDEwMDAgOiAwKSk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZShtYXJrZXIpKSB7XG4gICAgICAgICAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG1bMTNdKSB7XG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQgPSAobVsxNV0gPT09ICctJyA/IC0xIDogMSkgKiAoTnVtYmVyKG1bMTZdIHx8IDApICogNjAgK1xuICAgICAgICAgICAgICAgICAgICBOdW1iZXIobVsxOF0gfHwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtYXJrZXI6IG1hcmtlcixcbiAgICAgICAgICAgICAgICBpc1RpbWVVbnNwZWNpZmllZDogIW1bNl0sXG4gICAgICAgICAgICAgICAgdGltZVpvbmVPZmZzZXQ6IHRpbWVab25lT2Zmc2V0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxudmFyIERhdGVFbnYgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0ZUVudihzZXR0aW5ncykge1xuICAgICAgICB2YXIgdGltZVpvbmUgPSB0aGlzLnRpbWVab25lID0gc2V0dGluZ3MudGltZVpvbmU7XG4gICAgICAgIHZhciBpc05hbWVkVGltZVpvbmUgPSB0aW1lWm9uZSAhPT0gJ2xvY2FsJyAmJiB0aW1lWm9uZSAhPT0gJ1VUQyc7XG4gICAgICAgIGlmIChzZXR0aW5ncy5uYW1lZFRpbWVab25lSW1wbCAmJiBpc05hbWVkVGltZVpvbmUpIHtcbiAgICAgICAgICAgIHRoaXMubmFtZWRUaW1lWm9uZUltcGwgPSBuZXcgc2V0dGluZ3MubmFtZWRUaW1lWm9uZUltcGwodGltZVpvbmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2FuQ29tcHV0ZU9mZnNldCA9IEJvb2xlYW4oIWlzTmFtZWRUaW1lWm9uZSB8fCB0aGlzLm5hbWVkVGltZVpvbmVJbXBsKTtcbiAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbSA9IGNyZWF0ZUNhbGVuZGFyU3lzdGVtKHNldHRpbmdzLmNhbGVuZGFyU3lzdGVtKTtcbiAgICAgICAgdGhpcy5sb2NhbGUgPSBzZXR0aW5ncy5sb2NhbGU7XG4gICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmxvY2FsZS53ZWVrLmRvdztcbiAgICAgICAgdGhpcy53ZWVrRG95ID0gc2V0dGluZ3MubG9jYWxlLndlZWsuZG95O1xuICAgICAgICBpZiAoc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnSVNPJykge1xuICAgICAgICAgICAgdGhpcy53ZWVrRG93ID0gMTtcbiAgICAgICAgICAgIHRoaXMud2Vla0RveSA9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXR0aW5ncy5maXJzdERheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRoaXMud2Vla0RvdyA9IHNldHRpbmdzLmZpcnN0RGF5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLndlZWtOdW1iZXJGdW5jID0gc2V0dGluZ3Mud2Vla051bWJlckNhbGN1bGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2Vla1RleHQgPSBzZXR0aW5ncy53ZWVrVGV4dCAhPSBudWxsID8gc2V0dGluZ3Mud2Vla1RleHQgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dDtcbiAgICAgICAgdGhpcy53ZWVrVGV4dExvbmcgPSAoc2V0dGluZ3Mud2Vla1RleHRMb25nICE9IG51bGwgPyBzZXR0aW5ncy53ZWVrVGV4dExvbmcgOiBzZXR0aW5ncy5sb2NhbGUub3B0aW9ucy53ZWVrVGV4dExvbmcpIHx8IHRoaXMud2Vla1RleHQ7XG4gICAgICAgIHRoaXMuY21kRm9ybWF0dGVyID0gc2V0dGluZ3MuY21kRm9ybWF0dGVyO1xuICAgICAgICB0aGlzLmRlZmF1bHRTZXBhcmF0b3IgPSBzZXR0aW5ncy5kZWZhdWx0U2VwYXJhdG9yO1xuICAgIH1cbiAgICAvLyBDcmVhdGluZyAvIFBhcnNpbmdcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jcmVhdGVNYXJrZXIgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLmNyZWF0ZU1hcmtlck1ldGEoaW5wdXQpO1xuICAgICAgICBpZiAobWV0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1ldGEubWFya2VyO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuY3JlYXRlTm93TWFya2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5Db21wdXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50aW1lc3RhbXBUb01hcmtlcihuZXcgRGF0ZSgpLnZhbHVlT2YoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuJ3QgY29tcHV0ZSB0aGUgY3VycmVudCBkYXRlIHZhbCBmb3IgYSB0aW1lem9uZSxcbiAgICAgICAgLy8gYmV0dGVyIHRvIGdpdmUgdGhlIGN1cnJlbnQgbG9jYWwgZGF0ZSB2YWxzIHRoYW4gVVRDXG4gICAgICAgIHJldHVybiBhcnJheVRvVXRjRGF0ZShkYXRlVG9Mb2NhbEFycmF5KG5ldyBEYXRlKCkpKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLmNyZWF0ZU1hcmtlck1ldGEgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFya2VyID0gbnVsbDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIG1hcmtlciA9IHRoaXMudGltZXN0YW1wVG9NYXJrZXIoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSBhcnJheVRvVXRjRGF0ZShpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlciA9PT0gbnVsbCB8fCAhaXNWYWxpZERhdGUobWFya2VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbWFya2VyOiBtYXJrZXIsIGlzVGltZVVuc3BlY2lmaWVkOiBmYWxzZSwgZm9yY2VkVHpvOiBudWxsIH07XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IHBhcnNlKHMpO1xuICAgICAgICBpZiAocGFydHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrZXIgPSBwYXJ0cy5tYXJrZXI7XG4gICAgICAgIHZhciBmb3JjZWRUem8gPSBudWxsO1xuICAgICAgICBpZiAocGFydHMudGltZVpvbmVPZmZzZXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkNvbXB1dGVPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSB0aGlzLnRpbWVzdGFtcFRvTWFya2VyKG1hcmtlci52YWx1ZU9mKCkgLSBwYXJ0cy50aW1lWm9uZU9mZnNldCAqIDYwICogMTAwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JjZWRUem8gPSBwYXJ0cy50aW1lWm9uZU9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBtYXJrZXI6IG1hcmtlciwgaXNUaW1lVW5zcGVjaWZpZWQ6IHBhcnRzLmlzVGltZVVuc3BlY2lmaWVkLCBmb3JjZWRUem86IGZvcmNlZFR6byB9O1xuICAgIH07XG4gICAgLy8gQWNjZXNzb3JzXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0WWVhciA9IGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtYXJrZXIpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZ2V0TW9udGggPSBmdW5jdGlvbiAobWFya2VyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmdldE1hcmtlck1vbnRoKG1hcmtlcik7XG4gICAgfTtcbiAgICAvLyBBZGRpbmcgLyBTdWJ0cmFjdGluZ1xuICAgIERhdGVFbnYucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdICs9IGR1ci55ZWFycztcbiAgICAgICAgYVsxXSArPSBkdXIubW9udGhzO1xuICAgICAgICBhWzJdICs9IGR1ci5kYXlzO1xuICAgICAgICBhWzZdICs9IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChtYXJrZXIsIGR1cikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzBdIC09IGR1ci55ZWFycztcbiAgICAgICAgYVsxXSAtPSBkdXIubW9udGhzO1xuICAgICAgICBhWzJdIC09IGR1ci5kYXlzO1xuICAgICAgICBhWzZdIC09IGR1ci5taWxsaXNlY29uZHM7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5hZGRZZWFycyA9IGZ1bmN0aW9uIChtYXJrZXIsIG4pIHtcbiAgICAgICAgdmFyIGEgPSB0aGlzLmNhbGVuZGFyU3lzdGVtLm1hcmtlclRvQXJyYXkobWFya2VyKTtcbiAgICAgICAgYVswXSArPSBuO1xuICAgICAgICByZXR1cm4gdGhpcy5jYWxlbmRhclN5c3RlbS5hcnJheVRvTWFya2VyKGEpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuYWRkTW9udGhzID0gZnVuY3Rpb24gKG1hcmtlciwgbikge1xuICAgICAgICB2YXIgYSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW0ubWFya2VyVG9BcnJheShtYXJrZXIpO1xuICAgICAgICBhWzFdICs9IG47XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoYSk7XG4gICAgfTtcbiAgICAvLyBEaWZmaW5nIFdob2xlIFVuaXRzXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZGlmZldob2xlWWVhcnMgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBjYWxlbmRhclN5c3RlbSA9IHRoaXMuY2FsZW5kYXJTeXN0ZW07XG4gICAgICAgIGlmICh0aW1lQXNNcyhtMCkgPT09IHRpbWVBc01zKG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0wKSA9PT0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyRGF5KG0xKSAmJlxuICAgICAgICAgICAgY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApID09PSBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtMSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0xKSAtIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZGlmZldob2xlTW9udGhzID0gZnVuY3Rpb24gKG0wLCBtMSkge1xuICAgICAgICB2YXIgY2FsZW5kYXJTeXN0ZW0gPSB0aGlzLmNhbGVuZGFyU3lzdGVtO1xuICAgICAgICBpZiAodGltZUFzTXMobTApID09PSB0aW1lQXNNcyhtMSkgJiZcbiAgICAgICAgICAgIGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMCkgPT09IGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlckRheShtMSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyTW9udGgobTApKSArXG4gICAgICAgICAgICAgICAgKGNhbGVuZGFyU3lzdGVtLmdldE1hcmtlclllYXIobTEpIC0gY2FsZW5kYXJTeXN0ZW0uZ2V0TWFya2VyWWVhcihtMCkpICogMTI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBSYW5nZSAvIER1cmF0aW9uXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZ3JlYXRlc3RXaG9sZVVuaXQgPSBmdW5jdGlvbiAobTAsIG0xKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ3llYXInLCB2YWx1ZTogbiB9O1xuICAgICAgICB9XG4gICAgICAgIG4gPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ21vbnRoJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlV2Vla3MobTAsIG0xKTtcbiAgICAgICAgaWYgKG4gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICd3ZWVrJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZldob2xlRGF5cyhtMCwgbTEpO1xuICAgICAgICBpZiAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdW5pdDogJ2RheScsIHZhbHVlOiBuIH07XG4gICAgICAgIH1cbiAgICAgICAgbiA9IGRpZmZIb3VycyhtMCwgbTEpO1xuICAgICAgICBpZiAoaXNJbnQobikpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHVuaXQ6ICdob3VyJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZk1pbnV0ZXMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnbWludXRlJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICBuID0gZGlmZlNlY29uZHMobTAsIG0xKTtcbiAgICAgICAgaWYgKGlzSW50KG4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyB1bml0OiAnc2Vjb25kJywgdmFsdWU6IG4gfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1bml0OiAnbWlsbGlzZWNvbmQnLCB2YWx1ZTogbTEudmFsdWVPZigpIC0gbTAudmFsdWVPZigpIH07XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5jb3VudER1cmF0aW9uc0JldHdlZW4gPSBmdW5jdGlvbiAobTAsIG0xLCBkKSB7XG4gICAgICAgIC8vIFRPRE86IGNhbiB1c2UgZ3JlYXRlc3RXaG9sZVVuaXRcbiAgICAgICAgdmFyIGRpZmY7XG4gICAgICAgIGlmIChkLnllYXJzKSB7XG4gICAgICAgICAgICBkaWZmID0gdGhpcy5kaWZmV2hvbGVZZWFycyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hZZWFycyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5tb250aHMpIHtcbiAgICAgICAgICAgIGRpZmYgPSB0aGlzLmRpZmZXaG9sZU1vbnRocyhtMCwgbTEpO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlmZiAvIGFzUm91Z2hNb250aHMoZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQuZGF5cykge1xuICAgICAgICAgICAgZGlmZiA9IGRpZmZXaG9sZURheXMobTAsIG0xKTtcbiAgICAgICAgICAgIGlmIChkaWZmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpZmYgLyBhc1JvdWdoRGF5cyhkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG0xLnZhbHVlT2YoKSAtIG0wLnZhbHVlT2YoKSkgLyBhc1JvdWdoTXMoZCk7XG4gICAgfTtcbiAgICAvLyBTdGFydC1PZlxuICAgIC8vIHRoZXNlIERPTidUIHJldHVybiB6b25lZC1kYXRlcy4gb25seSBVVEMgc3RhcnQtb2YgZGF0ZXNcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mID0gZnVuY3Rpb24gKG0sIHVuaXQpIHtcbiAgICAgICAgaWYgKHVuaXQgPT09ICd5ZWFyJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRPZlllYXIobSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXQgPT09ICdtb250aCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0T2ZNb250aChtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ3dlZWsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFydE9mV2VlayhtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ2RheScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mRGF5KG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnaG91cicpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mSG91cihtKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5pdCA9PT0gJ21pbnV0ZScpIHtcbiAgICAgICAgICAgIHJldHVybiBzdGFydE9mTWludXRlKG0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bml0ID09PSAnc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0T2ZTZWNvbmQobSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mWWVhciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIERhdGVFbnYucHJvdG90eXBlLnN0YXJ0T2ZNb250aCA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5zdGFydE9mV2VlayA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbGVuZGFyU3lzdGVtLmFycmF5VG9NYXJrZXIoW1xuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJZZWFyKG0pLFxuICAgICAgICAgICAgdGhpcy5jYWxlbmRhclN5c3RlbS5nZXRNYXJrZXJNb250aChtKSxcbiAgICAgICAgICAgIG0uZ2V0VVRDRGF0ZSgpIC0gKChtLmdldFVUQ0RheSgpIC0gdGhpcy53ZWVrRG93ICsgNykgJSA3KSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvLyBXZWVrIE51bWJlclxuICAgIERhdGVFbnYucHJvdG90eXBlLmNvbXB1dGVXZWVrTnVtYmVyID0gZnVuY3Rpb24gKG1hcmtlcikge1xuICAgICAgICBpZiAodGhpcy53ZWVrTnVtYmVyRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMud2Vla051bWJlckZ1bmModGhpcy50b0RhdGUobWFya2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdlZWtPZlllYXIobWFya2VyLCB0aGlzLndlZWtEb3csIHRoaXMud2Vla0RveSk7XG4gICAgfTtcbiAgICAvLyBUT0RPOiBjaG9rZSBvbiB0aW1lWm9uZU5hbWU6IGxvbmdcbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbiAobWFya2VyLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGRhdGVPcHRpb25zID0ge307IH1cbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlci5mb3JtYXQoe1xuICAgICAgICAgICAgbWFya2VyOiBtYXJrZXIsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIobWFya2VyKSxcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfTtcbiAgICBEYXRlRW52LnByb3RvdHlwZS5mb3JtYXRSYW5nZSA9IGZ1bmN0aW9uIChzdGFydCwgZW5kLCBmb3JtYXR0ZXIsIGRhdGVPcHRpb25zKSB7XG4gICAgICAgIGlmIChkYXRlT3B0aW9ucyA9PT0gdm9pZCAwKSB7IGRhdGVPcHRpb25zID0ge307IH1cbiAgICAgICAgaWYgKGRhdGVPcHRpb25zLmlzRW5kRXhjbHVzaXZlKSB7XG4gICAgICAgICAgICBlbmQgPSBhZGRNcyhlbmQsIC0xKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0dGVyLmZvcm1hdFJhbmdlKHtcbiAgICAgICAgICAgIG1hcmtlcjogc3RhcnQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgZGF0ZU9wdGlvbnMuZm9yY2VkU3RhcnRUem8gOlxuICAgICAgICAgICAgICAgIHRoaXMub2Zmc2V0Rm9yTWFya2VyKHN0YXJ0KSxcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgbWFya2VyOiBlbmQsXG4gICAgICAgICAgICB0aW1lWm9uZU9mZnNldDogZGF0ZU9wdGlvbnMuZm9yY2VkRW5kVHpvICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGRhdGVPcHRpb25zLmZvcmNlZEVuZFR6byA6XG4gICAgICAgICAgICAgICAgdGhpcy5vZmZzZXRGb3JNYXJrZXIoZW5kKSxcbiAgICAgICAgfSwgdGhpcywgZGF0ZU9wdGlvbnMuZGVmYXVsdFNlcGFyYXRvcik7XG4gICAgfTtcbiAgICAvKlxuICAgIERVTUI6IHRoZSBvbWl0VGltZSBhcmcgaXMgZHVtYi4gaWYgd2Ugb21pdCB0aGUgdGltZSwgd2Ugd2FudCB0byBvbWl0IHRoZSB0aW1lem9uZSBvZmZzZXQuIGFuZCBpZiB3ZSBkbyB0aGF0LFxuICAgIG1pZ2h0IGFzIHdlbGwgdXNlIGJ1aWxkSXNvU3RyaW5nIG9yIHNvbWUgb3RoZXIgdXRpbCBkaXJlY3RseVxuICAgICovXG4gICAgRGF0ZUVudi5wcm90b3R5cGUuZm9ybWF0SXNvID0gZnVuY3Rpb24gKG1hcmtlciwgZXh0cmFPcHRpb25zKSB7XG4gICAgICAgIGlmIChleHRyYU9wdGlvbnMgPT09IHZvaWQgMCkgeyBleHRyYU9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgdGltZVpvbmVPZmZzZXQgPSBudWxsO1xuICAgICAgICBpZiAoIWV4dHJhT3B0aW9ucy5vbWl0VGltZVpvbmVPZmZzZXQpIHtcbiAgICAgICAgICAgIGlmIChleHRyYU9wdGlvbnMuZm9yY2VkVHpvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IGV4dHJhT3B0aW9ucy5mb3JjZWRUem87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aW1lWm9uZU9mZnNldCA9IHRoaXMub2Zmc2V0Rm9yTWFya2VyKG1hcmtlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ1aWxkSXNvU3RyaW5nKG1hcmtlciwgdGltZVpvbmVPZmZzZXQsIGV4dHJhT3B0aW9ucy5vbWl0VGltZSk7XG4gICAgfTtcbiAgICAvLyBUaW1lWm9uZVxuICAgIERhdGVFbnYucHJvdG90eXBlLnRpbWVzdGFtcFRvTWFya2VyID0gZnVuY3Rpb24gKG1zKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnbG9jYWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlUb1V0Y0RhdGUoZGF0ZVRvTG9jYWxBcnJheShuZXcgRGF0ZShtcykpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycgfHwgIXRoaXMubmFtZWRUaW1lWm9uZUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5VG9VdGNEYXRlKHRoaXMubmFtZWRUaW1lWm9uZUltcGwudGltZXN0YW1wVG9BcnJheShtcykpO1xuICAgIH07XG4gICAgRGF0ZUVudi5wcm90b3R5cGUub2Zmc2V0Rm9yTWFya2VyID0gZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgaWYgKHRoaXMudGltZVpvbmUgPT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgIHJldHVybiAtYXJyYXlUb0xvY2FsRGF0ZShkYXRlVG9VdGNBcnJheShtKSkuZ2V0VGltZXpvbmVPZmZzZXQoKTsgLy8gY29udmVydCBcImludmVyc2VcIiBvZmZzZXQgdG8gXCJub3JtYWxcIiBvZmZzZXRcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ1VUQycpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBDb252ZXJzaW9uXG4gICAgRGF0ZUVudi5wcm90b3R5cGUudG9EYXRlID0gZnVuY3Rpb24gKG0sIGZvcmNlZFR6bykge1xuICAgICAgICBpZiAodGhpcy50aW1lWm9uZSA9PT0gJ2xvY2FsJykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5VG9Mb2NhbERhdGUoZGF0ZVRvVXRjQXJyYXkobSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRpbWVab25lID09PSAnVVRDJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKG0udmFsdWVPZigpKTsgLy8gbWFrZSBzdXJlIGl0J3MgYSBjb3B5XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm5hbWVkVGltZVpvbmVJbXBsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLSAoZm9yY2VkVHpvIHx8IDApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IERhdGUobS52YWx1ZU9mKCkgLVxuICAgICAgICAgICAgdGhpcy5uYW1lZFRpbWVab25lSW1wbC5vZmZzZXRGb3JBcnJheShkYXRlVG9VdGNBcnJheShtKSkgKiAxMDAwICogNjApO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGVFbnY7XG59KCkpO1xuXG52YXIgZ2xvYmFsTG9jYWxlcyA9IFtdO1xuXG52YXIgTUlOSU1BTF9SQVdfRU5fTE9DQUxFID0ge1xuICAgIGNvZGU6ICdlbicsXG4gICAgd2Vlazoge1xuICAgICAgICBkb3c6IDAsXG4gICAgICAgIGRveTogNCwgLy8gNCBkYXlzIG5lZWQgdG8gYmUgd2l0aGluIHRoZSB5ZWFyIHRvIGJlIGNvbnNpZGVyZWQgdGhlIGZpcnN0IHdlZWtcbiAgICB9LFxuICAgIGRpcmVjdGlvbjogJ2x0cicsXG4gICAgYnV0dG9uVGV4dDoge1xuICAgICAgICBwcmV2OiAncHJldicsXG4gICAgICAgIG5leHQ6ICduZXh0JyxcbiAgICAgICAgcHJldlllYXI6ICdwcmV2IHllYXInLFxuICAgICAgICBuZXh0WWVhcjogJ25leHQgeWVhcicsXG4gICAgICAgIHllYXI6ICd5ZWFyJyxcbiAgICAgICAgdG9kYXk6ICd0b2RheScsXG4gICAgICAgIG1vbnRoOiAnbW9udGgnLFxuICAgICAgICB3ZWVrOiAnd2VlaycsXG4gICAgICAgIGRheTogJ2RheScsXG4gICAgICAgIGxpc3Q6ICdsaXN0JyxcbiAgICB9LFxuICAgIHdlZWtUZXh0OiAnVycsXG4gICAgd2Vla1RleHRMb25nOiAnV2VlaycsXG4gICAgY2xvc2VIaW50OiAnQ2xvc2UnLFxuICAgIHRpbWVIaW50OiAnVGltZScsXG4gICAgZXZlbnRIaW50OiAnRXZlbnQnLFxuICAgIGFsbERheVRleHQ6ICdhbGwtZGF5JyxcbiAgICBtb3JlTGlua1RleHQ6ICdtb3JlJyxcbiAgICBub0V2ZW50c1RleHQ6ICdObyBldmVudHMgdG8gZGlzcGxheScsXG59O1xudmFyIFJBV19FTl9MT0NBTEUgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgTUlOSU1BTF9SQVdfRU5fTE9DQUxFKSwgeyBcbiAgICAvLyBJbmNsdWRlcyB0aGluZ3Mgd2UgZG9uJ3Qgd2FudCBvdGhlciBsb2NhbGVzIHRvIGluaGVyaXQsXG4gICAgLy8gdGhpbmdzIHRoYXQgZGVyaXZlIGZyb20gb3RoZXIgdHJhbnNsYXRhYmxlIHN0cmluZ3MuXG4gICAgYnV0dG9uSGludHM6IHtcbiAgICAgICAgcHJldjogJ1ByZXZpb3VzICQwJyxcbiAgICAgICAgbmV4dDogJ05leHQgJDAnLFxuICAgICAgICB0b2RheTogZnVuY3Rpb24gKGJ1dHRvblRleHQsIHVuaXQpIHtcbiAgICAgICAgICAgIHJldHVybiAodW5pdCA9PT0gJ2RheScpXG4gICAgICAgICAgICAgICAgPyAnVG9kYXknXG4gICAgICAgICAgICAgICAgOiBcIlRoaXMgXCIgKyBidXR0b25UZXh0O1xuICAgICAgICB9LFxuICAgIH0sIHZpZXdIaW50OiAnJDAgdmlldycsIG5hdkxpbmtIaW50OiAnR28gdG8gJDAnLCBtb3JlTGlua0hpbnQ6IGZ1bmN0aW9uIChldmVudENudCkge1xuICAgICAgICByZXR1cm4gXCJTaG93IFwiICsgZXZlbnRDbnQgKyBcIiBtb3JlIGV2ZW50XCIgKyAoZXZlbnRDbnQgPT09IDEgPyAnJyA6ICdzJyk7XG4gICAgfSB9KTtcbmZ1bmN0aW9uIG9yZ2FuaXplUmF3TG9jYWxlcyhleHBsaWNpdFJhd0xvY2FsZXMpIHtcbiAgICB2YXIgZGVmYXVsdENvZGUgPSBleHBsaWNpdFJhd0xvY2FsZXMubGVuZ3RoID4gMCA/IGV4cGxpY2l0UmF3TG9jYWxlc1swXS5jb2RlIDogJ2VuJztcbiAgICB2YXIgYWxsUmF3TG9jYWxlcyA9IGdsb2JhbExvY2FsZXMuY29uY2F0KGV4cGxpY2l0UmF3TG9jYWxlcyk7XG4gICAgdmFyIHJhd0xvY2FsZU1hcCA9IHtcbiAgICAgICAgZW46IFJBV19FTl9MT0NBTEUsXG4gICAgfTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGFsbFJhd0xvY2FsZXNfMSA9IGFsbFJhd0xvY2FsZXM7IF9pIDwgYWxsUmF3TG9jYWxlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmF3TG9jYWxlID0gYWxsUmF3TG9jYWxlc18xW19pXTtcbiAgICAgICAgcmF3TG9jYWxlTWFwW3Jhd0xvY2FsZS5jb2RlXSA9IHJhd0xvY2FsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFwOiByYXdMb2NhbGVNYXAsXG4gICAgICAgIGRlZmF1bHRDb2RlOiBkZWZhdWx0Q29kZSxcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRMb2NhbGUoaW5wdXRTaW5ndWxhciwgYXZhaWxhYmxlKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dFNpbmd1bGFyID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbnB1dFNpbmd1bGFyKSkge1xuICAgICAgICByZXR1cm4gcGFyc2VMb2NhbGUoaW5wdXRTaW5ndWxhci5jb2RlLCBbaW5wdXRTaW5ndWxhci5jb2RlXSwgaW5wdXRTaW5ndWxhcik7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeUxvY2FsZShpbnB1dFNpbmd1bGFyLCBhdmFpbGFibGUpO1xufVxuZnVuY3Rpb24gcXVlcnlMb2NhbGUoY29kZUFyZywgYXZhaWxhYmxlKSB7XG4gICAgdmFyIGNvZGVzID0gW10uY29uY2F0KGNvZGVBcmcgfHwgW10pOyAvLyB3aWxsIGNvbnZlcnQgdG8gYXJyYXlcbiAgICB2YXIgcmF3ID0gcXVlcnlSYXdMb2NhbGUoY29kZXMsIGF2YWlsYWJsZSkgfHwgUkFXX0VOX0xPQ0FMRTtcbiAgICByZXR1cm4gcGFyc2VMb2NhbGUoY29kZUFyZywgY29kZXMsIHJhdyk7XG59XG5mdW5jdGlvbiBxdWVyeVJhd0xvY2FsZShjb2RlcywgYXZhaWxhYmxlKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2Rlcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgcGFydHMgPSBjb2Rlc1tpXS50b0xvY2FsZUxvd2VyQ2FzZSgpLnNwbGl0KCctJyk7XG4gICAgICAgIGZvciAodmFyIGogPSBwYXJ0cy5sZW5ndGg7IGogPiAwOyBqIC09IDEpIHtcbiAgICAgICAgICAgIHZhciBzaW1wbGVJZCA9IHBhcnRzLnNsaWNlKDAsIGopLmpvaW4oJy0nKTtcbiAgICAgICAgICAgIGlmIChhdmFpbGFibGVbc2ltcGxlSWRdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVtzaW1wbGVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwYXJzZUxvY2FsZShjb2RlQXJnLCBjb2RlcywgcmF3KSB7XG4gICAgdmFyIG1lcmdlZCA9IG1lcmdlUHJvcHMoW01JTklNQUxfUkFXX0VOX0xPQ0FMRSwgcmF3XSwgWydidXR0b25UZXh0J10pO1xuICAgIGRlbGV0ZSBtZXJnZWQuY29kZTsgLy8gZG9uJ3Qgd2FudCB0aGlzIHBhcnQgb2YgdGhlIG9wdGlvbnNcbiAgICB2YXIgd2VlayA9IG1lcmdlZC53ZWVrO1xuICAgIGRlbGV0ZSBtZXJnZWQud2VlaztcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlQXJnOiBjb2RlQXJnLFxuICAgICAgICBjb2RlczogY29kZXMsXG4gICAgICAgIHdlZWs6IHdlZWssXG4gICAgICAgIHNpbXBsZU51bWJlckZvcm1hdDogbmV3IEludGwuTnVtYmVyRm9ybWF0KGNvZGVBcmcpLFxuICAgICAgICBvcHRpb25zOiBtZXJnZWQsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0RGF0ZShkYXRlSW5wdXQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBkYXRlRW52ID0gYnVpbGREYXRlRW52JDEob3B0aW9ucyk7XG4gICAgdmFyIGZvcm1hdHRlciA9IGNyZWF0ZUZvcm1hdHRlcihvcHRpb25zKTtcbiAgICB2YXIgZGF0ZU1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZGF0ZUlucHV0KTtcbiAgICBpZiAoIWRhdGVNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0KGRhdGVNZXRhLm1hcmtlciwgZm9ybWF0dGVyLCB7XG4gICAgICAgIGZvcmNlZFR6bzogZGF0ZU1ldGEuZm9yY2VkVHpvLFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZm9ybWF0UmFuZ2Uoc3RhcnRJbnB1dCwgZW5kSW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGJ1aWxkRGF0ZUVudiQxKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zID8gb3B0aW9ucyA6IHt9KTsgLy8gcGFzcyBpbiBpZiBub24tbnVsbCBvYmplY3RcbiAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRm9ybWF0dGVyKG9wdGlvbnMpO1xuICAgIHZhciBzdGFydE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoc3RhcnRJbnB1dCk7XG4gICAgdmFyIGVuZE1ldGEgPSBkYXRlRW52LmNyZWF0ZU1hcmtlck1ldGEoZW5kSW5wdXQpO1xuICAgIGlmICghc3RhcnRNZXRhIHx8ICFlbmRNZXRhKSB7IC8vIFRPRE86IHdhcm5pbmc/XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2Uoc3RhcnRNZXRhLm1hcmtlciwgZW5kTWV0YS5tYXJrZXIsIGZvcm1hdHRlciwge1xuICAgICAgICBmb3JjZWRTdGFydFR6bzogc3RhcnRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgZm9yY2VkRW5kVHpvOiBlbmRNZXRhLmZvcmNlZFR6byxcbiAgICAgICAgaXNFbmRFeGNsdXNpdmU6IG9wdGlvbnMuaXNFbmRFeGNsdXNpdmUsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IEJBU0VfT1BUSU9OX0RFRkFVTFRTLmRlZmF1bHRSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIFRPRE86IG1vcmUgRFJZIGFuZCBvcHRpbWl6ZWRcbmZ1bmN0aW9uIGJ1aWxkRGF0ZUVudiQxKHNldHRpbmdzKSB7XG4gICAgdmFyIGxvY2FsZSA9IGJ1aWxkTG9jYWxlKHNldHRpbmdzLmxvY2FsZSB8fCAnZW4nLCBvcmdhbml6ZVJhd0xvY2FsZXMoW10pLm1hcCk7IC8vIFRPRE86IGRvbid0IGhhcmRjb2RlICdlbicgZXZlcnl3aGVyZVxuICAgIHJldHVybiBuZXcgRGF0ZUVudih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7IHRpbWVab25lOiBCQVNFX09QVElPTl9ERUZBVUxUUy50aW1lWm9uZSwgY2FsZW5kYXJTeXN0ZW06ICdncmVnb3J5JyB9LCBzZXR0aW5ncyksIHsgbG9jYWxlOiBsb2NhbGUgfSkpO1xufVxuXG52YXIgREVGX0RFRkFVTFRTID0ge1xuICAgIHN0YXJ0VGltZTogJzA5OjAwJyxcbiAgICBlbmRUaW1lOiAnMTc6MDAnLFxuICAgIGRheXNPZldlZWs6IFsxLCAyLCAzLCA0LCA1XSxcbiAgICBkaXNwbGF5OiAnaW52ZXJzZS1iYWNrZ3JvdW5kJyxcbiAgICBjbGFzc05hbWVzOiAnZmMtbm9uLWJ1c2luZXNzJyxcbiAgICBncm91cElkOiAnX2J1c2luZXNzSG91cnMnLCAvLyBzbyBtdWx0aXBsZSBkZWZzIGdldCBncm91cGVkXG59O1xuLypcblRPRE86IHBhc3MgYXJvdW5kIGFzIEV2ZW50RGVmSGFzaCEhIVxuKi9cbmZ1bmN0aW9uIHBhcnNlQnVzaW5lc3NIb3VycyhpbnB1dCwgY29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUV2ZW50cyhyZWZpbmVJbnB1dHMoaW5wdXQpLCBudWxsLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZmluZUlucHV0cyhpbnB1dCkge1xuICAgIHZhciByYXdEZWZzO1xuICAgIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICByYXdEZWZzID0gW3t9XTsgLy8gd2lsbCBnZXQgREVGX0RFRkFVTFRTIHZlcmJhdGltXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgIC8vIGlmIHNwZWNpZnlpbmcgYW4gYXJyYXksIGV2ZXJ5IHN1Yi1kZWZpbml0aW9uIE5FRURTIGEgZGF5LW9mLXdlZWtcbiAgICAgICAgcmF3RGVmcyA9IGlucHV0LmZpbHRlcihmdW5jdGlvbiAocmF3RGVmKSB7IHJldHVybiByYXdEZWYuZGF5c09mV2VlazsgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQpIHsgLy8gbm9uLW51bGwgb2JqZWN0XG4gICAgICAgIHJhd0RlZnMgPSBbaW5wdXRdO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gaXMgcHJvYmFibHkgZmFsc2VcbiAgICAgICAgcmF3RGVmcyA9IFtdO1xuICAgIH1cbiAgICByYXdEZWZzID0gcmF3RGVmcy5tYXAoZnVuY3Rpb24gKHJhd0RlZikgeyByZXR1cm4gKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBERUZfREVGQVVMVFMpLCByYXdEZWYpKTsgfSk7XG4gICAgcmV0dXJuIHJhd0RlZnM7XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5zaWRlUmVjdChwb2ludCwgcmVjdCkge1xuICAgIHJldHVybiBwb2ludC5sZWZ0ID49IHJlY3QubGVmdCAmJlxuICAgICAgICBwb2ludC5sZWZ0IDwgcmVjdC5yaWdodCAmJlxuICAgICAgICBwb2ludC50b3AgPj0gcmVjdC50b3AgJiZcbiAgICAgICAgcG9pbnQudG9wIDwgcmVjdC5ib3R0b207XG59XG4vLyBSZXR1cm5zIGEgbmV3IHJlY3RhbmdsZSB0aGF0IGlzIHRoZSBpbnRlcnNlY3Rpb24gb2YgdGhlIHR3byByZWN0YW5nbGVzLiBJZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyBmYWxzZVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdHMocmVjdDEsIHJlY3QyKSB7XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5tYXgocmVjdDEubGVmdCwgcmVjdDIubGVmdCksXG4gICAgICAgIHJpZ2h0OiBNYXRoLm1pbihyZWN0MS5yaWdodCwgcmVjdDIucmlnaHQpLFxuICAgICAgICB0b3A6IE1hdGgubWF4KHJlY3QxLnRvcCwgcmVjdDIudG9wKSxcbiAgICAgICAgYm90dG9tOiBNYXRoLm1pbihyZWN0MS5ib3R0b20sIHJlY3QyLmJvdHRvbSksXG4gICAgfTtcbiAgICBpZiAocmVzLmxlZnQgPCByZXMucmlnaHQgJiYgcmVzLnRvcCA8IHJlcy5ib3R0b20pIHtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gdHJhbnNsYXRlUmVjdChyZWN0LCBkZWx0YVgsIGRlbHRhWSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIGRlbHRhWCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyBkZWx0YVgsXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyBkZWx0YVksXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyBkZWx0YVksXG4gICAgfTtcbn1cbi8vIFJldHVybnMgYSBuZXcgcG9pbnQgdGhhdCB3aWxsIGhhdmUgYmVlbiBtb3ZlZCB0byByZXNpZGUgd2l0aGluIHRoZSBnaXZlbiByZWN0YW5nbGVcbmZ1bmN0aW9uIGNvbnN0cmFpblBvaW50KHBvaW50LCByZWN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQubGVmdCwgcmVjdC5sZWZ0KSwgcmVjdC5yaWdodCksXG4gICAgICAgIHRvcDogTWF0aC5taW4oTWF0aC5tYXgocG9pbnQudG9wLCByZWN0LnRvcCksIHJlY3QuYm90dG9tKSxcbiAgICB9O1xufVxuLy8gUmV0dXJucyBhIHBvaW50IHRoYXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlXG5mdW5jdGlvbiBnZXRSZWN0Q2VudGVyKHJlY3QpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLFxuICAgICAgICB0b3A6IChyZWN0LnRvcCArIHJlY3QuYm90dG9tKSAvIDIsXG4gICAgfTtcbn1cbi8vIFN1YnRyYWN0cyBwb2ludDIncyBjb29yZGluYXRlcyBmcm9tIHBvaW50MSdzIGNvb3JkaW5hdGVzLCByZXR1cm5pbmcgYSBkZWx0YVxuZnVuY3Rpb24gZGlmZlBvaW50cyhwb2ludDEsIHBvaW50Mikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHBvaW50MS5sZWZ0IC0gcG9pbnQyLmxlZnQsXG4gICAgICAgIHRvcDogcG9pbnQxLnRvcCAtIHBvaW50Mi50b3AsXG4gICAgfTtcbn1cblxudmFyIGNhblZHcm93V2l0aGluQ2VsbDtcbmZ1bmN0aW9uIGdldENhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICBpZiAoY2FuVkdyb3dXaXRoaW5DZWxsID09IG51bGwpIHtcbiAgICAgICAgY2FuVkdyb3dXaXRoaW5DZWxsID0gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpO1xuICAgIH1cbiAgICByZXR1cm4gY2FuVkdyb3dXaXRoaW5DZWxsO1xufVxuZnVuY3Rpb24gY29tcHV0ZUNhblZHcm93V2l0aGluQ2VsbCgpIHtcbiAgICAvLyBmb3IgU1NSLCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgY2FsbCBpbW1lZGlhdGVseSBhdCB0b3AtbGV2ZWxcbiAgICAvLyBUT0RPOiBqdXN0IG1ha2UgdGhpcyBsb2dpYyBleGVjdXRlIHRvcC1sZXZlbCwgaW1tZWRpYXRlbHksIGluc3RlYWQgb2YgZG9pbmcgbGF6aWx5XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBlbC5zdHlsZS50b3AgPSAnMHB4JztcbiAgICBlbC5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgZWwuaW5uZXJIVE1MID0gJzx0YWJsZT48dHI+PHRkPjxkaXY+PC9kaXY+PC90ZD48L3RyPjwvdGFibGU+JztcbiAgICBlbC5xdWVyeVNlbGVjdG9yKCd0YWJsZScpLnN0eWxlLmhlaWdodCA9ICcxMDBweCc7XG4gICAgZWwucXVlcnlTZWxlY3RvcignZGl2Jykuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIHZhciBkaXYgPSBlbC5xdWVyeVNlbGVjdG9yKCdkaXYnKTtcbiAgICB2YXIgcG9zc2libGUgPSBkaXYub2Zmc2V0SGVpZ2h0ID4gMDtcbiAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGVsKTtcbiAgICByZXR1cm4gcG9zc2libGU7XG59XG5cbnZhciBFTVBUWV9FVkVOVF9TVE9SRSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpOyAvLyBmb3IgcHVyZWNvbXBvbmVudHMuIFRPRE86IGtlZXAgZWxzZXdoZXJlXG52YXIgU3BsaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3BsaXR0ZXIoKSB7XG4gICAgICAgIHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IG1lbW9pemUodGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyk7XG4gICAgICAgIHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uID0gbWVtb2l6ZSh0aGlzLl9zcGxpdERhdGVTcGFuKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50U3RvcmUgPSBtZW1vaXplKHRoaXMuX3NwbGl0RXZlbnRTdG9yZSk7XG4gICAgICAgIHRoaXMuc3BsaXRJbmRpdmlkdWFsVWkgPSBtZW1vaXplKHRoaXMuX3NwbGl0SW5kaXZpZHVhbFVpKTtcbiAgICAgICAgdGhpcy5zcGxpdEV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc3BsaXRJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZXZlbnRVaUJ1aWxkZXJzID0ge307IC8vIFRPRE86IHR5cGVzY3JpcHQgcHJvdGVjdGlvblxuICAgIH1cbiAgICBTcGxpdHRlci5wcm90b3R5cGUuc3BsaXRQcm9wcyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIga2V5SW5mb3MgPSB0aGlzLmdldEtleUluZm8ocHJvcHMpO1xuICAgICAgICB2YXIgZGVmS2V5cyA9IHRoaXMuZ2V0S2V5c0ZvckV2ZW50RGVmcyhwcm9wcy5ldmVudFN0b3JlKTtcbiAgICAgICAgdmFyIGRhdGVTZWxlY3Rpb25zID0gdGhpcy5zcGxpdERhdGVTZWxlY3Rpb24ocHJvcHMuZGF0ZVNlbGVjdGlvbik7XG4gICAgICAgIHZhciBpbmRpdmlkdWFsVWkgPSB0aGlzLnNwbGl0SW5kaXZpZHVhbFVpKHByb3BzLmV2ZW50VWlCYXNlcywgZGVmS2V5cyk7IC8vIHRoZSBpbmRpdmlkdWFsICpiYXNlcypcbiAgICAgICAgdmFyIGV2ZW50U3RvcmVzID0gdGhpcy5zcGxpdEV2ZW50U3RvcmUocHJvcHMuZXZlbnRTdG9yZSwgZGVmS2V5cyk7XG4gICAgICAgIHZhciBldmVudERyYWdzID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcpO1xuICAgICAgICB2YXIgZXZlbnRSZXNpemVzID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplKTtcbiAgICAgICAgdmFyIHNwbGl0UHJvcHMgPSB7fTtcbiAgICAgICAgdGhpcy5ldmVudFVpQnVpbGRlcnMgPSBtYXBIYXNoKGtleUluZm9zLCBmdW5jdGlvbiAoaW5mbywga2V5KSB7IHJldHVybiBfdGhpcy5ldmVudFVpQnVpbGRlcnNba2V5XSB8fCBtZW1vaXplKGJ1aWxkRXZlbnRVaUZvcktleSk7IH0pO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4ga2V5SW5mb3MpIHtcbiAgICAgICAgICAgIHZhciBrZXlJbmZvID0ga2V5SW5mb3Nba2V5XTtcbiAgICAgICAgICAgIHZhciBldmVudFN0b3JlID0gZXZlbnRTdG9yZXNba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRTtcbiAgICAgICAgICAgIHZhciBidWlsZEV2ZW50VWkgPSB0aGlzLmV2ZW50VWlCdWlsZGVyc1trZXldO1xuICAgICAgICAgICAgc3BsaXRQcm9wc1trZXldID0ge1xuICAgICAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IGtleUluZm8uYnVzaW5lc3NIb3VycyB8fCBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IGRhdGVTZWxlY3Rpb25zW2tleV0gfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBldmVudFN0b3JlOiBldmVudFN0b3JlLFxuICAgICAgICAgICAgICAgIGV2ZW50VWlCYXNlczogYnVpbGRFdmVudFVpKHByb3BzLmV2ZW50VWlCYXNlc1snJ10sIGtleUluZm8udWksIGluZGl2aWR1YWxVaVtrZXldKSxcbiAgICAgICAgICAgICAgICBldmVudFNlbGVjdGlvbjogZXZlbnRTdG9yZS5pbnN0YW5jZXNbcHJvcHMuZXZlbnRTZWxlY3Rpb25dID8gcHJvcHMuZXZlbnRTZWxlY3Rpb24gOiAnJyxcbiAgICAgICAgICAgICAgICBldmVudERyYWc6IGV2ZW50RHJhZ3Nba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGV2ZW50UmVzaXplOiBldmVudFJlc2l6ZXNba2V5XSB8fCBudWxsLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BsaXRQcm9wcztcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXREYXRlU3BhbiA9IGZ1bmN0aW9uIChkYXRlU3Bhbikge1xuICAgICAgICB2YXIgZGF0ZVNwYW5zID0ge307XG4gICAgICAgIGlmIChkYXRlU3Bhbikge1xuICAgICAgICAgICAgdmFyIGtleXMgPSB0aGlzLmdldEtleXNGb3JEYXRlU3BhbihkYXRlU3Bhbik7XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGtleXNfMSA9IGtleXM7IF9pIDwga2V5c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGRhdGVTcGFuc1trZXldID0gZGF0ZVNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVTcGFucztcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fZ2V0S2V5c0ZvckV2ZW50RGVmcyA9IGZ1bmN0aW9uIChldmVudFN0b3JlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBtYXBIYXNoKGV2ZW50U3RvcmUuZGVmcywgZnVuY3Rpb24gKGV2ZW50RGVmKSB7IHJldHVybiBfdGhpcy5nZXRLZXlzRm9yRXZlbnREZWYoZXZlbnREZWYpOyB9KTtcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRFdmVudFN0b3JlID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGRlZktleXMpIHtcbiAgICAgICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnMsIGluc3RhbmNlcyA9IGV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgICAgICB2YXIgc3BsaXRTdG9yZXMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgZGVmSWQgaW4gZGVmcykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBfYVtfaV07XG4gICAgICAgICAgICAgICAgaWYgKCFzcGxpdFN0b3Jlc1trZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGl0U3RvcmVzW2tleV0gPSBjcmVhdGVFbXB0eUV2ZW50U3RvcmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5kZWZzW2RlZklkXSA9IGRlZnNbZGVmSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGluc3RhbmNlSWQgaW4gaW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBpbnN0YW5jZXNbaW5zdGFuY2VJZF07XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gZGVmS2V5c1tpbnN0YW5jZS5kZWZJZF07IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jW19iXTtcbiAgICAgICAgICAgICAgICBpZiAoc3BsaXRTdG9yZXNba2V5XSkgeyAvLyBtdXN0IGhhdmUgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdG9yZXNba2V5XS5pbnN0YW5jZXNbaW5zdGFuY2VJZF0gPSBpbnN0YW5jZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwbGl0U3RvcmVzO1xuICAgIH07XG4gICAgU3BsaXR0ZXIucHJvdG90eXBlLl9zcGxpdEluZGl2aWR1YWxVaSA9IGZ1bmN0aW9uIChldmVudFVpQmFzZXMsIGRlZktleXMpIHtcbiAgICAgICAgdmFyIHNwbGl0SGFzaGVzID0ge307XG4gICAgICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50VWlCYXNlcykge1xuICAgICAgICAgICAgaWYgKGRlZklkKSB7IC8vIG5vdCB0aGUgJycga2V5XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IGRlZktleXNbZGVmSWRdOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNwbGl0SGFzaGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0SGFzaGVzW2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzcGxpdEhhc2hlc1trZXldW2RlZklkXSA9IGV2ZW50VWlCYXNlc1tkZWZJZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdEhhc2hlcztcbiAgICB9O1xuICAgIFNwbGl0dGVyLnByb3RvdHlwZS5fc3BsaXRJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbikge1xuICAgICAgICB2YXIgc3BsaXRTdGF0ZXMgPSB7fTtcbiAgICAgICAgaWYgKGludGVyYWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgYWZmZWN0ZWRTdG9yZXNfMSA9IHRoaXMuX3NwbGl0RXZlbnRTdG9yZShpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cywgdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5hZmZlY3RlZEV2ZW50cykpO1xuICAgICAgICAgICAgLy8gY2FuJ3QgcmVseSBvbiBkZWZLZXlzIGJlY2F1c2UgZXZlbnQgZGF0YSBpcyBtdXRhdGVkXG4gICAgICAgICAgICB2YXIgbXV0YXRlZEtleXNCeURlZklkID0gdGhpcy5fZ2V0S2V5c0ZvckV2ZW50RGVmcyhpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzKTtcbiAgICAgICAgICAgIHZhciBtdXRhdGVkU3RvcmVzXzEgPSB0aGlzLl9zcGxpdEV2ZW50U3RvcmUoaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cywgbXV0YXRlZEtleXNCeURlZklkKTtcbiAgICAgICAgICAgIHZhciBwb3B1bGF0ZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNwbGl0U3RhdGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3BsaXRTdGF0ZXNba2V5XSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBhZmZlY3RlZFN0b3Jlc18xW2tleV0gfHwgRU1QVFlfRVZFTlRfU1RPUkUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdXRhdGVkRXZlbnRzOiBtdXRhdGVkU3RvcmVzXzFba2V5XSB8fCBFTVBUWV9FVkVOVF9TVE9SRSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRXZlbnQ6IGludGVyYWN0aW9uLmlzRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhZmZlY3RlZFN0b3Jlc18xKSB7XG4gICAgICAgICAgICAgICAgcG9wdWxhdGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBtdXRhdGVkU3RvcmVzXzEpIHtcbiAgICAgICAgICAgICAgICBwb3B1bGF0ZShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGxpdFN0YXRlcztcbiAgICB9O1xuICAgIHJldHVybiBTcGxpdHRlcjtcbn0oKSk7XG5mdW5jdGlvbiBidWlsZEV2ZW50VWlGb3JLZXkoYWxsVWksIGV2ZW50VWlGb3JLZXksIGluZGl2aWR1YWxVaSkge1xuICAgIHZhciBiYXNlUGFydHMgPSBbXTtcbiAgICBpZiAoYWxsVWkpIHtcbiAgICAgICAgYmFzZVBhcnRzLnB1c2goYWxsVWkpO1xuICAgIH1cbiAgICBpZiAoZXZlbnRVaUZvcktleSkge1xuICAgICAgICBiYXNlUGFydHMucHVzaChldmVudFVpRm9yS2V5KTtcbiAgICB9XG4gICAgdmFyIHN0dWZmID0ge1xuICAgICAgICAnJzogY29tYmluZUV2ZW50VWlzKGJhc2VQYXJ0cyksXG4gICAgfTtcbiAgICBpZiAoaW5kaXZpZHVhbFVpKSB7XG4gICAgICAgIHRzbGliLl9fYXNzaWduKHN0dWZmLCBpbmRpdmlkdWFsVWkpO1xuICAgIH1cbiAgICByZXR1cm4gc3R1ZmY7XG59XG5cbmZ1bmN0aW9uIGdldERhdGVNZXRhKGRhdGUsIHRvZGF5UmFuZ2UsIG5vd0RhdGUsIGRhdGVQcm9maWxlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZG93OiBkYXRlLmdldFVUQ0RheSgpLFxuICAgICAgICBpc0Rpc2FibGVkOiBCb29sZWFuKGRhdGVQcm9maWxlICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzT3RoZXI6IEJvb2xlYW4oZGF0ZVByb2ZpbGUgJiYgIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLCBkYXRlKSksXG4gICAgICAgIGlzVG9kYXk6IEJvb2xlYW4odG9kYXlSYW5nZSAmJiByYW5nZUNvbnRhaW5zTWFya2VyKHRvZGF5UmFuZ2UsIGRhdGUpKSxcbiAgICAgICAgaXNQYXN0OiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA8IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlIDwgdG9kYXlSYW5nZS5zdGFydCkgOiBmYWxzZSksXG4gICAgICAgIGlzRnV0dXJlOiBCb29sZWFuKG5vd0RhdGUgPyAoZGF0ZSA+IG5vd0RhdGUpIDogdG9kYXlSYW5nZSA/IChkYXRlID49IHRvZGF5UmFuZ2UuZW5kKSA6IGZhbHNlKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF5Q2xhc3NOYW1lcyhtZXRhLCB0aGVtZSkge1xuICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAnZmMtZGF5JyxcbiAgICAgICAgXCJmYy1kYXktXCIgKyBEQVlfSURTW21ldGEuZG93XSxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktZGlzYWJsZWQnKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChtZXRhLmlzVG9kYXkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtZGF5LXRvZGF5Jyk7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2godGhlbWUuZ2V0Q2xhc3MoJ3RvZGF5JykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzUGFzdCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1kYXktcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1mdXR1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWV0YS5pc090aGVyKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWRheS1vdGhlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gZ2V0U2xvdENsYXNzTmFtZXMobWV0YSwgdGhlbWUpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNsb3QnLFxuICAgICAgICBcImZjLXNsb3QtXCIgKyBEQVlfSURTW21ldGEuZG93XSxcbiAgICBdO1xuICAgIGlmIChtZXRhLmlzRGlzYWJsZWQpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zbG90LWRpc2FibGVkJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAobWV0YS5pc1RvZGF5KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtdG9kYXknKTtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCh0aGVtZS5nZXRDbGFzcygndG9kYXknKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGEuaXNQYXN0KSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtcGFzdCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRhLmlzRnV0dXJlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNsb3QtZnV0dXJlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbnZhciBEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgeWVhcjogJ251bWVyaWMnLCBtb250aDogJ2xvbmcnLCBkYXk6ICdudW1lcmljJyB9KTtcbnZhciBXRUVLX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICdsb25nJyB9KTtcbmZ1bmN0aW9uIGJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGVNYXJrZXIsIHZpZXdUeXBlLCBpc1RhYmJhYmxlKSB7XG4gICAgaWYgKHZpZXdUeXBlID09PSB2b2lkIDApIHsgdmlld1R5cGUgPSAnZGF5JzsgfVxuICAgIGlmIChpc1RhYmJhYmxlID09PSB2b2lkIDApIHsgaXNUYWJiYWJsZSA9IHRydWU7IH1cbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucywgY2FsZW5kYXJBcGkgPSBjb250ZXh0LmNhbGVuZGFyQXBpO1xuICAgIHZhciBkYXRlU3RyID0gZGF0ZUVudi5mb3JtYXQoZGF0ZU1hcmtlciwgdmlld1R5cGUgPT09ICd3ZWVrJyA/IFdFRUtfRk9STUFUIDogREFZX0ZPUk1BVCk7XG4gICAgaWYgKG9wdGlvbnMubmF2TGlua3MpIHtcbiAgICAgICAgdmFyIHpvbmVkRGF0ZSA9IGRhdGVFbnYudG9EYXRlKGRhdGVNYXJrZXIpO1xuICAgICAgICB2YXIgaGFuZGxlSW50ZXJhY3Rpb24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIHZhciBjdXN0b21BY3Rpb24gPSB2aWV3VHlwZSA9PT0gJ2RheScgPyBvcHRpb25zLm5hdkxpbmtEYXlDbGljayA6XG4gICAgICAgICAgICAgICAgdmlld1R5cGUgPT09ICd3ZWVrJyA/IG9wdGlvbnMubmF2TGlua1dlZWtDbGljayA6IG51bGw7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGN1c3RvbUFjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGN1c3RvbUFjdGlvbi5jYWxsKGNhbGVuZGFyQXBpLCBkYXRlRW52LnRvRGF0ZShkYXRlTWFya2VyKSwgZXYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXN0b21BY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdUeXBlID0gY3VzdG9tQWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS56b29tVG8oZGF0ZU1hcmtlciwgdmlld1R5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24oeyB0aXRsZTogZm9ybWF0V2l0aE9yZGluYWxzKG9wdGlvbnMubmF2TGlua0hpbnQsIFtkYXRlU3RyLCB6b25lZERhdGVdLCBkYXRlU3RyKSwgJ2RhdGEtbmF2bGluayc6ICcnIH0sIChpc1RhYmJhYmxlXG4gICAgICAgICAgICA/IGNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUludGVyYWN0aW9uKVxuICAgICAgICAgICAgOiB7IG9uQ2xpY2s6IGhhbmRsZUludGVyYWN0aW9uIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgJ2FyaWEtbGFiZWwnOiBkYXRlU3RyIH07XG59XG5cbnZhciBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBudWxsO1xuZnVuY3Rpb24gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQoKSB7XG4gICAgaWYgKF9pc1J0bFNjcm9sbGJhck9uTGVmdCA9PT0gbnVsbCkge1xuICAgICAgICBfaXNSdGxTY3JvbGxiYXJPbkxlZnQgPSBjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQoKTtcbiAgICB9XG4gICAgcmV0dXJuIF9pc1J0bFNjcm9sbGJhck9uTGVmdDtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVJc1J0bFNjcm9sbGJhck9uTGVmdCgpIHtcbiAgICB2YXIgb3V0ZXJFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFwcGx5U3R5bGUob3V0ZXJFbCwge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdG9wOiAtMTAwMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYm9yZGVyOiAwLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBvdmVyZmxvdzogJ3Njcm9sbCcsXG4gICAgICAgIGRpcmVjdGlvbjogJ3J0bCcsXG4gICAgfSk7XG4gICAgb3V0ZXJFbC5pbm5lckhUTUwgPSAnPGRpdj48L2Rpdj4nO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQob3V0ZXJFbCk7XG4gICAgdmFyIGlubmVyRWwgPSBvdXRlckVsLmZpcnN0Q2hpbGQ7XG4gICAgdmFyIHJlcyA9IGlubmVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCA+IG91dGVyRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICByZW1vdmVFbGVtZW50KG91dGVyRWwpO1xuICAgIHJldHVybiByZXM7XG59XG5cbnZhciBfc2Nyb2xsYmFyV2lkdGhzO1xuZnVuY3Rpb24gZ2V0U2Nyb2xsYmFyV2lkdGhzKCkge1xuICAgIGlmICghX3Njcm9sbGJhcldpZHRocykge1xuICAgICAgICBfc2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRocygpO1xuICAgIH1cbiAgICByZXR1cm4gX3Njcm9sbGJhcldpZHRocztcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHMoKSB7XG4gICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWwuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcbiAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWwuc3R5bGUudG9wID0gJy05OTk5cHgnO1xuICAgIGVsLnN0eWxlLmxlZnQgPSAnLTk5OTlweCc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChlbCk7XG4gICAgdmFyIHJlcyA9IGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCk7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChlbCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIFdBUk5JTkc6IHdpbGwgaW5jbHVkZSBib3JkZXJcbmZ1bmN0aW9uIGNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbChlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGVsLm9mZnNldEhlaWdodCAtIGVsLmNsaWVudEhlaWdodCxcbiAgICAgICAgeTogZWwub2Zmc2V0V2lkdGggLSBlbC5jbGllbnRXaWR0aCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRWRnZXMoZWwsIGdldFBhZGRpbmcpIHtcbiAgICBpZiAoZ2V0UGFkZGluZyA9PT0gdm9pZCAwKSB7IGdldFBhZGRpbmcgPSBmYWxzZTsgfVxuICAgIHZhciBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHZhciBib3JkZXJMZWZ0ID0gcGFyc2VJbnQoY29tcHV0ZWRTdHlsZS5ib3JkZXJMZWZ0V2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBib3JkZXJSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyUmlnaHRXaWR0aCwgMTApIHx8IDA7XG4gICAgdmFyIGJvcmRlclRvcCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUuYm9yZGVyVG9wV2lkdGgsIDEwKSB8fCAwO1xuICAgIHZhciBib3JkZXJCb3R0b20gPSBwYXJzZUludChjb21wdXRlZFN0eWxlLmJvcmRlckJvdHRvbVdpZHRoLCAxMCkgfHwgMDtcbiAgICB2YXIgYmFkU2Nyb2xsYmFyV2lkdGhzID0gY29tcHV0ZVNjcm9sbGJhcldpZHRoc0ZvckVsKGVsKTsgLy8gaW5jbHVkZXMgYm9yZGVyIVxuICAgIHZhciBzY3JvbGxiYXJMZWZ0UmlnaHQgPSBiYWRTY3JvbGxiYXJXaWR0aHMueSAtIGJvcmRlckxlZnQgLSBib3JkZXJSaWdodDtcbiAgICB2YXIgc2Nyb2xsYmFyQm90dG9tID0gYmFkU2Nyb2xsYmFyV2lkdGhzLnggLSBib3JkZXJUb3AgLSBib3JkZXJCb3R0b207XG4gICAgdmFyIHJlcyA9IHtcbiAgICAgICAgYm9yZGVyTGVmdDogYm9yZGVyTGVmdCxcbiAgICAgICAgYm9yZGVyUmlnaHQ6IGJvcmRlclJpZ2h0LFxuICAgICAgICBib3JkZXJUb3A6IGJvcmRlclRvcCxcbiAgICAgICAgYm9yZGVyQm90dG9tOiBib3JkZXJCb3R0b20sXG4gICAgICAgIHNjcm9sbGJhckJvdHRvbTogc2Nyb2xsYmFyQm90dG9tLFxuICAgICAgICBzY3JvbGxiYXJMZWZ0OiAwLFxuICAgICAgICBzY3JvbGxiYXJSaWdodDogMCxcbiAgICB9O1xuICAgIGlmIChnZXRJc1J0bFNjcm9sbGJhck9uTGVmdCgpICYmIGNvbXB1dGVkU3R5bGUuZGlyZWN0aW9uID09PSAncnRsJykgeyAvLyBpcyB0aGUgc2Nyb2xsYmFyIG9uIHRoZSBsZWZ0IHNpZGU/XG4gICAgICAgIHJlcy5zY3JvbGxiYXJMZWZ0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzLnNjcm9sbGJhclJpZ2h0ID0gc2Nyb2xsYmFyTGVmdFJpZ2h0O1xuICAgIH1cbiAgICBpZiAoZ2V0UGFkZGluZykge1xuICAgICAgICByZXMucGFkZGluZ0xlZnQgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdMZWZ0LCAxMCkgfHwgMDtcbiAgICAgICAgcmVzLnBhZGRpbmdSaWdodCA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ1JpZ2h0LCAxMCkgfHwgMDtcbiAgICAgICAgcmVzLnBhZGRpbmdUb3AgPSBwYXJzZUludChjb21wdXRlZFN0eWxlLnBhZGRpbmdUb3AsIDEwKSB8fCAwO1xuICAgICAgICByZXMucGFkZGluZ0JvdHRvbSA9IHBhcnNlSW50KGNvbXB1dGVkU3R5bGUucGFkZGluZ0JvdHRvbSwgMTApIHx8IDA7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBjb21wdXRlSW5uZXJSZWN0KGVsLCBnb1dpdGhpblBhZGRpbmcsIGRvRnJvbVdpbmRvd1ZpZXdwb3J0KSB7XG4gICAgaWYgKGdvV2l0aGluUGFkZGluZyA9PT0gdm9pZCAwKSB7IGdvV2l0aGluUGFkZGluZyA9IGZhbHNlOyB9XG4gICAgdmFyIG91dGVyUmVjdCA9IGRvRnJvbVdpbmRvd1ZpZXdwb3J0ID8gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgOiBjb21wdXRlUmVjdChlbCk7XG4gICAgdmFyIGVkZ2VzID0gY29tcHV0ZUVkZ2VzKGVsLCBnb1dpdGhpblBhZGRpbmcpO1xuICAgIHZhciByZXMgPSB7XG4gICAgICAgIGxlZnQ6IG91dGVyUmVjdC5sZWZ0ICsgZWRnZXMuYm9yZGVyTGVmdCArIGVkZ2VzLnNjcm9sbGJhckxlZnQsXG4gICAgICAgIHJpZ2h0OiBvdXRlclJlY3QucmlnaHQgLSBlZGdlcy5ib3JkZXJSaWdodCAtIGVkZ2VzLnNjcm9sbGJhclJpZ2h0LFxuICAgICAgICB0b3A6IG91dGVyUmVjdC50b3AgKyBlZGdlcy5ib3JkZXJUb3AsXG4gICAgICAgIGJvdHRvbTogb3V0ZXJSZWN0LmJvdHRvbSAtIGVkZ2VzLmJvcmRlckJvdHRvbSAtIGVkZ2VzLnNjcm9sbGJhckJvdHRvbSxcbiAgICB9O1xuICAgIGlmIChnb1dpdGhpblBhZGRpbmcpIHtcbiAgICAgICAgcmVzLmxlZnQgKz0gZWRnZXMucGFkZGluZ0xlZnQ7XG4gICAgICAgIHJlcy5yaWdodCAtPSBlZGdlcy5wYWRkaW5nUmlnaHQ7XG4gICAgICAgIHJlcy50b3AgKz0gZWRnZXMucGFkZGluZ1RvcDtcbiAgICAgICAgcmVzLmJvdHRvbSAtPSBlZGdlcy5wYWRkaW5nQm90dG9tO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gY29tcHV0ZVJlY3QoZWwpIHtcbiAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCArIHdpbmRvdy5wYWdlWE9mZnNldCxcbiAgICAgICAgdG9wOiByZWN0LnRvcCArIHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgcmlnaHQ6IHJlY3QucmlnaHQgKyB3aW5kb3cucGFnZVhPZmZzZXQsXG4gICAgICAgIGJvdHRvbTogcmVjdC5ib3R0b20gKyB3aW5kb3cucGFnZVlPZmZzZXQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVDbGlwcGVkQ2xpZW50UmVjdChlbCkge1xuICAgIHZhciBjbGlwcGluZ1BhcmVudHMgPSBnZXRDbGlwcGluZ1BhcmVudHMoZWwpO1xuICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjbGlwcGluZ1BhcmVudHNfMSA9IGNsaXBwaW5nUGFyZW50czsgX2kgPCBjbGlwcGluZ1BhcmVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNsaXBwaW5nUGFyZW50ID0gY2xpcHBpbmdQYXJlbnRzXzFbX2ldO1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmVjdHMocmVjdCwgY2xpcHBpbmdQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpO1xuICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICByZWN0ID0gaW50ZXJzZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlY3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlSGVpZ2h0QW5kTWFyZ2lucyhlbCkge1xuICAgIHJldHVybiBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgKyBjb21wdXRlVk1hcmdpbnMoZWwpO1xufVxuZnVuY3Rpb24gY29tcHV0ZVZNYXJnaW5zKGVsKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgIHJldHVybiBwYXJzZUludChjb21wdXRlZC5tYXJnaW5Ub3AsIDEwKSArXG4gICAgICAgIHBhcnNlSW50KGNvbXB1dGVkLm1hcmdpbkJvdHRvbSwgMTApO1xufVxuLy8gZG9lcyBub3QgcmV0dXJuIHdpbmRvd1xuZnVuY3Rpb24gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB3aGlsZSAoZWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkgeyAvLyB3aWxsIHN0b3Agd2hlbiBnZXRzIHRvIGRvY3VtZW50IG9yIG51bGxcbiAgICAgICAgdmFyIGNvbXB1dGVkU3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbCk7XG4gICAgICAgIGlmIChjb21wdXRlZFN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoKC8oYXV0b3xzY3JvbGwpLykudGVzdChjb21wdXRlZFN0eWxlLm92ZXJmbG93ICsgY29tcHV0ZWRTdHlsZS5vdmVyZmxvd1kgKyBjb21wdXRlZFN0eWxlLm92ZXJmbG93WCkpIHtcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWwgPSBlbC5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gcGFyZW50cztcbn1cblxuLy8gZ2l2ZW4gYSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIGEgcmVzdWx0IGFzeW5jaHJvbm91c2x5LlxuLy8gdGhlIGZ1bmN0aW9uIGNhbiBlaXRoZXIgY2FsbCBwYXNzZWQtaW4gc3VjY2VzcyBhbmQgZmFpbHVyZSBjYWxsYmFja3MsXG4vLyBvciBpdCBjYW4gcmV0dXJuIGEgcHJvbWlzZS5cbi8vIGlmIHlvdSBuZWVkIHRvIHBhc3MgYWRkaXRpb25hbCBwYXJhbXMgdG8gZnVuYywgYmluZCB0aGVtIGZpcnN0LlxuZnVuY3Rpb24gdW5wcm9taXNpZnkoZnVuYywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgIC8vIGd1YXJkIGFnYWluc3Qgc3VjY2Vzcy9mYWlsdXJlIGNhbGxiYWNrcyBiZWluZyBjYWxsZWQgbW9yZSB0aGFuIG9uY2VcbiAgICAvLyBhbmQgZ3VhcmQgYWdhaW5zdCBhIHByb21pc2UgQU5EIGNhbGxiYWNrIGJlaW5nIHVzZWQgdG9nZXRoZXIuXG4gICAgdmFyIGlzUmVzb2x2ZWQgPSBmYWxzZTtcbiAgICB2YXIgd3JhcHBlZFN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgaXNSZXNvbHZlZCA9IHRydWU7XG4gICAgICAgICAgICBzdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLXJlc3QtcGFyYW1zXG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciB3cmFwcGVkRmFpbHVyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc29sdmVkKSB7XG4gICAgICAgICAgICBpc1Jlc29sdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHByZWZlci1yZXN0LXBhcmFtc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVzID0gZnVuYyh3cmFwcGVkU3VjY2Vzcywgd3JhcHBlZEZhaWx1cmUpO1xuICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJlcy50aGVuKHdyYXBwZWRTdWNjZXNzLCB3cmFwcGVkRmFpbHVyZSk7XG4gICAgfVxufVxuXG52YXIgRW1pdHRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMudGhpc0NvbnRleHQgPSBudWxsO1xuICAgIH1cbiAgICBFbWl0dGVyLnByb3RvdHlwZS5zZXRUaGlzQ29udGV4dCA9IGZ1bmN0aW9uICh0aGlzQ29udGV4dCkge1xuICAgICAgICB0aGlzLnRoaXNDb250ZXh0ID0gdGhpc0NvbnRleHQ7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9O1xuICAgIEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgYWRkVG9IYXNoKHRoaXMuaGFuZGxlcnMsIHR5cGUsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgRW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGhhbmRsZXIpIHtcbiAgICAgICAgcmVtb3ZlRnJvbUhhc2godGhpcy5oYW5kbGVycywgdHlwZSwgaGFuZGxlcik7XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF0dGFjaGVkSGFuZGxlcnMgPSB0aGlzLmhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuICAgICAgICB2YXIgb3B0aW9uSGFuZGxlciA9IHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV07XG4gICAgICAgIHZhciBoYW5kbGVycyA9IFtdLmNvbmNhdChvcHRpb25IYW5kbGVyIHx8IFtdLCBhdHRhY2hlZEhhbmRsZXJzKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBoYW5kbGVyc18xID0gaGFuZGxlcnM7IF9hIDwgaGFuZGxlcnNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaGFuZGxlcnNfMVtfYV07XG4gICAgICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMudGhpc0NvbnRleHQsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbWl0dGVyLnByb3RvdHlwZS5oYXNIYW5kbGVycyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKCh0aGlzLmhhbmRsZXJzW3R5cGVdICYmIHRoaXMuaGFuZGxlcnNbdHlwZV0ubGVuZ3RoKSB8fFxuICAgICAgICAgICAgKHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnNbdHlwZV0pKTtcbiAgICB9O1xuICAgIHJldHVybiBFbWl0dGVyO1xufSgpKTtcbmZ1bmN0aW9uIGFkZFRvSGFzaChoYXNoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgKGhhc2hbdHlwZV0gfHwgKGhhc2hbdHlwZV0gPSBbXSkpXG4gICAgICAgIC5wdXNoKGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVtb3ZlRnJvbUhhc2goaGFzaCwgdHlwZSwgaGFuZGxlcikge1xuICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIGlmIChoYXNoW3R5cGVdKSB7XG4gICAgICAgICAgICBoYXNoW3R5cGVdID0gaGFzaFt0eXBlXS5maWx0ZXIoZnVuY3Rpb24gKGZ1bmMpIHsgcmV0dXJuIGZ1bmMgIT09IGhhbmRsZXI7IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgaGFzaFt0eXBlXTsgLy8gcmVtb3ZlIGFsbCBoYW5kbGVyIGZ1bmNzIGZvciB0aGlzIHR5cGVcbiAgICB9XG59XG5cbi8qXG5SZWNvcmRzIG9mZnNldCBpbmZvcm1hdGlvbiBmb3IgYSBzZXQgb2YgZWxlbWVudHMsIHJlbGF0aXZlIHRvIGFuIG9yaWdpbiBlbGVtZW50LlxuQ2FuIHJlY29yZCB0aGUgbGVmdC9yaWdodCBPUiB0aGUgdG9wL2JvdHRvbSBPUiBib3RoLlxuUHJvdmlkZXMgbWV0aG9kcyBmb3IgcXVlcnlpbmcgdGhlIGNhY2hlIGJ5IHBvc2l0aW9uLlxuKi9cbnZhciBQb3NpdGlvbkNhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGVscywgaXNIb3Jpem9udGFsLCBpc1ZlcnRpY2FsKSB7XG4gICAgICAgIHRoaXMuZWxzID0gZWxzO1xuICAgICAgICB2YXIgb3JpZ2luQ2xpZW50UmVjdCA9IHRoaXMub3JpZ2luQ2xpZW50UmVjdCA9IG9yaWdpbkVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOyAvLyByZWxhdGl2ZSB0byB2aWV3cG9ydCB0b3AtbGVmdFxuICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxIb3Jpem9udGFscyhvcmlnaW5DbGllbnRSZWN0LmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1ZlcnRpY2FsKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxWZXJ0aWNhbHMob3JpZ2luQ2xpZW50UmVjdC50b3ApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyB0aGUgbGVmdC9yaWdodCBpbnRlcm5hbCBjb29yZGluYXRlIGFycmF5c1xuICAgIFBvc2l0aW9uQ2FjaGUucHJvdG90eXBlLmJ1aWxkRWxIb3Jpem9udGFscyA9IGZ1bmN0aW9uIChvcmlnaW5DbGllbnRMZWZ0KSB7XG4gICAgICAgIHZhciBsZWZ0cyA9IFtdO1xuICAgICAgICB2YXIgcmlnaHRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSB0aGlzLmVsczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBlbCA9IF9hW19pXTtcbiAgICAgICAgICAgIHZhciByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBsZWZ0cy5wdXNoKHJlY3QubGVmdCAtIG9yaWdpbkNsaWVudExlZnQpO1xuICAgICAgICAgICAgcmlnaHRzLnB1c2gocmVjdC5yaWdodCAtIG9yaWdpbkNsaWVudExlZnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdHMgPSBsZWZ0cztcbiAgICAgICAgdGhpcy5yaWdodHMgPSByaWdodHM7XG4gICAgfTtcbiAgICAvLyBQb3B1bGF0ZXMgdGhlIHRvcC9ib3R0b20gaW50ZXJuYWwgY29vcmRpbmF0ZSBhcnJheXNcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5idWlsZEVsVmVydGljYWxzID0gZnVuY3Rpb24gKG9yaWdpbkNsaWVudFRvcCkge1xuICAgICAgICB2YXIgdG9wcyA9IFtdO1xuICAgICAgICB2YXIgYm90dG9tcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5lbHM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWwgPSBfYVtfaV07XG4gICAgICAgICAgICB2YXIgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdG9wcy5wdXNoKHJlY3QudG9wIC0gb3JpZ2luQ2xpZW50VG9wKTtcbiAgICAgICAgICAgIGJvdHRvbXMucHVzaChyZWN0LmJvdHRvbSAtIG9yaWdpbkNsaWVudFRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3BzID0gdG9wcztcbiAgICAgICAgdGhpcy5ib3R0b21zID0gYm90dG9tcztcbiAgICB9O1xuICAgIC8vIEdpdmVuIGEgbGVmdCBvZmZzZXQgKGZyb20gZG9jdW1lbnQgbGVmdCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IGhvcml6b250YWxseSBpbnRlcnNlY3RzLlxuICAgIC8vIElmIG5vIGludGVyc2VjdGlvbiBpcyBtYWRlLCByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5sZWZ0VG9JbmRleCA9IGZ1bmN0aW9uIChsZWZ0UG9zaXRpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgbGVmdHMgPSBfYS5sZWZ0cywgcmlnaHRzID0gX2EucmlnaHRzO1xuICAgICAgICB2YXIgbGVuID0gbGVmdHMubGVuZ3RoO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAobGVmdFBvc2l0aW9uID49IGxlZnRzW2ldICYmIGxlZnRQb3NpdGlvbiA8IHJpZ2h0c1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7IC8vIFRPRE86IGJldHRlclxuICAgIH07XG4gICAgLy8gR2l2ZW4gYSB0b3Agb2Zmc2V0IChmcm9tIGRvY3VtZW50IHRvcCksIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBlbCB0aGF0IGl0IHZlcnRpY2FsbHkgaW50ZXJzZWN0cy5cbiAgICAvLyBJZiBubyBpbnRlcnNlY3Rpb24gaXMgbWFkZSwgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUudG9wVG9JbmRleCA9IGZ1bmN0aW9uICh0b3BQb3NpdGlvbikge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCB0b3BzID0gX2EudG9wcywgYm90dG9tcyA9IF9hLmJvdHRvbXM7XG4gICAgICAgIHZhciBsZW4gPSB0b3BzLmxlbmd0aDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHRvcFBvc2l0aW9uID49IHRvcHNbaV0gJiYgdG9wUG9zaXRpb24gPCBib3R0b21zW2ldKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDsgLy8gVE9ETzogYmV0dGVyXG4gICAgfTtcbiAgICAvLyBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgZWxlbWVudCBhdCB0aGUgZ2l2ZW4gaW5kZXhcbiAgICBQb3NpdGlvbkNhY2hlLnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uIChsZWZ0SW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmlnaHRzW2xlZnRJbmRleF0gLSB0aGlzLmxlZnRzW2xlZnRJbmRleF07XG4gICAgfTtcbiAgICAvLyBHZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGVsZW1lbnQgYXQgdGhlIGdpdmVuIGluZGV4XG4gICAgUG9zaXRpb25DYWNoZS5wcm90b3R5cGUuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24gKHRvcEluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdHRvbXNbdG9wSW5kZXhdIC0gdGhpcy50b3BzW3RvcEluZGV4XTtcbiAgICB9O1xuICAgIHJldHVybiBQb3NpdGlvbkNhY2hlO1xufSgpKTtcblxuLyogZXNsaW50IG1heC1jbGFzc2VzLXBlci1maWxlOiBcIm9mZlwiICovXG4vKlxuQW4gb2JqZWN0IGZvciBnZXR0aW5nL3NldHRpbmcgc2Nyb2xsLXJlbGF0ZWQgaW5mb3JtYXRpb24gZm9yIGFuIGVsZW1lbnQuXG5JbnRlcm5hbGx5LCB0aGlzIGlzIGRvbmUgdmVyeSBkaWZmZXJlbnRseSBmb3Igd2luZG93IHZlcnN1cyBET00gZWxlbWVudCxcbnNvIHRoaXMgb2JqZWN0IHNlcnZlcyBhcyBhIGNvbW1vbiBpbnRlcmZhY2UuXG4qL1xudmFyIFNjcm9sbENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2Nyb2xsQ29udHJvbGxlcigpIHtcbiAgICB9XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0TWF4U2Nyb2xsVG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxIZWlnaHQoKSAtIHRoaXMuZ2V0Q2xpZW50SGVpZ2h0KCk7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRNYXhTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY3JvbGxXaWR0aCgpIC0gdGhpcy5nZXRDbGllbnRXaWR0aCgpO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsVmVydGljYWxseSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF4U2Nyb2xsVG9wKCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsSG9yaXpvbnRhbGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCkgPiAwO1xuICAgIH07XG4gICAgU2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuY2FuU2Nyb2xsVXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpID4gMDtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbERvd24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbFRvcCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxUb3AoKTtcbiAgICB9O1xuICAgIFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmNhblNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNjcm9sbExlZnQoKSA+IDA7XG4gICAgfTtcbiAgICBTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5jYW5TY3JvbGxSaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2Nyb2xsTGVmdCgpIDwgdGhpcy5nZXRNYXhTY3JvbGxMZWZ0KCk7XG4gICAgfTtcbiAgICByZXR1cm4gU2Nyb2xsQ29udHJvbGxlcjtcbn0oKSk7XG52YXIgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyKGVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsID0gZWw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsVG9wO1xuICAgIH07XG4gICAgRWxlbWVudFNjcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLnNjcm9sbExlZnQ7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuc2V0U2Nyb2xsVG9wID0gZnVuY3Rpb24gKHRvcCkge1xuICAgICAgICB0aGlzLmVsLnNjcm9sbFRvcCA9IHRvcDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgdGhpcy5lbC5zY3JvbGxMZWZ0ID0gbGVmdDtcbiAgICB9O1xuICAgIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWwuc2Nyb2xsV2lkdGg7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsSGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5zY3JvbGxIZWlnaHQ7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbC5jbGllbnRIZWlnaHQ7XG4gICAgfTtcbiAgICBFbGVtZW50U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50V2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsLmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgcmV0dXJuIEVsZW1lbnRTY3JvbGxDb250cm9sbGVyO1xufShTY3JvbGxDb250cm9sbGVyKSk7XG52YXIgV2luZG93U2Nyb2xsQ29udHJvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoV2luZG93U2Nyb2xsQ29udHJvbGxlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBXaW5kb3dTY3JvbGxDb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbFRvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldFNjcm9sbExlZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cucGFnZVhPZmZzZXQ7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxUb3AgPSBmdW5jdGlvbiAobikge1xuICAgICAgICB3aW5kb3cuc2Nyb2xsKHdpbmRvdy5wYWdlWE9mZnNldCwgbik7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5zZXRTY3JvbGxMZWZ0ID0gZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgd2luZG93LnNjcm9sbChuLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0U2Nyb2xsV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsV2lkdGg7XG4gICAgfTtcbiAgICBXaW5kb3dTY3JvbGxDb250cm9sbGVyLnByb3RvdHlwZS5nZXRTY3JvbGxIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0O1xuICAgIH07XG4gICAgV2luZG93U2Nyb2xsQ29udHJvbGxlci5wcm90b3R5cGUuZ2V0Q2xpZW50SGVpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICB9O1xuICAgIFdpbmRvd1Njcm9sbENvbnRyb2xsZXIucHJvdG90eXBlLmdldENsaWVudFdpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgIH07XG4gICAgcmV0dXJuIFdpbmRvd1Njcm9sbENvbnRyb2xsZXI7XG59KFNjcm9sbENvbnRyb2xsZXIpKTtcblxudmFyIFRoZW1lID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRoZW1lKGNhbGVuZGFyT3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5pY29uT3ZlcnJpZGVPcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNvbk92ZXJyaWRlKGNhbGVuZGFyT3B0aW9uc1t0aGlzLmljb25PdmVycmlkZU9wdGlvbl0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRoZW1lLnByb3RvdHlwZS5zZXRJY29uT3ZlcnJpZGUgPSBmdW5jdGlvbiAoaWNvbk92ZXJyaWRlSGFzaCkge1xuICAgICAgICB2YXIgaWNvbkNsYXNzZXNDb3B5O1xuICAgICAgICB2YXIgYnV0dG9uTmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpY29uT3ZlcnJpZGVIYXNoID09PSAnb2JqZWN0JyAmJiBpY29uT3ZlcnJpZGVIYXNoKSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICAgICAgaWNvbkNsYXNzZXNDb3B5ID0gdHNsaWIuX19hc3NpZ24oe30sIHRoaXMuaWNvbkNsYXNzZXMpO1xuICAgICAgICAgICAgZm9yIChidXR0b25OYW1lIGluIGljb25PdmVycmlkZUhhc2gpIHtcbiAgICAgICAgICAgICAgICBpY29uQ2xhc3Nlc0NvcHlbYnV0dG9uTmFtZV0gPSB0aGlzLmFwcGx5SWNvbk92ZXJyaWRlUHJlZml4KGljb25PdmVycmlkZUhhc2hbYnV0dG9uTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IGljb25DbGFzc2VzQ29weTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpY29uT3ZlcnJpZGVIYXNoID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdGhpcy5pY29uQ2xhc3NlcyA9IHt9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXggPSBmdW5jdGlvbiAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHZhciBwcmVmaXggPSB0aGlzLmljb25PdmVycmlkZVByZWZpeDtcbiAgICAgICAgaWYgKHByZWZpeCAmJiBjbGFzc05hbWUuaW5kZXhPZihwcmVmaXgpICE9PSAwKSB7IC8vIGlmIG5vdCBhbHJlYWR5IHByZXNlbnRcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHByZWZpeCArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH07XG4gICAgVGhlbWUucHJvdG90eXBlLmdldENsYXNzID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzW2tleV0gfHwgJyc7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0SWNvbkNsYXNzID0gZnVuY3Rpb24gKGJ1dHRvbk5hbWUsIGlzUnRsKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgIGlmIChpc1J0bCAmJiB0aGlzLnJ0bEljb25DbGFzc2VzKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLnJ0bEljb25DbGFzc2VzW2J1dHRvbk5hbWVdIHx8IHRoaXMuaWNvbkNsYXNzZXNbYnV0dG9uTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSB0aGlzLmljb25DbGFzc2VzW2J1dHRvbk5hbWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyBcIiBcIiArIGNsYXNzTmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICBUaGVtZS5wcm90b3R5cGUuZ2V0Q3VzdG9tQnV0dG9uSWNvbkNsYXNzID0gZnVuY3Rpb24gKGN1c3RvbUJ1dHRvblByb3BzKSB7XG4gICAgICAgIHZhciBjbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLmljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbikge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gY3VzdG9tQnV0dG9uUHJvcHNbdGhpcy5pY29uT3ZlcnJpZGVDdXN0b21CdXR0b25PcHRpb25dO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJhc2VJY29uQ2xhc3MgKyBcIiBcIiArIHRoaXMuYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfTtcbiAgICByZXR1cm4gVGhlbWU7XG59KCkpO1xuVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7fTtcblRoZW1lLnByb3RvdHlwZS5pY29uQ2xhc3NlcyA9IHt9O1xuVGhlbWUucHJvdG90eXBlLmJhc2VJY29uQ2xhc3MgPSAnJztcblRoZW1lLnByb3RvdHlwZS5pY29uT3ZlcnJpZGVQcmVmaXggPSAnJztcblxudmFyIFNjcm9sbFJlc3BvbmRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMsIGVtaXR0ZXIsIHNjcm9sbFRpbWUsIHNjcm9sbFRpbWVSZXNldCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmV4ZWNGdW5jID0gZXhlY0Z1bmM7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGltZSA9IHNjcm9sbFRpbWU7XG4gICAgICAgIHRoaXMuc2Nyb2xsVGltZVJlc2V0ID0gc2Nyb2xsVGltZVJlc2V0O1xuICAgICAgICB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdCkge1xuICAgICAgICAgICAgX3RoaXMucXVldWVkUmVxdWVzdCA9IHRzbGliLl9fYXNzaWduKHt9LCBfdGhpcy5xdWV1ZWRSZXF1ZXN0IHx8IHt9LCByZXF1ZXN0KTtcbiAgICAgICAgICAgIF90aGlzLmRyYWluKCk7XG4gICAgICAgIH07XG4gICAgICAgIGVtaXR0ZXIub24oJ19zY3JvbGxSZXF1ZXN0JywgdGhpcy5oYW5kbGVTY3JvbGxSZXF1ZXN0KTtcbiAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpO1xuICAgIH1cbiAgICBTY3JvbGxSZXNwb25kZXIucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyLm9mZignX3Njcm9sbFJlcXVlc3QnLCB0aGlzLmhhbmRsZVNjcm9sbFJlcXVlc3QpO1xuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaXNEYXRlc05ldykge1xuICAgICAgICBpZiAoaXNEYXRlc05ldyAmJiB0aGlzLnNjcm9sbFRpbWVSZXNldCkge1xuICAgICAgICAgICAgdGhpcy5maXJlSW5pdGlhbFNjcm9sbCgpOyAvLyB3aWxsIGRyYWluXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFNjcm9sbFJlc3BvbmRlci5wcm90b3R5cGUuZmlyZUluaXRpYWxTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU2Nyb2xsUmVxdWVzdCh7XG4gICAgICAgICAgICB0aW1lOiB0aGlzLnNjcm9sbFRpbWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU2Nyb2xsUmVzcG9uZGVyLnByb3RvdHlwZS5kcmFpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucXVldWVkUmVxdWVzdCAmJiB0aGlzLmV4ZWNGdW5jKHRoaXMucXVldWVkUmVxdWVzdCkpIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVkUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxSZXNwb25kZXI7XG59KCkpO1xuXG52YXIgVmlld0NvbnRleHRUeXBlID0gdmRvbV9janMuY3JlYXRlQ29udGV4dCh7fSk7IC8vIGZvciBDb21wb25lbnRzXG5mdW5jdGlvbiBidWlsZFZpZXdDb250ZXh0KHZpZXdTcGVjLCB2aWV3QXBpLCB2aWV3T3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IsIGRhdGVFbnYsIHRoZW1lLCBwbHVnaW5Ib29rcywgZGlzcGF0Y2gsIGdldEN1cnJlbnREYXRhLCBlbWl0dGVyLCBjYWxlbmRhckFwaSwgcmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCwgdW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGF0ZUVudjogZGF0ZUVudixcbiAgICAgICAgb3B0aW9uczogdmlld09wdGlvbnMsXG4gICAgICAgIHBsdWdpbkhvb2tzOiBwbHVnaW5Ib29rcyxcbiAgICAgICAgZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgZGlzcGF0Y2g6IGRpc3BhdGNoLFxuICAgICAgICBnZXRDdXJyZW50RGF0YTogZ2V0Q3VycmVudERhdGEsXG4gICAgICAgIGNhbGVuZGFyQXBpOiBjYWxlbmRhckFwaSxcbiAgICAgICAgdmlld1NwZWM6IHZpZXdTcGVjLFxuICAgICAgICB2aWV3QXBpOiB2aWV3QXBpLFxuICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvcjogZGF0ZVByb2ZpbGVHZW5lcmF0b3IsXG4gICAgICAgIHRoZW1lOiB0aGVtZSxcbiAgICAgICAgaXNSdGw6IHZpZXdPcHRpb25zLmRpcmVjdGlvbiA9PT0gJ3J0bCcsXG4gICAgICAgIGFkZFJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9uKCdfcmVzaXplJywgaGFuZGxlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVJlc2l6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBlbWl0dGVyLm9mZignX3Jlc2l6ZScsIGhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICBjcmVhdGVTY3JvbGxSZXNwb25kZXI6IGZ1bmN0aW9uIChleGVjRnVuYykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTY3JvbGxSZXNwb25kZXIoZXhlY0Z1bmMsIGVtaXR0ZXIsIGNyZWF0ZUR1cmF0aW9uKHZpZXdPcHRpb25zLnNjcm9sbFRpbWUpLCB2aWV3T3B0aW9ucy5zY3JvbGxUaW1lUmVzZXQpO1xuICAgICAgICB9LFxuICAgICAgICByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50OiByZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50LFxuICAgICAgICB1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQ6IHVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xudmFyIFB1cmVDb21wb25lbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFB1cmVDb21wb25lbnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHVyZUNvbXBvbmVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQdXJlQ29tcG9uZW50LnByb3RvdHlwZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPSBmdW5jdGlvbiAobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhnZXRVbmVxdWFsUHJvcHMobmV4dFByb3BzLCB0aGlzLnByb3BzKSwgZ2V0VW5lcXVhbFByb3BzKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhY29tcGFyZU9ianModGhpcy5wcm9wcywgbmV4dFByb3BzLCB0aGlzLnByb3BFcXVhbGl0eSkgfHxcbiAgICAgICAgICAgICFjb21wYXJlT2Jqcyh0aGlzLnN0YXRlLCBuZXh0U3RhdGUsIHRoaXMuc3RhdGVFcXVhbGl0eSk7XG4gICAgfTtcbiAgICAvLyBIQUNLIGZvciBmcmVha2luJyBSZWFjdCBTdHJpY3RNb2RlXG4gICAgUHVyZUNvbXBvbmVudC5wcm90b3R5cGUuc2FmZVNldFN0YXRlID0gZnVuY3Rpb24gKG5ld1N0YXRlKSB7XG4gICAgICAgIGlmICghY29tcGFyZU9ianModGhpcy5zdGF0ZSwgdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHRoaXMuc3RhdGUpLCBuZXdTdGF0ZSksIHRoaXMuc3RhdGVFcXVhbGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBQdXJlQ29tcG9uZW50LmFkZFByb3BzRXF1YWxpdHkgPSBhZGRQcm9wc0VxdWFsaXR5O1xuICAgIFB1cmVDb21wb25lbnQuYWRkU3RhdGVFcXVhbGl0eSA9IGFkZFN0YXRlRXF1YWxpdHk7XG4gICAgUHVyZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gUHVyZUNvbXBvbmVudDtcbn0odmRvbV9janMuQ29tcG9uZW50KSk7XG5QdXJlQ29tcG9uZW50LnByb3RvdHlwZS5wcm9wRXF1YWxpdHkgPSB7fTtcblB1cmVDb21wb25lbnQucHJvdG90eXBlLnN0YXRlRXF1YWxpdHkgPSB7fTtcbnZhciBCYXNlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhCYXNlQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhc2VDb21wb25lbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQmFzZUNvbXBvbmVudC5jb250ZXh0VHlwZSA9IFZpZXdDb250ZXh0VHlwZTtcbiAgICByZXR1cm4gQmFzZUNvbXBvbmVudDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYWRkUHJvcHNFcXVhbGl0eShwcm9wRXF1YWxpdHkpIHtcbiAgICB2YXIgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUucHJvcEVxdWFsaXR5KTtcbiAgICB0c2xpYi5fX2Fzc2lnbihoYXNoLCBwcm9wRXF1YWxpdHkpO1xuICAgIHRoaXMucHJvdG90eXBlLnByb3BFcXVhbGl0eSA9IGhhc2g7XG59XG5mdW5jdGlvbiBhZGRTdGF0ZUVxdWFsaXR5KHN0YXRlRXF1YWxpdHkpIHtcbiAgICB2YXIgaGFzaCA9IE9iamVjdC5jcmVhdGUodGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSk7XG4gICAgdHNsaWIuX19hc3NpZ24oaGFzaCwgc3RhdGVFcXVhbGl0eSk7XG4gICAgdGhpcy5wcm90b3R5cGUuc3RhdGVFcXVhbGl0eSA9IGhhc2g7XG59XG4vLyB1c2Ugb3RoZXIgb25lXG5mdW5jdGlvbiBzZXRSZWYocmVmLCBjdXJyZW50KSB7XG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmVmKGN1cnJlbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChyZWYpIHtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMwMjlcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgIH1cbn1cblxuLypcbmFuIElOVEVSQUNUQUJMRSBkYXRlIGNvbXBvbmVudFxuXG5QVVJQT1NFUzpcbi0gaG9vayB1cCB0byBmZywgZmlsbCwgYW5kIG1pcnJvciByZW5kZXJlcnNcbi0gaW50ZXJmYWNlIGZvciBkcmFnZ2luZyBhbmQgaGl0c1xuKi9cbnZhciBEYXRlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXRlQ29tcG9uZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERhdGVDb21wb25lbnQoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51aWQgPSBndWlkKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgLy8gSGl0IFN5c3RlbVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgRGF0ZUNvbXBvbmVudC5wcm90b3R5cGUucHJlcGFyZUhpdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICByZXR1cm4gbnVsbDsgLy8gdGhpcyBzaG91bGQgYmUgYWJzdHJhY3RcbiAgICB9O1xuICAgIC8vIFBvaW50ZXIgSW50ZXJhY3Rpb24gVXRpbHNcbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIERhdGVDb21wb25lbnQucHJvdG90eXBlLmlzVmFsaWRTZWdEb3duRWwgPSBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnByb3BzLmV2ZW50RHJhZyAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhdGhpcy5wcm9wcy5ldmVudFJlc2l6ZSAmJiAvLyBIQUNLXG4gICAgICAgICAgICAhZWxlbWVudENsb3Nlc3QoZWwsICcuZmMtZXZlbnQtbWlycm9yJyk7XG4gICAgfTtcbiAgICBEYXRlQ29tcG9uZW50LnByb3RvdHlwZS5pc1ZhbGlkRGF0ZURvd25FbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICByZXR1cm4gIWVsZW1lbnRDbG9zZXN0KGVsLCAnLmZjLWV2ZW50Om5vdCguZmMtYmctZXZlbnQpJykgJiZcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1tb3JlLWxpbmsnKSAmJiAvLyBhIFwibW9yZS4uXCIgbGlua1xuICAgICAgICAgICAgIWVsZW1lbnRDbG9zZXN0KGVsLCAnYVtkYXRhLW5hdmxpbmtdJykgJiYgLy8gYSBjbGlja2FibGUgbmF2IGxpbmtcbiAgICAgICAgICAgICFlbGVtZW50Q2xvc2VzdChlbCwgJy5mYy1wb3BvdmVyJyk7IC8vIGhhY2tcbiAgICB9O1xuICAgIHJldHVybiBEYXRlQ29tcG9uZW50O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIFRPRE86IGVhc2llciB3YXkgdG8gYWRkIG5ldyBob29rcz8gbmVlZCB0byB1cGRhdGUgYSBtaWxsaW9uIHRoaW5nc1xuZnVuY3Rpb24gY3JlYXRlUGx1Z2luKGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGd1aWQoKSxcbiAgICAgICAgZGVwczogaW5wdXQuZGVwcyB8fCBbXSxcbiAgICAgICAgcmVkdWNlcnM6IGlucHV0LnJlZHVjZXJzIHx8IFtdLFxuICAgICAgICBpc0xvYWRpbmdGdW5jczogaW5wdXQuaXNMb2FkaW5nRnVuY3MgfHwgW10sXG4gICAgICAgIGNvbnRleHRJbml0OiBbXS5jb25jYXQoaW5wdXQuY29udGV4dEluaXQgfHwgW10pLFxuICAgICAgICBldmVudFJlZmluZXJzOiBpbnB1dC5ldmVudFJlZmluZXJzIHx8IHt9LFxuICAgICAgICBldmVudERlZk1lbWJlckFkZGVyczogaW5wdXQuZXZlbnREZWZNZW1iZXJBZGRlcnMgfHwgW10sXG4gICAgICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IGlucHV0LmV2ZW50U291cmNlUmVmaW5lcnMgfHwge30sXG4gICAgICAgIGlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzOiBpbnB1dC5pc0RyYWdnYWJsZVRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnM6IGlucHV0LmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzIHx8IFtdLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGlucHV0LmV2ZW50RGVmTXV0YXRpb25BcHBsaWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVyczogaW5wdXQuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycyB8fCBbXSxcbiAgICAgICAgZGF0ZVBvaW50VHJhbnNmb3JtczogaW5wdXQuZGF0ZVBvaW50VHJhbnNmb3JtcyB8fCBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBpbnB1dC5kYXRlU3BhblRyYW5zZm9ybXMgfHwgW10sXG4gICAgICAgIHZpZXdzOiBpbnB1dC52aWV3cyB8fCB7fSxcbiAgICAgICAgdmlld1Byb3BzVHJhbnNmb3JtZXJzOiBpbnB1dC52aWV3UHJvcHNUcmFuc2Zvcm1lcnMgfHwgW10sXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaW5wdXQuaXNQcm9wc1ZhbGlkIHx8IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogaW5wdXQuZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIHx8IFtdLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaW5wdXQudmlld0NvbnRhaW5lckFwcGVuZHMgfHwgW10sXG4gICAgICAgIGV2ZW50RHJvcFRyYW5zZm9ybWVyczogaW5wdXQuZXZlbnREcm9wVHJhbnNmb3JtZXJzIHx8IFtdLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGlucHV0LmNvbXBvbmVudEludGVyYWN0aW9ucyB8fCBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IGlucHV0LmNhbGVuZGFySW50ZXJhY3Rpb25zIHx8IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IGlucHV0LnRoZW1lQ2xhc3NlcyB8fCB7fSxcbiAgICAgICAgZXZlbnRTb3VyY2VEZWZzOiBpbnB1dC5ldmVudFNvdXJjZURlZnMgfHwgW10sXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaW5wdXQuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaW5wdXQucmVjdXJyaW5nVHlwZXMgfHwgW10sXG4gICAgICAgIG5hbWVkVGltZVpvbmVkSW1wbDogaW5wdXQubmFtZWRUaW1lWm9uZWRJbXBsLFxuICAgICAgICBpbml0aWFsVmlldzogaW5wdXQuaW5pdGlhbFZpZXcgfHwgJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGlucHV0LmVsZW1lbnREcmFnZ2luZ0ltcGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiBpbnB1dC5vcHRpb25DaGFuZ2VIYW5kbGVycyB8fCB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IGlucHV0LnNjcm9sbEdyaWRJbXBsIHx8IG51bGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IGlucHV0LmNvbnRlbnRUeXBlSGFuZGxlcnMgfHwge30sXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IGlucHV0Lmxpc3RlbmVyUmVmaW5lcnMgfHwge30sXG4gICAgICAgIG9wdGlvblJlZmluZXJzOiBpbnB1dC5vcHRpb25SZWZpbmVycyB8fCB7fSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiBpbnB1dC5wcm9wU2V0SGFuZGxlcnMgfHwge30sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUGx1Z2luSG9va3MocGx1Z2luRGVmcywgZ2xvYmFsRGVmcykge1xuICAgIHZhciBpc0FkZGVkID0ge307XG4gICAgdmFyIGhvb2tzID0ge1xuICAgICAgICByZWR1Y2VyczogW10sXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBbXSxcbiAgICAgICAgY29udGV4dEluaXQ6IFtdLFxuICAgICAgICBldmVudFJlZmluZXJzOiB7fSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IFtdLFxuICAgICAgICBldmVudFNvdXJjZVJlZmluZXJzOiB7fSxcbiAgICAgICAgaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogW10sXG4gICAgICAgIGV2ZW50RGVmTXV0YXRpb25BcHBsaWVyczogW10sXG4gICAgICAgIGRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgZGF0ZVNwYW5UcmFuc2Zvcm1zOiBbXSxcbiAgICAgICAgdmlld3M6IHt9LFxuICAgICAgICB2aWV3UHJvcHNUcmFuc2Zvcm1lcnM6IFtdLFxuICAgICAgICBpc1Byb3BzVmFsaWQ6IG51bGwsXG4gICAgICAgIGV4dGVybmFsRGVmVHJhbnNmb3JtczogW10sXG4gICAgICAgIHZpZXdDb250YWluZXJBcHBlbmRzOiBbXSxcbiAgICAgICAgZXZlbnREcm9wVHJhbnNmb3JtZXJzOiBbXSxcbiAgICAgICAgY29tcG9uZW50SW50ZXJhY3Rpb25zOiBbXSxcbiAgICAgICAgY2FsZW5kYXJJbnRlcmFjdGlvbnM6IFtdLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IHt9LFxuICAgICAgICBldmVudFNvdXJjZURlZnM6IFtdLFxuICAgICAgICBjbWRGb3JtYXR0ZXI6IG51bGwsXG4gICAgICAgIHJlY3VycmluZ1R5cGVzOiBbXSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZWRJbXBsOiBudWxsLFxuICAgICAgICBpbml0aWFsVmlldzogJycsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IG51bGwsXG4gICAgICAgIG9wdGlvbkNoYW5nZUhhbmRsZXJzOiB7fSxcbiAgICAgICAgc2Nyb2xsR3JpZEltcGw6IG51bGwsXG4gICAgICAgIGNvbnRlbnRUeXBlSGFuZGxlcnM6IHt9LFxuICAgICAgICBsaXN0ZW5lclJlZmluZXJzOiB7fSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHt9LFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHt9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gYWRkRGVmcyhkZWZzKSB7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZGVmc18xID0gZGVmczsgX2kgPCBkZWZzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZGVmID0gZGVmc18xW19pXTtcbiAgICAgICAgICAgIGlmICghaXNBZGRlZFtkZWYuaWRdKSB7XG4gICAgICAgICAgICAgICAgaXNBZGRlZFtkZWYuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhZGREZWZzKGRlZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBob29rcyA9IGNvbWJpbmVIb29rcyhob29rcywgZGVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGx1Z2luRGVmcykge1xuICAgICAgICBhZGREZWZzKHBsdWdpbkRlZnMpO1xuICAgIH1cbiAgICBhZGREZWZzKGdsb2JhbERlZnMpO1xuICAgIHJldHVybiBob29rcztcbn1cbmZ1bmN0aW9uIGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpIHtcbiAgICB2YXIgY3VycmVudE92ZXJyaWRlRGVmcyA9IFtdO1xuICAgIHZhciBjdXJyZW50R2xvYmFsRGVmcyA9IFtdO1xuICAgIHZhciBjdXJyZW50SG9va3M7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChvdmVycmlkZURlZnMsIGdsb2JhbERlZnMpIHtcbiAgICAgICAgaWYgKCFjdXJyZW50SG9va3MgfHwgIWlzQXJyYXlzRXF1YWwob3ZlcnJpZGVEZWZzLCBjdXJyZW50T3ZlcnJpZGVEZWZzKSB8fCAhaXNBcnJheXNFcXVhbChnbG9iYWxEZWZzLCBjdXJyZW50R2xvYmFsRGVmcykpIHtcbiAgICAgICAgICAgIGN1cnJlbnRIb29rcyA9IGJ1aWxkUGx1Z2luSG9va3Mob3ZlcnJpZGVEZWZzLCBnbG9iYWxEZWZzKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50T3ZlcnJpZGVEZWZzID0gb3ZlcnJpZGVEZWZzO1xuICAgICAgICBjdXJyZW50R2xvYmFsRGVmcyA9IGdsb2JhbERlZnM7XG4gICAgICAgIHJldHVybiBjdXJyZW50SG9va3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbWJpbmVIb29rcyhob29rczAsIGhvb2tzMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHJlZHVjZXJzOiBob29rczAucmVkdWNlcnMuY29uY2F0KGhvb2tzMS5yZWR1Y2VycyksXG4gICAgICAgIGlzTG9hZGluZ0Z1bmNzOiBob29rczAuaXNMb2FkaW5nRnVuY3MuY29uY2F0KGhvb2tzMS5pc0xvYWRpbmdGdW5jcyksXG4gICAgICAgIGNvbnRleHRJbml0OiBob29rczAuY29udGV4dEluaXQuY29uY2F0KGhvb2tzMS5jb250ZXh0SW5pdCksXG4gICAgICAgIGV2ZW50UmVmaW5lcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAuZXZlbnRSZWZpbmVycyksIGhvb2tzMS5ldmVudFJlZmluZXJzKSxcbiAgICAgICAgZXZlbnREZWZNZW1iZXJBZGRlcnM6IGhvb2tzMC5ldmVudERlZk1lbWJlckFkZGVycy5jb25jYXQoaG9va3MxLmV2ZW50RGVmTWVtYmVyQWRkZXJzKSxcbiAgICAgICAgZXZlbnRTb3VyY2VSZWZpbmVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5ldmVudFNvdXJjZVJlZmluZXJzKSwgaG9va3MxLmV2ZW50U291cmNlUmVmaW5lcnMpLFxuICAgICAgICBpc0RyYWdnYWJsZVRyYW5zZm9ybWVyczogaG9va3MwLmlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzLmNvbmNhdChob29rczEuaXNEcmFnZ2FibGVUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VyczogaG9va3MwLmV2ZW50RHJhZ011dGF0aW9uTWFzc2FnZXJzLmNvbmNhdChob29rczEuZXZlbnREcmFnTXV0YXRpb25NYXNzYWdlcnMpLFxuICAgICAgICBldmVudERlZk11dGF0aW9uQXBwbGllcnM6IGhvb2tzMC5ldmVudERlZk11dGF0aW9uQXBwbGllcnMuY29uY2F0KGhvb2tzMS5ldmVudERlZk11dGF0aW9uQXBwbGllcnMpLFxuICAgICAgICBkYXRlU2VsZWN0aW9uVHJhbnNmb3JtZXJzOiBob29rczAuZGF0ZVNlbGVjdGlvblRyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLmRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMpLFxuICAgICAgICBkYXRlUG9pbnRUcmFuc2Zvcm1zOiBob29rczAuZGF0ZVBvaW50VHJhbnNmb3Jtcy5jb25jYXQoaG9va3MxLmRhdGVQb2ludFRyYW5zZm9ybXMpLFxuICAgICAgICBkYXRlU3BhblRyYW5zZm9ybXM6IGhvb2tzMC5kYXRlU3BhblRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5kYXRlU3BhblRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3czogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC52aWV3cyksIGhvb2tzMS52aWV3cyksXG4gICAgICAgIHZpZXdQcm9wc1RyYW5zZm9ybWVyczogaG9va3MwLnZpZXdQcm9wc1RyYW5zZm9ybWVycy5jb25jYXQoaG9va3MxLnZpZXdQcm9wc1RyYW5zZm9ybWVycyksXG4gICAgICAgIGlzUHJvcHNWYWxpZDogaG9va3MxLmlzUHJvcHNWYWxpZCB8fCBob29rczAuaXNQcm9wc1ZhbGlkLFxuICAgICAgICBleHRlcm5hbERlZlRyYW5zZm9ybXM6IGhvb2tzMC5leHRlcm5hbERlZlRyYW5zZm9ybXMuY29uY2F0KGhvb2tzMS5leHRlcm5hbERlZlRyYW5zZm9ybXMpLFxuICAgICAgICB2aWV3Q29udGFpbmVyQXBwZW5kczogaG9va3MwLnZpZXdDb250YWluZXJBcHBlbmRzLmNvbmNhdChob29rczEudmlld0NvbnRhaW5lckFwcGVuZHMpLFxuICAgICAgICBldmVudERyb3BUcmFuc2Zvcm1lcnM6IGhvb2tzMC5ldmVudERyb3BUcmFuc2Zvcm1lcnMuY29uY2F0KGhvb2tzMS5ldmVudERyb3BUcmFuc2Zvcm1lcnMpLFxuICAgICAgICBjYWxlbmRhckludGVyYWN0aW9uczogaG9va3MwLmNhbGVuZGFySW50ZXJhY3Rpb25zLmNvbmNhdChob29rczEuY2FsZW5kYXJJbnRlcmFjdGlvbnMpLFxuICAgICAgICBjb21wb25lbnRJbnRlcmFjdGlvbnM6IGhvb2tzMC5jb21wb25lbnRJbnRlcmFjdGlvbnMuY29uY2F0KGhvb2tzMS5jb21wb25lbnRJbnRlcmFjdGlvbnMpLFxuICAgICAgICB0aGVtZUNsYXNzZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAudGhlbWVDbGFzc2VzKSwgaG9va3MxLnRoZW1lQ2xhc3NlcyksXG4gICAgICAgIGV2ZW50U291cmNlRGVmczogaG9va3MwLmV2ZW50U291cmNlRGVmcy5jb25jYXQoaG9va3MxLmV2ZW50U291cmNlRGVmcyksXG4gICAgICAgIGNtZEZvcm1hdHRlcjogaG9va3MxLmNtZEZvcm1hdHRlciB8fCBob29rczAuY21kRm9ybWF0dGVyLFxuICAgICAgICByZWN1cnJpbmdUeXBlczogaG9va3MwLnJlY3VycmluZ1R5cGVzLmNvbmNhdChob29rczEucmVjdXJyaW5nVHlwZXMpLFxuICAgICAgICBuYW1lZFRpbWVab25lZEltcGw6IGhvb2tzMS5uYW1lZFRpbWVab25lZEltcGwgfHwgaG9va3MwLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgaW5pdGlhbFZpZXc6IGhvb2tzMC5pbml0aWFsVmlldyB8fCBob29rczEuaW5pdGlhbFZpZXcsXG4gICAgICAgIGVsZW1lbnREcmFnZ2luZ0ltcGw6IGhvb2tzMC5lbGVtZW50RHJhZ2dpbmdJbXBsIHx8IGhvb2tzMS5lbGVtZW50RHJhZ2dpbmdJbXBsLFxuICAgICAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGhvb2tzMC5vcHRpb25DaGFuZ2VIYW5kbGVycyksIGhvb2tzMS5vcHRpb25DaGFuZ2VIYW5kbGVycyksXG4gICAgICAgIHNjcm9sbEdyaWRJbXBsOiBob29rczEuc2Nyb2xsR3JpZEltcGwgfHwgaG9va3MwLnNjcm9sbEdyaWRJbXBsLFxuICAgICAgICBjb250ZW50VHlwZUhhbmRsZXJzOiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgaG9va3MwLmNvbnRlbnRUeXBlSGFuZGxlcnMpLCBob29rczEuY29udGVudFR5cGVIYW5kbGVycyksXG4gICAgICAgIGxpc3RlbmVyUmVmaW5lcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAubGlzdGVuZXJSZWZpbmVycyksIGhvb2tzMS5saXN0ZW5lclJlZmluZXJzKSxcbiAgICAgICAgb3B0aW9uUmVmaW5lcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAub3B0aW9uUmVmaW5lcnMpLCBob29rczEub3B0aW9uUmVmaW5lcnMpLFxuICAgICAgICBwcm9wU2V0SGFuZGxlcnM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBob29rczAucHJvcFNldEhhbmRsZXJzKSwgaG9va3MxLnByb3BTZXRIYW5kbGVycyksXG4gICAgfTtcbn1cblxudmFyIFN0YW5kYXJkVGhlbWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFN0YW5kYXJkVGhlbWUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhbmRhcmRUaGVtZSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gU3RhbmRhcmRUaGVtZTtcbn0oVGhlbWUpKTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmNsYXNzZXMgPSB7XG4gICAgcm9vdDogJ2ZjLXRoZW1lLXN0YW5kYXJkJyxcbiAgICB0YWJsZUNlbGxTaGFkZWQ6ICdmYy1jZWxsLXNoYWRlZCcsXG4gICAgYnV0dG9uR3JvdXA6ICdmYy1idXR0b24tZ3JvdXAnLFxuICAgIGJ1dHRvbjogJ2ZjLWJ1dHRvbiBmYy1idXR0b24tcHJpbWFyeScsXG4gICAgYnV0dG9uQWN0aXZlOiAnZmMtYnV0dG9uLWFjdGl2ZScsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuYmFzZUljb25DbGFzcyA9ICdmYy1pY29uJztcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLmljb25DbGFzc2VzID0ge1xuICAgIGNsb3NlOiAnZmMtaWNvbi14JyxcbiAgICBwcmV2OiAnZmMtaWNvbi1jaGV2cm9uLWxlZnQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIHByZXZZZWFyOiAnZmMtaWNvbi1jaGV2cm9ucy1sZWZ0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtcmlnaHQnLFxufTtcblN0YW5kYXJkVGhlbWUucHJvdG90eXBlLnJ0bEljb25DbGFzc2VzID0ge1xuICAgIHByZXY6ICdmYy1pY29uLWNoZXZyb24tcmlnaHQnLFxuICAgIG5leHQ6ICdmYy1pY29uLWNoZXZyb24tbGVmdCcsXG4gICAgcHJldlllYXI6ICdmYy1pY29uLWNoZXZyb25zLXJpZ2h0JyxcbiAgICBuZXh0WWVhcjogJ2ZjLWljb24tY2hldnJvbnMtbGVmdCcsXG59O1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlT3B0aW9uID0gJ2J1dHRvbkljb25zJzsgLy8gVE9ETzogbWFrZSBUUy1mcmllbmRseVxuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlQ3VzdG9tQnV0dG9uT3B0aW9uID0gJ2ljb24nO1xuU3RhbmRhcmRUaGVtZS5wcm90b3R5cGUuaWNvbk92ZXJyaWRlUHJlZml4ID0gJ2ZjLWljb24tJztcblxuZnVuY3Rpb24gY29tcGlsZVZpZXdEZWZzKGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICB2YXIgaGFzaCA9IHt9O1xuICAgIHZhciB2aWV3VHlwZTtcbiAgICBmb3IgKHZpZXdUeXBlIGluIGRlZmF1bHRDb25maWdzKSB7XG4gICAgICAgIGVuc3VyZVZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBmb3IgKHZpZXdUeXBlIGluIG92ZXJyaWRlQ29uZmlncykge1xuICAgICAgICBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGhhc2g7XG59XG5mdW5jdGlvbiBlbnN1cmVWaWV3RGVmKHZpZXdUeXBlLCBoYXNoLCBkZWZhdWx0Q29uZmlncywgb3ZlcnJpZGVDb25maWdzKSB7XG4gICAgaWYgKGhhc2hbdmlld1R5cGVdKSB7XG4gICAgICAgIHJldHVybiBoYXNoW3ZpZXdUeXBlXTtcbiAgICB9XG4gICAgdmFyIHZpZXdEZWYgPSBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIGlmICh2aWV3RGVmKSB7XG4gICAgICAgIGhhc2hbdmlld1R5cGVdID0gdmlld0RlZjtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdEZWY7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdEZWYodmlld1R5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpIHtcbiAgICB2YXIgZGVmYXVsdENvbmZpZyA9IGRlZmF1bHRDb25maWdzW3ZpZXdUeXBlXTtcbiAgICB2YXIgb3ZlcnJpZGVDb25maWcgPSBvdmVycmlkZUNvbmZpZ3Nbdmlld1R5cGVdO1xuICAgIHZhciBxdWVyeVByb3AgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gKChkZWZhdWx0Q29uZmlnICYmIGRlZmF1bHRDb25maWdbbmFtZV0gIT09IG51bGwpID8gZGVmYXVsdENvbmZpZ1tuYW1lXSA6XG4gICAgICAgICgob3ZlcnJpZGVDb25maWcgJiYgb3ZlcnJpZGVDb25maWdbbmFtZV0gIT09IG51bGwpID8gb3ZlcnJpZGVDb25maWdbbmFtZV0gOiBudWxsKSk7IH07XG4gICAgdmFyIHRoZUNvbXBvbmVudCA9IHF1ZXJ5UHJvcCgnY29tcG9uZW50Jyk7XG4gICAgdmFyIHN1cGVyVHlwZSA9IHF1ZXJ5UHJvcCgnc3VwZXJUeXBlJyk7XG4gICAgdmFyIHN1cGVyRGVmID0gbnVsbDtcbiAgICBpZiAoc3VwZXJUeXBlKSB7XG4gICAgICAgIGlmIChzdXBlclR5cGUgPT09IHZpZXdUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgaGF2ZSBhIGN1c3RvbSB2aWV3IHR5cGUgdGhhdCByZWZlcmVuY2VzIGl0c2VsZicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyRGVmID0gZW5zdXJlVmlld0RlZihzdXBlclR5cGUsIGhhc2gsIGRlZmF1bHRDb25maWdzLCBvdmVycmlkZUNvbmZpZ3MpO1xuICAgIH1cbiAgICBpZiAoIXRoZUNvbXBvbmVudCAmJiBzdXBlckRlZikge1xuICAgICAgICB0aGVDb21wb25lbnQgPSBzdXBlckRlZi5jb21wb25lbnQ7XG4gICAgfVxuICAgIGlmICghdGhlQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsOyAvLyBkb24ndCB0aHJvdyBhIHdhcm5pbmcsIG1pZ2h0IGJlIHNldHRpbmdzIGZvciBhIHNpbmdsZS11bml0IHZpZXdcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogdmlld1R5cGUsXG4gICAgICAgIGNvbXBvbmVudDogdGhlQ29tcG9uZW50LFxuICAgICAgICBkZWZhdWx0czogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIChzdXBlckRlZiA/IHN1cGVyRGVmLmRlZmF1bHRzIDoge30pKSwgKGRlZmF1bHRDb25maWcgPyBkZWZhdWx0Q29uZmlnLnJhd09wdGlvbnMgOiB7fSkpLFxuICAgICAgICBvdmVycmlkZXM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCAoc3VwZXJEZWYgPyBzdXBlckRlZi5vdmVycmlkZXMgOiB7fSkpLCAob3ZlcnJpZGVDb25maWcgPyBvdmVycmlkZUNvbmZpZy5yYXdPcHRpb25zIDoge30pKSxcbiAgICB9O1xufVxuXG4vKiBlc2xpbnQgbWF4LWNsYXNzZXMtcGVyLWZpbGU6IG9mZiAqL1xuLy8gTk9URTogaW4gSlNYLCB5b3Ugc2hvdWxkIGFsd2F5cyB1c2UgdGhpcyBjbGFzcyB3aXRoIDxIb29rUHJvcHM+IGFyZy4gb3RoZXJ3aXNlLCB3aWxsIGRlZmF1bHQgdG8gYW55Pz8/XG52YXIgUmVuZGVySG9vayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoUmVuZGVySG9vaywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZW5kZXJIb29rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgc2V0UmVmKF90aGlzLnJvb3RFbFJlZiwgZWwpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCBlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVuZGVySG9vay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gcHJvcHMuaG9va1Byb3BzO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoTW91bnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBkaWRNb3VudDogcHJvcHMuZGlkTW91bnQsIHdpbGxVbm1vdW50OiBwcm9wcy53aWxsVW5tb3VudCwgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0sIGZ1bmN0aW9uIChyb290RWxSZWYpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KENvbnRlbnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjb250ZW50OiBwcm9wcy5jb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQsIGJhY2t1cEVsUmVmOiBfdGhpcy5yb290RWxSZWYgfSwgZnVuY3Rpb24gKGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBub3JtYWxpemVDbGFzc05hbWVzKHByb3BzLmNsYXNzTmFtZXMsIGhvb2tQcm9wcyksIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCk7IH0pKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFJlbmRlckhvb2s7XG59KEJhc2VDb21wb25lbnQpKTtcbi8vIFRPRE86IHJlbmFtZSB0byBiZSBhYm91dCBmdW5jdGlvbiwgbm90IGRlZmF1bHQuIHVzZSBpbiBhYm92ZSB0eXBlXG4vLyBmb3IgZm9yY2luZyByZXJlbmRlciBvZiBjb21wb25lbnRzIHRoYXQgdXNlIHRoZSBDb250ZW50SG9va1xudmFyIEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0ID0gdmRvbV9janMuY3JlYXRlQ29udGV4dCgwKTtcbmZ1bmN0aW9uIENvbnRlbnRIb29rKHByb3BzKSB7XG4gICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KEN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0LkNvbnN1bWVyLCBudWxsLCBmdW5jdGlvbiAocmVuZGVySWQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KENvbnRlbnRIb29rSW5uZXIsIHRzbGliLl9fYXNzaWduKHsgcmVuZGVySWQ6IHJlbmRlcklkIH0sIHByb3BzKSkpOyB9KSk7XG59XG52YXIgQ29udGVudEhvb2tJbm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoQ29udGVudEhvb2tJbm5lciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb250ZW50SG9va0lubmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5uZXJFbFJlZiA9IHZkb21fY2pzLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5pbm5lckVsUmVmLCB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUN1c3RvbUNvbnRlbnQoKTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDdXN0b21Db250ZW50KCk7XG4gICAgfTtcbiAgICBDb250ZW50SG9va0lubmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tQ29udGVudEluZm8gJiYgdGhpcy5jdXN0b21Db250ZW50SW5mby5kZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VzdG9tQ29udGVudEluZm8gPSB0aGlzLmN1c3RvbUNvbnRlbnRJbmZvOyAvLyBvbmx5IHBvcHVsYXRlZCBpZiB1c2luZyBub24tW3BdcmVhY3Qgbm9kZShzKVxuICAgICAgICB2YXIgaW5uZXJDb250ZW50ID0gdGhpcy5nZXRJbm5lckNvbnRlbnQoKTtcbiAgICAgICAgdmFyIG1ldGEgPSB0aGlzLmdldENvbnRlbnRNZXRhKGlubmVyQ29udGVudCk7XG4gICAgICAgIC8vIGluaXRpYWwgcnVuLCBvciBjb250ZW50LXR5cGUgY2hhbmdpbmc/IChmcm9tIHZ1ZSAtPiByZWFjdCBmb3IgZXhhbXBsZSlcbiAgICAgICAgaWYgKCFjdXN0b21Db250ZW50SW5mbyB8fCBjdXN0b21Db250ZW50SW5mby5jb250ZW50S2V5ICE9PSBtZXRhLmNvbnRlbnRLZXkpIHtcbiAgICAgICAgICAgIC8vIGNsZWFyaW5nIG9sZCB2YWx1ZVxuICAgICAgICAgICAgaWYgKGN1c3RvbUNvbnRlbnRJbmZvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUNvbnRlbnRJbmZvLmRlc3Ryb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQ29udGVudEluZm8uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXN0b21Db250ZW50SW5mbyA9IHRoaXMuY3VzdG9tQ29udGVudEluZm8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYXNzaWduaW5nIG5ldyB2YWx1ZVxuICAgICAgICAgICAgaWYgKG1ldGEuY29udGVudEtleSkge1xuICAgICAgICAgICAgICAgIGN1c3RvbUNvbnRlbnRJbmZvID0gdGhpcy5jdXN0b21Db250ZW50SW5mbyA9IHRzbGliLl9fYXNzaWduKHsgY29udGVudEtleTogbWV0YS5jb250ZW50S2V5LCBjb250ZW50VmFsOiBpbm5lckNvbnRlbnRbbWV0YS5jb250ZW50S2V5XSB9LCBtZXRhLmJ1aWxkTGlmZWN5Y2xlRnVuY3MoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB1cGRhdGluZ1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGN1c3RvbUNvbnRlbnRJbmZvKSB7XG4gICAgICAgICAgICBjdXN0b21Db250ZW50SW5mby5jb250ZW50VmFsID0gaW5uZXJDb250ZW50W21ldGEuY29udGVudEtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1c3RvbUNvbnRlbnRJbmZvXG4gICAgICAgICAgICA/IFtdIC8vIHNpZ25hbCB0aGF0IHNvbWV0aGluZyB3YXMgc3BlY2lmaWVkXG4gICAgICAgICAgICA6IGlubmVyQ29udGVudDsgLy8gYXNzdW1lIGEgW3BdcmVhY3QgdmRvbSBub2RlLiB1c2UgaXRcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLmdldElubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGlubmVyQ29udGVudCA9IG5vcm1hbGl6ZUNvbnRlbnQocHJvcHMuY29udGVudCwgcHJvcHMuaG9va1Byb3BzKTtcbiAgICAgICAgaWYgKGlubmVyQ29udGVudCA9PT0gdW5kZWZpbmVkKSB7IC8vIHVzZSB0aGUgZGVmYXVsdFxuICAgICAgICAgICAgaW5uZXJDb250ZW50ID0gbm9ybWFsaXplQ29udGVudChwcm9wcy5kZWZhdWx0Q29udGVudCwgcHJvcHMuaG9va1Byb3BzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5uZXJDb250ZW50ID09IG51bGwgPyBudWxsIDogaW5uZXJDb250ZW50OyAvLyBjb252ZXJ0IHVuZGVmaW5lZCB0byBudWxsIChiZXR0ZXIgZm9yIFJlYWN0KVxuICAgIH07XG4gICAgQ29udGVudEhvb2tJbm5lci5wcm90b3R5cGUuZ2V0Q29udGVudE1ldGEgPSBmdW5jdGlvbiAoaW5uZXJDb250ZW50KSB7XG4gICAgICAgIHZhciBjb250ZW50VHlwZUhhbmRsZXJzID0gdGhpcy5jb250ZXh0LnBsdWdpbkhvb2tzLmNvbnRlbnRUeXBlSGFuZGxlcnM7XG4gICAgICAgIHZhciBjb250ZW50S2V5ID0gJyc7XG4gICAgICAgIHZhciBidWlsZExpZmVjeWNsZUZ1bmNzID0gbnVsbDtcbiAgICAgICAgaWYgKGlubmVyQ29udGVudCkgeyAvLyBhbGxvd2VkIHRvIGJlIG51bGwsIGZvciBjb252ZW5pZW5jZSB0byBjYWxsZXJcbiAgICAgICAgICAgIGZvciAodmFyIHNlYXJjaEtleSBpbiBjb250ZW50VHlwZUhhbmRsZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyQ29udGVudFtzZWFyY2hLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudEtleSA9IHNlYXJjaEtleTtcbiAgICAgICAgICAgICAgICAgICAgYnVpbGRMaWZlY3ljbGVGdW5jcyA9IGNvbnRlbnRUeXBlSGFuZGxlcnNbc2VhcmNoS2V5XTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGNvbnRlbnRLZXk6IGNvbnRlbnRLZXksIGJ1aWxkTGlmZWN5Y2xlRnVuY3M6IGJ1aWxkTGlmZWN5Y2xlRnVuY3MgfTtcbiAgICB9O1xuICAgIENvbnRlbnRIb29rSW5uZXIucHJvdG90eXBlLnVwZGF0ZUN1c3RvbUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1c3RvbUNvbnRlbnRJbmZvKSB7IC8vIGZvciBub24tW3BdcmVhY3RcbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8ucmVuZGVyKHRoaXMuaW5uZXJFbFJlZi5jdXJyZW50IHx8IHRoaXMucHJvcHMuYmFja3VwRWxSZWYuY3VycmVudCwgLy8gdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGludG9cbiAgICAgICAgICAgIHRoaXMuY3VzdG9tQ29udGVudEluZm8uY29udGVudFZhbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBDb250ZW50SG9va0lubmVyO1xufShCYXNlQ29tcG9uZW50KSk7XG52YXIgTW91bnRIb29rID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhNb3VudEhvb2ssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW91bnRIb29rKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKHJvb3RFbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKF90aGlzLnByb3BzLmVsUmVmKSB7XG4gICAgICAgICAgICAgICAgc2V0UmVmKF90aGlzLnByb3BzLmVsUmVmLCByb290RWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1vdW50SG9vay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbih0aGlzLmhhbmRsZVJvb3RFbCk7XG4gICAgfTtcbiAgICBNb3VudEhvb2sucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0aGlzLnByb3BzLmRpZE1vdW50O1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLmhvb2tQcm9wcyksIHsgZWw6IHRoaXMucm9vdEVsIH0pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW91bnRIb29rLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5wcm9wcy53aWxsVW5tb3VudDtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdGhpcy5wcm9wcy5ob29rUHJvcHMpLCB7IGVsOiB0aGlzLnJvb3RFbCB9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNb3VudEhvb2s7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcigpIHtcbiAgICB2YXIgY3VycmVudEdlbmVyYXRvcjtcbiAgICB2YXIgY3VycmVudEhvb2tQcm9wcztcbiAgICB2YXIgY3VycmVudENsYXNzTmFtZXMgPSBbXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGdlbmVyYXRvciwgaG9va1Byb3BzKSB7XG4gICAgICAgIGlmICghY3VycmVudEhvb2tQcm9wcyB8fCAhaXNQcm9wc0VxdWFsKGN1cnJlbnRIb29rUHJvcHMsIGhvb2tQcm9wcykgfHwgZ2VuZXJhdG9yICE9PSBjdXJyZW50R2VuZXJhdG9yKSB7XG4gICAgICAgICAgICBjdXJyZW50R2VuZXJhdG9yID0gZ2VuZXJhdG9yO1xuICAgICAgICAgICAgY3VycmVudEhvb2tQcm9wcyA9IGhvb2tQcm9wcztcbiAgICAgICAgICAgIGN1cnJlbnRDbGFzc05hbWVzID0gbm9ybWFsaXplQ2xhc3NOYW1lcyhnZW5lcmF0b3IsIGhvb2tQcm9wcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDbGFzc05hbWVzO1xuICAgIH07XG59XG5mdW5jdGlvbiBub3JtYWxpemVDbGFzc05hbWVzKGNsYXNzTmFtZXMsIGhvb2tQcm9wcykge1xuICAgIGlmICh0eXBlb2YgY2xhc3NOYW1lcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjbGFzc05hbWVzID0gY2xhc3NOYW1lcyhob29rUHJvcHMpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VDbGFzc05hbWVzKGNsYXNzTmFtZXMpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQ29udGVudChpbnB1dCwgaG9va1Byb3BzKSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gaW5wdXQoaG9va1Byb3BzLCB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KTsgLy8gZ2l2ZSB0aGUgZnVuY3Rpb24gdGhlIHZkb20tY3JlYXRpb24gZnVuY1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQ7XG59XG5cbnZhciBWaWV3Um9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVmlld1Jvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlld1Jvb3QoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5ub3JtYWxpemVDbGFzc05hbWVzID0gYnVpbGRDbGFzc05hbWVOb3JtYWxpemVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmlld1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zO1xuICAgICAgICB2YXIgaG9va1Byb3BzID0geyB2aWV3OiBjb250ZXh0LnZpZXdBcGkgfTtcbiAgICAgICAgdmFyIGN1c3RvbUNsYXNzTmFtZXMgPSB0aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy52aWV3Q2xhc3NOYW1lcywgaG9va1Byb3BzKTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KE1vdW50SG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgZGlkTW91bnQ6IG9wdGlvbnMudmlld0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy52aWV3V2lsbFVubW91bnQsIGVsUmVmOiBwcm9wcy5lbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmKSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIFtcImZjLVwiICsgcHJvcHMudmlld1NwZWMudHlwZSArIFwiLXZpZXdcIiwgJ2ZjLXZpZXcnXS5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlld1Jvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gcGFyc2VWaWV3Q29uZmlncyhpbnB1dHMpIHtcbiAgICByZXR1cm4gbWFwSGFzaChpbnB1dHMsIHBhcnNlVmlld0NvbmZpZyk7XG59XG5mdW5jdGlvbiBwYXJzZVZpZXdDb25maWcoaW5wdXQpIHtcbiAgICB2YXIgcmF3T3B0aW9ucyA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHsgY29tcG9uZW50OiBpbnB1dCB9IDpcbiAgICAgICAgaW5wdXQ7XG4gICAgdmFyIGNvbXBvbmVudCA9IHJhd09wdGlvbnMuY29tcG9uZW50O1xuICAgIGlmIChyYXdPcHRpb25zLmNvbnRlbnQpIHtcbiAgICAgICAgY29tcG9uZW50ID0gY3JlYXRlVmlld0hvb2tDb21wb25lbnQocmF3T3B0aW9ucyk7XG4gICAgICAgIC8vIFRPRE86IHJlbW92ZSBjb250ZW50L2NsYXNzTmFtZXMvZGlkTW91bnQvZXRjIGZyb20gb3B0aW9ucz9cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3VwZXJUeXBlOiByYXdPcHRpb25zLnR5cGUsXG4gICAgICAgIGNvbXBvbmVudDogY29tcG9uZW50LFxuICAgICAgICByYXdPcHRpb25zOiByYXdPcHRpb25zLFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWaWV3SG9va0NvbXBvbmVudChvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2aWV3UHJvcHMpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdSb290LCB7IHZpZXdTcGVjOiBjb250ZXh0LnZpZXdTcGVjIH0sIGZ1bmN0aW9uICh2aWV3RWxSZWYsIHZpZXdDbGFzc05hbWVzKSB7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdmlld1Byb3BzKSwgeyBuZXh0RGF5VGhyZXNob2xkOiBjb250ZXh0Lm9wdGlvbnMubmV4dERheVRocmVzaG9sZCB9KTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuY2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5jb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5kaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMud2lsbFVubW91bnQsIGVsUmVmOiB2aWV3RWxSZWYgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogdmlld0NsYXNzTmFtZXMuY29uY2F0KGN1c3RvbUNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgcmVmOiByb290RWxSZWYgfSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICB9KSk7IH0pKTsgfTtcbn1cblxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlY3MoZGVmYXVsdElucHV0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cykge1xuICAgIHZhciBkZWZhdWx0Q29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3MoZGVmYXVsdElucHV0cyk7XG4gICAgdmFyIG92ZXJyaWRlQ29uZmlncyA9IHBhcnNlVmlld0NvbmZpZ3Mob3B0aW9uT3ZlcnJpZGVzLnZpZXdzKTtcbiAgICB2YXIgdmlld0RlZnMgPSBjb21waWxlVmlld0RlZnMoZGVmYXVsdENvbmZpZ3MsIG92ZXJyaWRlQ29uZmlncyk7XG4gICAgcmV0dXJuIG1hcEhhc2godmlld0RlZnMsIGZ1bmN0aW9uICh2aWV3RGVmKSB7IHJldHVybiBidWlsZFZpZXdTcGVjKHZpZXdEZWYsIG92ZXJyaWRlQ29uZmlncywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7IH0pO1xufVxuZnVuY3Rpb24gYnVpbGRWaWV3U3BlYyh2aWV3RGVmLCBvdmVycmlkZUNvbmZpZ3MsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgbG9jYWxlRGVmYXVsdHMpIHtcbiAgICB2YXIgZHVyYXRpb25JbnB1dCA9IHZpZXdEZWYub3ZlcnJpZGVzLmR1cmF0aW9uIHx8XG4gICAgICAgIHZpZXdEZWYuZGVmYXVsdHMuZHVyYXRpb24gfHxcbiAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcy5kdXJhdGlvbiB8fFxuICAgICAgICBvcHRpb25PdmVycmlkZXMuZHVyYXRpb247XG4gICAgdmFyIGR1cmF0aW9uID0gbnVsbDtcbiAgICB2YXIgZHVyYXRpb25Vbml0ID0gJyc7XG4gICAgdmFyIHNpbmdsZVVuaXQgPSAnJztcbiAgICB2YXIgc2luZ2xlVW5pdE92ZXJyaWRlcyA9IHt9O1xuICAgIGlmIChkdXJhdGlvbklucHV0KSB7XG4gICAgICAgIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb25DYWNoZWQoZHVyYXRpb25JbnB1dCk7XG4gICAgICAgIGlmIChkdXJhdGlvbikgeyAvLyB2YWxpZD9cbiAgICAgICAgICAgIHZhciBkZW5vbSA9IGdyZWF0ZXN0RHVyYXRpb25EZW5vbWluYXRvcihkdXJhdGlvbik7XG4gICAgICAgICAgICBkdXJhdGlvblVuaXQgPSBkZW5vbS51bml0O1xuICAgICAgICAgICAgaWYgKGRlbm9tLnZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgc2luZ2xlVW5pdCA9IGR1cmF0aW9uVW5pdDtcbiAgICAgICAgICAgICAgICBzaW5nbGVVbml0T3ZlcnJpZGVzID0gb3ZlcnJpZGVDb25maWdzW2R1cmF0aW9uVW5pdF0gPyBvdmVycmlkZUNvbmZpZ3NbZHVyYXRpb25Vbml0XS5yYXdPcHRpb25zIDoge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHF1ZXJ5QnV0dG9uVGV4dCA9IGZ1bmN0aW9uIChvcHRpb25zU3Vic2V0KSB7XG4gICAgICAgIHZhciBidXR0b25UZXh0TWFwID0gb3B0aW9uc1N1YnNldC5idXR0b25UZXh0IHx8IHt9O1xuICAgICAgICB2YXIgYnV0dG9uVGV4dEtleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTtcbiAgICAgICAgaWYgKGJ1dHRvblRleHRLZXkgIT0gbnVsbCAmJiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25UZXh0TWFwW2J1dHRvblRleHRLZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChidXR0b25UZXh0TWFwW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvblRleHRNYXBbdmlld0RlZi50eXBlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uVGV4dE1hcFtzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHZhciBxdWVyeUJ1dHRvblRpdGxlID0gZnVuY3Rpb24gKG9wdGlvbnNTdWJzZXQpIHtcbiAgICAgICAgdmFyIGJ1dHRvbkhpbnRzID0gb3B0aW9uc1N1YnNldC5idXR0b25IaW50cyB8fCB7fTtcbiAgICAgICAgdmFyIGJ1dHRvbktleSA9IHZpZXdEZWYuZGVmYXVsdHMuYnV0dG9uVGV4dEtleTsgLy8gdXNlIHNhbWUga2V5IGFzIHRleHRcbiAgICAgICAgaWYgKGJ1dHRvbktleSAhPSBudWxsICYmIGJ1dHRvbkhpbnRzW2J1dHRvbktleV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW2J1dHRvbktleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbkhpbnRzW3ZpZXdEZWYudHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJ1dHRvbkhpbnRzW3NpbmdsZVVuaXRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBidXR0b25IaW50c1tzaW5nbGVVbml0XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHZpZXdEZWYudHlwZSxcbiAgICAgICAgY29tcG9uZW50OiB2aWV3RGVmLmNvbXBvbmVudCxcbiAgICAgICAgZHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBkdXJhdGlvblVuaXQ6IGR1cmF0aW9uVW5pdCxcbiAgICAgICAgc2luZ2xlVW5pdDogc2luZ2xlVW5pdCxcbiAgICAgICAgb3B0aW9uRGVmYXVsdHM6IHZpZXdEZWYuZGVmYXVsdHMsXG4gICAgICAgIG9wdGlvbk92ZXJyaWRlczogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHNpbmdsZVVuaXRPdmVycmlkZXMpLCB2aWV3RGVmLm92ZXJyaWRlcyksXG4gICAgICAgIGJ1dHRvblRleHRPdmVycmlkZTogcXVlcnlCdXR0b25UZXh0KGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQob3B0aW9uT3ZlcnJpZGVzKSB8fCAvLyBjb25zdHJ1Y3Rvci1zcGVjaWZpZWQgYnV0dG9uVGV4dCBsb29rdXAgaGFzaCB0YWtlcyBwcmVjZWRlbmNlXG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25UZXh0LFxuICAgICAgICBidXR0b25UZXh0RGVmYXVsdDogcXVlcnlCdXR0b25UZXh0KGxvY2FsZURlZmF1bHRzKSB8fFxuICAgICAgICAgICAgdmlld0RlZi5kZWZhdWx0cy5idXR0b25UZXh0IHx8XG4gICAgICAgICAgICBxdWVyeUJ1dHRvblRleHQoQkFTRV9PUFRJT05fREVGQVVMVFMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLnR5cGUsXG4gICAgICAgIC8vIG5vdCBEUllcbiAgICAgICAgYnV0dG9uVGl0bGVPdmVycmlkZTogcXVlcnlCdXR0b25UaXRsZShkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSB8fFxuICAgICAgICAgICAgcXVlcnlCdXR0b25UaXRsZShvcHRpb25PdmVycmlkZXMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLm92ZXJyaWRlcy5idXR0b25IaW50LFxuICAgICAgICBidXR0b25UaXRsZURlZmF1bHQ6IHF1ZXJ5QnV0dG9uVGl0bGUobG9jYWxlRGVmYXVsdHMpIHx8XG4gICAgICAgICAgICB2aWV3RGVmLmRlZmF1bHRzLmJ1dHRvbkhpbnQgfHxcbiAgICAgICAgICAgIHF1ZXJ5QnV0dG9uVGl0bGUoQkFTRV9PUFRJT05fREVGQVVMVFMpLFxuICAgICAgICAvLyB3aWxsIGV2ZW50dWFsbHkgZmFsbCBiYWNrIHRvIGJ1dHRvblRleHRcbiAgICB9O1xufVxuLy8gaGFjayB0byBnZXQgbWVtb2l6YXRpb24gd29ya2luZ1xudmFyIGR1cmF0aW9uSW5wdXRNYXAgPSB7fTtcbmZ1bmN0aW9uIGNyZWF0ZUR1cmF0aW9uQ2FjaGVkKGR1cmF0aW9uSW5wdXQpIHtcbiAgICB2YXIganNvbiA9IEpTT04uc3RyaW5naWZ5KGR1cmF0aW9uSW5wdXQpO1xuICAgIHZhciByZXMgPSBkdXJhdGlvbklucHV0TWFwW2pzb25dO1xuICAgIGlmIChyZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXMgPSBjcmVhdGVEdXJhdGlvbihkdXJhdGlvbklucHV0KTtcbiAgICAgICAgZHVyYXRpb25JbnB1dE1hcFtqc29uXSA9IHJlcztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxudmFyIERhdGVQcm9maWxlR2VuZXJhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzKSB7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5ub3dEYXRlID0gZ2V0Tm93KHByb3BzLm5vd0lucHV0LCBwcm9wcy5kYXRlRW52KTtcbiAgICAgICAgdGhpcy5pbml0SGlkZGVuRGF5cygpO1xuICAgIH1cbiAgICAvKiBEYXRlIFJhbmdlIENvbXB1dGF0aW9uXG4gICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbiAgICAvLyBCdWlsZHMgYSBzdHJ1Y3R1cmUgd2l0aCBpbmZvIGFib3V0IHdoYXQgdGhlIGRhdGVzL3JhbmdlcyB3aWxsIGJlIGZvciB0aGUgXCJwcmV2XCIgdmlldy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRQcmV2ID0gZnVuY3Rpb24gKGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZvcmNlVG9WYWxpZCkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMucHJvcHMuZGF0ZUVudjtcbiAgICAgICAgdmFyIHByZXZEYXRlID0gZGF0ZUVudi5zdWJ0cmFjdChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKHByZXZEYXRlLCAtMSwgZm9yY2VUb1ZhbGlkKTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyBhIHN0cnVjdHVyZSB3aXRoIGluZm8gYWJvdXQgd2hhdCB0aGUgZGF0ZXMvcmFuZ2VzIHdpbGwgYmUgZm9yIHRoZSBcIm5leHRcIiB2aWV3LlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZE5leHQgPSBmdW5jdGlvbiAoY3VycmVudERhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5wcm9wcy5kYXRlRW52O1xuICAgICAgICB2YXIgbmV4dERhdGUgPSBkYXRlRW52LmFkZChkYXRlRW52LnN0YXJ0T2YoY3VycmVudERhdGUsIGN1cnJlbnREYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0KSwgLy8gaW1wb3J0YW50IGZvciBzdGFydC1vZi1tb250aFxuICAgICAgICBjdXJyZW50RGF0ZVByb2ZpbGUuZGF0ZUluY3JlbWVudCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1aWxkKG5leHREYXRlLCAxLCBmb3JjZVRvVmFsaWQpO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIGhvbGRpbmcgZGF0ZXMvcmFuZ2VzIGZvciByZW5kZXJpbmcgYXJvdW5kIHRoZSBnaXZlbiBkYXRlLlxuICAgIC8vIE9wdGlvbmFsIGRpcmVjdGlvbiBwYXJhbSBpbmRpY2F0ZXMgd2hldGhlciB0aGUgZGF0ZSBpcyBiZWluZyBpbmNyZW1lbnRlZC9kZWNyZW1lbnRlZFxuICAgIC8vIGZyb20gaXRzIHByZXZpb3VzIHZhbHVlLiBkZWNyZW1lbnRlZCA9IC0xLCBpbmNyZW1lbnRlZCA9IDEgKGRlZmF1bHQpLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZCA9IGZ1bmN0aW9uIChjdXJyZW50RGF0ZSwgZGlyZWN0aW9uLCBmb3JjZVRvVmFsaWQpIHtcbiAgICAgICAgaWYgKGZvcmNlVG9WYWxpZCA9PT0gdm9pZCAwKSB7IGZvcmNlVG9WYWxpZCA9IHRydWU7IH1cbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHZhbGlkUmFuZ2U7XG4gICAgICAgIHZhciBjdXJyZW50SW5mbztcbiAgICAgICAgdmFyIGlzUmFuZ2VBbGxEYXk7XG4gICAgICAgIHZhciByZW5kZXJSYW5nZTtcbiAgICAgICAgdmFyIGFjdGl2ZVJhbmdlO1xuICAgICAgICB2YXIgaXNWYWxpZDtcbiAgICAgICAgdmFsaWRSYW5nZSA9IHRoaXMuYnVpbGRWYWxpZFJhbmdlKCk7XG4gICAgICAgIHZhbGlkUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHZhbGlkUmFuZ2UpO1xuICAgICAgICBpZiAoZm9yY2VUb1ZhbGlkKSB7XG4gICAgICAgICAgICBjdXJyZW50RGF0ZSA9IGNvbnN0cmFpbk1hcmtlclRvUmFuZ2UoY3VycmVudERhdGUsIHZhbGlkUmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRJbmZvID0gdGhpcy5idWlsZEN1cnJlbnRSYW5nZUluZm8oY3VycmVudERhdGUsIGRpcmVjdGlvbik7XG4gICAgICAgIGlzUmFuZ2VBbGxEYXkgPSAvXih5ZWFyfG1vbnRofHdlZWt8ZGF5KSQvLnRlc3QoY3VycmVudEluZm8udW5pdCk7XG4gICAgICAgIHJlbmRlclJhbmdlID0gdGhpcy5idWlsZFJlbmRlclJhbmdlKHRoaXMudHJpbUhpZGRlbkRheXMoY3VycmVudEluZm8ucmFuZ2UpLCBjdXJyZW50SW5mby51bml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgcmVuZGVyUmFuZ2UgPSB0aGlzLnRyaW1IaWRkZW5EYXlzKHJlbmRlclJhbmdlKTtcbiAgICAgICAgYWN0aXZlUmFuZ2UgPSByZW5kZXJSYW5nZTtcbiAgICAgICAgaWYgKCFwcm9wcy5zaG93Tm9uQ3VycmVudERhdGVzKSB7XG4gICAgICAgICAgICBhY3RpdmVSYW5nZSA9IGludGVyc2VjdFJhbmdlcyhhY3RpdmVSYW5nZSwgY3VycmVudEluZm8ucmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gdGhpcy5hZGp1c3RBY3RpdmVSYW5nZShhY3RpdmVSYW5nZSk7XG4gICAgICAgIGFjdGl2ZVJhbmdlID0gaW50ZXJzZWN0UmFuZ2VzKGFjdGl2ZVJhbmdlLCB2YWxpZFJhbmdlKTsgLy8gbWlnaHQgcmV0dXJuIG51bGxcbiAgICAgICAgLy8gaXQncyBpbnZhbGlkIGlmIHRoZSBvcmlnaW5hbGx5IHJlcXVlc3RlZCBkYXRlIGlzIG5vdCBjb250YWluZWQsXG4gICAgICAgIC8vIG9yIGlmIHRoZSByYW5nZSBpcyBjb21wbGV0ZWx5IG91dHNpZGUgb2YgdGhlIHZhbGlkIHJhbmdlLlxuICAgICAgICBpc1ZhbGlkID0gcmFuZ2VzSW50ZXJzZWN0KGN1cnJlbnRJbmZvLnJhbmdlLCB2YWxpZFJhbmdlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpbnQgZm9yIHdoZXJlIHByZXYvbmV4dCBvcGVyYXRpb25zIGNhbiBnbyBhbmQgd2hlcmUgZXZlbnRzIGNhbiBiZSBkcmFnZ2VkL3Jlc2l6ZWQgdG8uXG4gICAgICAgICAgICAvLyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydCBhbmQgZW5kIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YWxpZFJhbmdlOiB2YWxpZFJhbmdlLFxuICAgICAgICAgICAgLy8gcmFuZ2UgdGhlIHZpZXcgaXMgZm9ybWFsbHkgcmVzcG9uc2libGUgZm9yLlxuICAgICAgICAgICAgLy8gZm9yIGV4YW1wbGUsIGEgbW9udGggdmlldyBtaWdodCBoYXZlIDFzdC0zMXN0LCBleGNsdWRpbmcgcGFkZGVkIGRhdGVzXG4gICAgICAgICAgICBjdXJyZW50UmFuZ2U6IGN1cnJlbnRJbmZvLnJhbmdlLFxuICAgICAgICAgICAgLy8gbmFtZSBvZiBsYXJnZXN0IHVuaXQgYmVpbmcgZGlzcGxheWVkLCBsaWtlIFwibW9udGhcIiBvciBcIndlZWtcIlxuICAgICAgICAgICAgY3VycmVudFJhbmdlVW5pdDogY3VycmVudEluZm8udW5pdCxcbiAgICAgICAgICAgIGlzUmFuZ2VBbGxEYXk6IGlzUmFuZ2VBbGxEYXksXG4gICAgICAgICAgICAvLyBkYXRlcyB0aGF0IGRpc3BsYXkgZXZlbnRzIGFuZCBhY2NlcHQgZHJhZy1uLWRyb3BcbiAgICAgICAgICAgIC8vIHdpbGwgYmUgYG51bGxgIGlmIG5vIGRhdGVzIGFjY2VwdCBldmVudHNcbiAgICAgICAgICAgIGFjdGl2ZVJhbmdlOiBhY3RpdmVSYW5nZSxcbiAgICAgICAgICAgIC8vIGRhdGUgcmFuZ2Ugd2l0aCBhIHJlbmRlcmVkIHNrZWxldG9uXG4gICAgICAgICAgICAvLyBpbmNsdWRlcyBub3QtYWN0aXZlIGRheXMgdGhhdCBuZWVkIHNvbWUgc29ydCBvZiBET01cbiAgICAgICAgICAgIHJlbmRlclJhbmdlOiByZW5kZXJSYW5nZSxcbiAgICAgICAgICAgIC8vIER1cmF0aW9uIG9iamVjdCB0aGF0IGRlbm90ZXMgdGhlIGZpcnN0IHZpc2libGUgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG4gICAgICAgICAgICBzbG90TWluVGltZTogcHJvcHMuc2xvdE1pblRpbWUsXG4gICAgICAgICAgICAvLyBEdXJhdGlvbiBvYmplY3QgdGhhdCBkZW5vdGVzIHRoZSBleGNsdXNpdmUgdmlzaWJsZSBlbmQgdGltZSBvZiBhbnkgZ2l2ZW4gZGF5XG4gICAgICAgICAgICBzbG90TWF4VGltZTogcHJvcHMuc2xvdE1heFRpbWUsXG4gICAgICAgICAgICBpc1ZhbGlkOiBpc1ZhbGlkLFxuICAgICAgICAgICAgLy8gaG93IGZhciB0aGUgY3VycmVudCBkYXRlIHdpbGwgbW92ZSBmb3IgYSBwcmV2L25leHQgb3BlcmF0aW9uXG4gICAgICAgICAgICBkYXRlSW5jcmVtZW50OiB0aGlzLmJ1aWxkRGF0ZUluY3JlbWVudChjdXJyZW50SW5mby5kdXJhdGlvbiksXG4gICAgICAgICAgICAvLyBwYXNzIGEgZmFsbGJhY2sgKG1pZ2h0IGJlIG51bGwpIF5cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBzdGFydC9lbmQgcHJvcGVydGllcy5cbiAgICAvLyBJbmRpY2F0ZXMgdGhlIG1pbmltdW0vbWF4aW11bSBkYXRlcyB0byBkaXNwbGF5LlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkVmFsaWRSYW5nZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gdGhpcy5wcm9wcy52YWxpZFJhbmdlSW5wdXQ7XG4gICAgICAgIHZhciBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHRoaXMucHJvcHMuY2FsZW5kYXJBcGksIHRoaXMubm93RGF0ZSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZVJhbmdlKHNpbXBsZUlucHV0KSB8fFxuICAgICAgICAgICAgeyBzdGFydDogbnVsbCwgZW5kOiBudWxsIH07IC8vIGNvbXBsZXRlbHkgb3Blbi1lbmRlZFxuICAgIH07XG4gICAgLy8gQnVpbGRzIGEgc3RydWN0dXJlIHdpdGggaW5mbyBhYm91dCB0aGUgXCJjdXJyZW50XCIgcmFuZ2UsIHRoZSByYW5nZSB0aGF0IGlzXG4gICAgLy8gaGlnaGxpZ2h0ZWQgYXMgYmVpbmcgdGhlIGN1cnJlbnQgbW9udGggZm9yIGV4YW1wbGUuXG4gICAgLy8gU2VlIGJ1aWxkKCkgZm9yIGEgZGVzY3JpcHRpb24gb2YgYGRpcmVjdGlvbmAuXG4gICAgLy8gR3VhcmFudGVlZCB0byBoYXZlIGByYW5nZWAgYW5kIGB1bml0YCBwcm9wZXJ0aWVzLiBgZHVyYXRpb25gIGlzIG9wdGlvbmFsLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZEN1cnJlbnRSYW5nZUluZm8gPSBmdW5jdGlvbiAoZGF0ZSwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IG51bGw7XG4gICAgICAgIHZhciB1bml0ID0gbnVsbDtcbiAgICAgICAgdmFyIHJhbmdlID0gbnVsbDtcbiAgICAgICAgdmFyIGRheUNvdW50O1xuICAgICAgICBpZiAocHJvcHMuZHVyYXRpb24pIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gcHJvcHMuZHVyYXRpb247XG4gICAgICAgICAgICB1bml0ID0gcHJvcHMuZHVyYXRpb25Vbml0O1xuICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLmJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24oZGF0ZSwgZGlyZWN0aW9uLCBkdXJhdGlvbiwgdW5pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRheUNvdW50ID0gdGhpcy5wcm9wcy5kYXlDb3VudCkpIHtcbiAgICAgICAgICAgIHVuaXQgPSAnZGF5JztcbiAgICAgICAgICAgIHJhbmdlID0gdGhpcy5idWlsZFJhbmdlRnJvbURheUNvdW50KGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChyYW5nZSA9IHRoaXMuYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UoZGF0ZSkpKSB7XG4gICAgICAgICAgICB1bml0ID0gcHJvcHMuZGF0ZUVudi5ncmVhdGVzdFdob2xlVW5pdChyYW5nZS5zdGFydCwgcmFuZ2UuZW5kKS51bml0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSB0aGlzLmdldEZhbGxiYWNrRHVyYXRpb24oKTtcbiAgICAgICAgICAgIHVuaXQgPSBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IoZHVyYXRpb24pLnVuaXQ7XG4gICAgICAgICAgICByYW5nZSA9IHRoaXMuYnVpbGRSYW5nZUZyb21EdXJhdGlvbihkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkdXJhdGlvbjogZHVyYXRpb24sIHVuaXQ6IHVuaXQsIHJhbmdlOiByYW5nZSB9O1xuICAgIH07XG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmdldEZhbGxiYWNrRHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7IGRheTogMSB9KTtcbiAgICB9O1xuICAgIC8vIFJldHVybnMgYSBuZXcgYWN0aXZlUmFuZ2UgdG8gaGF2ZSB0aW1lIHZhbHVlcyAodW4tYW1iaWd1YXRlKVxuICAgIC8vIHNsb3RNaW5UaW1lIG9yIHNsb3RNYXhUaW1lIGNhdXNlcyB0aGUgcmFuZ2UgdG8gZXhwYW5kLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5hZGp1c3RBY3RpdmVSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgdXNlc01pbk1heFRpbWUgPSBfYS51c2VzTWluTWF4VGltZSwgc2xvdE1pblRpbWUgPSBfYS5zbG90TWluVGltZSwgc2xvdE1heFRpbWUgPSBfYS5zbG90TWF4VGltZTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmFuZ2Uuc3RhcnQsIGVuZCA9IHJhbmdlLmVuZDtcbiAgICAgICAgaWYgKHVzZXNNaW5NYXhUaW1lKSB7XG4gICAgICAgICAgICAvLyBleHBhbmQgYWN0aXZlIHJhbmdlIGlmIHNsb3RNaW5UaW1lIGlzIG5lZ2F0aXZlICh3aHkgbm90IHdoZW4gcG9zaXRpdmU/KVxuICAgICAgICAgICAgaWYgKGFzUm91Z2hEYXlzKHNsb3RNaW5UaW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBkYXRlRW52LmFkZChzdGFydCwgc2xvdE1pblRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXhwYW5kIGFjdGl2ZSByYW5nZSBpZiBzbG90TWF4VGltZSBpcyBiZXlvbmQgb25lIGRheSAod2h5IG5vdCB3aGVuIG5lZ2F0aXZlPylcbiAgICAgICAgICAgIGlmIChhc1JvdWdoRGF5cyhzbG90TWF4VGltZSkgPiAxKSB7XG4gICAgICAgICAgICAgICAgZW5kID0gc3RhcnRPZkRheShlbmQpOyAvLyBuZWNlc3Nhcnk/XG4gICAgICAgICAgICAgICAgZW5kID0gYWRkRGF5cyhlbmQsIC0xKTtcbiAgICAgICAgICAgICAgICBlbmQgPSBkYXRlRW52LmFkZChlbmQsIHNsb3RNYXhUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfTtcbiAgICAvLyBCdWlsZHMgdGhlIFwiY3VycmVudFwiIHJhbmdlIHdoZW4gaXQgaXMgc3BlY2lmaWVkIGFzIGFuIGV4cGxpY2l0IGR1cmF0aW9uLlxuICAgIC8vIGB1bml0YCBpcyB0aGUgYWxyZWFkeS1jb21wdXRlZCBncmVhdGVzdER1cmF0aW9uRGVub21pbmF0b3IgdW5pdCBvZiBkdXJhdGlvbi5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGRSYW5nZUZyb21EdXJhdGlvbiA9IGZ1bmN0aW9uIChkYXRlLCBkaXJlY3Rpb24sIGR1cmF0aW9uLCB1bml0KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBkYXRlQWxpZ25tZW50ID0gX2EuZGF0ZUFsaWdubWVudDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICB2YXIgZW5kO1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICAvLyBjb21wdXRlIHdoYXQgdGhlIGFsaWdubWVudCBzaG91bGQgYmVcbiAgICAgICAgaWYgKCFkYXRlQWxpZ25tZW50KSB7XG4gICAgICAgICAgICB2YXIgZGF0ZUluY3JlbWVudCA9IHRoaXMucHJvcHMuZGF0ZUluY3JlbWVudDtcbiAgICAgICAgICAgIGlmIChkYXRlSW5jcmVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gdXNlIHRoZSBzbWFsbGVyIG9mIHRoZSB0d28gdW5pdHNcbiAgICAgICAgICAgICAgICBpZiAoYXNSb3VnaE1zKGRhdGVJbmNyZW1lbnQpIDwgYXNSb3VnaE1zKGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yKGRhdGVJbmNyZW1lbnQpLnVuaXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXRlQWxpZ25tZW50ID0gdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdmlldyBkaXNwbGF5cyBhIHNpbmdsZSBkYXkgb3Igc21hbGxlclxuICAgICAgICBpZiAoYXNSb3VnaERheXMoZHVyYXRpb24pIDw9IDEpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGlkZGVuRGF5KHN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ID0gdGhpcy5za2lwSGlkZGVuRGF5cyhzdGFydCwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGNvbXB1dGVSZXMoKSB7XG4gICAgICAgICAgICBzdGFydCA9IGRhdGVFbnYuc3RhcnRPZihkYXRlLCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgICAgIGVuZCA9IGRhdGVFbnYuYWRkKHN0YXJ0LCBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXMgPSB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb21wdXRlUmVzKCk7XG4gICAgICAgIC8vIGlmIHJhbmdlIGlzIGNvbXBsZXRlbHkgZW52ZWxvcGVkIGJ5IGhpZGRlbiBkYXlzLCBnbyBwYXN0IHRoZSBoaWRkZW4gZGF5c1xuICAgICAgICBpZiAoIXRoaXMudHJpbUhpZGRlbkRheXMocmVzKSkge1xuICAgICAgICAgICAgZGF0ZSA9IHRoaXMuc2tpcEhpZGRlbkRheXMoZGF0ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGNvbXB1dGVSZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgLy8gQnVpbGRzIHRoZSBcImN1cnJlbnRcIiByYW5nZSB3aGVuIGEgZGF5Q291bnQgaXMgc3BlY2lmaWVkLlxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJhbmdlRnJvbURheUNvdW50ID0gZnVuY3Rpb24gKGRhdGUsIGRpcmVjdGlvbiwgZGF5Q291bnQpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgZGF0ZUVudiA9IF9hLmRhdGVFbnYsIGRhdGVBbGlnbm1lbnQgPSBfYS5kYXRlQWxpZ25tZW50O1xuICAgICAgICB2YXIgcnVubmluZ0NvdW50ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZGF0ZTtcbiAgICAgICAgdmFyIGVuZDtcbiAgICAgICAgaWYgKGRhdGVBbGlnbm1lbnQpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mKHN0YXJ0LCBkYXRlQWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IHN0YXJ0T2ZEYXkoc3RhcnQpO1xuICAgICAgICBzdGFydCA9IHRoaXMuc2tpcEhpZGRlbkRheXMoc3RhcnQsIGRpcmVjdGlvbik7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgICBlbmQgPSBhZGREYXlzKGVuZCwgMSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNIaWRkZW5EYXkoZW5kKSkge1xuICAgICAgICAgICAgICAgIHJ1bm5pbmdDb3VudCArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChydW5uaW5nQ291bnQgPCBkYXlDb3VudCk7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIC8vIEJ1aWxkcyBhIG5vcm1hbGl6ZWQgcmFuZ2Ugb2JqZWN0IGZvciB0aGUgXCJ2aXNpYmxlXCIgcmFuZ2UsXG4gICAgLy8gd2hpY2ggaXMgYSB3YXkgdG8gZGVmaW5lIHRoZSBjdXJyZW50UmFuZ2UgYW5kIGFjdGl2ZVJhbmdlIGF0IHRoZSBzYW1lIHRpbWUuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkQ3VzdG9tVmlzaWJsZVJhbmdlID0gZnVuY3Rpb24gKGRhdGUpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGlucHV0ID0gcHJvcHMudmlzaWJsZVJhbmdlSW5wdXQ7XG4gICAgICAgIHZhciBzaW1wbGVJbnB1dCA9IHR5cGVvZiBpbnB1dCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICAgICAgPyBpbnB1dC5jYWxsKHByb3BzLmNhbGVuZGFyQXBpLCBwcm9wcy5kYXRlRW52LnRvRGF0ZShkYXRlKSlcbiAgICAgICAgICAgIDogaW5wdXQ7XG4gICAgICAgIHZhciByYW5nZSA9IHRoaXMucmVmaW5lUmFuZ2Uoc2ltcGxlSW5wdXQpO1xuICAgICAgICBpZiAocmFuZ2UgJiYgKHJhbmdlLnN0YXJ0ID09IG51bGwgfHwgcmFuZ2UuZW5kID09IG51bGwpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlcyB0aGUgcmFuZ2UgdGhhdCB3aWxsIHJlcHJlc2VudCB0aGUgZWxlbWVudC9jZWxscyBmb3IgKnJlbmRlcmluZyosXG4gICAgLy8gYnV0IHdoaWNoIG1heSBoYXZlIHZvaWRlZCBkYXlzL3RpbWVzLlxuICAgIC8vIG5vdCByZXNwb25zaWJsZSBmb3IgdHJpbW1pbmcgaGlkZGVuIGRheXMuXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLmJ1aWxkUmVuZGVyUmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50UmFuZ2U7XG4gICAgfTtcbiAgICAvLyBDb21wdXRlIHRoZSBkdXJhdGlvbiB2YWx1ZSB0aGF0IHNob3VsZCBiZSBhZGRlZC9zdWJzdHJhY3RlZCB0byB0aGUgY3VycmVudCBkYXRlXG4gICAgLy8gd2hlbiBhIHByZXYvbmV4dCBvcGVyYXRpb24gaGFwcGVucy5cbiAgICBEYXRlUHJvZmlsZUdlbmVyYXRvci5wcm90b3R5cGUuYnVpbGREYXRlSW5jcmVtZW50ID0gZnVuY3Rpb24gKGZhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRlSW5jcmVtZW50ID0gdGhpcy5wcm9wcy5kYXRlSW5jcmVtZW50O1xuICAgICAgICB2YXIgY3VzdG9tQWxpZ25tZW50O1xuICAgICAgICBpZiAoZGF0ZUluY3JlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGVJbmNyZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChjdXN0b21BbGlnbm1lbnQgPSB0aGlzLnByb3BzLmRhdGVBbGlnbm1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oMSwgY3VzdG9tQWxpZ25tZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oeyBkYXlzOiAxIH0pO1xuICAgIH07XG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnJlZmluZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgaWYgKHJhbmdlSW5wdXQpIHtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IHBhcnNlUmFuZ2UocmFuZ2VJbnB1dCwgdGhpcy5wcm9wcy5kYXRlRW52KTtcbiAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgIHJhbmdlID0gY29tcHV0ZVZpc2libGVEYXlSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvKiBIaWRkZW4gRGF5c1xuICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4gICAgLy8gSW5pdGlhbGl6ZXMgaW50ZXJuYWwgdmFyaWFibGVzIHJlbGF0ZWQgdG8gY2FsY3VsYXRpbmcgaGlkZGVuIGRheXMtb2Ytd2Vla1xuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5pbml0SGlkZGVuRGF5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGhpZGRlbkRheXMgPSB0aGlzLnByb3BzLmhpZGRlbkRheXMgfHwgW107IC8vIGFycmF5IG9mIGRheS1vZi13ZWVrIGluZGljZXMgdGhhdCBhcmUgaGlkZGVuXG4gICAgICAgIHZhciBpc0hpZGRlbkRheUhhc2ggPSBbXTsgLy8gaXMgdGhlIGRheS1vZi13ZWVrIGhpZGRlbj8gKGhhc2ggd2l0aCBkYXktb2Ytd2Vlay1pbmRleCAtPiBib29sKVxuICAgICAgICB2YXIgZGF5Q250ID0gMDtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLndlZWtlbmRzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgaGlkZGVuRGF5cy5wdXNoKDAsIDYpOyAvLyAwPXN1bmRheSwgNj1zYXR1cmRheVxuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpICs9IDEpIHtcbiAgICAgICAgICAgIGlmICghKGlzSGlkZGVuRGF5SGFzaFtpXSA9IGhpZGRlbkRheXMuaW5kZXhPZihpKSAhPT0gLTEpKSB7XG4gICAgICAgICAgICAgICAgZGF5Q250ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXlDbnQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBoaWRkZW5EYXlzJyk7IC8vIGFsbCBkYXlzIHdlcmUgaGlkZGVuPyBiYWQuXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0hpZGRlbkRheUhhc2ggPSBpc0hpZGRlbkRheUhhc2g7XG4gICAgfTtcbiAgICAvLyBSZW1vdmUgZGF5cyBmcm9tIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiB0aGUgcmFuZ2UgdGhhdCBhcmUgY29tcHV0ZWQgYXMgaGlkZGVuLlxuICAgIC8vIElmIHRoZSB3aG9sZSByYW5nZSBpcyB0cmltbWVkIG9mZiwgcmV0dXJucyBudWxsXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnRyaW1IaWRkZW5EYXlzID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHJhbmdlLnN0YXJ0LCBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIGlmIChzdGFydCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW5kKSB7XG4gICAgICAgICAgICBlbmQgPSB0aGlzLnNraXBIaWRkZW5EYXlzKGVuZCwgLTEsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydCA9PSBudWxsIHx8IGVuZCA9PSBudWxsIHx8IHN0YXJ0IDwgZW5kKSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICAvLyBJcyB0aGUgY3VycmVudCBkYXkgaGlkZGVuP1xuICAgIC8vIGBkYXlgIGlzIGEgZGF5LW9mLXdlZWsgaW5kZXggKDAtNiksIG9yIGEgRGF0ZSAodXNlZCBmb3IgVVRDKVxuICAgIERhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5pc0hpZGRlbkRheSA9IGZ1bmN0aW9uIChkYXkpIHtcbiAgICAgICAgaWYgKGRheSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIGRheSA9IGRheS5nZXRVVENEYXkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc0hpZGRlbkRheUhhc2hbZGF5XTtcbiAgICB9O1xuICAgIC8vIEluY3JlbWVudGluZyB0aGUgY3VycmVudCBkYXkgdW50aWwgaXQgaXMgbm8gbG9uZ2VyIGEgaGlkZGVuIGRheSwgcmV0dXJuaW5nIGEgY29weS5cbiAgICAvLyBET0VTIE5PVCBDT05TSURFUiB2YWxpZFJhbmdlIVxuICAgIC8vIElmIHRoZSBpbml0aWFsIHZhbHVlIG9mIGBkYXRlYCBpcyBub3QgYSBoaWRkZW4gZGF5LCBkb24ndCBkbyBhbnl0aGluZy5cbiAgICAvLyBQYXNzIGBpc0V4Y2x1c2l2ZWAgYXMgYHRydWVgIGlmIHlvdSBhcmUgZGVhbGluZyB3aXRoIGFuIGVuZCBkYXRlLlxuICAgIC8vIGBpbmNgIGRlZmF1bHRzIHRvIGAxYCAoaW5jcmVtZW50IG9uZSBkYXkgZm9yd2FyZCBlYWNoIHRpbWUpXG4gICAgRGF0ZVByb2ZpbGVHZW5lcmF0b3IucHJvdG90eXBlLnNraXBIaWRkZW5EYXlzID0gZnVuY3Rpb24gKGRhdGUsIGluYywgaXNFeGNsdXNpdmUpIHtcbiAgICAgICAgaWYgKGluYyA9PT0gdm9pZCAwKSB7IGluYyA9IDE7IH1cbiAgICAgICAgaWYgKGlzRXhjbHVzaXZlID09PSB2b2lkIDApIHsgaXNFeGNsdXNpdmUgPSBmYWxzZTsgfVxuICAgICAgICB3aGlsZSAodGhpcy5pc0hpZGRlbkRheUhhc2hbKGRhdGUuZ2V0VVRDRGF5KCkgKyAoaXNFeGNsdXNpdmUgPyBpbmMgOiAwKSArIDcpICUgN10pIHtcbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIGluYyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0ZVByb2ZpbGVHZW5lcmF0b3I7XG59KCkpO1xuXG5mdW5jdGlvbiByZWR1Y2VWaWV3VHlwZSh2aWV3VHlwZSwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdDSEFOR0VfVklFV19UWVBFJzpcbiAgICAgICAgICAgIHZpZXdUeXBlID0gYWN0aW9uLnZpZXdUeXBlO1xuICAgIH1cbiAgICByZXR1cm4gdmlld1R5cGU7XG59XG5cbmZ1bmN0aW9uIHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnU0VUX09QVElPTic6XG4gICAgICAgICAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpLCAoX2EgPSB7fSwgX2FbYWN0aW9uLm9wdGlvbk5hbWVdID0gYWN0aW9uLnJhd09wdGlvblZhbHVlLCBfYSkpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGR5bmFtaWNPcHRpb25PdmVycmlkZXM7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VEYXRlUHJvZmlsZShjdXJyZW50RGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgdmFyIGRwO1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQ0hBTkdFX1ZJRVdfVFlQRSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIgfHwgY3VycmVudERhdGUpO1xuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgICAgICByZXR1cm4gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoYWN0aW9uLmRhdGVNYXJrZXIpO1xuICAgICAgICBjYXNlICdQUkVWJzpcbiAgICAgICAgICAgIGRwID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGN1cnJlbnREYXRlUHJvZmlsZSwgY3VycmVudERhdGUpO1xuICAgICAgICAgICAgaWYgKGRwLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTkVYVCc6XG4gICAgICAgICAgICBkcCA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChjdXJyZW50RGF0ZVByb2ZpbGUsIGN1cnJlbnREYXRlKTtcbiAgICAgICAgICAgIGlmIChkcC5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50RGF0ZVByb2ZpbGU7XG59XG5cbmZ1bmN0aW9uIGluaXRFdmVudFNvdXJjZXMoY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY29udGV4dCkge1xuICAgIHZhciBhY3RpdmVSYW5nZSA9IGRhdGVQcm9maWxlID8gZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UgOiBudWxsO1xuICAgIHJldHVybiBhZGRTb3VyY2VzKHt9LCBwYXJzZUluaXRpYWxTb3VyY2VzKGNhbGVuZGFyT3B0aW9ucywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlcyhldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHN3aXRjaCAoYWN0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UX1NPVVJDRVMnOiAvLyBhbHJlYWR5IHBhcnNlZFxuICAgICAgICAgICAgcmV0dXJuIGFkZFNvdXJjZXMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTb3VyY2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZldGNoRGlydHlTb3VyY2VzKGV2ZW50U291cmNlcywgYWN0aXZlUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U291cmNlcztcbiAgICAgICAgY2FzZSAnRkVUQ0hfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWRzID8gLy8gd2h5IG5vIHR5cGU/XG4gICAgICAgICAgICAgICAgYXJyYXlUb0hhc2goYWN0aW9uLnNvdXJjZUlkcykgOlxuICAgICAgICAgICAgICAgIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCBhY3Rpb24uaXNSZWZldGNoIHx8IGZhbHNlLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnUkVDRUlWRV9FVkVOVFMnOlxuICAgICAgICBjYXNlICdSRUNFSVZFX0VWRU5UX0VSUk9SJzpcbiAgICAgICAgICAgIHJldHVybiByZWNlaXZlUmVzcG9uc2UoZXZlbnRTb3VyY2VzLCBhY3Rpb24uc291cmNlSWQsIGFjdGlvbi5mZXRjaElkLCBhY3Rpb24uZmV0Y2hSYW5nZSk7XG4gICAgICAgIGNhc2UgJ1JFTU9WRV9BTExfRVZFTlRfU09VUkNFUyc6XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTb3VyY2VzO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWN0aXZlUmFuZ2UgPSBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbDsgLy8gbmVlZCB0aGlzIGNoZWNrP1xuICAgIHJldHVybiBmZXRjaFNvdXJjZXNCeUlkcyhldmVudFNvdXJjZXMsIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCksIGFjdGl2ZVJhbmdlLCB0cnVlLCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nKGV2ZW50U291cmNlcykge1xuICAgIGZvciAodmFyIHNvdXJjZUlkIGluIGV2ZW50U291cmNlcykge1xuICAgICAgICBpZiAoZXZlbnRTb3VyY2VzW3NvdXJjZUlkXS5pc0ZldGNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhZGRTb3VyY2VzKGV2ZW50U291cmNlSGFzaCwgc291cmNlcywgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIHZhciBoYXNoID0ge307XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzb3VyY2VzXzEgPSBzb3VyY2VzOyBfaSA8IHNvdXJjZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNfMVtfaV07XG4gICAgICAgIGhhc2hbc291cmNlLnNvdXJjZUlkXSA9IHNvdXJjZTtcbiAgICB9XG4gICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgaGFzaCA9IGZldGNoRGlydHlTb3VyY2VzKGhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50U291cmNlSGFzaCksIGhhc2gpO1xufVxuZnVuY3Rpb24gcmVtb3ZlU291cmNlKGV2ZW50U291cmNlSGFzaCwgc291cmNlSWQpIHtcbiAgICByZXR1cm4gZmlsdGVySGFzaChldmVudFNvdXJjZUhhc2gsIGZ1bmN0aW9uIChldmVudFNvdXJjZSkgeyByZXR1cm4gZXZlbnRTb3VyY2Uuc291cmNlSWQgIT09IHNvdXJjZUlkOyB9KTtcbn1cbmZ1bmN0aW9uIGZldGNoRGlydHlTb3VyY2VzKHNvdXJjZUhhc2gsIGZldGNoUmFuZ2UsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gZmV0Y2hTb3VyY2VzQnlJZHMoc291cmNlSGFzaCwgZmlsdGVySGFzaChzb3VyY2VIYXNoLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGlzU291cmNlRGlydHkoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGNvbnRleHQpOyB9KSwgZmV0Y2hSYW5nZSwgZmFsc2UsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gaXNTb3VyY2VEaXJ0eShldmVudFNvdXJjZSwgZmV0Y2hSYW5nZSwgY29udGV4dCkge1xuICAgIGlmICghZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkO1xuICAgIH1cbiAgICByZXR1cm4gIWNvbnRleHQub3B0aW9ucy5sYXp5RmV0Y2hpbmcgfHxcbiAgICAgICAgIWV2ZW50U291cmNlLmZldGNoUmFuZ2UgfHxcbiAgICAgICAgZXZlbnRTb3VyY2UuaXNGZXRjaGluZyB8fCAvLyBhbHdheXMgY2FuY2VsIG91dGRhdGVkIGluLXByb2dyZXNzIGZldGNoZXNcbiAgICAgICAgZmV0Y2hSYW5nZS5zdGFydCA8IGV2ZW50U291cmNlLmZldGNoUmFuZ2Uuc3RhcnQgfHxcbiAgICAgICAgZmV0Y2hSYW5nZS5lbmQgPiBldmVudFNvdXJjZS5mZXRjaFJhbmdlLmVuZDtcbn1cbmZ1bmN0aW9uIGZldGNoU291cmNlc0J5SWRzKHByZXZTb3VyY2VzLCBzb3VyY2VJZEhhc2gsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIHZhciBuZXh0U291cmNlcyA9IHt9O1xuICAgIGZvciAodmFyIHNvdXJjZUlkIGluIHByZXZTb3VyY2VzKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBwcmV2U291cmNlc1tzb3VyY2VJZF07XG4gICAgICAgIGlmIChzb3VyY2VJZEhhc2hbc291cmNlSWRdKSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBmZXRjaFNvdXJjZShzb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXh0U291cmNlc1tzb3VyY2VJZF0gPSBzb3VyY2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5leHRTb3VyY2VzO1xufVxuZnVuY3Rpb24gZmV0Y2hTb3VyY2UoZXZlbnRTb3VyY2UsIGZldGNoUmFuZ2UsIGlzUmVmZXRjaCwgY29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgdmFyIHNvdXJjZURlZiA9IGNvbnRleHQucGx1Z2luSG9va3MuZXZlbnRTb3VyY2VEZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXTtcbiAgICB2YXIgZmV0Y2hJZCA9IGd1aWQoKTtcbiAgICBzb3VyY2VEZWYuZmV0Y2goe1xuICAgICAgICBldmVudFNvdXJjZTogZXZlbnRTb3VyY2UsXG4gICAgICAgIHJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICBpc1JlZmV0Y2g6IGlzUmVmZXRjaCxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICB9LCBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHZhciByYXdFdmVudHMgPSByZXMucmF3RXZlbnRzO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZVN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIHJhd0V2ZW50cyA9IG9wdGlvbnMuZXZlbnRTb3VyY2VTdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnhocikgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFNvdXJjZS5zdWNjZXNzKSB7XG4gICAgICAgICAgICByYXdFdmVudHMgPSBldmVudFNvdXJjZS5zdWNjZXNzLmNhbGwoY2FsZW5kYXJBcGksIHJhd0V2ZW50cywgcmVzLnhocikgfHwgcmF3RXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFQ0VJVkVfRVZFTlRTJyxcbiAgICAgICAgICAgIHNvdXJjZUlkOiBldmVudFNvdXJjZS5zb3VyY2VJZCxcbiAgICAgICAgICAgIGZldGNoSWQ6IGZldGNoSWQsXG4gICAgICAgICAgICBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlLFxuICAgICAgICAgICAgcmF3RXZlbnRzOiByYXdFdmVudHMsXG4gICAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oZXJyb3IubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICBpZiAob3B0aW9ucy5ldmVudFNvdXJjZUZhaWx1cmUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXZlbnRTb3VyY2VGYWlsdXJlLmNhbGwoY2FsZW5kYXJBcGksIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnRTb3VyY2UuZmFpbHVyZSkge1xuICAgICAgICAgICAgZXZlbnRTb3VyY2UuZmFpbHVyZShlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5kaXNwYXRjaCh7XG4gICAgICAgICAgICB0eXBlOiAnUkVDRUlWRV9FVkVOVF9FUlJPUicsXG4gICAgICAgICAgICBzb3VyY2VJZDogZXZlbnRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgICAgICBmZXRjaElkOiBmZXRjaElkLFxuICAgICAgICAgICAgZmV0Y2hSYW5nZTogZmV0Y2hSYW5nZSxcbiAgICAgICAgICAgIGVycm9yOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBldmVudFNvdXJjZSksIHsgaXNGZXRjaGluZzogdHJ1ZSwgbGF0ZXN0RmV0Y2hJZDogZmV0Y2hJZCB9KTtcbn1cbmZ1bmN0aW9uIHJlY2VpdmVSZXNwb25zZShzb3VyY2VIYXNoLCBzb3VyY2VJZCwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgZXZlbnRTb3VyY2UgPSBzb3VyY2VIYXNoW3NvdXJjZUlkXTtcbiAgICBpZiAoZXZlbnRTb3VyY2UgJiYgLy8gbm90IGFscmVhZHkgcmVtb3ZlZFxuICAgICAgICBmZXRjaElkID09PSBldmVudFNvdXJjZS5sYXRlc3RGZXRjaElkKSB7XG4gICAgICAgIHJldHVybiB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgc291cmNlSGFzaCksIChfYSA9IHt9LCBfYVtzb3VyY2VJZF0gPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZXZlbnRTb3VyY2UpLCB7IGlzRmV0Y2hpbmc6IGZhbHNlLCBmZXRjaFJhbmdlOiBmZXRjaFJhbmdlIH0pLCBfYSkpO1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlSGFzaDtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVTdGF0aWNTb3VyY2VzKGV2ZW50U291cmNlcywgY29udGV4dCkge1xuICAgIHJldHVybiBmaWx0ZXJIYXNoKGV2ZW50U291cmNlcywgZnVuY3Rpb24gKGV2ZW50U291cmNlKSB7IHJldHVybiBkb2VzU291cmNlTmVlZFJhbmdlKGV2ZW50U291cmNlLCBjb250ZXh0KTsgfSk7XG59XG5mdW5jdGlvbiBwYXJzZUluaXRpYWxTb3VyY2VzKHJhd09wdGlvbnMsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVmaW5lcnMgPSBidWlsZEV2ZW50U291cmNlUmVmaW5lcnMoY29udGV4dCk7XG4gICAgdmFyIHJhd1NvdXJjZXMgPSBbXS5jb25jYXQocmF3T3B0aW9ucy5ldmVudFNvdXJjZXMgfHwgW10pO1xuICAgIHZhciBzb3VyY2VzID0gW107IC8vIHBhcnNlZFxuICAgIGlmIChyYXdPcHRpb25zLmluaXRpYWxFdmVudHMpIHtcbiAgICAgICAgcmF3U291cmNlcy51bnNoaWZ0KHJhd09wdGlvbnMuaW5pdGlhbEV2ZW50cyk7XG4gICAgfVxuICAgIGlmIChyYXdPcHRpb25zLmV2ZW50cykge1xuICAgICAgICByYXdTb3VyY2VzLnVuc2hpZnQocmF3T3B0aW9ucy5ldmVudHMpO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHJhd1NvdXJjZXNfMSA9IHJhd1NvdXJjZXM7IF9pIDwgcmF3U291cmNlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmF3U291cmNlID0gcmF3U291cmNlc18xW19pXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHBhcnNlRXZlbnRTb3VyY2UocmF3U291cmNlLCBjb250ZXh0LCByZWZpbmVycyk7XG4gICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIHNvdXJjZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VzO1xufVxuZnVuY3Rpb24gZG9lc1NvdXJjZU5lZWRSYW5nZShldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciBkZWZzID0gY29udGV4dC5wbHVnaW5Ib29rcy5ldmVudFNvdXJjZURlZnM7XG4gICAgcmV0dXJuICFkZWZzW2V2ZW50U291cmNlLnNvdXJjZURlZklkXS5pZ25vcmVSYW5nZTtcbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRTdG9yZShldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1JFQ0VJVkVfRVZFTlRTJzogLy8gcmF3XG4gICAgICAgICAgICByZXR1cm4gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZXNbYWN0aW9uLnNvdXJjZUlkXSwgYWN0aW9uLmZldGNoSWQsIGFjdGlvbi5mZXRjaFJhbmdlLCBhY3Rpb24ucmF3RXZlbnRzLCBjb250ZXh0KTtcbiAgICAgICAgY2FzZSAnQUREX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkLCBidXQgbm90IGV4cGFuZGVkXG4gICAgICAgICAgICByZXR1cm4gYWRkRXZlbnQoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUsIC8vIG5ldyBvbmVzXG4gICAgICAgICAgICBkYXRlUHJvZmlsZSA/IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlIDogbnVsbCwgY29udGV4dCk7XG4gICAgICAgIGNhc2UgJ1JFU0VUX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmV2ZW50U3RvcmU7XG4gICAgICAgIGNhc2UgJ01FUkdFX0VWRU5UUyc6IC8vIGFscmVhZHkgcGFyc2VkIGFuZCBleHBhbmRlZFxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdQUkVWJzogLy8gVE9ETzogaG93IGRvIHdlIHRyYWNrIGFsbCBhY3Rpb25zIHRoYXQgYWZmZWN0IGRhdGVQcm9maWxlIDooXG4gICAgICAgIGNhc2UgJ05FWFQnOlxuICAgICAgICBjYXNlICdDSEFOR0VfREFURSc6XG4gICAgICAgIGNhc2UgJ0NIQU5HRV9WSUVXX1RZUEUnOlxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJlY3VycmluZyhldmVudFN0b3JlLCBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRTdG9yZTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0VWRU5UUyc6XG4gICAgICAgICAgICByZXR1cm4gZXhjbHVkZVN1YkV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgYWN0aW9uLmV2ZW50U3RvcmUpO1xuICAgICAgICBjYXNlICdSRU1PVkVfRVZFTlRfU09VUkNFJzpcbiAgICAgICAgICAgIHJldHVybiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBhY3Rpb24uc291cmNlSWQpO1xuICAgICAgICBjYXNlICdSRU1PVkVfQUxMX0VWRU5UX1NPVVJDRVMnOlxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlckV2ZW50U3RvcmVEZWZzKGV2ZW50U3RvcmUsIGZ1bmN0aW9uIChldmVudERlZikgeyByZXR1cm4gKCFldmVudERlZi5zb3VyY2VJZCAvLyBvbmx5IGtlZXAgZXZlbnRzIHdpdGggbm8gc291cmNlIGlkXG4gICAgICAgICAgICApOyB9KTtcbiAgICAgICAgY2FzZSAnUkVNT1ZFX0FMTF9FVkVOVFMnOlxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUVtcHR5RXZlbnRTdG9yZSgpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmU7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVjZWl2ZVJhd0V2ZW50cyhldmVudFN0b3JlLCBldmVudFNvdXJjZSwgZmV0Y2hJZCwgZmV0Y2hSYW5nZSwgcmF3RXZlbnRzLCBjb250ZXh0KSB7XG4gICAgaWYgKGV2ZW50U291cmNlICYmIC8vIG5vdCBhbHJlYWR5IHJlbW92ZWRcbiAgICAgICAgZmV0Y2hJZCA9PT0gZXZlbnRTb3VyY2UubGF0ZXN0RmV0Y2hJZCAvLyBUT0RPOiB3aXNoIHRoaXMgbG9naWMgd2FzIGFsd2F5cyBpbiBldmVudC1zb3VyY2VzXG4gICAgKSB7XG4gICAgICAgIHZhciBzdWJzZXQgPSBwYXJzZUV2ZW50cyh0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCksIGV2ZW50U291cmNlLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKGZldGNoUmFuZ2UpIHtcbiAgICAgICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGZldGNoUmFuZ2UsIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZUV2ZW50U3RvcmVzKGV4Y2x1ZGVFdmVudHNCeVNvdXJjZUlkKGV2ZW50U3RvcmUsIGV2ZW50U291cmNlLnNvdXJjZUlkKSwgc3Vic2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV2ZW50U3RvcmU7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1SYXdFdmVudHMocmF3RXZlbnRzLCBldmVudFNvdXJjZSwgY29udGV4dCkge1xuICAgIHZhciBjYWxFYWNoVHJhbnNmb3JtID0gY29udGV4dC5vcHRpb25zLmV2ZW50RGF0YVRyYW5zZm9ybTtcbiAgICB2YXIgc291cmNlRWFjaFRyYW5zZm9ybSA9IGV2ZW50U291cmNlID8gZXZlbnRTb3VyY2UuZXZlbnREYXRhVHJhbnNmb3JtIDogbnVsbDtcbiAgICBpZiAoc291cmNlRWFjaFRyYW5zZm9ybSkge1xuICAgICAgICByYXdFdmVudHMgPSB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBzb3VyY2VFYWNoVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKGNhbEVhY2hUcmFuc2Zvcm0pIHtcbiAgICAgICAgcmF3RXZlbnRzID0gdHJhbnNmb3JtRWFjaFJhd0V2ZW50KHJhd0V2ZW50cywgY2FsRWFjaFRyYW5zZm9ybSk7XG4gICAgfVxuICAgIHJldHVybiByYXdFdmVudHM7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1FYWNoUmF3RXZlbnQocmF3RXZlbnRzLCBmdW5jKSB7XG4gICAgdmFyIHJlZmluZWRFdmVudHM7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIHJlZmluZWRFdmVudHMgPSByYXdFdmVudHM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZWZpbmVkRXZlbnRzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmF3RXZlbnRzXzEgPSByYXdFdmVudHM7IF9pIDwgcmF3RXZlbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmF3RXZlbnQgPSByYXdFdmVudHNfMVtfaV07XG4gICAgICAgICAgICB2YXIgcmVmaW5lZEV2ZW50ID0gZnVuYyhyYXdFdmVudCk7XG4gICAgICAgICAgICBpZiAocmVmaW5lZEV2ZW50KSB7XG4gICAgICAgICAgICAgICAgcmVmaW5lZEV2ZW50cy5wdXNoKHJlZmluZWRFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZWZpbmVkRXZlbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRFdmVudHMucHVzaChyYXdFdmVudCk7XG4gICAgICAgICAgICB9IC8vIGlmIGEgZGlmZmVyZW50IGZhbHN5IHZhbHVlLCBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlZmluZWRFdmVudHM7XG59XG5mdW5jdGlvbiBhZGRFdmVudChldmVudFN0b3JlLCBzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KSB7XG4gICAgaWYgKGV4cGFuZFJhbmdlKSB7XG4gICAgICAgIHN1YnNldCA9IGV4cGFuZFJlY3VycmluZyhzdWJzZXQsIGV4cGFuZFJhbmdlLCBjb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRXZlbnRTdG9yZXMoZXZlbnRTdG9yZSwgc3Vic2V0KTtcbn1cbmZ1bmN0aW9uIHJlem9uZUV2ZW50U3RvcmVEYXRlcyhldmVudFN0b3JlLCBvbGREYXRlRW52LCBuZXdEYXRlRW52KSB7XG4gICAgdmFyIGRlZnMgPSBldmVudFN0b3JlLmRlZnM7XG4gICAgdmFyIGluc3RhbmNlcyA9IG1hcEhhc2goZXZlbnRTdG9yZS5pbnN0YW5jZXMsIGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICB2YXIgZGVmID0gZGVmc1tpbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIGlmIChkZWYuYWxsRGF5IHx8IGRlZi5yZWN1cnJpbmdEZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTsgLy8gaXNuJ3QgZGVwZW5kZW50IG9uIHRpbWV6b25lXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBpbnN0YW5jZSksIHsgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICBzdGFydDogbmV3RGF0ZUVudi5jcmVhdGVNYXJrZXIob2xkRGF0ZUVudi50b0RhdGUoaW5zdGFuY2UucmFuZ2Uuc3RhcnQsIGluc3RhbmNlLmZvcmNlZFN0YXJ0VHpvKSksXG4gICAgICAgICAgICAgICAgZW5kOiBuZXdEYXRlRW52LmNyZWF0ZU1hcmtlcihvbGREYXRlRW52LnRvRGF0ZShpbnN0YW5jZS5yYW5nZS5lbmQsIGluc3RhbmNlLmZvcmNlZEVuZFR6bykpLFxuICAgICAgICAgICAgfSwgZm9yY2VkU3RhcnRUem86IG5ld0RhdGVFbnYuY2FuQ29tcHV0ZU9mZnNldCA/IG51bGwgOiBpbnN0YW5jZS5mb3JjZWRTdGFydFR6bywgZm9yY2VkRW5kVHpvOiBuZXdEYXRlRW52LmNhbkNvbXB1dGVPZmZzZXQgPyBudWxsIDogaW5zdGFuY2UuZm9yY2VkRW5kVHpvIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGRlZnM6IGRlZnMsIGluc3RhbmNlczogaW5zdGFuY2VzIH07XG59XG5mdW5jdGlvbiBleGNsdWRlRXZlbnRzQnlTb3VyY2VJZChldmVudFN0b3JlLCBzb3VyY2VJZCkge1xuICAgIHJldHVybiBmaWx0ZXJFdmVudFN0b3JlRGVmcyhldmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIGV2ZW50RGVmLnNvdXJjZUlkICE9PSBzb3VyY2VJZDsgfSk7XG59XG4vLyBRVUVTVElPTjogd2h5IG5vdCBqdXN0IHJldHVybiBpbnN0YW5jZXM/IGRvIGEgZ2VuZXJhbCBvYmplY3QtcHJvcGVydHktZXhjbHVzaW9uIHV0aWxcbmZ1bmN0aW9uIGV4Y2x1ZGVJbnN0YW5jZXMoZXZlbnRTdG9yZSwgcmVtb3ZhbHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBkZWZzOiBldmVudFN0b3JlLmRlZnMsXG4gICAgICAgIGluc3RhbmNlczogZmlsdGVySGFzaChldmVudFN0b3JlLmluc3RhbmNlcywgZnVuY3Rpb24gKGluc3RhbmNlKSB7IHJldHVybiAhcmVtb3ZhbHNbaW5zdGFuY2UuaW5zdGFuY2VJZF07IH0pLFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlZHVjZURhdGVTZWxlY3Rpb24oY3VycmVudFNlbGVjdGlvbiwgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlICdVTlNFTEVDVF9EQVRFUyc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VMRUNUX0RBVEVTJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uc2VsZWN0aW9uO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRTZWxlY3Rpb247XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWR1Y2VTZWxlY3RlZEV2ZW50KGN1cnJlbnRJbnN0YW5jZUlkLCBhY3Rpb24pIHtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY2FzZSAnU0VMRUNUX0VWRU5UJzpcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb24uZXZlbnRJbnN0YW5jZUlkO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRJbnN0YW5jZUlkO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnREcmFnKGN1cnJlbnREcmFnLCBhY3Rpb24pIHtcbiAgICB2YXIgbmV3RHJhZztcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX0RSQUcnOlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIGNhc2UgJ1NFVF9FVkVOVF9EUkFHJzpcbiAgICAgICAgICAgIG5ld0RyYWcgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdEcmFnLmFmZmVjdGVkRXZlbnRzLFxuICAgICAgICAgICAgICAgIG11dGF0ZWRFdmVudHM6IG5ld0RyYWcubXV0YXRlZEV2ZW50cyxcbiAgICAgICAgICAgICAgICBpc0V2ZW50OiBuZXdEcmFnLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREcmFnO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcmVkdWNlRXZlbnRSZXNpemUoY3VycmVudFJlc2l6ZSwgYWN0aW9uKSB7XG4gICAgdmFyIG5ld1Jlc2l6ZTtcbiAgICBzd2l0Y2ggKGFjdGlvbi50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1VOU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgY2FzZSAnU0VUX0VWRU5UX1JFU0laRSc6XG4gICAgICAgICAgICBuZXdSZXNpemUgPSBhY3Rpb24uc3RhdGU7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGFmZmVjdGVkRXZlbnRzOiBuZXdSZXNpemUuYWZmZWN0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgbXV0YXRlZEV2ZW50czogbmV3UmVzaXplLm11dGF0ZWRFdmVudHMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogbmV3UmVzaXplLmlzRXZlbnQsXG4gICAgICAgICAgICB9O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRSZXNpemU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVRvb2xiYXJzKGNhbGVuZGFyT3B0aW9ucywgY2FsZW5kYXJPcHRpb25PdmVycmlkZXMsIHRoZW1lLCB2aWV3U3BlY3MsIGNhbGVuZGFyQXBpKSB7XG4gICAgdmFyIGhlYWRlciA9IGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyID8gcGFyc2VUb29sYmFyKGNhbGVuZGFyT3B0aW9ucy5oZWFkZXJUb29sYmFyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSkgOiBudWxsO1xuICAgIHZhciBmb290ZXIgPSBjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciA/IHBhcnNlVG9vbGJhcihjYWxlbmRhck9wdGlvbnMuZm9vdGVyVG9vbGJhciwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIDogbnVsbDtcbiAgICByZXR1cm4geyBoZWFkZXI6IGhlYWRlciwgZm9vdGVyOiBmb290ZXIgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlVG9vbGJhcihzZWN0aW9uU3RySGFzaCwgY2FsZW5kYXJPcHRpb25zLCBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcywgdGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgc2VjdGlvbldpZGdldHMgPSB7fTtcbiAgICB2YXIgdmlld3NXaXRoQnV0dG9ucyA9IFtdO1xuICAgIHZhciBoYXNUaXRsZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHNlY3Rpb25OYW1lIGluIHNlY3Rpb25TdHJIYXNoKSB7XG4gICAgICAgIHZhciBzZWN0aW9uU3RyID0gc2VjdGlvblN0ckhhc2hbc2VjdGlvbk5hbWVdO1xuICAgICAgICB2YXIgc2VjdGlvblJlcyA9IHBhcnNlU2VjdGlvbihzZWN0aW9uU3RyLCBjYWxlbmRhck9wdGlvbnMsIGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHNlY3Rpb25XaWRnZXRzW3NlY3Rpb25OYW1lXSA9IHNlY3Rpb25SZXMud2lkZ2V0cztcbiAgICAgICAgdmlld3NXaXRoQnV0dG9ucy5wdXNoLmFwcGx5KHZpZXdzV2l0aEJ1dHRvbnMsIHNlY3Rpb25SZXMudmlld3NXaXRoQnV0dG9ucyk7XG4gICAgICAgIGhhc1RpdGxlID0gaGFzVGl0bGUgfHwgc2VjdGlvblJlcy5oYXNUaXRsZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc2VjdGlvbldpZGdldHM6IHNlY3Rpb25XaWRnZXRzLCB2aWV3c1dpdGhCdXR0b25zOiB2aWV3c1dpdGhCdXR0b25zLCBoYXNUaXRsZTogaGFzVGl0bGUgfTtcbn1cbi8qXG5CQUQ6IHF1ZXJ5aW5nIGljb25zIGFuZCB0ZXh0IGhlcmUuIHNob3VsZCBiZSBkb25lIGF0IHJlbmRlciB0aW1lXG4qL1xuZnVuY3Rpb24gcGFyc2VTZWN0aW9uKHNlY3Rpb25TdHIsIGNhbGVuZGFyT3B0aW9ucywgLy8gZGVmYXVsdHMrb3ZlcnJpZGVzLCB0aGVuIHJlZmluZWRcbmNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLCAvLyBvdmVycmlkZXMgb25seSEsIHVucmVmaW5lZCA6KFxudGhlbWUsIHZpZXdTcGVjcywgY2FsZW5kYXJBcGkpIHtcbiAgICB2YXIgaXNSdGwgPSBjYWxlbmRhck9wdGlvbnMuZGlyZWN0aW9uID09PSAncnRsJztcbiAgICB2YXIgY2FsZW5kYXJDdXN0b21CdXR0b25zID0gY2FsZW5kYXJPcHRpb25zLmN1c3RvbUJ1dHRvbnMgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyA9IGNhbGVuZGFyT3B0aW9uT3ZlcnJpZGVzLmJ1dHRvblRleHQgfHwge307XG4gICAgdmFyIGNhbGVuZGFyQnV0dG9uVGV4dCA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25UZXh0IHx8IHt9O1xuICAgIHZhciBjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXMgPSBjYWxlbmRhck9wdGlvbk92ZXJyaWRlcy5idXR0b25IaW50cyB8fCB7fTtcbiAgICB2YXIgY2FsZW5kYXJCdXR0b25IaW50cyA9IGNhbGVuZGFyT3B0aW9ucy5idXR0b25IaW50cyB8fCB7fTtcbiAgICB2YXIgc2VjdGlvblN1YnN0cnMgPSBzZWN0aW9uU3RyID8gc2VjdGlvblN0ci5zcGxpdCgnICcpIDogW107XG4gICAgdmFyIHZpZXdzV2l0aEJ1dHRvbnMgPSBbXTtcbiAgICB2YXIgaGFzVGl0bGUgPSBmYWxzZTtcbiAgICB2YXIgd2lkZ2V0cyA9IHNlY3Rpb25TdWJzdHJzLm1hcChmdW5jdGlvbiAoYnV0dG9uR3JvdXBTdHIpIHsgcmV0dXJuIChidXR0b25Hcm91cFN0ci5zcGxpdCgnLCcpLm1hcChmdW5jdGlvbiAoYnV0dG9uTmFtZSkge1xuICAgICAgICBpZiAoYnV0dG9uTmFtZSA9PT0gJ3RpdGxlJykge1xuICAgICAgICAgICAgaGFzVGl0bGUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgYnV0dG9uTmFtZTogYnV0dG9uTmFtZSB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXN0b21CdXR0b25Qcm9wcztcbiAgICAgICAgdmFyIHZpZXdTcGVjO1xuICAgICAgICB2YXIgYnV0dG9uQ2xpY2s7XG4gICAgICAgIHZhciBidXR0b25JY29uOyAvLyBvbmx5IG9uZSBvZiB0aGVzZSB3aWxsIGJlIHNldFxuICAgICAgICB2YXIgYnV0dG9uVGV4dDsgLy8gXCJcbiAgICAgICAgdmFyIGJ1dHRvbkhpbnQ7XG4gICAgICAgIC8vIF4gZm9yIHRoZSB0aXRsZT1cIlwiIGF0dHJpYnV0ZSwgZm9yIGFjY2Vzc2liaWxpdHlcbiAgICAgICAgaWYgKChjdXN0b21CdXR0b25Qcm9wcyA9IGNhbGVuZGFyQ3VzdG9tQnV0dG9uc1tidXR0b25OYW1lXSkpIHtcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUJ1dHRvblByb3BzLmNsaWNrLmNhbGwoZXYudGFyZ2V0LCBldiwgZXYudGFyZ2V0KTsgLy8gVE9ETzogdXNlIENhbGVuZGFyIHRoaXMgY29udGV4dD9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRDdXN0b21CdXR0b25JY29uQ2xhc3MoY3VzdG9tQnV0dG9uUHJvcHMpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IGN1c3RvbUJ1dHRvblByb3BzLnRleHQpO1xuICAgICAgICAgICAgYnV0dG9uSGludCA9IGN1c3RvbUJ1dHRvblByb3BzLmhpbnQgfHwgY3VzdG9tQnV0dG9uUHJvcHMudGV4dDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgodmlld1NwZWMgPSB2aWV3U3BlY3NbYnV0dG9uTmFtZV0pKSB7XG4gICAgICAgICAgICB2aWV3c1dpdGhCdXR0b25zLnB1c2goYnV0dG9uTmFtZSk7XG4gICAgICAgICAgICBidXR0b25DbGljayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWxlbmRhckFwaS5jaGFuZ2VWaWV3KGJ1dHRvbk5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIChidXR0b25UZXh0ID0gdmlld1NwZWMuYnV0dG9uVGV4dE92ZXJyaWRlKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25JY29uID0gdGhlbWUuZ2V0SWNvbkNsYXNzKGJ1dHRvbk5hbWUsIGlzUnRsKSkgfHxcbiAgICAgICAgICAgICAgICAoYnV0dG9uVGV4dCA9IHZpZXdTcGVjLmJ1dHRvblRleHREZWZhdWx0KTtcbiAgICAgICAgICAgIHZhciB0ZXh0RmFsbGJhY2sgPSB2aWV3U3BlYy5idXR0b25UZXh0T3ZlcnJpZGUgfHxcbiAgICAgICAgICAgICAgICB2aWV3U3BlYy5idXR0b25UZXh0RGVmYXVsdDtcbiAgICAgICAgICAgIGJ1dHRvbkhpbnQgPSBmb3JtYXRXaXRoT3JkaW5hbHModmlld1NwZWMuYnV0dG9uVGl0bGVPdmVycmlkZSB8fFxuICAgICAgICAgICAgICAgIHZpZXdTcGVjLmJ1dHRvblRpdGxlRGVmYXVsdCB8fFxuICAgICAgICAgICAgICAgIGNhbGVuZGFyT3B0aW9ucy52aWV3SGludCwgW3RleHRGYWxsYmFjaywgYnV0dG9uTmFtZV0sIC8vIHZpZXctbmFtZSA9IGJ1dHRvbk5hbWVcbiAgICAgICAgICAgIHRleHRGYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2FsZW5kYXJBcGlbYnV0dG9uTmFtZV0pIHsgLy8gYSBjYWxlbmRhckFwaSBtZXRob2RcbiAgICAgICAgICAgIGJ1dHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGVuZGFyQXBpW2J1dHRvbk5hbWVdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgKGJ1dHRvblRleHQgPSBjYWxlbmRhckJ1dHRvblRleHRPdmVycmlkZXNbYnV0dG9uTmFtZV0pIHx8XG4gICAgICAgICAgICAgICAgKGJ1dHRvbkljb24gPSB0aGVtZS5nZXRJY29uQ2xhc3MoYnV0dG9uTmFtZSwgaXNSdGwpKSB8fFxuICAgICAgICAgICAgICAgIChidXR0b25UZXh0ID0gY2FsZW5kYXJCdXR0b25UZXh0W2J1dHRvbk5hbWVdKTsgLy8gZXZlcnl0aGluZyBlbHNlIGlzIGNvbnNpZGVyZWQgZGVmYXVsdFxuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICdwcmV2WWVhcicgfHwgYnV0dG9uTmFtZSA9PT0gJ25leHRZZWFyJykge1xuICAgICAgICAgICAgICAgIHZhciBwcmV2T3JOZXh0ID0gYnV0dG9uTmFtZSA9PT0gJ3ByZXZZZWFyJyA/ICdwcmV2JyA6ICduZXh0JztcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZm9ybWF0V2l0aE9yZGluYWxzKGNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlc1twcmV2T3JOZXh0XSB8fFxuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvbkhpbnRzW3ByZXZPck5leHRdLCBbXG4gICAgICAgICAgICAgICAgICAgIGNhbGVuZGFyQnV0dG9uVGV4dC55ZWFyIHx8ICd5ZWFyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3llYXInLFxuICAgICAgICAgICAgICAgIF0sIGNhbGVuZGFyQnV0dG9uVGV4dFtidXR0b25OYW1lXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b25IaW50ID0gZnVuY3Rpb24gKG5hdlVuaXQpIHsgcmV0dXJuIGZvcm1hdFdpdGhPcmRpbmFscyhjYWxlbmRhckJ1dHRvbkhpbnRPdmVycmlkZXNbYnV0dG9uTmFtZV0gfHxcbiAgICAgICAgICAgICAgICAgICAgY2FsZW5kYXJCdXR0b25IaW50c1tidXR0b25OYW1lXSwgW1xuICAgICAgICAgICAgICAgICAgICBjYWxlbmRhckJ1dHRvblRleHRbbmF2VW5pdF0gfHwgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICAgICAgbmF2VW5pdCxcbiAgICAgICAgICAgICAgICBdLCBjYWxlbmRhckJ1dHRvblRleHRbYnV0dG9uTmFtZV0pOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ1dHRvbk5hbWU6IGJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrOiBidXR0b25DbGljaywgYnV0dG9uSWNvbjogYnV0dG9uSWNvbiwgYnV0dG9uVGV4dDogYnV0dG9uVGV4dCwgYnV0dG9uSGludDogYnV0dG9uSGludCB9O1xuICAgIH0pKTsgfSk7XG4gICAgcmV0dXJuIHsgd2lkZ2V0czogd2lkZ2V0cywgdmlld3NXaXRoQnV0dG9uczogdmlld3NXaXRoQnV0dG9ucywgaGFzVGl0bGU6IGhhc1RpdGxlIH07XG59XG5cbnZhciBldmVudFNvdXJjZURlZiQyID0ge1xuICAgIGlnbm9yZVJhbmdlOiB0cnVlLFxuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVmaW5lZC5ldmVudHMpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVmaW5lZC5ldmVudHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2Vzcykge1xuICAgICAgICBzdWNjZXNzKHtcbiAgICAgICAgICAgIHJhd0V2ZW50czogYXJnLmV2ZW50U291cmNlLm1ldGEsXG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xudmFyIGFycmF5RXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlRGVmczogW2V2ZW50U291cmNlRGVmJDJdLFxufSk7XG5cbnZhciBldmVudFNvdXJjZURlZiQxID0ge1xuICAgIHBhcnNlTWV0YTogZnVuY3Rpb24gKHJlZmluZWQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZWZpbmVkLmV2ZW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIHJlZmluZWQuZXZlbnRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZmV0Y2g6IGZ1bmN0aW9uIChhcmcsIHN1Y2Nlc3MsIGZhaWx1cmUpIHtcbiAgICAgICAgdmFyIGRhdGVFbnYgPSBhcmcuY29udGV4dC5kYXRlRW52O1xuICAgICAgICB2YXIgZnVuYyA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB1bnByb21pc2lmeShmdW5jLmJpbmQobnVsbCwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShhcmcucmFuZ2UsIGRhdGVFbnYpKSwgZnVuY3Rpb24gKHJhd0V2ZW50cykge1xuICAgICAgICAgICAgc3VjY2Vzcyh7IHJhd0V2ZW50czogcmF3RXZlbnRzIH0pOyAvLyBuZWVkcyBhbiBvYmplY3QgcmVzcG9uc2VcbiAgICAgICAgfSwgZmFpbHVyZSk7XG4gICAgfSxcbn07XG52YXIgZnVuY0V2ZW50U291cmNlUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBldmVudFNvdXJjZURlZnM6IFtldmVudFNvdXJjZURlZiQxXSxcbn0pO1xuXG5mdW5jdGlvbiByZXF1ZXN0SnNvbihtZXRob2QsIHVybCwgcGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgIHZhciBib2R5ID0gbnVsbDtcbiAgICBpZiAobWV0aG9kID09PSAnR0VUJykge1xuICAgICAgICB1cmwgPSBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBib2R5ID0gZW5jb2RlUGFyYW1zKHBhcmFtcyk7XG4gICAgfVxuICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB4aHIub3BlbihtZXRob2QsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKG1ldGhvZCAhPT0gJ0dFVCcpIHtcbiAgICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoJ0NvbnRlbnQtVHlwZScsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnKTtcbiAgICB9XG4gICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHhoci5zdGF0dXMgPj0gMjAwICYmIHhoci5zdGF0dXMgPCA0MDApIHtcbiAgICAgICAgICAgIHZhciBwYXJzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciByZXMgPSB2b2lkIDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJlcyA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB3aWxsIGhhbmRsZSBwYXJzZWQ9ZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2socmVzLCB4aHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmFpbHVyZUNhbGxiYWNrKCdGYWlsdXJlIHBhcnNpbmcgSlNPTicsIHhocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmYWlsdXJlQ2FsbGJhY2soJ1JlcXVlc3QgZmFpbGVkJywgeGhyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZhaWx1cmVDYWxsYmFjaygnUmVxdWVzdCBmYWlsZWQnLCB4aHIpO1xuICAgIH07XG4gICAgeGhyLnNlbmQoYm9keSk7XG59XG5mdW5jdGlvbiBpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyh1cmwsIHBhcmFtcykge1xuICAgIHJldHVybiB1cmwgK1xuICAgICAgICAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICtcbiAgICAgICAgZW5jb2RlUGFyYW1zKHBhcmFtcyk7XG59XG5mdW5jdGlvbiBlbmNvZGVQYXJhbXMocGFyYW1zKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIHBhcmFtcykge1xuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocGFyYW1zW2tleV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJyYnKTtcbn1cblxudmFyIEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMgPSB7XG4gICAgbWV0aG9kOiBTdHJpbmcsXG4gICAgZXh0cmFQYXJhbXM6IGlkZW50aXR5LFxuICAgIHN0YXJ0UGFyYW06IFN0cmluZyxcbiAgICBlbmRQYXJhbTogU3RyaW5nLFxuICAgIHRpbWVab25lUGFyYW06IFN0cmluZyxcbn07XG5cbnZhciBldmVudFNvdXJjZURlZiA9IHtcbiAgICBwYXJzZU1ldGE6IGZ1bmN0aW9uIChyZWZpbmVkKSB7XG4gICAgICAgIGlmIChyZWZpbmVkLnVybCAmJiAocmVmaW5lZC5mb3JtYXQgPT09ICdqc29uJyB8fCAhcmVmaW5lZC5mb3JtYXQpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVybDogcmVmaW5lZC51cmwsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiAnanNvbicsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAocmVmaW5lZC5tZXRob2QgfHwgJ0dFVCcpLnRvVXBwZXJDYXNlKCksXG4gICAgICAgICAgICAgICAgZXh0cmFQYXJhbXM6IHJlZmluZWQuZXh0cmFQYXJhbXMsXG4gICAgICAgICAgICAgICAgc3RhcnRQYXJhbTogcmVmaW5lZC5zdGFydFBhcmFtLFxuICAgICAgICAgICAgICAgIGVuZFBhcmFtOiByZWZpbmVkLmVuZFBhcmFtLFxuICAgICAgICAgICAgICAgIHRpbWVab25lUGFyYW06IHJlZmluZWQudGltZVpvbmVQYXJhbSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBmZXRjaDogZnVuY3Rpb24gKGFyZywgc3VjY2VzcywgZmFpbHVyZSkge1xuICAgICAgICB2YXIgbWV0YSA9IGFyZy5ldmVudFNvdXJjZS5tZXRhO1xuICAgICAgICB2YXIgcmVxdWVzdFBhcmFtcyA9IGJ1aWxkUmVxdWVzdFBhcmFtcyhtZXRhLCBhcmcucmFuZ2UsIGFyZy5jb250ZXh0KTtcbiAgICAgICAgcmVxdWVzdEpzb24obWV0YS5tZXRob2QsIG1ldGEudXJsLCByZXF1ZXN0UGFyYW1zLCBmdW5jdGlvbiAocmF3RXZlbnRzLCB4aHIpIHtcbiAgICAgICAgICAgIHN1Y2Nlc3MoeyByYXdFdmVudHM6IHJhd0V2ZW50cywgeGhyOiB4aHIgfSk7XG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvck1lc3NhZ2UsIHhocikge1xuICAgICAgICAgICAgZmFpbHVyZSh7IG1lc3NhZ2U6IGVycm9yTWVzc2FnZSwgeGhyOiB4aHIgfSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xudmFyIGpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIGV2ZW50U291cmNlUmVmaW5lcnM6IEpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMsXG4gICAgZXZlbnRTb3VyY2VEZWZzOiBbZXZlbnRTb3VyY2VEZWZdLFxufSk7XG5mdW5jdGlvbiBidWlsZFJlcXVlc3RQYXJhbXMobWV0YSwgcmFuZ2UsIGNvbnRleHQpIHtcbiAgICB2YXIgZGF0ZUVudiA9IGNvbnRleHQuZGF0ZUVudiwgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICB2YXIgc3RhcnRQYXJhbTtcbiAgICB2YXIgZW5kUGFyYW07XG4gICAgdmFyIHRpbWVab25lUGFyYW07XG4gICAgdmFyIGN1c3RvbVJlcXVlc3RQYXJhbXM7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHN0YXJ0UGFyYW0gPSBtZXRhLnN0YXJ0UGFyYW07XG4gICAgaWYgKHN0YXJ0UGFyYW0gPT0gbnVsbCkge1xuICAgICAgICBzdGFydFBhcmFtID0gb3B0aW9ucy5zdGFydFBhcmFtO1xuICAgIH1cbiAgICBlbmRQYXJhbSA9IG1ldGEuZW5kUGFyYW07XG4gICAgaWYgKGVuZFBhcmFtID09IG51bGwpIHtcbiAgICAgICAgZW5kUGFyYW0gPSBvcHRpb25zLmVuZFBhcmFtO1xuICAgIH1cbiAgICB0aW1lWm9uZVBhcmFtID0gbWV0YS50aW1lWm9uZVBhcmFtO1xuICAgIGlmICh0aW1lWm9uZVBhcmFtID09IG51bGwpIHtcbiAgICAgICAgdGltZVpvbmVQYXJhbSA9IG9wdGlvbnMudGltZVpvbmVQYXJhbTtcbiAgICB9XG4gICAgLy8gcmV0cmlldmUgYW55IG91dGJvdW5kIEdFVC9QT1NUIGRhdGEgZnJvbSB0aGUgb3B0aW9uc1xuICAgIGlmICh0eXBlb2YgbWV0YS5leHRyYVBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBzdXBwbGllZCBhcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGtleS92YWx1ZSBvYmplY3RcbiAgICAgICAgY3VzdG9tUmVxdWVzdFBhcmFtcyA9IG1ldGEuZXh0cmFQYXJhbXMoKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIHByb2JhYmx5IHN1cHBsaWVkIGFzIGEgc3RyYWlnaHQga2V5L3ZhbHVlIG9iamVjdFxuICAgICAgICBjdXN0b21SZXF1ZXN0UGFyYW1zID0gbWV0YS5leHRyYVBhcmFtcyB8fCB7fTtcbiAgICB9XG4gICAgdHNsaWIuX19hc3NpZ24ocGFyYW1zLCBjdXN0b21SZXF1ZXN0UGFyYW1zKTtcbiAgICBwYXJhbXNbc3RhcnRQYXJhbV0gPSBkYXRlRW52LmZvcm1hdElzbyhyYW5nZS5zdGFydCk7XG4gICAgcGFyYW1zW2VuZFBhcmFtXSA9IGRhdGVFbnYuZm9ybWF0SXNvKHJhbmdlLmVuZCk7XG4gICAgaWYgKGRhdGVFbnYudGltZVpvbmUgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgcGFyYW1zW3RpbWVab25lUGFyYW1dID0gZGF0ZUVudi50aW1lWm9uZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cblxudmFyIFNJTVBMRV9SRUNVUlJJTkdfUkVGSU5FUlMgPSB7XG4gICAgZGF5c09mV2VlazogaWRlbnRpdHksXG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBlbmRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgc3RhcnRSZWN1cjogaWRlbnRpdHksXG4gICAgZW5kUmVjdXI6IGlkZW50aXR5LFxufTtcblxudmFyIHJlY3VycmluZyA9IHtcbiAgICBwYXJzZTogZnVuY3Rpb24gKHJlZmluZWQsIGRhdGVFbnYpIHtcbiAgICAgICAgaWYgKHJlZmluZWQuZGF5c09mV2VlayB8fCByZWZpbmVkLnN0YXJ0VGltZSB8fCByZWZpbmVkLmVuZFRpbWUgfHwgcmVmaW5lZC5zdGFydFJlY3VyIHx8IHJlZmluZWQuZW5kUmVjdXIpIHtcbiAgICAgICAgICAgIHZhciByZWN1cnJpbmdEYXRhID0ge1xuICAgICAgICAgICAgICAgIGRheXNPZldlZWs6IHJlZmluZWQuZGF5c09mV2VlayB8fCBudWxsLFxuICAgICAgICAgICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRUaW1lOiByZWZpbmVkLmVuZFRpbWUgfHwgbnVsbCxcbiAgICAgICAgICAgICAgICBzdGFydFJlY3VyOiByZWZpbmVkLnN0YXJ0UmVjdXIgPyBkYXRlRW52LmNyZWF0ZU1hcmtlcihyZWZpbmVkLnN0YXJ0UmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgICAgICBlbmRSZWN1cjogcmVmaW5lZC5lbmRSZWN1ciA/IGRhdGVFbnYuY3JlYXRlTWFya2VyKHJlZmluZWQuZW5kUmVjdXIpIDogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZHVyYXRpb24gPSB2b2lkIDA7XG4gICAgICAgICAgICBpZiAocmVmaW5lZC5kdXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gcmVmaW5lZC5kdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZHVyYXRpb24gJiYgcmVmaW5lZC5zdGFydFRpbWUgJiYgcmVmaW5lZC5lbmRUaW1lKSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBzdWJ0cmFjdER1cmF0aW9ucyhyZWZpbmVkLmVuZFRpbWUsIHJlZmluZWQuc3RhcnRUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWxsRGF5R3Vlc3M6IEJvb2xlYW4oIXJlZmluZWQuc3RhcnRUaW1lICYmICFyZWZpbmVkLmVuZFRpbWUpLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcbiAgICAgICAgICAgICAgICB0eXBlRGF0YTogcmVjdXJyaW5nRGF0YSwgLy8gZG9lc24ndCBuZWVkIGVuZFRpbWUgYW55bW9yZSBidXQgb2ggd2VsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIGV4cGFuZDogZnVuY3Rpb24gKHR5cGVEYXRhLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICAgICAgdmFyIGNsaXBwZWRGcmFtaW5nUmFuZ2UgPSBpbnRlcnNlY3RSYW5nZXMoZnJhbWluZ1JhbmdlLCB7IHN0YXJ0OiB0eXBlRGF0YS5zdGFydFJlY3VyLCBlbmQ6IHR5cGVEYXRhLmVuZFJlY3VyIH0pO1xuICAgICAgICBpZiAoY2xpcHBlZEZyYW1pbmdSYW5nZSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cGFuZFJhbmdlcyh0eXBlRGF0YS5kYXlzT2ZXZWVrLCB0eXBlRGF0YS5zdGFydFRpbWUsIGNsaXBwZWRGcmFtaW5nUmFuZ2UsIGRhdGVFbnYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxufTtcbnZhciBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4gPSBjcmVhdGVQbHVnaW4oe1xuICAgIHJlY3VycmluZ1R5cGVzOiBbcmVjdXJyaW5nXSxcbiAgICBldmVudFJlZmluZXJzOiBTSU1QTEVfUkVDVVJSSU5HX1JFRklORVJTLFxufSk7XG5mdW5jdGlvbiBleHBhbmRSYW5nZXMoZGF5c09mV2Vlaywgc3RhcnRUaW1lLCBmcmFtaW5nUmFuZ2UsIGRhdGVFbnYpIHtcbiAgICB2YXIgZG93SGFzaCA9IGRheXNPZldlZWsgPyBhcnJheVRvSGFzaChkYXlzT2ZXZWVrKSA6IG51bGw7XG4gICAgdmFyIGRheU1hcmtlciA9IHN0YXJ0T2ZEYXkoZnJhbWluZ1JhbmdlLnN0YXJ0KTtcbiAgICB2YXIgZW5kTWFya2VyID0gZnJhbWluZ1JhbmdlLmVuZDtcbiAgICB2YXIgaW5zdGFuY2VTdGFydHMgPSBbXTtcbiAgICB3aGlsZSAoZGF5TWFya2VyIDwgZW5kTWFya2VyKSB7XG4gICAgICAgIHZhciBpbnN0YW5jZVN0YXJ0IFxuICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG4gICAgICAgID0gdm9pZCAwO1xuICAgICAgICAvLyBpZiBldmVyeWRheSwgb3IgdGhpcyBwYXJ0aWN1bGFyIGRheS1vZi13ZWVrXG4gICAgICAgIGlmICghZG93SGFzaCB8fCBkb3dIYXNoW2RheU1hcmtlci5nZXRVVENEYXkoKV0pIHtcbiAgICAgICAgICAgIGlmIChzdGFydFRpbWUpIHtcbiAgICAgICAgICAgICAgICBpbnN0YW5jZVN0YXJ0ID0gZGF0ZUVudi5hZGQoZGF5TWFya2VyLCBzdGFydFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2VTdGFydCA9IGRheU1hcmtlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluc3RhbmNlU3RhcnRzLnB1c2goaW5zdGFuY2VTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF5TWFya2VyID0gYWRkRGF5cyhkYXlNYXJrZXIsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2VTdGFydHM7XG59XG5cbnZhciBjaGFuZ2VIYW5kbGVyUGx1Z2luID0gY3JlYXRlUGx1Z2luKHtcbiAgICBvcHRpb25DaGFuZ2VIYW5kbGVyczoge1xuICAgICAgICBldmVudHM6IGZ1bmN0aW9uIChldmVudHMsIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGhhbmRsZUV2ZW50U291cmNlcyhbZXZlbnRzXSwgY29udGV4dCk7XG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50U291cmNlczogaGFuZGxlRXZlbnRTb3VyY2VzLFxuICAgIH0sXG59KTtcbi8qXG5CVUc6IGlmIGBldmVudGAgd2FzIHN1cHBsaWVkLCBhbGwgcHJldmlvdXNseS1naXZlbiBgZXZlbnRTb3VyY2VzYCB3aWxsIGJlIHdpcGVkIG91dFxuKi9cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50U291cmNlcyhpbnB1dHMsIGNvbnRleHQpIHtcbiAgICB2YXIgdW5mb3VuZFNvdXJjZXMgPSBoYXNoVmFsdWVzVG9BcnJheShjb250ZXh0LmdldEN1cnJlbnREYXRhKCkuZXZlbnRTb3VyY2VzKTtcbiAgICB2YXIgbmV3SW5wdXRzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwLCBpbnB1dHNfMSA9IGlucHV0czsgX2kgPCBpbnB1dHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzXzFbX2ldO1xuICAgICAgICB2YXIgaW5wdXRGb3VuZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVuZm91bmRTb3VyY2VzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAodW5mb3VuZFNvdXJjZXNbaV0uX3JhdyA9PT0gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICB1bmZvdW5kU291cmNlcy5zcGxpY2UoaSwgMSk7IC8vIGRlbGV0ZVxuICAgICAgICAgICAgICAgIGlucHV0Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaW5wdXRGb3VuZCkge1xuICAgICAgICAgICAgbmV3SW5wdXRzLnB1c2goaW5wdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIF9hID0gMCwgdW5mb3VuZFNvdXJjZXNfMSA9IHVuZm91bmRTb3VyY2VzOyBfYSA8IHVuZm91bmRTb3VyY2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgIHZhciB1bmZvdW5kU291cmNlID0gdW5mb3VuZFNvdXJjZXNfMVtfYV07XG4gICAgICAgIGNvbnRleHQuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogJ1JFTU9WRV9FVkVOVF9TT1VSQ0UnLFxuICAgICAgICAgICAgc291cmNlSWQ6IHVuZm91bmRTb3VyY2Uuc291cmNlSWQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmb3IgKHZhciBfYiA9IDAsIG5ld0lucHV0c18xID0gbmV3SW5wdXRzOyBfYiA8IG5ld0lucHV0c18xLmxlbmd0aDsgX2IrKykge1xuICAgICAgICB2YXIgbmV3SW5wdXQgPSBuZXdJbnB1dHNfMVtfYl07XG4gICAgICAgIGNvbnRleHQuY2FsZW5kYXJBcGkuYWRkRXZlbnRTb3VyY2UobmV3SW5wdXQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICBjb250ZXh0LmVtaXR0ZXIudHJpZ2dlcignZGF0ZXNTZXQnLCB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgYnVpbGRSYW5nZUFwaVdpdGhUaW1lWm9uZShkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZSwgY29udGV4dC5kYXRlRW52KSksIHsgdmlldzogY29udGV4dC52aWV3QXBpIH0pKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRTdG9yZShldmVudFN0b3JlLCBjb250ZXh0KSB7XG4gICAgdmFyIGVtaXR0ZXIgPSBjb250ZXh0LmVtaXR0ZXI7XG4gICAgaWYgKGVtaXR0ZXIuaGFzSGFuZGxlcnMoJ2V2ZW50c1NldCcpKSB7XG4gICAgICAgIGVtaXR0ZXIudHJpZ2dlcignZXZlbnRzU2V0JywgYnVpbGRFdmVudEFwaXMoZXZlbnRTdG9yZSwgY29udGV4dCkpO1xuICAgIH1cbn1cblxuLypcbnRoaXMgYXJyYXkgaXMgZXhwb3NlZCBvbiB0aGUgcm9vdCBuYW1lc3BhY2Ugc28gdGhhdCBVTUQgcGx1Z2lucyBjYW4gYWRkIHRvIGl0Llxuc2VlIHRoZSByb2xsdXAtYnVuZGxlcyBzY3JpcHQuXG4qL1xudmFyIGdsb2JhbFBsdWdpbnMgPSBbXG4gICAgYXJyYXlFdmVudFNvdXJjZVBsdWdpbixcbiAgICBmdW5jRXZlbnRTb3VyY2VQbHVnaW4sXG4gICAganNvbkZlZWRFdmVudFNvdXJjZVBsdWdpbixcbiAgICBzaW1wbGVSZWN1cnJpbmdFdmVudHNQbHVnaW4sXG4gICAgY2hhbmdlSGFuZGxlclBsdWdpbixcbiAgICBjcmVhdGVQbHVnaW4oe1xuICAgICAgICBpc0xvYWRpbmdGdW5jczogW1xuICAgICAgICAgICAgZnVuY3Rpb24gKHN0YXRlKSB7IHJldHVybiBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhzdGF0ZS5ldmVudFNvdXJjZXMpOyB9LFxuICAgICAgICBdLFxuICAgICAgICBjb250ZW50VHlwZUhhbmRsZXJzOiB7XG4gICAgICAgICAgICBodG1sOiBidWlsZEh0bWxSZW5kZXJlcixcbiAgICAgICAgICAgIGRvbU5vZGVzOiBidWlsZERvbU5vZGVSZW5kZXJlcixcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcFNldEhhbmRsZXJzOiB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogaGFuZGxlRGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFN0b3JlOiBoYW5kbGVFdmVudFN0b3JlLFxuICAgICAgICB9LFxuICAgIH0pLFxuXTtcbmZ1bmN0aW9uIGJ1aWxkSHRtbFJlbmRlcmVyKCkge1xuICAgIHZhciBjdXJyZW50RWwgPSBudWxsO1xuICAgIHZhciBjdXJyZW50SHRtbCA9ICcnO1xuICAgIGZ1bmN0aW9uIHJlbmRlcihlbCwgaHRtbCkge1xuICAgICAgICBpZiAoZWwgIT09IGN1cnJlbnRFbCB8fCBodG1sICE9PSBjdXJyZW50SHRtbCkge1xuICAgICAgICAgICAgZWwuaW5uZXJIVE1MID0gaHRtbDtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50RWwgPSBlbDtcbiAgICAgICAgY3VycmVudEh0bWwgPSBodG1sO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBjdXJyZW50RWwuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGN1cnJlbnRFbCA9IG51bGw7XG4gICAgICAgIGN1cnJlbnRIdG1sID0gJyc7XG4gICAgfVxuICAgIHJldHVybiB7IHJlbmRlcjogcmVuZGVyLCBkZXN0cm95OiBkZXN0cm95IH07XG59XG5mdW5jdGlvbiBidWlsZERvbU5vZGVSZW5kZXJlcigpIHtcbiAgICB2YXIgY3VycmVudEVsID0gbnVsbDtcbiAgICB2YXIgY3VycmVudERvbU5vZGVzID0gW107XG4gICAgZnVuY3Rpb24gcmVuZGVyKGVsLCBkb21Ob2Rlcykge1xuICAgICAgICB2YXIgbmV3RG9tTm9kZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChkb21Ob2Rlcyk7XG4gICAgICAgIGlmIChlbCAhPT0gY3VycmVudEVsIHx8ICFpc0FycmF5c0VxdWFsKGN1cnJlbnREb21Ob2RlcywgbmV3RG9tTm9kZXMpKSB7XG4gICAgICAgICAgICAvLyBhcHBlbmQgZmlyc3QsIHJlbW92ZSBzZWNvbmQgKGZvciBzY3JvbGwgcmVzZXR0aW5nKVxuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBuZXdEb21Ob2Rlc18xID0gbmV3RG9tTm9kZXM7IF9pIDwgbmV3RG9tTm9kZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3Tm9kZSA9IG5ld0RvbU5vZGVzXzFbX2ldO1xuICAgICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG5ld05vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRFbCA9IGVsO1xuICAgICAgICBjdXJyZW50RG9tTm9kZXMgPSBuZXdEb21Ob2RlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgY3VycmVudERvbU5vZGVzLmZvckVhY2gocmVtb3ZlRWxlbWVudCk7XG4gICAgICAgIGN1cnJlbnREb21Ob2RlcyA9IFtdO1xuICAgICAgICBjdXJyZW50RWwgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4geyByZW5kZXI6IHJlbmRlciwgZGVzdHJveTogZGVzdHJveSB9O1xufVxuXG52YXIgRGVsYXllZFJ1bm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZWxheWVkUnVubmVyKGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgIH1cbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKGRlbGF5KSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgICAgIGlmICghdGhpcy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dCgpO1xuICAgICAgICAgICAgaWYgKGRlbGF5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoLy8gTk9UIE9QVElNQUwhIFRPRE86IGxvb2sgYXQgZGVib3VuY2VcbiAgICAgICAgICAgICAgICB0aGlzLnRyeURyYWluLmJpbmQodGhpcyksIGRlbGF5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSAnJzsgfVxuICAgICAgICB2YXIgcGF1c2VEZXB0aHMgPSB0aGlzLnBhdXNlRGVwdGhzO1xuICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gPSAocGF1c2VEZXB0aHNbc2NvcGVdIHx8IDApICsgMTtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgaWYgKHNjb3BlID09PSB2b2lkIDApIHsgc2NvcGUgPSAnJzsgfVxuICAgICAgICB2YXIgcGF1c2VEZXB0aHMgPSB0aGlzLnBhdXNlRGVwdGhzO1xuICAgICAgICBpZiAoc2NvcGUgaW4gcGF1c2VEZXB0aHMpIHtcbiAgICAgICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXVzZURlcHRoc1tzY29wZV0gLT0gMTtcbiAgICAgICAgICAgICAgICB2YXIgZGVwdGggPSBwYXVzZURlcHRoc1tzY29wZV07XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHBhdXNlRGVwdGhzW3Njb3BlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyeURyYWluKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5wYXVzZURlcHRocykubGVuZ3RoO1xuICAgIH07XG4gICAgRGVsYXllZFJ1bm5lci5wcm90b3R5cGUudHJ5RHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1J1bm5pbmcgJiYgIXRoaXMuaXNQYXVzZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pc1J1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhaW5lZCgpOyAvLyBtaWdodCBzZXQgaXNEaXJ0eSB0byB0cnVlIGFnYWluXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzUnVubmluZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGF1c2VEZXB0aHMgPSB7fTtcbiAgICB9O1xuICAgIERlbGF5ZWRSdW5uZXIucHJvdG90eXBlLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZW91dElkKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0SWQpO1xuICAgICAgICAgICAgdGhpcy50aW1lb3V0SWQgPSAwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBEZWxheWVkUnVubmVyLnByb3RvdHlwZS5kcmFpbmVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kcmFpbmVkT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWluZWRPcHRpb24oKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIERlbGF5ZWRSdW5uZXI7XG59KCkpO1xuXG52YXIgVGFza1J1bm5lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYXNrUnVubmVyKHJ1blRhc2tPcHRpb24sIGRyYWluZWRPcHRpb24pIHtcbiAgICAgICAgdGhpcy5ydW5UYXNrT3B0aW9uID0gcnVuVGFza09wdGlvbjtcbiAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uID0gZHJhaW5lZE9wdGlvbjtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRlbGF5ZWRSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcih0aGlzLmRyYWluLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICBUYXNrUnVubmVyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKHRhc2ssIGRlbGF5KSB7XG4gICAgICAgIHRoaXMucXVldWUucHVzaCh0YXNrKTtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlcXVlc3QoZGVsYXkpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnBhdXNlKHNjb3BlKTtcbiAgICB9O1xuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uIChzY29wZSwgZm9yY2UpIHtcbiAgICAgICAgdGhpcy5kZWxheWVkUnVubmVyLnJlc3VtZShzY29wZSwgZm9yY2UpO1xuICAgIH07XG4gICAgVGFza1J1bm5lci5wcm90b3R5cGUuZHJhaW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBxdWV1ZSA9IHRoaXMucXVldWU7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBjb21wbGV0ZWRUYXNrcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB2b2lkIDA7XG4gICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBxdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucnVuVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWRUYXNrcy5wdXNoKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFpbmVkKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfSAvLyBrZWVwIGdvaW5nLCBpbiBjYXNlIG5ldyB0YXNrcyB3ZXJlIGFkZGVkIGluIHRoZSBkcmFpbmVkIGhhbmRsZXJcbiAgICB9O1xuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLnJ1blRhc2sgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICBpZiAodGhpcy5ydW5UYXNrT3B0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnJ1blRhc2tPcHRpb24odGFzayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRhc2tSdW5uZXIucHJvdG90eXBlLmRyYWluZWQgPSBmdW5jdGlvbiAoY29tcGxldGVkVGFza3MpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhaW5lZE9wdGlvbikge1xuICAgICAgICAgICAgdGhpcy5kcmFpbmVkT3B0aW9uKGNvbXBsZXRlZFRhc2tzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFRhc2tSdW5uZXI7XG59KCkpO1xuXG4vLyBDb21wdXRlcyB3aGF0IHRoZSB0aXRsZSBhdCB0aGUgdG9wIG9mIHRoZSBjYWxlbmRhckFwaSBzaG91bGQgYmUgZm9yIHRoaXMgdmlld1xuZnVuY3Rpb24gYnVpbGRUaXRsZShkYXRlUHJvZmlsZSwgdmlld09wdGlvbnMsIGRhdGVFbnYpIHtcbiAgICB2YXIgcmFuZ2U7XG4gICAgLy8gZm9yIHZpZXdzIHRoYXQgc3BhbiBhIGxhcmdlIHVuaXQgb2YgdGltZSwgc2hvdyB0aGUgcHJvcGVyIGludGVydmFsLCBpZ25vcmluZyBzdHJheSBkYXlzIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICBpZiAoL14oeWVhcnxtb250aCkkLy50ZXN0KGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZVVuaXQpKSB7XG4gICAgICAgIHJhbmdlID0gZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlO1xuICAgIH1cbiAgICBlbHNlIHsgLy8gZm9yIGRheSB1bml0cyBvciBzbWFsbGVyLCB1c2UgdGhlIGFjdHVhbCBkYXkgcmFuZ2VcbiAgICAgICAgcmFuZ2UgPSBkYXRlUHJvZmlsZS5hY3RpdmVSYW5nZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGVFbnYuZm9ybWF0UmFuZ2UocmFuZ2Uuc3RhcnQsIHJhbmdlLmVuZCwgY3JlYXRlRm9ybWF0dGVyKHZpZXdPcHRpb25zLnRpdGxlRm9ybWF0IHx8IGJ1aWxkVGl0bGVGb3JtYXQoZGF0ZVByb2ZpbGUpKSwge1xuICAgICAgICBpc0VuZEV4Y2x1c2l2ZTogZGF0ZVByb2ZpbGUuaXNSYW5nZUFsbERheSxcbiAgICAgICAgZGVmYXVsdFNlcGFyYXRvcjogdmlld09wdGlvbnMudGl0bGVSYW5nZVNlcGFyYXRvcixcbiAgICB9KTtcbn1cbi8vIEdlbmVyYXRlcyB0aGUgZm9ybWF0IHN0cmluZyB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSB0aXRsZSBmb3IgdGhlIGN1cnJlbnQgZGF0ZSByYW5nZS5cbi8vIEF0dGVtcHRzIHRvIGNvbXB1dGUgdGhlIG1vc3QgYXBwcm9wcmlhdGUgZm9ybWF0IGlmIG5vdCBleHBsaWNpdGx5IHNwZWNpZmllZCB3aXRoIGB0aXRsZUZvcm1hdGAuXG5mdW5jdGlvbiBidWlsZFRpdGxlRm9ybWF0KGRhdGVQcm9maWxlKSB7XG4gICAgdmFyIGN1cnJlbnRSYW5nZVVuaXQgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2VVbml0O1xuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAneWVhcicpIHtcbiAgICAgICAgcmV0dXJuIHsgeWVhcjogJ251bWVyaWMnIH07XG4gICAgfVxuICAgIGlmIChjdXJyZW50UmFuZ2VVbml0ID09PSAnbW9udGgnKSB7XG4gICAgICAgIHJldHVybiB7IHllYXI6ICdudW1lcmljJywgbW9udGg6ICdsb25nJyB9OyAvLyBsaWtlIFwiU2VwdGVtYmVyIDIwMTRcIlxuICAgIH1cbiAgICB2YXIgZGF5cyA9IGRpZmZXaG9sZURheXMoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlLnN0YXJ0LCBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UuZW5kKTtcbiAgICBpZiAoZGF5cyAhPT0gbnVsbCAmJiBkYXlzID4gMSkge1xuICAgICAgICAvLyBtdWx0aS1kYXkgcmFuZ2UuIHNob3J0ZXIsIGxpa2UgXCJTZXAgOSAtIDEwIDIwMTRcIlxuICAgICAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnc2hvcnQnLCBkYXk6ICdudW1lcmljJyB9O1xuICAgIH1cbiAgICAvLyBvbmUgZGF5LiBsb25nZXIsIGxpa2UgXCJTZXB0ZW1iZXIgOSAyMDE0XCJcbiAgICByZXR1cm4geyB5ZWFyOiAnbnVtZXJpYycsIG1vbnRoOiAnbG9uZycsIGRheTogJ251bWVyaWMnIH07XG59XG5cbi8vIGluIGZ1dHVyZSByZWZhY3RvciwgZG8gdGhlIHJlZHV4LXN0eWxlIGZ1bmN0aW9uKHN0YXRlPWluaXRpYWwpIGZvciBpbml0aWFsLXN0YXRlXG4vLyBhbHNvLCB3aGF0ZXZlciBpcyBoYXBwZW5pbmcgaW4gY29uc3RydWN0b3IsIGhhdmUgaXQgaGFwcGVuIGluIGFjdGlvbiBxdWV1ZSB0b29cbnZhciBDYWxlbmRhckRhdGFNYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyRGF0YU1hbmFnZXIocHJvcHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEgPSBtZW1vaXplKHRoaXMuX2NvbXB1dGVPcHRpb25zRGF0YSk7XG4gICAgICAgIHRoaXMuY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSA9IG1lbW9pemUodGhpcy5fY29tcHV0ZUN1cnJlbnRWaWV3RGF0YSk7XG4gICAgICAgIHRoaXMub3JnYW5pemVSYXdMb2NhbGVzID0gbWVtb2l6ZShvcmdhbml6ZVJhd0xvY2FsZXMpO1xuICAgICAgICB0aGlzLmJ1aWxkTG9jYWxlID0gbWVtb2l6ZShidWlsZExvY2FsZSk7XG4gICAgICAgIHRoaXMuYnVpbGRQbHVnaW5Ib29rcyA9IGJ1aWxkQnVpbGRQbHVnaW5Ib29rcygpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZUVudiA9IG1lbW9pemUoYnVpbGREYXRlRW52KTtcbiAgICAgICAgdGhpcy5idWlsZFRoZW1lID0gbWVtb2l6ZShidWlsZFRoZW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZVRvb2xiYXJzID0gbWVtb2l6ZShwYXJzZVRvb2xiYXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdTcGVjcyA9IG1lbW9pemUoYnVpbGRWaWV3U3BlY3MpO1xuICAgICAgICB0aGlzLmJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBtZW1vaXplT2JqQXJnKGJ1aWxkRGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB0aGlzLmJ1aWxkVmlld0FwaSA9IG1lbW9pemUoYnVpbGRWaWV3QXBpKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXdVaVByb3BzID0gbWVtb2l6ZU9iakFyZyhidWlsZFZpZXdVaVByb3BzKTtcbiAgICAgICAgdGhpcy5idWlsZEV2ZW50VWlCeVNvdXJjZSA9IG1lbW9pemUoYnVpbGRFdmVudFVpQnlTb3VyY2UsIGlzUHJvcHNFcXVhbCk7XG4gICAgICAgIHRoaXMuYnVpbGRFdmVudFVpQmFzZXMgPSBtZW1vaXplKGJ1aWxkRXZlbnRVaUJhc2VzKTtcbiAgICAgICAgdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzID0gbWVtb2l6ZU9iakFyZyhwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5idWlsZFRpdGxlID0gbWVtb2l6ZShidWlsZFRpdGxlKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIgPSBuZXcgVGFza1J1bm5lcih0aGlzLl9oYW5kbGVBY3Rpb24uYmluZCh0aGlzKSwgdGhpcy51cGRhdGVEYXRhLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCA9IHt9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudFZpZXdPcHRpb25zSW5wdXQgPSB7fTtcbiAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0ge307XG4gICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0ge307XG4gICAgICAgIHRoaXMuZ2V0Q3VycmVudERhdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5kYXRhOyB9O1xuICAgICAgICB0aGlzLmRpc3BhdGNoID0gZnVuY3Rpb24gKGFjdGlvbikge1xuICAgICAgICAgICAgX3RoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3QoYWN0aW9uKTsgLy8gcHJvdGVjdHMgYWdhaW5zdCByZWN1cnNpdmUgY2FsbHMgdG8gX2hhbmRsZUFjdGlvblxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnBhdXNlKCk7XG4gICAgICAgIHZhciBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzID0ge307XG4gICAgICAgIHZhciBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB2YXIgY3VycmVudFZpZXdUeXBlID0gb3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLmluaXRpYWxWaWV3IHx8IG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLmluaXRpYWxWaWV3O1xuICAgICAgICB2YXIgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKGN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIC8vIHdpcmUgdGhpbmdzIHVwXG4gICAgICAgIC8vIFRPRE86IG5vdCBEUllcbiAgICAgICAgcHJvcHMuY2FsZW5kYXJBcGkuY3VycmVudERhdGFNYW5hZ2VyID0gdGhpcztcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgdGhpcy5lbWl0dGVyLnNldE9wdGlvbnMoY3VycmVudFZpZXdEYXRhLm9wdGlvbnMpO1xuICAgICAgICB2YXIgY3VycmVudERhdGUgPSBnZXRJbml0aWFsRGF0ZShvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICBpZiAoIXJhbmdlQ29udGFpbnNNYXJrZXIoZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IHRoaXMuZW1pdHRlcixcbiAgICAgICAgICAgIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhLFxuICAgICAgICB9O1xuICAgICAgICAvLyBuZWVkcyB0byBiZSBhZnRlciBzZXRUaGlzQ29udGV4dFxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3MuY29udGV4dEluaXQ7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgY2FsbGJhY2sgPSBfYVtfaV07XG4gICAgICAgICAgICBjYWxsYmFjayhjYWxlbmRhckNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5PVCBEUllcbiAgICAgICAgdmFyIGV2ZW50U291cmNlcyA9IGluaXRFdmVudFNvdXJjZXMob3B0aW9uc0RhdGEuY2FsZW5kYXJPcHRpb25zLCBkYXRlUHJvZmlsZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGluaXRpYWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXM6IGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgICAgICBjdXJyZW50Vmlld1R5cGU6IGN1cnJlbnRWaWV3VHlwZSxcbiAgICAgICAgICAgIGN1cnJlbnREYXRlOiBjdXJyZW50RGF0ZSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91cnM6IHRoaXMucGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyhjYWxlbmRhckNvbnRleHQpLFxuICAgICAgICAgICAgZXZlbnRTb3VyY2VzOiBldmVudFNvdXJjZXMsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHt9LFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogY3JlYXRlRW1wdHlFdmVudFN0b3JlKCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRTZWxlY3Rpb246ICcnLFxuICAgICAgICAgICAgZXZlbnREcmFnOiBudWxsLFxuICAgICAgICAgICAgZXZlbnRSZXNpemU6IG51bGwsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHRoaXMuYnVpbGRWaWV3VWlQcm9wcyhjYWxlbmRhckNvbnRleHQpLnNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnRleHRBbmRTdGF0ZSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBpbml0aWFsU3RhdGUpO1xuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIF9jID0gb3B0aW9uc0RhdGEucGx1Z2luSG9va3MucmVkdWNlcnM7IF9iIDwgX2MubGVuZ3RoOyBfYisrKSB7XG4gICAgICAgICAgICB2YXIgcmVkdWNlciA9IF9jW19iXTtcbiAgICAgICAgICAgIHRzbGliLl9fYXNzaWduKGluaXRpYWxTdGF0ZSwgcmVkdWNlcihudWxsLCBudWxsLCBjb250ZXh0QW5kU3RhdGUpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZUlzTG9hZGluZyhpbml0aWFsU3RhdGUsIGNhbGVuZGFyQ29udGV4dCkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdHRlci50cmlnZ2VyKCdsb2FkaW5nJywgdHJ1ZSk7IC8vIE5PVCBEUllcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgICAgICB0aGlzLnVwZGF0ZURhdGEoKTtcbiAgICAgICAgdGhpcy5hY3Rpb25SdW5uZXIucmVzdW1lKCk7XG4gICAgfVxuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLnJlc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25PdmVycmlkZXMsIGFwcGVuZCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBwcm9wcy5vcHRpb25PdmVycmlkZXMgPSBhcHBlbmRcbiAgICAgICAgICAgID8gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHByb3BzLm9wdGlvbk92ZXJyaWRlcyksIG9wdGlvbk92ZXJyaWRlcykgOiBvcHRpb25PdmVycmlkZXM7XG4gICAgICAgIHRoaXMuYWN0aW9uUnVubmVyLnJlcXVlc3Qoe1xuICAgICAgICAgICAgdHlwZTogJ05PVEhJTkcnLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENhbGVuZGFyRGF0YU1hbmFnZXIucHJvdG90eXBlLl9oYW5kbGVBY3Rpb24gPSBmdW5jdGlvbiAoYWN0aW9uKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIGVtaXR0ZXIgPSBfYS5lbWl0dGVyO1xuICAgICAgICB2YXIgZHluYW1pY09wdGlvbk92ZXJyaWRlcyA9IHJlZHVjZUR5bmFtaWNPcHRpb25PdmVycmlkZXMoc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgYWN0aW9uKTtcbiAgICAgICAgdmFyIG9wdGlvbnNEYXRhID0gdGhpcy5jb21wdXRlT3B0aW9uc0RhdGEocHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBwcm9wcy5jYWxlbmRhckFwaSk7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld1R5cGUgPSByZWR1Y2VWaWV3VHlwZShzdGF0ZS5jdXJyZW50Vmlld1R5cGUsIGFjdGlvbik7XG4gICAgICAgIHZhciBjdXJyZW50Vmlld0RhdGEgPSB0aGlzLmNvbXB1dGVDdXJyZW50Vmlld0RhdGEoY3VycmVudFZpZXdUeXBlLCBvcHRpb25zRGF0YSwgcHJvcHMub3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgLy8gd2lyZSB0aGluZ3MgdXBcbiAgICAgICAgLy8gVE9ETzogbm90IERSWVxuICAgICAgICBwcm9wcy5jYWxlbmRhckFwaS5jdXJyZW50RGF0YU1hbmFnZXIgPSB0aGlzO1xuICAgICAgICBlbWl0dGVyLnNldFRoaXNDb250ZXh0KHByb3BzLmNhbGVuZGFyQXBpKTtcbiAgICAgICAgZW1pdHRlci5zZXRPcHRpb25zKGN1cnJlbnRWaWV3RGF0YS5vcHRpb25zKTtcbiAgICAgICAgdmFyIGNhbGVuZGFyQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogb3B0aW9uc0RhdGEucGx1Z2luSG9va3MsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksXG4gICAgICAgICAgICBkaXNwYXRjaDogdGhpcy5kaXNwYXRjaCxcbiAgICAgICAgICAgIGVtaXR0ZXI6IGVtaXR0ZXIsXG4gICAgICAgICAgICBnZXRDdXJyZW50RGF0YTogdGhpcy5nZXRDdXJyZW50RGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGN1cnJlbnREYXRlID0gc3RhdGUuY3VycmVudERhdGUsIGRhdGVQcm9maWxlID0gc3RhdGUuZGF0ZVByb2ZpbGU7XG4gICAgICAgIGlmICh0aGlzLmRhdGEgJiYgdGhpcy5kYXRhLmRhdGVQcm9maWxlR2VuZXJhdG9yICE9PSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IpIHsgLy8gaGFja1xuICAgICAgICAgICAgZGF0ZVByb2ZpbGUgPSBjdXJyZW50Vmlld0RhdGEuZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQoY3VycmVudERhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnREYXRlID0gcmVkdWNlQ3VycmVudERhdGUoY3VycmVudERhdGUsIGFjdGlvbik7XG4gICAgICAgIGRhdGVQcm9maWxlID0gcmVkdWNlRGF0ZVByb2ZpbGUoZGF0ZVByb2ZpbGUsIGFjdGlvbiwgY3VycmVudERhdGUsIGN1cnJlbnRWaWV3RGF0YS5kYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgICAgIGlmIChhY3Rpb24udHlwZSA9PT0gJ1BSRVYnIHx8IC8vIFRPRE86IG1vdmUgdGhpcyBsb2dpYyBpbnRvIERhdGVQcm9maWxlR2VuZXJhdG9yXG4gICAgICAgICAgICBhY3Rpb24udHlwZSA9PT0gJ05FWFQnIHx8IC8vIFwiXG4gICAgICAgICAgICAhcmFuZ2VDb250YWluc01hcmtlcihkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2UsIGN1cnJlbnREYXRlKSkge1xuICAgICAgICAgICAgY3VycmVudERhdGUgPSBkYXRlUHJvZmlsZS5jdXJyZW50UmFuZ2Uuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlcyhzdGF0ZS5ldmVudFNvdXJjZXMsIGFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIHZhciBldmVudFN0b3JlID0gcmVkdWNlRXZlbnRTdG9yZShzdGF0ZS5ldmVudFN0b3JlLCBhY3Rpb24sIGV2ZW50U291cmNlcywgZGF0ZVByb2ZpbGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIHZhciBpc0V2ZW50c0xvYWRpbmcgPSBjb21wdXRlRXZlbnRTb3VyY2VzTG9hZGluZyhldmVudFNvdXJjZXMpOyAvLyBCQUQuIGFsc28gY2FsbGVkIGluIHRoaXMgZnVuYyBpbiBjb21wdXRlSXNMb2FkaW5nXG4gICAgICAgIHZhciByZW5kZXJhYmxlRXZlbnRTdG9yZSA9IChpc0V2ZW50c0xvYWRpbmcgJiYgIWN1cnJlbnRWaWV3RGF0YS5vcHRpb25zLnByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmcpID9cbiAgICAgICAgICAgIChzdGF0ZS5yZW5kZXJhYmxlRXZlbnRTdG9yZSB8fCBldmVudFN0b3JlKSA6IC8vIHRyeSBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICBldmVudFN0b3JlO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLmJ1aWxkVmlld1VpUHJvcHMoY2FsZW5kYXJDb250ZXh0KSwgZXZlbnRVaVNpbmdsZUJhc2UgPSBfYi5ldmVudFVpU2luZ2xlQmFzZSwgc2VsZWN0aW9uQ29uZmlnID0gX2Iuc2VsZWN0aW9uQ29uZmlnOyAvLyB3aWxsIG1lbW9pemUgb2JqXG4gICAgICAgIHZhciBldmVudFVpQnlTb3VyY2UgPSB0aGlzLmJ1aWxkRXZlbnRVaUJ5U291cmNlKGV2ZW50U291cmNlcyk7XG4gICAgICAgIHZhciBldmVudFVpQmFzZXMgPSB0aGlzLmJ1aWxkRXZlbnRVaUJhc2VzKHJlbmRlcmFibGVFdmVudFN0b3JlLmRlZnMsIGV2ZW50VWlTaW5nbGVCYXNlLCBldmVudFVpQnlTb3VyY2UpO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB7XG4gICAgICAgICAgICBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzOiBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgY3VycmVudFZpZXdUeXBlOiBjdXJyZW50Vmlld1R5cGUsXG4gICAgICAgICAgICBjdXJyZW50RGF0ZTogY3VycmVudERhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBldmVudFNvdXJjZXM6IGV2ZW50U291cmNlcyxcbiAgICAgICAgICAgIGV2ZW50U3RvcmU6IGV2ZW50U3RvcmUsXG4gICAgICAgICAgICByZW5kZXJhYmxlRXZlbnRTdG9yZTogcmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBzZWxlY3Rpb25Db25maWc6IHNlbGVjdGlvbkNvbmZpZyxcbiAgICAgICAgICAgIGV2ZW50VWlCYXNlczogZXZlbnRVaUJhc2VzLFxuICAgICAgICAgICAgYnVzaW5lc3NIb3VyczogdGhpcy5wYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgICAgICBkYXRlU2VsZWN0aW9uOiByZWR1Y2VEYXRlU2VsZWN0aW9uKHN0YXRlLmRhdGVTZWxlY3Rpb24sIGFjdGlvbiksXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcmVkdWNlU2VsZWN0ZWRFdmVudChzdGF0ZS5ldmVudFNlbGVjdGlvbiwgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogcmVkdWNlRXZlbnREcmFnKHN0YXRlLmV2ZW50RHJhZywgYWN0aW9uKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiByZWR1Y2VFdmVudFJlc2l6ZShzdGF0ZS5ldmVudFJlc2l6ZSwgYWN0aW9uKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGNvbnRleHRBbmRTdGF0ZSA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBjYWxlbmRhckNvbnRleHQpLCBuZXdTdGF0ZSk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgX2MgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5yZWR1Y2VyczsgX2kgPCBfYy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciByZWR1Y2VyID0gX2NbX2ldO1xuICAgICAgICAgICAgdHNsaWIuX19hc3NpZ24obmV3U3RhdGUsIHJlZHVjZXIoc3RhdGUsIGFjdGlvbiwgY29udGV4dEFuZFN0YXRlKSk7IC8vIGdpdmUgdGhlIE9MRCBzdGF0ZSwgZm9yIG9sZCB2YWx1ZVxuICAgICAgICB9XG4gICAgICAgIHZhciB3YXNMb2FkaW5nID0gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY2FsZW5kYXJDb250ZXh0KTtcbiAgICAgICAgdmFyIGlzTG9hZGluZyA9IGNvbXB1dGVJc0xvYWRpbmcobmV3U3RhdGUsIGNhbGVuZGFyQ29udGV4dCk7XG4gICAgICAgIC8vIFRPRE86IHVzZSBwcm9wU2V0SGFuZGxlcnMgaW4gcGx1Z2luIHN5c3RlbVxuICAgICAgICBpZiAoIXdhc0xvYWRpbmcgJiYgaXNMb2FkaW5nKSB7XG4gICAgICAgICAgICBlbWl0dGVyLnRyaWdnZXIoJ2xvYWRpbmcnLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3YXNMb2FkaW5nICYmICFpc0xvYWRpbmcpIHtcbiAgICAgICAgICAgIGVtaXR0ZXIudHJpZ2dlcignbG9hZGluZycsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIGlmIChwcm9wcy5vbkFjdGlvbikge1xuICAgICAgICAgICAgcHJvcHMub25BY3Rpb24oYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUudXBkYXRlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgdmFyIG9sZERhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBvcHRpb25zRGF0YSA9IHRoaXMuY29tcHV0ZU9wdGlvbnNEYXRhKHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcywgcHJvcHMuY2FsZW5kYXJBcGkpO1xuICAgICAgICB2YXIgY3VycmVudFZpZXdEYXRhID0gdGhpcy5jb21wdXRlQ3VycmVudFZpZXdEYXRhKHN0YXRlLmN1cnJlbnRWaWV3VHlwZSwgb3B0aW9uc0RhdGEsIHByb3BzLm9wdGlvbk92ZXJyaWRlcywgc3RhdGUuZHluYW1pY09wdGlvbk92ZXJyaWRlcyk7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyB2aWV3VGl0bGU6IHRoaXMuYnVpbGRUaXRsZShzdGF0ZS5kYXRlUHJvZmlsZSwgY3VycmVudFZpZXdEYXRhLm9wdGlvbnMsIG9wdGlvbnNEYXRhLmRhdGVFbnYpLCBjYWxlbmRhckFwaTogcHJvcHMuY2FsZW5kYXJBcGksIGRpc3BhdGNoOiB0aGlzLmRpc3BhdGNoLCBlbWl0dGVyOiB0aGlzLmVtaXR0ZXIsIGdldEN1cnJlbnREYXRhOiB0aGlzLmdldEN1cnJlbnREYXRhIH0sIG9wdGlvbnNEYXRhKSwgY3VycmVudFZpZXdEYXRhKSwgc3RhdGUpO1xuICAgICAgICB2YXIgY2hhbmdlSGFuZGxlcnMgPSBvcHRpb25zRGF0YS5wbHVnaW5Ib29rcy5vcHRpb25DaGFuZ2VIYW5kbGVycztcbiAgICAgICAgdmFyIG9sZENhbGVuZGFyT3B0aW9ucyA9IG9sZERhdGEgJiYgb2xkRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIHZhciBuZXdDYWxlbmRhck9wdGlvbnMgPSBvcHRpb25zRGF0YS5jYWxlbmRhck9wdGlvbnM7XG4gICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMgJiYgb2xkQ2FsZW5kYXJPcHRpb25zICE9PSBuZXdDYWxlbmRhck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvbGRDYWxlbmRhck9wdGlvbnMudGltZVpvbmUgIT09IG5ld0NhbGVuZGFyT3B0aW9ucy50aW1lWm9uZSkge1xuICAgICAgICAgICAgICAgIC8vIGhhY2tcbiAgICAgICAgICAgICAgICBzdGF0ZS5ldmVudFNvdXJjZXMgPSBkYXRhLmV2ZW50U291cmNlcyA9IHJlZHVjZUV2ZW50U291cmNlc05ld1RpbWVab25lKGRhdGEuZXZlbnRTb3VyY2VzLCBzdGF0ZS5kYXRlUHJvZmlsZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgc3RhdGUuZXZlbnRTdG9yZSA9IGRhdGEuZXZlbnRTdG9yZSA9IHJlem9uZUV2ZW50U3RvcmVEYXRlcyhkYXRhLmV2ZW50U3RvcmUsIG9sZERhdGEuZGF0ZUVudiwgZGF0YS5kYXRlRW52KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gY2hhbmdlSGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAob2xkQ2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdICE9PSBuZXdDYWxlbmRhck9wdGlvbnNbb3B0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlSGFuZGxlcnNbb3B0aW9uTmFtZV0obmV3Q2FsZW5kYXJPcHRpb25zW29wdGlvbk5hbWVdLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BzLm9uRGF0YSkge1xuICAgICAgICAgICAgcHJvcHMub25EYXRhKGRhdGEpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFNYW5hZ2VyLnByb3RvdHlwZS5fY29tcHV0ZU9wdGlvbnNEYXRhID0gZnVuY3Rpb24gKG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcywgY2FsZW5kYXJBcGkpIHtcbiAgICAgICAgLy8gVE9ETzogYmxhY2tsaXN0IG9wdGlvbnMgdGhhdCBhcmUgaGFuZGxlZCBieSBvcHRpb25DaGFuZ2VIYW5kbGVyc1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb2Nlc3NSYXdDYWxlbmRhck9wdGlvbnMob3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgcmVmaW5lZE9wdGlvbnMgPSBfYS5yZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MgPSBfYS5wbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMgPSBfYS5sb2NhbGVEZWZhdWx0cywgYXZhaWxhYmxlTG9jYWxlRGF0YSA9IF9hLmF2YWlsYWJsZUxvY2FsZURhdGEsIGV4dHJhID0gX2EuZXh0cmE7XG4gICAgICAgIHdhcm5Vbmtub3duT3B0aW9ucyhleHRyYSk7XG4gICAgICAgIHZhciBkYXRlRW52ID0gdGhpcy5idWlsZERhdGVFbnYocmVmaW5lZE9wdGlvbnMudGltZVpvbmUsIHJlZmluZWRPcHRpb25zLmxvY2FsZSwgcmVmaW5lZE9wdGlvbnMud2Vla051bWJlckNhbGN1bGF0aW9uLCByZWZpbmVkT3B0aW9ucy5maXJzdERheSwgcmVmaW5lZE9wdGlvbnMud2Vla1RleHQsIHBsdWdpbkhvb2tzLCBhdmFpbGFibGVMb2NhbGVEYXRhLCByZWZpbmVkT3B0aW9ucy5kZWZhdWx0UmFuZ2VTZXBhcmF0b3IpO1xuICAgICAgICB2YXIgdmlld1NwZWNzID0gdGhpcy5idWlsZFZpZXdTcGVjcyhwbHVnaW5Ib29rcy52aWV3cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzLCBsb2NhbGVEZWZhdWx0cyk7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuYnVpbGRUaGVtZShyZWZpbmVkT3B0aW9ucywgcGx1Z2luSG9va3MpO1xuICAgICAgICB2YXIgdG9vbGJhckNvbmZpZyA9IHRoaXMucGFyc2VUb29sYmFycyhyZWZpbmVkT3B0aW9ucywgb3B0aW9uT3ZlcnJpZGVzLCB0aGVtZSwgdmlld1NwZWNzLCBjYWxlbmRhckFwaSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYWxlbmRhck9wdGlvbnM6IHJlZmluZWRPcHRpb25zLFxuICAgICAgICAgICAgcGx1Z2luSG9va3M6IHBsdWdpbkhvb2tzLFxuICAgICAgICAgICAgZGF0ZUVudjogZGF0ZUVudixcbiAgICAgICAgICAgIHZpZXdTcGVjczogdmlld1NwZWNzLFxuICAgICAgICAgICAgdGhlbWU6IHRoZW1lLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZzogdG9vbGJhckNvbmZpZyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzOiBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIGF2YWlsYWJsZVJhd0xvY2FsZXM6IGF2YWlsYWJsZUxvY2FsZURhdGEubWFwLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLy8gYWx3YXlzIGNhbGxlZCBmcm9tIGJlaGluZCBhIG1lbW9pemVyXG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1Jhd0NhbGVuZGFyT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgdmFyIF9hID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSksIGxvY2FsZXMgPSBfYS5sb2NhbGVzLCBsb2NhbGUgPSBfYS5sb2NhbGU7XG4gICAgICAgIHZhciBhdmFpbGFibGVMb2NhbGVEYXRhID0gdGhpcy5vcmdhbml6ZVJhd0xvY2FsZXMobG9jYWxlcyk7XG4gICAgICAgIHZhciBhdmFpbGFibGVSYXdMb2NhbGVzID0gYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXA7XG4gICAgICAgIHZhciBsb2NhbGVEZWZhdWx0cyA9IHRoaXMuYnVpbGRMb2NhbGUobG9jYWxlIHx8IGF2YWlsYWJsZUxvY2FsZURhdGEuZGVmYXVsdENvZGUsIGF2YWlsYWJsZVJhd0xvY2FsZXMpLm9wdGlvbnM7XG4gICAgICAgIHZhciBwbHVnaW5Ib29rcyA9IHRoaXMuYnVpbGRQbHVnaW5Ib29rcyhvcHRpb25PdmVycmlkZXMucGx1Z2lucyB8fCBbXSwgZ2xvYmFsUGx1Z2lucyk7XG4gICAgICAgIHZhciByZWZpbmVycyA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZXJzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIEJBU0VfT1BUSU9OX1JFRklORVJTKSwgQ0FMRU5EQVJfTElTVEVORVJfUkVGSU5FUlMpLCBDQUxFTkRBUl9PUFRJT05fUkVGSU5FUlMpLCBwbHVnaW5Ib29rcy5saXN0ZW5lclJlZmluZXJzKSwgcGx1Z2luSG9va3Mub3B0aW9uUmVmaW5lcnMpO1xuICAgICAgICB2YXIgZXh0cmEgPSB7fTtcbiAgICAgICAgdmFyIHJhdyA9IG1lcmdlUmF3T3B0aW9ucyhbXG4gICAgICAgICAgICBCQVNFX09QVElPTl9ERUZBVUxUUyxcbiAgICAgICAgICAgIGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgb3B0aW9uT3ZlcnJpZGVzLFxuICAgICAgICAgICAgZHluYW1pY09wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgXSk7XG4gICAgICAgIHZhciByZWZpbmVkID0ge307XG4gICAgICAgIHZhciBjdXJyZW50UmF3ID0gdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zSW5wdXQ7XG4gICAgICAgIHZhciBjdXJyZW50UmVmaW5lZCA9IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIHZhciBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gcmF3KSB7XG4gICAgICAgICAgICBpZiAob3B0aW9uTmFtZSAhPT0gJ3BsdWdpbnMnKSB7IC8vIGJlY2F1c2UgcGx1Z2lucyBpcyBzcGVjaWFsLWNhc2VkXG4gICAgICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgICAgICAoQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChvcHRpb25OYW1lIGluIGN1cnJlbnRSYXcpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShjdXJyZW50UmF3W29wdGlvbk5hbWVdLCByYXdbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgICAgICByZWZpbmVkW29wdGlvbk5hbWVdID0gY3VycmVudFJlZmluZWRbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBhbnlDaGFuZ2VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhW29wdGlvbk5hbWVdID0gY3VycmVudFJhd1tvcHRpb25OYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueUNoYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lZCA9IHJlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhd09wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0LFxuICAgICAgICAgICAgcmVmaW5lZE9wdGlvbnM6IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBwbHVnaW5Ib29rczogcGx1Z2luSG9va3MsXG4gICAgICAgICAgICBhdmFpbGFibGVMb2NhbGVEYXRhOiBhdmFpbGFibGVMb2NhbGVEYXRhLFxuICAgICAgICAgICAgbG9jYWxlRGVmYXVsdHM6IGxvY2FsZURlZmF1bHRzLFxuICAgICAgICAgICAgZXh0cmE6IGV4dHJhLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUuX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEgPSBmdW5jdGlvbiAodmlld1R5cGUsIG9wdGlvbnNEYXRhLCBvcHRpb25PdmVycmlkZXMsIGR5bmFtaWNPcHRpb25PdmVycmlkZXMpIHtcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gb3B0aW9uc0RhdGEudmlld1NwZWNzW3ZpZXdUeXBlXTtcbiAgICAgICAgaWYgKCF2aWV3U3BlYykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmlld1R5cGUgXFxcIlwiICsgdmlld1R5cGUgKyBcIlxcXCIgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIG1ha2Ugc3VyZSB5b3UndmUgbG9hZGVkIGFsbCBuZWNjZXNzYXJ5IHBsdWdpbnNcIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9jZXNzUmF3Vmlld09wdGlvbnModmlld1NwZWMsIG9wdGlvbnNEYXRhLnBsdWdpbkhvb2tzLCBvcHRpb25zRGF0YS5sb2NhbGVEZWZhdWx0cywgb3B0aW9uT3ZlcnJpZGVzLCBkeW5hbWljT3B0aW9uT3ZlcnJpZGVzKSwgcmVmaW5lZE9wdGlvbnMgPSBfYS5yZWZpbmVkT3B0aW9ucywgZXh0cmEgPSBfYS5leHRyYTtcbiAgICAgICAgd2FyblVua25vd25PcHRpb25zKGV4dHJhKTtcbiAgICAgICAgdmFyIGRhdGVQcm9maWxlR2VuZXJhdG9yID0gdGhpcy5idWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHtcbiAgICAgICAgICAgIGRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3M6IHZpZXdTcGVjLm9wdGlvbkRlZmF1bHRzLmRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MsXG4gICAgICAgICAgICBkdXJhdGlvbjogdmlld1NwZWMuZHVyYXRpb24sXG4gICAgICAgICAgICBkdXJhdGlvblVuaXQ6IHZpZXdTcGVjLmR1cmF0aW9uVW5pdCxcbiAgICAgICAgICAgIHVzZXNNaW5NYXhUaW1lOiB2aWV3U3BlYy5vcHRpb25EZWZhdWx0cy51c2VzTWluTWF4VGltZSxcbiAgICAgICAgICAgIGRhdGVFbnY6IG9wdGlvbnNEYXRhLmRhdGVFbnYsXG4gICAgICAgICAgICBjYWxlbmRhckFwaTogdGhpcy5wcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIHNsb3RNaW5UaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWluVGltZSxcbiAgICAgICAgICAgIHNsb3RNYXhUaW1lOiByZWZpbmVkT3B0aW9ucy5zbG90TWF4VGltZSxcbiAgICAgICAgICAgIHNob3dOb25DdXJyZW50RGF0ZXM6IHJlZmluZWRPcHRpb25zLnNob3dOb25DdXJyZW50RGF0ZXMsXG4gICAgICAgICAgICBkYXlDb3VudDogcmVmaW5lZE9wdGlvbnMuZGF5Q291bnQsXG4gICAgICAgICAgICBkYXRlQWxpZ25tZW50OiByZWZpbmVkT3B0aW9ucy5kYXRlQWxpZ25tZW50LFxuICAgICAgICAgICAgZGF0ZUluY3JlbWVudDogcmVmaW5lZE9wdGlvbnMuZGF0ZUluY3JlbWVudCxcbiAgICAgICAgICAgIGhpZGRlbkRheXM6IHJlZmluZWRPcHRpb25zLmhpZGRlbkRheXMsXG4gICAgICAgICAgICB3ZWVrZW5kczogcmVmaW5lZE9wdGlvbnMud2Vla2VuZHMsXG4gICAgICAgICAgICBub3dJbnB1dDogcmVmaW5lZE9wdGlvbnMubm93LFxuICAgICAgICAgICAgdmFsaWRSYW5nZUlucHV0OiByZWZpbmVkT3B0aW9ucy52YWxpZFJhbmdlLFxuICAgICAgICAgICAgdmlzaWJsZVJhbmdlSW5wdXQ6IHJlZmluZWRPcHRpb25zLnZpc2libGVSYW5nZSxcbiAgICAgICAgICAgIG1vbnRoTW9kZTogcmVmaW5lZE9wdGlvbnMubW9udGhNb2RlLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHJlZmluZWRPcHRpb25zLmZpeGVkV2Vla0NvdW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZpZXdBcGkgPSB0aGlzLmJ1aWxkVmlld0FwaSh2aWV3VHlwZSwgdGhpcy5nZXRDdXJyZW50RGF0YSwgb3B0aW9uc0RhdGEuZGF0ZUVudik7XG4gICAgICAgIHJldHVybiB7IHZpZXdTcGVjOiB2aWV3U3BlYywgb3B0aW9uczogcmVmaW5lZE9wdGlvbnMsIGRhdGVQcm9maWxlR2VuZXJhdG9yOiBkYXRlUHJvZmlsZUdlbmVyYXRvciwgdmlld0FwaTogdmlld0FwaSB9O1xuICAgIH07XG4gICAgQ2FsZW5kYXJEYXRhTWFuYWdlci5wcm90b3R5cGUucHJvY2Vzc1Jhd1ZpZXdPcHRpb25zID0gZnVuY3Rpb24gKHZpZXdTcGVjLCBwbHVnaW5Ib29rcywgbG9jYWxlRGVmYXVsdHMsIG9wdGlvbk92ZXJyaWRlcywgZHluYW1pY09wdGlvbk92ZXJyaWRlcykge1xuICAgICAgICB2YXIgcmF3ID0gbWVyZ2VSYXdPcHRpb25zKFtcbiAgICAgICAgICAgIEJBU0VfT1BUSU9OX0RFRkFVTFRTLFxuICAgICAgICAgICAgdmlld1NwZWMub3B0aW9uRGVmYXVsdHMsXG4gICAgICAgICAgICBsb2NhbGVEZWZhdWx0cyxcbiAgICAgICAgICAgIG9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIHZpZXdTcGVjLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGR5bmFtaWNPcHRpb25PdmVycmlkZXMsXG4gICAgICAgIF0pO1xuICAgICAgICB2YXIgcmVmaW5lcnMgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgQkFTRV9PUFRJT05fUkVGSU5FUlMpLCBDQUxFTkRBUl9MSVNURU5FUl9SRUZJTkVSUyksIENBTEVOREFSX09QVElPTl9SRUZJTkVSUyksIFZJRVdfT1BUSU9OX1JFRklORVJTKSwgcGx1Z2luSG9va3MubGlzdGVuZXJSZWZpbmVycyksIHBsdWdpbkhvb2tzLm9wdGlvblJlZmluZXJzKTtcbiAgICAgICAgdmFyIHJlZmluZWQgPSB7fTtcbiAgICAgICAgdmFyIGN1cnJlbnRSYXcgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0O1xuICAgICAgICB2YXIgY3VycmVudFJlZmluZWQgPSB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQ7XG4gICAgICAgIHZhciBhbnlDaGFuZ2VzID0gZmFsc2U7XG4gICAgICAgIHZhciBleHRyYSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBvcHRpb25OYW1lIGluIHJhdykge1xuICAgICAgICAgICAgaWYgKHJhd1tvcHRpb25OYW1lXSA9PT0gY3VycmVudFJhd1tvcHRpb25OYW1lXSB8fFxuICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICBDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0sIGN1cnJlbnRSYXdbb3B0aW9uTmFtZV0pKSkge1xuICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSBjdXJyZW50UmVmaW5lZFtvcHRpb25OYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyYXdbb3B0aW9uTmFtZV0gPT09IHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc0lucHV0W29wdGlvbk5hbWVdIHx8XG4gICAgICAgICAgICAgICAgICAgIChDT01QTEVYX09QVElPTl9DT01QQVJBVE9SU1tvcHRpb25OYW1lXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlNbb3B0aW9uTmFtZV0ocmF3W29wdGlvbk5hbWVdLCB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dFtvcHRpb25OYW1lXSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25OYW1lIGluIHRoaXMuY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQpIHsgLy8gbWlnaHQgYmUgYW4gXCJleHRyYVwiIHByb3BcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSB0aGlzLmN1cnJlbnRDYWxlbmRhck9wdGlvbnNSZWZpbmVkW29wdGlvbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlZmluZXJzW29wdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZmluZWRbb3B0aW9uTmFtZV0gPSByZWZpbmVyc1tvcHRpb25OYW1lXShyYXdbb3B0aW9uTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFbb3B0aW9uTmFtZV0gPSByYXdbb3B0aW9uTmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFueUNoYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChhbnlDaGFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc0lucHV0ID0gcmF3O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlld09wdGlvbnNSZWZpbmVkID0gcmVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcmF3T3B0aW9uczogdGhpcy5jdXJyZW50Vmlld09wdGlvbnNJbnB1dCxcbiAgICAgICAgICAgIHJlZmluZWRPcHRpb25zOiB0aGlzLmN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQsXG4gICAgICAgICAgICBleHRyYTogZXh0cmEsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJEYXRhTWFuYWdlcjtcbn0oKSk7XG5mdW5jdGlvbiBidWlsZERhdGVFbnYodGltZVpvbmUsIGV4cGxpY2l0TG9jYWxlLCB3ZWVrTnVtYmVyQ2FsY3VsYXRpb24sIGZpcnN0RGF5LCB3ZWVrVGV4dCwgcGx1Z2luSG9va3MsIGF2YWlsYWJsZUxvY2FsZURhdGEsIGRlZmF1bHRTZXBhcmF0b3IpIHtcbiAgICB2YXIgbG9jYWxlID0gYnVpbGRMb2NhbGUoZXhwbGljaXRMb2NhbGUgfHwgYXZhaWxhYmxlTG9jYWxlRGF0YS5kZWZhdWx0Q29kZSwgYXZhaWxhYmxlTG9jYWxlRGF0YS5tYXApO1xuICAgIHJldHVybiBuZXcgRGF0ZUVudih7XG4gICAgICAgIGNhbGVuZGFyU3lzdGVtOiAnZ3JlZ29yeScsXG4gICAgICAgIHRpbWVab25lOiB0aW1lWm9uZSxcbiAgICAgICAgbmFtZWRUaW1lWm9uZUltcGw6IHBsdWdpbkhvb2tzLm5hbWVkVGltZVpvbmVkSW1wbCxcbiAgICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICAgIHdlZWtOdW1iZXJDYWxjdWxhdGlvbjogd2Vla051bWJlckNhbGN1bGF0aW9uLFxuICAgICAgICBmaXJzdERheTogZmlyc3REYXksXG4gICAgICAgIHdlZWtUZXh0OiB3ZWVrVGV4dCxcbiAgICAgICAgY21kRm9ybWF0dGVyOiBwbHVnaW5Ib29rcy5jbWRGb3JtYXR0ZXIsXG4gICAgICAgIGRlZmF1bHRTZXBhcmF0b3I6IGRlZmF1bHRTZXBhcmF0b3IsXG4gICAgfSk7XG59XG5mdW5jdGlvbiBidWlsZFRoZW1lKG9wdGlvbnMsIHBsdWdpbkhvb2tzKSB7XG4gICAgdmFyIFRoZW1lQ2xhc3MgPSBwbHVnaW5Ib29rcy50aGVtZUNsYXNzZXNbb3B0aW9ucy50aGVtZVN5c3RlbV0gfHwgU3RhbmRhcmRUaGVtZTtcbiAgICByZXR1cm4gbmV3IFRoZW1lQ2xhc3Mob3B0aW9ucyk7XG59XG5mdW5jdGlvbiBidWlsZERhdGVQcm9maWxlR2VuZXJhdG9yKHByb3BzKSB7XG4gICAgdmFyIERhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MgPSBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIHx8IERhdGVQcm9maWxlR2VuZXJhdG9yO1xuICAgIHJldHVybiBuZXcgRGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyhwcm9wcyk7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdBcGkodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpIHtcbiAgICByZXR1cm4gbmV3IFZpZXdBcGkodHlwZSwgZ2V0Q3VycmVudERhdGEsIGRhdGVFbnYpO1xufVxuZnVuY3Rpb24gYnVpbGRFdmVudFVpQnlTb3VyY2UoZXZlbnRTb3VyY2VzKSB7XG4gICAgcmV0dXJuIG1hcEhhc2goZXZlbnRTb3VyY2VzLCBmdW5jdGlvbiAoZXZlbnRTb3VyY2UpIHsgcmV0dXJuIGV2ZW50U291cmNlLnVpOyB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRXZlbnRVaUJhc2VzKGV2ZW50RGVmcywgZXZlbnRVaVNpbmdsZUJhc2UsIGV2ZW50VWlCeVNvdXJjZSkge1xuICAgIHZhciBldmVudFVpQmFzZXMgPSB7ICcnOiBldmVudFVpU2luZ2xlQmFzZSB9O1xuICAgIGZvciAodmFyIGRlZklkIGluIGV2ZW50RGVmcykge1xuICAgICAgICB2YXIgZGVmID0gZXZlbnREZWZzW2RlZklkXTtcbiAgICAgICAgaWYgKGRlZi5zb3VyY2VJZCAmJiBldmVudFVpQnlTb3VyY2VbZGVmLnNvdXJjZUlkXSkge1xuICAgICAgICAgICAgZXZlbnRVaUJhc2VzW2RlZklkXSA9IGV2ZW50VWlCeVNvdXJjZVtkZWYuc291cmNlSWRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBldmVudFVpQmFzZXM7XG59XG5mdW5jdGlvbiBidWlsZFZpZXdVaVByb3BzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIHZhciBvcHRpb25zID0gY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZXZlbnRVaVNpbmdsZUJhc2U6IGNyZWF0ZUV2ZW50VWkoe1xuICAgICAgICAgICAgZGlzcGxheTogb3B0aW9ucy5ldmVudERpc3BsYXksXG4gICAgICAgICAgICBlZGl0YWJsZTogb3B0aW9ucy5lZGl0YWJsZSxcbiAgICAgICAgICAgIHN0YXJ0RWRpdGFibGU6IG9wdGlvbnMuZXZlbnRTdGFydEVkaXRhYmxlLFxuICAgICAgICAgICAgZHVyYXRpb25FZGl0YWJsZTogb3B0aW9ucy5ldmVudER1cmF0aW9uRWRpdGFibGUsXG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLmV2ZW50Q29uc3RyYWludCxcbiAgICAgICAgICAgIG92ZXJsYXA6IHR5cGVvZiBvcHRpb25zLmV2ZW50T3ZlcmxhcCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ldmVudE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5ldmVudEFsbG93LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBvcHRpb25zLmV2ZW50QmFja2dyb3VuZENvbG9yLFxuICAgICAgICAgICAgYm9yZGVyQ29sb3I6IG9wdGlvbnMuZXZlbnRCb3JkZXJDb2xvcixcbiAgICAgICAgICAgIHRleHRDb2xvcjogb3B0aW9ucy5ldmVudFRleHRDb2xvcixcbiAgICAgICAgICAgIGNvbG9yOiBvcHRpb25zLmV2ZW50Q29sb3IsXG4gICAgICAgICAgICAvLyBjbGFzc05hbWVzOiBvcHRpb25zLmV2ZW50Q2xhc3NOYW1lcyAvLyByZW5kZXIgaG9vayB3aWxsIGhhbmRsZSB0aGlzXG4gICAgICAgIH0sIGNhbGVuZGFyQ29udGV4dCksXG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZzogY3JlYXRlRXZlbnRVaSh7XG4gICAgICAgICAgICBjb25zdHJhaW50OiBvcHRpb25zLnNlbGVjdENvbnN0cmFpbnQsXG4gICAgICAgICAgICBvdmVybGFwOiB0eXBlb2Ygb3B0aW9ucy5zZWxlY3RPdmVybGFwID09PSAnYm9vbGVhbicgPyBvcHRpb25zLnNlbGVjdE92ZXJsYXAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5zZWxlY3RBbGxvdyxcbiAgICAgICAgfSwgY2FsZW5kYXJDb250ZXh0KSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUlzTG9hZGluZyhzdGF0ZSwgY29udGV4dCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBjb250ZXh0LnBsdWdpbkhvb2tzLmlzTG9hZGluZ0Z1bmNzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgaXNMb2FkaW5nRnVuYyA9IF9hW19pXTtcbiAgICAgICAgaWYgKGlzTG9hZGluZ0Z1bmMoc3RhdGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwYXJzZUNvbnRleHRCdXNpbmVzc0hvdXJzKGNhbGVuZGFyQ29udGV4dCkge1xuICAgIHJldHVybiBwYXJzZUJ1c2luZXNzSG91cnMoY2FsZW5kYXJDb250ZXh0Lm9wdGlvbnMuYnVzaW5lc3NIb3VycywgY2FsZW5kYXJDb250ZXh0KTtcbn1cbmZ1bmN0aW9uIHdhcm5Vbmtub3duT3B0aW9ucyhvcHRpb25zLCB2aWV3TmFtZSkge1xuICAgIGZvciAodmFyIG9wdGlvbk5hbWUgaW4gb3B0aW9ucykge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJVbmtub3duIG9wdGlvbiAnXCIgKyBvcHRpb25OYW1lICsgXCInXCIgK1xuICAgICAgICAgICAgKHZpZXdOYW1lID8gXCIgZm9yIHZpZXcgJ1wiICsgdmlld05hbWUgKyBcIidcIiA6ICcnKSk7XG4gICAgfVxufVxuXG4vLyBUT0RPOiBtb3ZlIHRoaXMgdG8gcmVhY3QgcGx1Z2luP1xudmFyIENhbGVuZGFyRGF0YVByb3ZpZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDYWxlbmRhckRhdGFQcm92aWRlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDYWxlbmRhckRhdGFQcm92aWRlcihwcm9wcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICBpZiAoIV90aGlzLmRhdGFNYW5hZ2VyKSB7IC8vIHN0aWxsIHdpdGhpbiBpbml0aWFsIHJ1biwgYmVmb3JlIGFzc2lnbm1lbnQgaW4gY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3Qvbm8tZGlyZWN0LW11dGF0aW9uLXN0YXRlXG4gICAgICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSBkYXRhOyAvLyBjYW4ndCB1c2Ugc2V0U3RhdGUgeWV0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuZGF0YU1hbmFnZXIgPSBuZXcgQ2FsZW5kYXJEYXRhTWFuYWdlcih7XG4gICAgICAgICAgICBvcHRpb25PdmVycmlkZXM6IHByb3BzLm9wdGlvbk92ZXJyaWRlcyxcbiAgICAgICAgICAgIGNhbGVuZGFyQXBpOiBwcm9wcy5jYWxlbmRhckFwaSxcbiAgICAgICAgICAgIG9uRGF0YTogX3RoaXMuaGFuZGxlRGF0YSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2FsZW5kYXJEYXRhUHJvdmlkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW4odGhpcy5zdGF0ZSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckRhdGFQcm92aWRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgbmV3T3B0aW9uT3ZlcnJpZGVzID0gdGhpcy5wcm9wcy5vcHRpb25PdmVycmlkZXM7XG4gICAgICAgIGlmIChuZXdPcHRpb25PdmVycmlkZXMgIT09IHByZXZQcm9wcy5vcHRpb25PdmVycmlkZXMpIHsgLy8gcHJldmVudCByZWN1cnNpdmUgaGFuZGxlRGF0YVxuICAgICAgICAgICAgdGhpcy5kYXRhTWFuYWdlci5yZXNldE9wdGlvbnMobmV3T3B0aW9uT3ZlcnJpZGVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIENhbGVuZGFyRGF0YVByb3ZpZGVyO1xufSh2ZG9tX2Nqcy5Db21wb25lbnQpKTtcblxuLy8gSEVMUEVSU1xuLypcbmlmIG5leHREYXlUaHJlc2hvbGQgaXMgc3BlY2lmaWVkLCBzbGljaW5nIGlzIGRvbmUgaW4gYW4gYWxsLWRheSBmYXNoaW9uLlxueW91IGNhbiBnZXQgbmV4dERheVRocmVzaG9sZCBmcm9tIGNvbnRleHQubmV4dERheVRocmVzaG9sZFxuKi9cbmZ1bmN0aW9uIHNsaWNlRXZlbnRzKHByb3BzLCBhbGxEYXkpIHtcbiAgICByZXR1cm4gc2xpY2VFdmVudFN0b3JlKHByb3BzLmV2ZW50U3RvcmUsIHByb3BzLmV2ZW50VWlCYXNlcywgcHJvcHMuZGF0ZVByb2ZpbGUuYWN0aXZlUmFuZ2UsIGFsbERheSA/IHByb3BzLm5leHREYXlUaHJlc2hvbGQgOiBudWxsKS5mZztcbn1cblxudmFyIE5hbWVkVGltZVpvbmVJbXBsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5hbWVkVGltZVpvbmVJbXBsKHRpbWVab25lTmFtZSkge1xuICAgICAgICB0aGlzLnRpbWVab25lTmFtZSA9IHRpbWVab25lTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIE5hbWVkVGltZVpvbmVJbXBsO1xufSgpKTtcblxudmFyIFNlZ0hpZXJhcmNoeSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTZWdIaWVyYXJjaHkoKSB7XG4gICAgICAgIC8vIHNldHRpbmdzXG4gICAgICAgIHRoaXMuc3RyaWN0T3JkZXIgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hbGxvd1Jlc2xpY2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1heENvb3JkID0gLTE7IC8vIC0xIG1lYW5zIG5vIG1heFxuICAgICAgICB0aGlzLm1heFN0YWNrQ250ID0gLTE7IC8vIC0xIG1lYW5zIG5vIG1heFxuICAgICAgICB0aGlzLmxldmVsQ29vcmRzID0gW107IC8vIG9yZGVyZWRcbiAgICAgICAgdGhpcy5lbnRyaWVzQnlMZXZlbCA9IFtdOyAvLyBwYXJhbGxlbCB3aXRoIGxldmVsQ29vcmRzXG4gICAgICAgIHRoaXMuc3RhY2tDbnRzID0ge307IC8vIFRPRE86IHVzZSBiZXR0ZXIgdGVjaG5pcXVlIT9cbiAgICB9XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5hZGRTZWdzID0gZnVuY3Rpb24gKGlucHV0cykge1xuICAgICAgICB2YXIgaGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGlucHV0c18xID0gaW5wdXRzOyBfaSA8IGlucHV0c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gaW5wdXRzXzFbX2ldO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRFbnRyeShpbnB1dCwgaGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhpZGRlbkVudHJpZXM7XG4gICAgfTtcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmluc2VydEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIHZhciBpbnNlcnRpb24gPSB0aGlzLmZpbmRJbnNlcnRpb24oZW50cnkpO1xuICAgICAgICBpZiAodGhpcy5pc0luc2VydGlvblZhbGlkKGluc2VydGlvbiwgZW50cnkpKSB7XG4gICAgICAgICAgICB0aGlzLmluc2VydEVudHJ5QXQoZW50cnksIGluc2VydGlvbik7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uKGluc2VydGlvbiwgZW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5pc0luc2VydGlvblZhbGlkID0gZnVuY3Rpb24gKGluc2VydGlvbiwgZW50cnkpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1heENvb3JkID09PSAtMSB8fCBpbnNlcnRpb24ubGV2ZWxDb29yZCArIGVudHJ5LnRoaWNrbmVzcyA8PSB0aGlzLm1heENvb3JkKSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4U3RhY2tDbnQgPT09IC0xIHx8IGluc2VydGlvbi5zdGFja0NudCA8IHRoaXMubWF4U3RhY2tDbnQpO1xuICAgIH07XG4gICAgLy8gcmV0dXJucyBudW1iZXIgb2YgbmV3IGVudHJpZXMgaW5zZXJ0ZWRcbiAgICBTZWdIaWVyYXJjaHkucHJvdG90eXBlLmhhbmRsZUludmFsaWRJbnNlcnRpb24gPSBmdW5jdGlvbiAoaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICBpZiAodGhpcy5hbGxvd1Jlc2xpY2luZyAmJiBpbnNlcnRpb24udG91Y2hpbmdFbnRyeSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaXRFbnRyeShlbnRyeSwgaW5zZXJ0aW9uLnRvdWNoaW5nRW50cnksIGhpZGRlbkVudHJpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5zcGxpdEVudHJ5ID0gZnVuY3Rpb24gKGVudHJ5LCBiYXJyaWVyLCBoaWRkZW5FbnRyaWVzKSB7XG4gICAgICAgIHZhciBwYXJ0Q250ID0gMDtcbiAgICAgICAgdmFyIHNwbGl0SGlkZGVuRW50cmllcyA9IFtdO1xuICAgICAgICB2YXIgZW50cnlTcGFuID0gZW50cnkuc3BhbjtcbiAgICAgICAgdmFyIGJhcnJpZXJTcGFuID0gYmFycmllci5zcGFuO1xuICAgICAgICBpZiAoZW50cnlTcGFuLnN0YXJ0IDwgYmFycmllclNwYW4uc3RhcnQpIHtcbiAgICAgICAgICAgIHBhcnRDbnQgKz0gdGhpcy5pbnNlcnRFbnRyeSh7XG4gICAgICAgICAgICAgICAgaW5kZXg6IGVudHJ5LmluZGV4LFxuICAgICAgICAgICAgICAgIHRoaWNrbmVzczogZW50cnkudGhpY2tuZXNzLFxuICAgICAgICAgICAgICAgIHNwYW46IHsgc3RhcnQ6IGVudHJ5U3Bhbi5zdGFydCwgZW5kOiBiYXJyaWVyU3Bhbi5zdGFydCB9LFxuICAgICAgICAgICAgfSwgc3BsaXRIaWRkZW5FbnRyaWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlTcGFuLmVuZCA+IGJhcnJpZXJTcGFuLmVuZCkge1xuICAgICAgICAgICAgcGFydENudCArPSB0aGlzLmluc2VydEVudHJ5KHtcbiAgICAgICAgICAgICAgICBpbmRleDogZW50cnkuaW5kZXgsXG4gICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgc3BhbjogeyBzdGFydDogYmFycmllclNwYW4uZW5kLCBlbmQ6IGVudHJ5U3Bhbi5lbmQgfSxcbiAgICAgICAgICAgIH0sIHNwbGl0SGlkZGVuRW50cmllcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRDbnQpIHtcbiAgICAgICAgICAgIGhpZGRlbkVudHJpZXMucHVzaC5hcHBseShoaWRkZW5FbnRyaWVzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFt7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBlbnRyeS5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgdGhpY2tuZXNzOiBlbnRyeS50aGlja25lc3MsXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGludGVyc2VjdFNwYW5zKGJhcnJpZXJTcGFuLCBlbnRyeVNwYW4pLCAvLyBndWFyYW50ZWVkIHRvIGludGVyc2VjdFxuICAgICAgICAgICAgICAgIH1dLCBzcGxpdEhpZGRlbkVudHJpZXMpKTtcbiAgICAgICAgICAgIHJldHVybiBwYXJ0Q250O1xuICAgICAgICB9XG4gICAgICAgIGhpZGRlbkVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS5pbnNlcnRFbnRyeUF0ID0gZnVuY3Rpb24gKGVudHJ5LCBpbnNlcnRpb24pIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgZW50cmllc0J5TGV2ZWwgPSBfYS5lbnRyaWVzQnlMZXZlbCwgbGV2ZWxDb29yZHMgPSBfYS5sZXZlbENvb3JkcztcbiAgICAgICAgaWYgKGluc2VydGlvbi5sYXRlcmFsID09PSAtMSkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGxldmVsXG4gICAgICAgICAgICBpbnNlcnRBdChsZXZlbENvb3JkcywgaW5zZXJ0aW9uLmxldmVsLCBpbnNlcnRpb24ubGV2ZWxDb29yZCk7XG4gICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbCwgaW5zZXJ0aW9uLmxldmVsLCBbZW50cnldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluc2VydCBpbnRvIGV4aXN0aW5nIGxldmVsXG4gICAgICAgICAgICBpbnNlcnRBdChlbnRyaWVzQnlMZXZlbFtpbnNlcnRpb24ubGV2ZWxdLCBpbnNlcnRpb24ubGF0ZXJhbCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhY2tDbnRzW2J1aWxkRW50cnlLZXkoZW50cnkpXSA9IGluc2VydGlvbi5zdGFja0NudDtcbiAgICB9O1xuICAgIFNlZ0hpZXJhcmNoeS5wcm90b3R5cGUuZmluZEluc2VydGlvbiA9IGZ1bmN0aW9uIChuZXdFbnRyeSkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBzdHJpY3RPcmRlciA9IF9hLnN0cmljdE9yZGVyLCBzdGFja0NudHMgPSBfYS5zdGFja0NudHM7XG4gICAgICAgIHZhciBsZXZlbENudCA9IGxldmVsQ29vcmRzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUNvb3JkID0gMDtcbiAgICAgICAgdmFyIHRvdWNoaW5nTGV2ZWwgPSAtMTtcbiAgICAgICAgdmFyIHRvdWNoaW5nTGF0ZXJhbCA9IC0xO1xuICAgICAgICB2YXIgdG91Y2hpbmdFbnRyeSA9IG51bGw7XG4gICAgICAgIHZhciBzdGFja0NudCA9IDA7XG4gICAgICAgIGZvciAodmFyIHRyYWNraW5nTGV2ZWwgPSAwOyB0cmFja2luZ0xldmVsIDwgbGV2ZWxDbnQ7IHRyYWNraW5nTGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgdmFyIHRyYWNraW5nQ29vcmQgPSBsZXZlbENvb3Jkc1t0cmFja2luZ0xldmVsXTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjdXJyZW50IGxldmVsIGlzIHBhc3QgdGhlIHBsYWNlZCBlbnRyeSwgd2UgaGF2ZSBmb3VuZCBhIGdvb2QgZW1wdHkgc3BhY2UgYW5kIGNhbiBzdG9wLlxuICAgICAgICAgICAgLy8gaWYgc3RyaWN0T3JkZXIsIGtlZXAgZmluZGluZyBtb3JlIGxhdGVyYWwgaW50ZXJzZWN0aW9ucy5cbiAgICAgICAgICAgIGlmICghc3RyaWN0T3JkZXIgJiYgdHJhY2tpbmdDb29yZCA+PSBjYW5kaWRhdGVDb29yZCArIG5ld0VudHJ5LnRoaWNrbmVzcykge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRyYWNraW5nRW50cmllcyA9IGVudHJpZXNCeUxldmVsW3RyYWNraW5nTGV2ZWxdO1xuICAgICAgICAgICAgdmFyIHRyYWNraW5nRW50cnkgPSB2b2lkIDA7XG4gICAgICAgICAgICB2YXIgc2VhcmNoUmVzID0gYmluYXJ5U2VhcmNoKHRyYWNraW5nRW50cmllcywgbmV3RW50cnkuc3Bhbi5zdGFydCwgZ2V0RW50cnlTcGFuRW5kKTsgLy8gZmluZCBmaXJzdCBlbnRyeSBhZnRlciBuZXdFbnRyeSdzIGVuZFxuICAgICAgICAgICAgdmFyIGxhdGVyYWxJbmRleCA9IHNlYXJjaFJlc1swXSArIHNlYXJjaFJlc1sxXTsgLy8gaWYgZXhhY3QgbWF0Y2ggKHdoaWNoIGRvZXNuJ3QgY29sbGlkZSksIGdvIHRvIG5leHQgb25lXG4gICAgICAgICAgICB3aGlsZSAoIC8vIGxvb3AgdGhyb3VnaCBlbnRyaWVzIHRoYXQgaG9yaXpvbnRhbGx5IGludGVyc2VjdFxuICAgICAgICAgICAgKHRyYWNraW5nRW50cnkgPSB0cmFja2luZ0VudHJpZXNbbGF0ZXJhbEluZGV4XSkgJiYgLy8gYnV0IG5vdCBwYXN0IHRoZSB3aG9sZSBlbnRyeSBsaXN0XG4gICAgICAgICAgICAgICAgdHJhY2tpbmdFbnRyeS5zcGFuLnN0YXJ0IDwgbmV3RW50cnkuc3Bhbi5lbmQgLy8gYW5kIG5vdCBlbnRpcmVseSBwYXN0IG5ld0VudHJ5XG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhY2tpbmdFbnRyeUJvdHRvbSA9IHRyYWNraW5nQ29vcmQgKyB0cmFja2luZ0VudHJ5LnRoaWNrbmVzcztcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnNlY3RzIGludG8gdGhlIHRvcCBvZiB0aGUgY2FuZGlkYXRlP1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID4gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlQ29vcmQgPSB0cmFja2luZ0VudHJ5Qm90dG9tO1xuICAgICAgICAgICAgICAgICAgICB0b3VjaGluZ0VudHJ5ID0gdHJhY2tpbmdFbnRyeTtcbiAgICAgICAgICAgICAgICAgICAgdG91Y2hpbmdMZXZlbCA9IHRyYWNraW5nTGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIHRvdWNoaW5nTGF0ZXJhbCA9IGxhdGVyYWxJbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gYnV0dHMgdXAgYWdhaW5zdCB0b3Agb2YgY2FuZGlkYXRlPyAod2lsbCBoYXBwZW4gaWYganVzdCBpbnRlcnNlY3RlZCBhcyB3ZWxsKVxuICAgICAgICAgICAgICAgIGlmICh0cmFja2luZ0VudHJ5Qm90dG9tID09PSBjYW5kaWRhdGVDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhY2N1bXVsYXRlIHRoZSBoaWdoZXN0IHBvc3NpYmxlIHN0YWNrQ250IG9mIHRoZSB0cmFja2luZ0VudHJpZXMgdGhhdCBidXR0IHVwXG4gICAgICAgICAgICAgICAgICAgIHN0YWNrQ250ID0gTWF0aC5tYXgoc3RhY2tDbnQsIHN0YWNrQ250c1tidWlsZEVudHJ5S2V5KHRyYWNraW5nRW50cnkpXSArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXRlcmFsSW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGVzdGluYXRpb24gbGV2ZWwgd2lsbCBiZSBhZnRlciB0b3VjaGluZ0VudHJ5J3MgbGV2ZWwuIGZpbmQgaXRcbiAgICAgICAgdmFyIGRlc3RMZXZlbCA9IDA7XG4gICAgICAgIGlmICh0b3VjaGluZ0VudHJ5KSB7XG4gICAgICAgICAgICBkZXN0TGV2ZWwgPSB0b3VjaGluZ0xldmVsICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChkZXN0TGV2ZWwgPCBsZXZlbENudCAmJiBsZXZlbENvb3Jkc1tkZXN0TGV2ZWxdIDwgY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgICAgICBkZXN0TGV2ZWwgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhZGRpbmcgdG8gYW4gZXhpc3RpbmcgbGV2ZWwsIGZpbmQgd2hlcmUgdG8gaW5zZXJ0XG4gICAgICAgIHZhciBkZXN0TGF0ZXJhbCA9IC0xO1xuICAgICAgICBpZiAoZGVzdExldmVsIDwgbGV2ZWxDbnQgJiYgbGV2ZWxDb29yZHNbZGVzdExldmVsXSA9PT0gY2FuZGlkYXRlQ29vcmQpIHtcbiAgICAgICAgICAgIGRlc3RMYXRlcmFsID0gYmluYXJ5U2VhcmNoKGVudHJpZXNCeUxldmVsW2Rlc3RMZXZlbF0sIG5ld0VudHJ5LnNwYW4uZW5kLCBnZXRFbnRyeVNwYW5FbmQpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b3VjaGluZ0xldmVsOiB0b3VjaGluZ0xldmVsLFxuICAgICAgICAgICAgdG91Y2hpbmdMYXRlcmFsOiB0b3VjaGluZ0xhdGVyYWwsXG4gICAgICAgICAgICB0b3VjaGluZ0VudHJ5OiB0b3VjaGluZ0VudHJ5LFxuICAgICAgICAgICAgc3RhY2tDbnQ6IHN0YWNrQ250LFxuICAgICAgICAgICAgbGV2ZWxDb29yZDogY2FuZGlkYXRlQ29vcmQsXG4gICAgICAgICAgICBsZXZlbDogZGVzdExldmVsLFxuICAgICAgICAgICAgbGF0ZXJhbDogZGVzdExhdGVyYWwsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvLyBzb3J0ZWQgYnkgbGV2ZWxDb29yZCAobG93ZXN0IHRvIGhpZ2hlc3QpXG4gICAgU2VnSGllcmFyY2h5LnByb3RvdHlwZS50b1JlY3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBsZXZlbENvb3JkcyA9IF9hLmxldmVsQ29vcmRzO1xuICAgICAgICB2YXIgbGV2ZWxDbnQgPSBlbnRyaWVzQnlMZXZlbC5sZW5ndGg7XG4gICAgICAgIHZhciByZWN0cyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBsZXZlbCA9IDA7IGxldmVsIDwgbGV2ZWxDbnQ7IGxldmVsICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdO1xuICAgICAgICAgICAgdmFyIGxldmVsQ29vcmQgPSBsZXZlbENvb3Jkc1tsZXZlbF07XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGVudHJpZXNfMSA9IGVudHJpZXM7IF9pIDwgZW50cmllc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgcmVjdHMucHVzaCh0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZW50cnkpLCB7IGxldmVsQ29vcmQ6IGxldmVsQ29vcmQgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZWN0cztcbiAgICB9O1xuICAgIHJldHVybiBTZWdIaWVyYXJjaHk7XG59KCkpO1xuZnVuY3Rpb24gZ2V0RW50cnlTcGFuRW5kKGVudHJ5KSB7XG4gICAgcmV0dXJuIGVudHJ5LnNwYW4uZW5kO1xufVxuZnVuY3Rpb24gYnVpbGRFbnRyeUtleShlbnRyeSkge1xuICAgIHJldHVybiBlbnRyeS5pbmRleCArICc6JyArIGVudHJ5LnNwYW4uc3RhcnQ7XG59XG4vLyByZXR1cm5zIGdyb3VwcyB3aXRoIGVudHJpZXMgc29ydGVkIGJ5IGlucHV0IG9yZGVyXG5mdW5jdGlvbiBncm91cEludGVyc2VjdGluZ0VudHJpZXMoZW50cmllcykge1xuICAgIHZhciBtZXJnZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGVudHJpZXNfMiA9IGVudHJpZXM7IF9pIDwgZW50cmllc18yLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzXzJbX2ldO1xuICAgICAgICB2YXIgZmlsdGVyZWRNZXJnZXMgPSBbXTtcbiAgICAgICAgdmFyIGh1bmdyeU1lcmdlID0ge1xuICAgICAgICAgICAgc3BhbjogZW50cnkuc3BhbixcbiAgICAgICAgICAgIGVudHJpZXM6IFtlbnRyeV0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgbWVyZ2VzXzEgPSBtZXJnZXM7IF9hIDwgbWVyZ2VzXzEubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVyZ2UgPSBtZXJnZXNfMVtfYV07XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0U3BhbnMobWVyZ2Uuc3BhbiwgaHVuZ3J5TWVyZ2Uuc3BhbikpIHtcbiAgICAgICAgICAgICAgICBodW5ncnlNZXJnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZW50cmllczogbWVyZ2UuZW50cmllcy5jb25jYXQoaHVuZ3J5TWVyZ2UuZW50cmllcyksXG4gICAgICAgICAgICAgICAgICAgIHNwYW46IGpvaW5TcGFucyhtZXJnZS5zcGFuLCBodW5ncnlNZXJnZS5zcGFuKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChtZXJnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmlsdGVyZWRNZXJnZXMucHVzaChodW5ncnlNZXJnZSk7XG4gICAgICAgIG1lcmdlcyA9IGZpbHRlcmVkTWVyZ2VzO1xuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VzO1xufVxuZnVuY3Rpb24gam9pblNwYW5zKHNwYW4wLCBzcGFuMSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBNYXRoLm1pbihzcGFuMC5zdGFydCwgc3BhbjEuc3RhcnQpLFxuICAgICAgICBlbmQ6IE1hdGgubWF4KHNwYW4wLmVuZCwgc3BhbjEuZW5kKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0U3BhbnMoc3BhbjAsIHNwYW4xKSB7XG4gICAgdmFyIHN0YXJ0ID0gTWF0aC5tYXgoc3BhbjAuc3RhcnQsIHNwYW4xLnN0YXJ0KTtcbiAgICB2YXIgZW5kID0gTWF0aC5taW4oc3BhbjAuZW5kLCBzcGFuMS5lbmQpO1xuICAgIGlmIChzdGFydCA8IGVuZCkge1xuICAgICAgICByZXR1cm4geyBzdGFydDogc3RhcnQsIGVuZDogZW5kIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuLy8gZ2VuZXJhbCB1dGlsXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGluc2VydEF0KGFyciwgaW5kZXgsIGl0ZW0pIHtcbiAgICBhcnIuc3BsaWNlKGluZGV4LCAwLCBpdGVtKTtcbn1cbmZ1bmN0aW9uIGJpbmFyeVNlYXJjaChhLCBzZWFyY2hWYWwsIGdldEl0ZW1WYWwpIHtcbiAgICB2YXIgc3RhcnRJbmRleCA9IDA7XG4gICAgdmFyIGVuZEluZGV4ID0gYS5sZW5ndGg7IC8vIGV4Y2x1c2l2ZVxuICAgIGlmICghZW5kSW5kZXggfHwgc2VhcmNoVmFsIDwgZ2V0SXRlbVZhbChhW3N0YXJ0SW5kZXhdKSkgeyAvLyBubyBpdGVtcyBPUiBiZWZvcmUgZmlyc3QgaXRlbVxuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH1cbiAgICBpZiAoc2VhcmNoVmFsID4gZ2V0SXRlbVZhbChhW2VuZEluZGV4IC0gMV0pKSB7IC8vIGFmdGVyIGxhc3QgaXRlbVxuICAgICAgICByZXR1cm4gW2VuZEluZGV4LCAwXTtcbiAgICB9XG4gICAgd2hpbGUgKHN0YXJ0SW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICB2YXIgbWlkZGxlSW5kZXggPSBNYXRoLmZsb29yKHN0YXJ0SW5kZXggKyAoZW5kSW5kZXggLSBzdGFydEluZGV4KSAvIDIpO1xuICAgICAgICB2YXIgbWlkZGxlVmFsID0gZ2V0SXRlbVZhbChhW21pZGRsZUluZGV4XSk7XG4gICAgICAgIGlmIChzZWFyY2hWYWwgPCBtaWRkbGVWYWwpIHtcbiAgICAgICAgICAgIGVuZEluZGV4ID0gbWlkZGxlSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VhcmNoVmFsID4gbWlkZGxlVmFsKSB7XG4gICAgICAgICAgICBzdGFydEluZGV4ID0gbWlkZGxlSW5kZXggKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBlcXVhbCFcbiAgICAgICAgICAgIHJldHVybiBbbWlkZGxlSW5kZXgsIDFdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbc3RhcnRJbmRleCwgMF07XG59XG5cbnZhciBJbnRlcmFjdGlvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBJbnRlcmFjdGlvbihzZXR0aW5ncykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudCA9IHNldHRpbmdzLmNvbXBvbmVudDtcbiAgICAgICAgdGhpcy5pc0hpdENvbWJvQWxsb3dlZCA9IHNldHRpbmdzLmlzSGl0Q29tYm9BbGxvd2VkIHx8IG51bGw7XG4gICAgfVxuICAgIEludGVyYWN0aW9uLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgcmV0dXJuIEludGVyYWN0aW9uO1xufSgpKTtcbmZ1bmN0aW9uIHBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyhjb21wb25lbnQsIGlucHV0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gICAgICAgIGVsOiBpbnB1dC5lbCxcbiAgICAgICAgdXNlRXZlbnRDZW50ZXI6IGlucHV0LnVzZUV2ZW50Q2VudGVyICE9IG51bGwgPyBpbnB1dC51c2VFdmVudENlbnRlciA6IHRydWUsXG4gICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBpbnB1dC5pc0hpdENvbWJvQWxsb3dlZCB8fCBudWxsLFxuICAgIH07XG59XG5mdW5jdGlvbiBpbnRlcmFjdGlvblNldHRpbmdzVG9TdG9yZShzZXR0aW5ncykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX2EgPSB7fSxcbiAgICAgICAgX2Fbc2V0dGluZ3MuY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncyxcbiAgICAgICAgX2E7XG59XG4vLyBnbG9iYWwgc3RhdGVcbnZhciBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSB7fTtcblxuLypcbkFuIGFic3RyYWN0aW9uIGZvciBhIGRyYWdnaW5nIGludGVyYWN0aW9uIG9yaWdpbmF0aW5nIG9uIGFuIGV2ZW50LlxuRG9lcyBoaWdoZXItbGV2ZWwgdGhpbmdzIHRoYW4gUG9pbnRlckRyYWdnZXIsIHN1Y2ggYXMgcG9zc2libHk6XG4tIGEgXCJtaXJyb3JcIiB0aGF0IG1vdmVzIHdpdGggdGhlIHBvaW50ZXJcbi0gYSBtaW5pbXVtIG51bWJlciBvZiBwaXhlbHMgb3Igb3RoZXIgY3JpdGVyaWEgZm9yIGEgdHJ1ZSBkcmFnIHRvIGJlZ2luXG5cbnN1YmNsYXNzZXMgbXVzdCBlbWl0OlxuLSBwb2ludGVyZG93blxuLSBkcmFnc3RhcnRcbi0gZHJhZ21vdmVcbi0gcG9pbnRlcnVwXG4tIGRyYWdlbmRcbiovXG52YXIgRWxlbWVudERyYWdnaW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsZW1lbnREcmFnZ2luZyhlbCwgc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5lbWl0dGVyID0gbmV3IEVtaXR0ZXIoKTtcbiAgICB9XG4gICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JJc1Zpc2libGUgPSBmdW5jdGlvbiAoYm9vbCkge1xuICAgICAgICAvLyBvcHRpb25hbCBpZiBzdWJjbGFzcyBkb2Vzbid0IHdhbnQgdG8gc3VwcG9ydCBhIG1pcnJvclxuICAgIH07XG4gICAgRWxlbWVudERyYWdnaW5nLnByb3RvdHlwZS5zZXRNaXJyb3JOZWVkc1JldmVydCA9IGZ1bmN0aW9uIChib29sKSB7XG4gICAgICAgIC8vIG9wdGlvbmFsIGlmIHN1YmNsYXNzIGRvZXNuJ3Qgd2FudCB0byBzdXBwb3J0IGEgbWlycm9yXG4gICAgfTtcbiAgICBFbGVtZW50RHJhZ2dpbmcucHJvdG90eXBlLnNldEF1dG9TY3JvbGxFbmFibGVkID0gZnVuY3Rpb24gKGJvb2wpIHtcbiAgICAgICAgLy8gb3B0aW9uYWxcbiAgICB9O1xuICAgIHJldHVybiBFbGVtZW50RHJhZ2dpbmc7XG59KCkpO1xuXG4vLyBUT0RPOiBnZXQgcmlkIG9mIHRoaXMgaW4gZmF2b3Igb2Ygb3B0aW9ucyBzeXN0ZW0sXG4vLyB0aG8gaXQncyByZWFsbHkgZWFzeSB0byBhY2Nlc3MgdGhpcyBnbG9iYWxseSByYXRoZXIgdGhhbiBwYXNzIHRocnUgb3B0aW9ucy5cbnZhciBjb25maWcgPSB7fTtcblxuLypcbkluZm9ybWF0aW9uIGFib3V0IHdoYXQgd2lsbCBoYXBwZW4gd2hlbiBhbiBleHRlcm5hbCBlbGVtZW50IGlzIGRyYWdnZWQtYW5kLWRyb3BwZWRcbm9udG8gYSBjYWxlbmRhci4gQ29udGFpbnMgaW5mb3JtYXRpb24gZm9yIGNyZWF0aW5nIGFuIGV2ZW50LlxuKi9cbnZhciBEUkFHX01FVEFfUkVGSU5FUlMgPSB7XG4gICAgc3RhcnRUaW1lOiBjcmVhdGVEdXJhdGlvbixcbiAgICBkdXJhdGlvbjogY3JlYXRlRHVyYXRpb24sXG4gICAgY3JlYXRlOiBCb29sZWFuLFxuICAgIHNvdXJjZUlkOiBTdHJpbmcsXG59O1xuZnVuY3Rpb24gcGFyc2VEcmFnTWV0YShyYXcpIHtcbiAgICB2YXIgX2EgPSByZWZpbmVQcm9wcyhyYXcsIERSQUdfTUVUQV9SRUZJTkVSUyksIHJlZmluZWQgPSBfYS5yZWZpbmVkLCBleHRyYSA9IF9hLmV4dHJhO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0VGltZTogcmVmaW5lZC5zdGFydFRpbWUgfHwgbnVsbCxcbiAgICAgICAgZHVyYXRpb246IHJlZmluZWQuZHVyYXRpb24gfHwgbnVsbCxcbiAgICAgICAgY3JlYXRlOiByZWZpbmVkLmNyZWF0ZSAhPSBudWxsID8gcmVmaW5lZC5jcmVhdGUgOiB0cnVlLFxuICAgICAgICBzb3VyY2VJZDogcmVmaW5lZC5zb3VyY2VJZCxcbiAgICAgICAgbGVmdG92ZXJQcm9wczogZXh0cmEsXG4gICAgfTtcbn1cblxudmFyIFRvb2xiYXJTZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUb29sYmFyU2VjdGlvbiwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUb29sYmFyU2VjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUb29sYmFyU2VjdGlvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLnByb3BzLndpZGdldEdyb3Vwcy5tYXAoZnVuY3Rpb24gKHdpZGdldEdyb3VwKSB7IHJldHVybiBfdGhpcy5yZW5kZXJXaWRnZXRHcm91cCh3aWRnZXRHcm91cCk7IH0pO1xuICAgICAgICByZXR1cm4gdmRvbV9janMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoWydkaXYnLCB7IGNsYXNzTmFtZTogJ2ZjLXRvb2xiYXItY2h1bmsnIH1dLCBjaGlsZHJlbikpO1xuICAgIH07XG4gICAgVG9vbGJhclNlY3Rpb24ucHJvdG90eXBlLnJlbmRlcldpZGdldEdyb3VwID0gZnVuY3Rpb24gKHdpZGdldEdyb3VwKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciB0aGVtZSA9IHRoaXMuY29udGV4dC50aGVtZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gW107XG4gICAgICAgIHZhciBpc09ubHlCdXR0b25zID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCB3aWRnZXRHcm91cF8xID0gd2lkZ2V0R3JvdXA7IF9pIDwgd2lkZ2V0R3JvdXBfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciB3aWRnZXQgPSB3aWRnZXRHcm91cF8xW19pXTtcbiAgICAgICAgICAgIHZhciBidXR0b25OYW1lID0gd2lkZ2V0LmJ1dHRvbk5hbWUsIGJ1dHRvbkNsaWNrID0gd2lkZ2V0LmJ1dHRvbkNsaWNrLCBidXR0b25UZXh0ID0gd2lkZ2V0LmJ1dHRvblRleHQsIGJ1dHRvbkljb24gPSB3aWRnZXQuYnV0dG9uSWNvbiwgYnV0dG9uSGludCA9IHdpZGdldC5idXR0b25IaW50O1xuICAgICAgICAgICAgaWYgKGJ1dHRvbk5hbWUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgICAgICBpc09ubHlCdXR0b25zID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiaDJcIiwgeyBjbGFzc05hbWU6IFwiZmMtdG9vbGJhci10aXRsZVwiLCBpZDogcHJvcHMudGl0bGVJZCB9LCBwcm9wcy50aXRsZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzUHJlc3NlZCA9IGJ1dHRvbk5hbWUgPT09IHByb3BzLmFjdGl2ZUJ1dHRvbjtcbiAgICAgICAgICAgICAgICB2YXIgaXNEaXNhYmxlZCA9ICghcHJvcHMuaXNUb2RheUVuYWJsZWQgJiYgYnV0dG9uTmFtZSA9PT0gJ3RvZGF5JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc1ByZXZFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICdwcmV2JykgfHxcbiAgICAgICAgICAgICAgICAgICAgKCFwcm9wcy5pc05leHRFbmFibGVkICYmIGJ1dHRvbk5hbWUgPT09ICduZXh0Jyk7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbkNsYXNzZXMgPSBbXCJmYy1cIiArIGJ1dHRvbk5hbWUgKyBcIi1idXR0b25cIiwgdGhlbWUuZ2V0Q2xhc3MoJ2J1dHRvbicpXTtcbiAgICAgICAgICAgICAgICBpZiAoaXNQcmVzc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkNsYXNzZXMucHVzaCh0aGVtZS5nZXRDbGFzcygnYnV0dG9uQWN0aXZlJykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCB0aXRsZTogdHlwZW9mIGJ1dHRvbkhpbnQgPT09ICdmdW5jdGlvbicgPyBidXR0b25IaW50KHByb3BzLm5hdlVuaXQpIDogYnV0dG9uSGludCwgZGlzYWJsZWQ6IGlzRGlzYWJsZWQsIFwiYXJpYS1wcmVzc2VkXCI6IGlzUHJlc3NlZCwgY2xhc3NOYW1lOiBidXR0b25DbGFzc2VzLmpvaW4oJyAnKSwgb25DbGljazogYnV0dG9uQ2xpY2sgfSwgYnV0dG9uVGV4dCB8fCAoYnV0dG9uSWNvbiA/IHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBidXR0b25JY29uIH0pIDogJycpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkcmVuLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBncm91cENsYXNzTmFtZSA9IChpc09ubHlCdXR0b25zICYmIHRoZW1lLmdldENsYXNzKCdidXR0b25Hcm91cCcpKSB8fCAnJztcbiAgICAgICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbJ2RpdicsIHsgY2xhc3NOYW1lOiBncm91cENsYXNzTmFtZSB9XSwgY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hpbGRyZW5bMF07XG4gICAgfTtcbiAgICByZXR1cm4gVG9vbGJhclNlY3Rpb247XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIFRvb2xiYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRvb2xiYXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVG9vbGJhcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUb29sYmFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIG1vZGVsID0gX2EubW9kZWwsIGV4dHJhQ2xhc3NOYW1lID0gX2EuZXh0cmFDbGFzc05hbWU7XG4gICAgICAgIHZhciBmb3JjZUx0ciA9IGZhbHNlO1xuICAgICAgICB2YXIgc3RhcnRDb250ZW50O1xuICAgICAgICB2YXIgZW5kQ29udGVudDtcbiAgICAgICAgdmFyIHNlY3Rpb25XaWRnZXRzID0gbW9kZWwuc2VjdGlvbldpZGdldHM7XG4gICAgICAgIHZhciBjZW50ZXJDb250ZW50ID0gc2VjdGlvbldpZGdldHMuY2VudGVyO1xuICAgICAgICBpZiAoc2VjdGlvbldpZGdldHMubGVmdCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgc3RhcnRDb250ZW50ID0gc2VjdGlvbldpZGdldHMubGVmdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0YXJ0Q29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWN0aW9uV2lkZ2V0cy5yaWdodCkge1xuICAgICAgICAgICAgZm9yY2VMdHIgPSB0cnVlO1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLnJpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5kQ29udGVudCA9IHNlY3Rpb25XaWRnZXRzLmVuZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgIGV4dHJhQ2xhc3NOYW1lIHx8ICcnLFxuICAgICAgICAgICAgJ2ZjLXRvb2xiYXInLFxuICAgICAgICAgICAgZm9yY2VMdHIgPyAnZmMtdG9vbGJhci1sdHInIDogJycsXG4gICAgICAgIF07XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJykgfSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignc3RhcnQnLCBzdGFydENvbnRlbnQgfHwgW10pLFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJTZWN0aW9uKCdjZW50ZXInLCBjZW50ZXJDb250ZW50IHx8IFtdKSxcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2VjdGlvbignZW5kJywgZW5kQ29udGVudCB8fCBbXSkpKTtcbiAgICB9O1xuICAgIFRvb2xiYXIucHJvdG90eXBlLnJlbmRlclNlY3Rpb24gPSBmdW5jdGlvbiAoa2V5LCB3aWRnZXRHcm91cHMpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFRvb2xiYXJTZWN0aW9uLCB7IGtleToga2V5LCB3aWRnZXRHcm91cHM6IHdpZGdldEdyb3VwcywgdGl0bGU6IHByb3BzLnRpdGxlLCBuYXZVbml0OiBwcm9wcy5uYXZVbml0LCBhY3RpdmVCdXR0b246IHByb3BzLmFjdGl2ZUJ1dHRvbiwgaXNUb2RheUVuYWJsZWQ6IHByb3BzLmlzVG9kYXlFbmFibGVkLCBpc1ByZXZFbmFibGVkOiBwcm9wcy5pc1ByZXZFbmFibGVkLCBpc05leHRFbmFibGVkOiBwcm9wcy5pc05leHRFbmFibGVkLCB0aXRsZUlkOiBwcm9wcy50aXRsZUlkIH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUb29sYmFyO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIFRPRE86IGRvIGZ1bmN0aW9uIGNvbXBvbmVudD9cbnZhciBWaWV3Q29udGFpbmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhWaWV3Q29udGFpbmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFZpZXdDb250YWluZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGF2YWlsYWJsZVdpZHRoOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXZhaWxhYmxlV2lkdGgoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIHZhciBhc3BlY3RSYXRpbyA9IHByb3BzLmFzcGVjdFJhdGlvO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy12aWV3LWhhcm5lc3MnLFxuICAgICAgICAgICAgKGFzcGVjdFJhdGlvIHx8IHByb3BzLmxpcXVpZCB8fCBwcm9wcy5oZWlnaHQpXG4gICAgICAgICAgICAgICAgPyAnZmMtdmlldy1oYXJuZXNzLWFjdGl2ZScgLy8gaGFybmVzcyBjb250cm9scyB0aGUgaGVpZ2h0XG4gICAgICAgICAgICAgICAgOiAnZmMtdmlldy1oYXJuZXNzLXBhc3NpdmUnLCAvLyBsZXQgdGhlIHZpZXcgZG8gdGhlIGhlaWdodFxuICAgICAgICBdO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gJyc7XG4gICAgICAgIHZhciBwYWRkaW5nQm90dG9tID0gJyc7XG4gICAgICAgIGlmIChhc3BlY3RSYXRpbykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLmF2YWlsYWJsZVdpZHRoICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaGVpZ2h0ID0gc3RhdGUuYXZhaWxhYmxlV2lkdGggLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdoaWxlIHdhaXRpbmcgdG8ga25vdyBhdmFpbGFibGVXaWR0aCwgd2UgY2FuJ3Qgc2V0IGhlaWdodCB0byAqemVybypcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHdpbGwgY2F1c2UgbG90cyBvZiB1bm5lY2Vzc2FyeSBzY3JvbGxiYXJzIHdpdGhpbiBzY3JvbGxncmlkLlxuICAgICAgICAgICAgICAgIC8vIEJFVFRFUjogZG9uJ3Qgc3RhcnQgcmVuZGVyaW5nIEFOWVRISU5HIHlldCB1bnRpbCB3ZSBrbm93IGNvbnRhaW5lciB3aWR0aFxuICAgICAgICAgICAgICAgIC8vIE5PVEU6IHdoeSBub3QgYWx3YXlzIHVzZSBwYWRkaW5nQm90dG9tPyBDYXVzZXMgaGVpZ2h0IG9zY2lsbGF0aW9uIChpc3N1ZSA1NjA2KVxuICAgICAgICAgICAgICAgIHBhZGRpbmdCb3R0b20gPSAoMSAvIGFzcGVjdFJhdGlvKSAqIDEwMCArIFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0IHx8ICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IHByb3BzLmxhYmVsZWRCeUlkLCByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHN0eWxlOiB7IGhlaWdodDogaGVpZ2h0LCBwYWRkaW5nQm90dG9tOiBwYWRkaW5nQm90dG9tIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIFZpZXdDb250YWluZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRleHQuYWRkUmVzaXplSGFuZGxlcih0aGlzLmhhbmRsZVJlc2l6ZSk7XG4gICAgfTtcbiAgICBWaWV3Q29udGFpbmVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgIH07XG4gICAgVmlld0NvbnRhaW5lci5wcm90b3R5cGUudXBkYXRlQXZhaWxhYmxlV2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVsICYmIC8vIG5lZWRlZC4gYnV0IHdoeT9cbiAgICAgICAgICAgIHRoaXMucHJvcHMuYXNwZWN0UmF0aW8gLy8gYXNwZWN0UmF0aW8gaXMgdGhlIG9ubHkgaGVpZ2h0IHNldHRpbmcgdGhhdCBuZWVkcyBhdmFpbGFibGVXaWR0aFxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBhdmFpbGFibGVXaWR0aDogdGhpcy5lbC5vZmZzZXRXaWR0aCB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFZpZXdDb250YWluZXI7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLypcbkRldGVjdHMgd2hlbiB0aGUgdXNlciBjbGlja3Mgb24gYW4gZXZlbnQgd2l0aGluIGEgRGF0ZUNvbXBvbmVudFxuKi9cbnZhciBFdmVudENsaWNraW5nID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhFdmVudENsaWNraW5nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50Q2xpY2tpbmcoc2V0dGluZ3MpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgc2V0dGluZ3MpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0NsaWNrID0gZnVuY3Rpb24gKGV2LCBzZWdFbCkge1xuICAgICAgICAgICAgdmFyIGNvbXBvbmVudCA9IF90aGlzLmNvbXBvbmVudDtcbiAgICAgICAgICAgIHZhciBjb250ZXh0ID0gY29tcG9uZW50LmNvbnRleHQ7XG4gICAgICAgICAgICB2YXIgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICAgICAgaWYgKHNlZyAmJiAvLyBtaWdodCBiZSB0aGUgPGRpdj4gc3Vycm91bmRpbmcgdGhlIG1vcmUgbGlua1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBvdXIgd2F5IHRvIHNpbXVsYXRlIGEgbGluayBjbGljayBmb3IgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSA8YT4gdGFnc1xuICAgICAgICAgICAgICAgIC8vIGdyYWIgYmVmb3JlIHRyaWdnZXIgZmlyZWQgaW4gY2FzZSB0cmlnZ2VyIHRyYXNoZXMgRE9NIHRocnUgcmVyZW5kZXJpbmdcbiAgICAgICAgICAgICAgICB2YXIgaGFzVXJsQ29udGFpbmVyID0gZWxlbWVudENsb3Nlc3QoZXYudGFyZ2V0LCAnLmZjLWV2ZW50LWZvcmNlZC11cmwnKTtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gaGFzVXJsQ29udGFpbmVyID8gaGFzVXJsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJ2FbaHJlZl0nKS5ocmVmIDogJyc7XG4gICAgICAgICAgICAgICAgY29udGV4dC5lbWl0dGVyLnRyaWdnZXIoJ2V2ZW50Q2xpY2snLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb21wb25lbnQuY29udGV4dCwgc2VnLmV2ZW50UmFuZ2UuZGVmLCBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZSksXG4gICAgICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgICAgICB2aWV3OiBjb250ZXh0LnZpZXdBcGksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAmJiAhZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmRlc3Ryb3kgPSBsaXN0ZW5CeVNlbGVjdG9yKHNldHRpbmdzLmVsLCAnY2xpY2snLCAnLmZjLWV2ZW50JywgLy8gb24gYm90aCBmZyBhbmQgYmcgZXZlbnRzXG4gICAgICAgIF90aGlzLmhhbmRsZVNlZ0NsaWNrKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRDbGlja2luZztcbn0oSW50ZXJhY3Rpb24pKTtcblxuLypcblRyaWdnZXJzIGV2ZW50cyBhbmQgYWRkcy9yZW1vdmVzIGNvcmUgY2xhc3NOYW1lcyB3aGVuIHRoZSB1c2VyJ3MgcG9pbnRlclxuZW50ZXJzL2xlYXZlcyBldmVudC1lbGVtZW50cyBvZiBhIGNvbXBvbmVudC5cbiovXG52YXIgRXZlbnRIb3ZlcmluZyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRXZlbnRIb3ZlcmluZywgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFdmVudEhvdmVyaW5nKHNldHRpbmdzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHNldHRpbmdzKSB8fCB0aGlzO1xuICAgICAgICAvLyBmb3Igc2ltdWxhdGluZyBhbiBldmVudE1vdXNlTGVhdmUgd2hlbiB0aGUgZXZlbnQgZWwgaXMgZGVzdHJveWVkIHdoaWxlIG1vdXNlIGlzIG92ZXIgaXRcbiAgICAgICAgX3RoaXMuaGFuZGxlRXZlbnRFbFJlbW92ZSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgaWYgKGVsID09PSBfdGhpcy5jdXJyZW50U2VnRWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVTZWdMZWF2ZShudWxsLCBfdGhpcy5jdXJyZW50U2VnRWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVTZWdFbnRlciA9IGZ1bmN0aW9uIChldiwgc2VnRWwpIHtcbiAgICAgICAgICAgIGlmIChnZXRFbFNlZyhzZWdFbCkpIHsgLy8gVE9ETzogYmV0dGVyIHdheSB0byBtYWtlIHN1cmUgbm90IGhvdmVyaW5nIG92ZXIgbW9yZSsgbGluayBvciBpdHMgd3JhcHBlclxuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRTZWdFbCA9IHNlZ0VsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyaWdnZXJFdmVudCgnZXZlbnRNb3VzZUVudGVyJywgZXYsIHNlZ0VsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnTGVhdmUgPSBmdW5jdGlvbiAoZXYsIHNlZ0VsKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFNlZ0VsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFNlZ0VsID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfdGhpcy50cmlnZ2VyRXZlbnQoJ2V2ZW50TW91c2VMZWF2ZScsIGV2LCBzZWdFbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzID0gbGlzdGVuVG9Ib3ZlckJ5U2VsZWN0b3Ioc2V0dGluZ3MuZWwsICcuZmMtZXZlbnQnLCAvLyBvbiBib3RoIGZnIGFuZCBiZyBldmVudHNcbiAgICAgICAgX3RoaXMuaGFuZGxlU2VnRW50ZXIsIF90aGlzLmhhbmRsZVNlZ0xlYXZlKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBFdmVudEhvdmVyaW5nLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUhvdmVyTGlzdGVuZXJzKCk7XG4gICAgfTtcbiAgICBFdmVudEhvdmVyaW5nLnByb3RvdHlwZS50cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiAocHVibGljRXZOYW1lLCBldiwgc2VnRWwpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuY29tcG9uZW50O1xuICAgICAgICB2YXIgY29udGV4dCA9IGNvbXBvbmVudC5jb250ZXh0O1xuICAgICAgICB2YXIgc2VnID0gZ2V0RWxTZWcoc2VnRWwpO1xuICAgICAgICBpZiAoIWV2IHx8IGNvbXBvbmVudC5pc1ZhbGlkU2VnRG93bkVsKGV2LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnRleHQuZW1pdHRlci50cmlnZ2VyKHB1YmxpY0V2TmFtZSwge1xuICAgICAgICAgICAgICAgIGVsOiBzZWdFbCxcbiAgICAgICAgICAgICAgICBldmVudDogbmV3IEV2ZW50QXBpKGNvbnRleHQsIHNlZy5ldmVudFJhbmdlLmRlZiwgc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgIGpzRXZlbnQ6IGV2LFxuICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gRXZlbnRIb3ZlcmluZztcbn0oSW50ZXJhY3Rpb24pKTtcblxudmFyIENhbGVuZGFyQ29udGVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoQ2FsZW5kYXJDb250ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENhbGVuZGFyQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmJ1aWxkVmlld0NvbnRleHQgPSBtZW1vaXplKGJ1aWxkVmlld0NvbnRleHQpO1xuICAgICAgICBfdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzID0gbWVtb2l6ZShidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKTtcbiAgICAgICAgX3RoaXMuYnVpbGRUb29sYmFyUHJvcHMgPSBtZW1vaXplKGJ1aWxkVG9vbGJhclByb3BzKTtcbiAgICAgICAgX3RoaXMuaGVhZGVyUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIF90aGlzLmZvb3RlclJlZiA9IHZkb21fY2pzLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5pbnRlcmFjdGlvbnNTdG9yZSA9IHt9O1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICB2aWV3TGFiZWxJZDogZ2V0VW5pcXVlRG9tSWQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQ29tcG9uZW50IFJlZ2lzdHJhdGlvblxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBfdGhpcy5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCkge1xuICAgICAgICAgICAgdmFyIHNldHRpbmdzID0gcGFyc2VJbnRlcmFjdGlvblNldHRpbmdzKGNvbXBvbmVudCwgc2V0dGluZ3NJbnB1dCk7XG4gICAgICAgICAgICB2YXIgREVGQVVMVF9JTlRFUkFDVElPTlMgPSBbXG4gICAgICAgICAgICAgICAgRXZlbnRDbGlja2luZyxcbiAgICAgICAgICAgICAgICBFdmVudEhvdmVyaW5nLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbkNsYXNzZXMgPSBERUZBVUxUX0lOVEVSQUNUSU9OUy5jb25jYXQoX3RoaXMucHJvcHMucGx1Z2luSG9va3MuY29tcG9uZW50SW50ZXJhY3Rpb25zKTtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbnMgPSBpbnRlcmFjdGlvbkNsYXNzZXMubWFwKGZ1bmN0aW9uIChUaGVJbnRlcmFjdGlvbkNsYXNzKSB7IHJldHVybiBuZXcgVGhlSW50ZXJhY3Rpb25DbGFzcyhzZXR0aW5ncyk7IH0pO1xuICAgICAgICAgICAgX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF0gPSBpbnRlcmFjdGlvbnM7XG4gICAgICAgICAgICBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmVbY29tcG9uZW50LnVpZF0gPSBzZXR0aW5ncztcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50ID0gZnVuY3Rpb24gKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IF90aGlzLmludGVyYWN0aW9uc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgbGlzdGVuZXJzXzEgPSBsaXN0ZW5lcnM7IF9pIDwgbGlzdGVuZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuaW50ZXJhY3Rpb25zU3RvcmVbY29tcG9uZW50LnVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgaW50ZXJhY3Rpb25TZXR0aW5nc1N0b3JlW2NvbXBvbmVudC51aWRdO1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNpemluZ1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICBfdGhpcy5yZXNpemVSdW5uZXIgPSBuZXcgRGVsYXllZFJ1bm5lcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ19yZXNpemUnLCB0cnVlKTsgLy8gc2hvdWxkIHdpbmRvdyByZXNpemVzIGJlIGNvbnNpZGVyZWQgXCJmb3JjZWRcIiA/XG4gICAgICAgICAgICBfdGhpcy5wcm9wcy5lbWl0dGVyLnRyaWdnZXIoJ3dpbmRvd1Jlc2l6ZScsIHsgdmlldzogX3RoaXMucHJvcHMudmlld0FwaSB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmhhbmRsZVdpbmRvd1Jlc2l6ZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBfdGhpcy5wcm9wcy5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGFuZGxlV2luZG93UmVzaXplICYmXG4gICAgICAgICAgICAgICAgZXYudGFyZ2V0ID09PSB3aW5kb3cgLy8gYXZvaWQganF1aSBldmVudHNcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIF90aGlzLnJlc2l6ZVJ1bm5lci5yZXF1ZXN0KG9wdGlvbnMud2luZG93UmVzaXplRGVsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIC8qXG4gICAgcmVuZGVycyBJTlNJREUgb2YgYW4gb3V0ZXIgZGl2XG4gICAgKi9cbiAgICBDYWxlbmRhckNvbnRlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIHRvb2xiYXJDb25maWcgPSBwcm9wcy50b29sYmFyQ29uZmlnLCBvcHRpb25zID0gcHJvcHMub3B0aW9ucztcbiAgICAgICAgdmFyIHRvb2xiYXJQcm9wcyA9IHRoaXMuYnVpbGRUb29sYmFyUHJvcHMocHJvcHMudmlld1NwZWMsIHByb3BzLmRhdGVQcm9maWxlLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuY3VycmVudERhdGUsIGdldE5vdyhwcm9wcy5vcHRpb25zLm5vdywgcHJvcHMuZGF0ZUVudiksIC8vIFRPRE86IHVzZSBOb3dUaW1lcj8/Pz9cbiAgICAgICAgcHJvcHMudmlld1RpdGxlKTtcbiAgICAgICAgdmFyIHZpZXdWR3JvdyA9IGZhbHNlO1xuICAgICAgICB2YXIgdmlld0hlaWdodCA9ICcnO1xuICAgICAgICB2YXIgdmlld0FzcGVjdFJhdGlvO1xuICAgICAgICBpZiAocHJvcHMuaXNIZWlnaHRBdXRvIHx8IHByb3BzLmZvclByaW50KSB7XG4gICAgICAgICAgICB2aWV3SGVpZ2h0ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld1ZHcm93ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcHRpb25zLmNvbnRlbnRIZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmlld0hlaWdodCA9IG9wdGlvbnMuY29udGVudEhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZpZXdBc3BlY3RSYXRpbyA9IE1hdGgubWF4KG9wdGlvbnMuYXNwZWN0UmF0aW8sIDAuNSk7IC8vIHByZXZlbnQgZnJvbSBnZXR0aW5nIHRvbyB0YWxsXG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZpZXdDb250ZXh0ID0gdGhpcy5idWlsZFZpZXdDb250ZXh0KHByb3BzLnZpZXdTcGVjLCBwcm9wcy52aWV3QXBpLCBwcm9wcy5vcHRpb25zLCBwcm9wcy5kYXRlUHJvZmlsZUdlbmVyYXRvciwgcHJvcHMuZGF0ZUVudiwgcHJvcHMudGhlbWUsIHByb3BzLnBsdWdpbkhvb2tzLCBwcm9wcy5kaXNwYXRjaCwgcHJvcHMuZ2V0Q3VycmVudERhdGEsIHByb3BzLmVtaXR0ZXIsIHByb3BzLmNhbGVuZGFyQXBpLCB0aGlzLnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQsIHRoaXMudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KTtcbiAgICAgICAgdmFyIHZpZXdMYWJlbElkID0gKHRvb2xiYXJDb25maWcuaGVhZGVyICYmIHRvb2xiYXJDb25maWcuaGVhZGVyLmhhc1RpdGxlKVxuICAgICAgICAgICAgPyB0aGlzLnN0YXRlLnZpZXdMYWJlbElkXG4gICAgICAgICAgICA6ICcnO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRleHRUeXBlLlByb3ZpZGVyLCB7IHZhbHVlOiB2aWV3Q29udGV4dCB9LFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5oZWFkZXIgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1oZWFkZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5oZWFkZXIsIHRpdGxlSWQ6IHZpZXdMYWJlbElkIH0sIHRvb2xiYXJQcm9wcykpKSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVmlld0NvbnRhaW5lciwgeyBsaXF1aWQ6IHZpZXdWR3JvdywgaGVpZ2h0OiB2aWV3SGVpZ2h0LCBhc3BlY3RSYXRpbzogdmlld0FzcGVjdFJhdGlvLCBsYWJlbGVkQnlJZDogdmlld0xhYmVsSWQgfSxcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlclZpZXcocHJvcHMpLFxuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRBcHBlbmRDb250ZW50KCkpLFxuICAgICAgICAgICAgdG9vbGJhckNvbmZpZy5mb290ZXIgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoVG9vbGJhciwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHRoaXMuZm9vdGVyUmVmLCBleHRyYUNsYXNzTmFtZTogXCJmYy1mb290ZXItdG9vbGJhclwiLCBtb2RlbDogdG9vbGJhckNvbmZpZy5mb290ZXIsIHRpdGxlSWQ6IFwiXCIgfSwgdG9vbGJhclByb3BzKSkpKSk7XG4gICAgfTtcbiAgICBDYWxlbmRhckNvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB0aGlzLmNhbGVuZGFySW50ZXJhY3Rpb25zID0gcHJvcHMucGx1Z2luSG9va3MuY2FsZW5kYXJJbnRlcmFjdGlvbnNcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcykgeyByZXR1cm4gbmV3IENhbGVuZGFySW50ZXJhY3Rpb25DbGFzcyhwcm9wcyk7IH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB2YXIgcHJvcFNldEhhbmRsZXJzID0gcHJvcHMucGx1Z2luSG9va3MucHJvcFNldEhhbmRsZXJzO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIHByb3BTZXRIYW5kbGVyc1twcm9wTmFtZV0ocHJvcHNbcHJvcE5hbWVdLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgcHJvcFNldEhhbmRsZXJzID0gcHJvcHMucGx1Z2luSG9va3MucHJvcFNldEhhbmRsZXJzO1xuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wU2V0SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gIT09IHByZXZQcm9wc1twcm9wTmFtZV0pIHtcbiAgICAgICAgICAgICAgICBwcm9wU2V0SGFuZGxlcnNbcHJvcE5hbWVdKHByb3BzW3Byb3BOYW1lXSwgcHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDYWxlbmRhckNvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5oYW5kbGVXaW5kb3dSZXNpemUpO1xuICAgICAgICB0aGlzLnJlc2l6ZVJ1bm5lci5jbGVhcigpO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5jYWxlbmRhckludGVyYWN0aW9uczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBpbnRlcmFjdGlvbiA9IF9hW19pXTtcbiAgICAgICAgICAgIGludGVyYWN0aW9uLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb3BzLmVtaXR0ZXIudHJpZ2dlcignX3VubW91bnQnKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUuYnVpbGRBcHBlbmRDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5wbHVnaW5Ib29rcy52aWV3Q29udGFpbmVyQXBwZW5kcy5tYXAoZnVuY3Rpb24gKGJ1aWxkQXBwZW5kQ29udGVudCkgeyByZXR1cm4gYnVpbGRBcHBlbmRDb250ZW50KHByb3BzKTsgfSk7XG4gICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50LmFwcGx5KHZvaWQgMCwgdHNsaWIuX19zcHJlYWRBcnJheShbdmRvbV9janMuRnJhZ21lbnQsIHt9XSwgY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIENhbGVuZGFyQ29udGVudC5wcm90b3R5cGUucmVuZGVyVmlldyA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgcGx1Z2luSG9va3MgPSBwcm9wcy5wbHVnaW5Ib29rcztcbiAgICAgICAgdmFyIHZpZXdTcGVjID0gcHJvcHMudmlld1NwZWM7XG4gICAgICAgIHZhciB2aWV3UHJvcHMgPSB7XG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICBidXNpbmVzc0hvdXJzOiBwcm9wcy5idXNpbmVzc0hvdXJzLFxuICAgICAgICAgICAgZXZlbnRTdG9yZTogcHJvcHMucmVuZGVyYWJsZUV2ZW50U3RvcmUsXG4gICAgICAgICAgICBldmVudFVpQmFzZXM6IHByb3BzLmV2ZW50VWlCYXNlcyxcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb246IHByb3BzLmRhdGVTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudFNlbGVjdGlvbjogcHJvcHMuZXZlbnRTZWxlY3Rpb24sXG4gICAgICAgICAgICBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZyxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSxcbiAgICAgICAgICAgIGlzSGVpZ2h0QXV0bzogcHJvcHMuaXNIZWlnaHRBdXRvLFxuICAgICAgICAgICAgZm9yUHJpbnQ6IHByb3BzLmZvclByaW50LFxuICAgICAgICB9O1xuICAgICAgICB2YXIgdHJhbnNmb3JtZXJzID0gdGhpcy5idWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzKHBsdWdpbkhvb2tzLnZpZXdQcm9wc1RyYW5zZm9ybWVycyk7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgdHJhbnNmb3JtZXJzXzEgPSB0cmFuc2Zvcm1lcnM7IF9pIDwgdHJhbnNmb3JtZXJzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtZXIgPSB0cmFuc2Zvcm1lcnNfMVtfaV07XG4gICAgICAgICAgICB0c2xpYi5fX2Fzc2lnbih2aWV3UHJvcHMsIHRyYW5zZm9ybWVyLnRyYW5zZm9ybSh2aWV3UHJvcHMsIHByb3BzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFZpZXdDb21wb25lbnQgPSB2aWV3U3BlYy5jb21wb25lbnQ7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29tcG9uZW50LCB0c2xpYi5fX2Fzc2lnbih7fSwgdmlld1Byb3BzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIENhbGVuZGFyQ29udGVudDtcbn0oUHVyZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gYnVpbGRUb29sYmFyUHJvcHModmlld1NwZWMsIGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvciwgY3VycmVudERhdGUsIG5vdywgdGl0bGUpIHtcbiAgICAvLyBkb24ndCBmb3JjZSBhbnkgZGF0ZS1wcm9maWxlcyB0byB2YWxpZCBkYXRlIHByb2ZpbGVzICh0aGUgYGZhbHNlYCkgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBpdCdzIGludmFsaWRcbiAgICB2YXIgdG9kYXlJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGQobm93LCB1bmRlZmluZWQsIGZhbHNlKTsgLy8gVE9ETzogbmVlZCBgdW5kZWZpbmVkYCBvciBlbHNlIElORklOSVRFIExPT1AgZm9yIHNvbWUgcmVhc29uXG4gICAgdmFyIHByZXZJbmZvID0gZGF0ZVByb2ZpbGVHZW5lcmF0b3IuYnVpbGRQcmV2KGRhdGVQcm9maWxlLCBjdXJyZW50RGF0ZSwgZmFsc2UpO1xuICAgIHZhciBuZXh0SW5mbyA9IGRhdGVQcm9maWxlR2VuZXJhdG9yLmJ1aWxkTmV4dChkYXRlUHJvZmlsZSwgY3VycmVudERhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgIGFjdGl2ZUJ1dHRvbjogdmlld1NwZWMudHlwZSxcbiAgICAgICAgbmF2VW5pdDogdmlld1NwZWMuc2luZ2xlVW5pdCxcbiAgICAgICAgaXNUb2RheUVuYWJsZWQ6IHRvZGF5SW5mby5pc1ZhbGlkICYmICFyYW5nZUNvbnRhaW5zTWFya2VyKGRhdGVQcm9maWxlLmN1cnJlbnRSYW5nZSwgbm93KSxcbiAgICAgICAgaXNQcmV2RW5hYmxlZDogcHJldkluZm8uaXNWYWxpZCxcbiAgICAgICAgaXNOZXh0RW5hYmxlZDogbmV4dEluZm8uaXNWYWxpZCxcbiAgICB9O1xufVxuLy8gUGx1Z2luXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYnVpbGRWaWV3UHJvcFRyYW5zZm9ybWVycyh0aGVDbGFzc2VzKSB7XG4gICAgcmV0dXJuIHRoZUNsYXNzZXMubWFwKGZ1bmN0aW9uIChUaGVDbGFzcykgeyByZXR1cm4gbmV3IFRoZUNsYXNzKCk7IH0pO1xufVxuXG52YXIgQ2FsZW5kYXJSb290ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhDYWxlbmRhclJvb3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2FsZW5kYXJSb290KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBmb3JQcmludDogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZUJlZm9yZVByaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBmb3JQcmludDogdHJ1ZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlQWZ0ZXJQcmludCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnNldFN0YXRlKHsgZm9yUHJpbnQ6IGZhbHNlIH0pO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHByb3BzLm9wdGlvbnM7XG4gICAgICAgIHZhciBmb3JQcmludCA9IHRoaXMuc3RhdGUuZm9yUHJpbnQ7XG4gICAgICAgIHZhciBpc0hlaWdodEF1dG8gPSBmb3JQcmludCB8fCBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMuY29udGVudEhlaWdodCA9PT0gJ2F1dG8nO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gKCFpc0hlaWdodEF1dG8gJiYgb3B0aW9ucy5oZWlnaHQgIT0gbnVsbCkgPyBvcHRpb25zLmhlaWdodCA6ICcnO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYycsXG4gICAgICAgICAgICBmb3JQcmludCA/ICdmYy1tZWRpYS1wcmludCcgOiAnZmMtbWVkaWEtc2NyZWVuJyxcbiAgICAgICAgICAgIFwiZmMtZGlyZWN0aW9uLVwiICsgb3B0aW9ucy5kaXJlY3Rpb24sXG4gICAgICAgICAgICBwcm9wcy50aGVtZS5nZXRDbGFzcygncm9vdCcpLFxuICAgICAgICBdO1xuICAgICAgICBpZiAoIWdldENhblZHcm93V2l0aGluQ2VsbCgpKSB7XG4gICAgICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLWxpcXVpZC1oYWNrJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCk7XG4gICAgfTtcbiAgICBDYWxlbmRhclJvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZW1pdHRlciA9IHRoaXMucHJvcHMuZW1pdHRlcjtcbiAgICAgICAgZW1pdHRlci5vbignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub24oJ19hZnRlcnByaW50JywgdGhpcy5oYW5kbGVBZnRlclByaW50KTtcbiAgICB9O1xuICAgIENhbGVuZGFyUm9vdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbWl0dGVyID0gdGhpcy5wcm9wcy5lbWl0dGVyO1xuICAgICAgICBlbWl0dGVyLm9mZignX2JlZm9yZXByaW50JywgdGhpcy5oYW5kbGVCZWZvcmVQcmludCk7XG4gICAgICAgIGVtaXR0ZXIub2ZmKCdfYWZ0ZXJwcmludCcsIHRoaXMuaGFuZGxlQWZ0ZXJQcmludCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2FsZW5kYXJSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5cbi8vIENvbXB1dGVzIGEgZGVmYXVsdCBjb2x1bW4gaGVhZGVyIGZvcm1hdHRpbmcgc3RyaW5nIGlmIGBjb2xGb3JtYXRgIGlzIG5vdCBleHBsaWNpdGx5IGRlZmluZWRcbmZ1bmN0aW9uIGNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdChkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF5Q250KSB7XG4gICAgLy8gaWYgbW9yZSB0aGFuIG9uZSB3ZWVrIHJvdywgb3IgaWYgdGhlcmUgYXJlIGEgbG90IG9mIGNvbHVtbnMgd2l0aCBub3QgbXVjaCBzcGFjZSxcbiAgICAvLyBwdXQganVzdCB0aGUgZGF5IG51bWJlcnMgd2lsbCBiZSBpbiBlYWNoIGNlbGxcbiAgICBpZiAoIWRhdGVzUmVwRGlzdGluY3REYXlzIHx8IGRheUNudCA+IDEwKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnIH0pOyAvLyBcIlNhdFwiXG4gICAgfVxuICAgIGlmIChkYXlDbnQgPiAxKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVGb3JtYXR0ZXIoeyB3ZWVrZGF5OiAnc2hvcnQnLCBtb250aDogJ251bWVyaWMnLCBkYXk6ICdudW1lcmljJywgb21pdENvbW1hczogdHJ1ZSB9KTsgLy8gXCJTYXQgMTEvMTJcIlxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pOyAvLyBcIlNhdHVyZGF5XCJcbn1cblxudmFyIENMQVNTX05BTUUgPSAnZmMtY29sLWhlYWRlci1jZWxsJzsgLy8gZG8gdGhlIGN1c2hpb24gdG9vPyBub1xuZnVuY3Rpb24gcmVuZGVySW5uZXIkMShob29rUHJvcHMpIHtcbiAgICByZXR1cm4gaG9va1Byb3BzLnRleHQ7XG59XG5cbnZhciBUYWJsZURhdGVDZWxsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZURhdGVDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlRGF0ZUNlbGwoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFibGVEYXRlQ2VsbC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIGRhdGVFbnYgPSBfYS5kYXRlRW52LCBvcHRpb25zID0gX2Eub3B0aW9ucywgdGhlbWUgPSBfYS50aGVtZSwgdmlld0FwaSA9IF9hLnZpZXdBcGk7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBkYXRlID0gcHJvcHMuZGF0ZSwgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZTtcbiAgICAgICAgdmFyIGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCBwcm9wcy50b2RheVJhbmdlLCBudWxsLCBkYXRlUHJvZmlsZSk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRheU1ldGEsIHRoZW1lKSk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgLy8gaWYgY29sQ250IGlzIDEsIHdlIGFyZSBhbHJlYWR5IGluIGEgZGF5LXZpZXcgYW5kIGRvbid0IG5lZWQgYSBuYXZsaW5rXG4gICAgICAgIHZhciBuYXZMaW5rQXR0cnMgPSAoIWRheU1ldGEuaXNEaXNhYmxlZCAmJiBwcm9wcy5jb2xDbnQgPiAxKVxuICAgICAgICAgICAgPyBidWlsZE5hdkxpbmtBdHRycyh0aGlzLmNvbnRleHQsIGRhdGUpXG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICB2YXIgaG9va1Byb3BzID0gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogdmlld0FwaSB9LCBwcm9wcy5leHRyYUhvb2tQcm9wcyksIHsgdGV4dDogdGV4dCB9KSwgZGF5TWV0YSk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLmRheUhlYWRlckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMuZGF5SGVhZGVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyJDEsIGRpZE1vdW50OiBvcHRpb25zLmRheUhlYWRlckRpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlIZWFkZXJXaWxsVW5tb3VudCB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwidGhcIiwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHJvb3RFbFJlZiwgcm9sZTogXCJjb2x1bW5oZWFkZXJcIiwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKS5qb2luKCcgJyksIFwiZGF0YS1kYXRlXCI6ICFkYXlNZXRhLmlzRGlzYWJsZWQgPyBmb3JtYXREYXlTdHJpbmcoZGF0ZSkgOiB1bmRlZmluZWQsIGNvbFNwYW46IHByb3BzLmNvbFNwYW4gfSwgcHJvcHMuZXh0cmFEYXRhQXR0cnMpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1zY3JvbGxncmlkLXN5bmMtaW5uZXJcIiB9LCAhZGF5TWV0YS5pc0Rpc2FibGVkICYmICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogaW5uZXJFbFJlZiwgY2xhc3NOYW1lOiBbXG4gICAgICAgICAgICAgICAgICAgICdmYy1jb2wtaGVhZGVyLWNlbGwtY3VzaGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ID8gJ2ZjLXN0aWNreScgOiAnJyxcbiAgICAgICAgICAgICAgICBdLmpvaW4oJyAnKSB9LCBuYXZMaW5rQXR0cnMpLCBpbm5lckNvbnRlbnQpKSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlRGF0ZUNlbGw7XG59KEJhc2VDb21wb25lbnQpKTtcblxudmFyIFdFRUtEQVlfRk9STUFUID0gY3JlYXRlRm9ybWF0dGVyKHsgd2Vla2RheTogJ2xvbmcnIH0pO1xudmFyIFRhYmxlRG93Q2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVEb3dDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlRG93Q2VsbCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYWJsZURvd0NlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBkYXRlRW52ID0gX2EuZGF0ZUVudiwgdGhlbWUgPSBfYS50aGVtZSwgdmlld0FwaSA9IF9hLnZpZXdBcGksIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgZGF0ZSA9IGFkZERheXMobmV3IERhdGUoMjU5MjAwMDAwKSwgcHJvcHMuZG93KTsgLy8gc3RhcnQgd2l0aCBTdW4sIDA0IEphbiAxOTcwIDAwOjAwOjAwIEdNVFxuICAgICAgICB2YXIgZGF0ZU1ldGEgPSB7XG4gICAgICAgICAgICBkb3c6IHByb3BzLmRvdyxcbiAgICAgICAgICAgIGlzRGlzYWJsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgaXNGdXR1cmU6IGZhbHNlLFxuICAgICAgICAgICAgaXNQYXN0OiBmYWxzZSxcbiAgICAgICAgICAgIGlzVG9kYXk6IGZhbHNlLFxuICAgICAgICAgICAgaXNPdGhlcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW0NMQVNTX05BTUVdLmNvbmNhdChnZXREYXlDbGFzc05hbWVzKGRhdGVNZXRhLCB0aGVtZSksIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHZhciB0ZXh0ID0gZGF0ZUVudi5mb3JtYXQoZGF0ZSwgcHJvcHMuZGF5SGVhZGVyRm9ybWF0KTtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHsgLy8gVE9ETzogbWFrZSB0aGlzIHB1YmxpYz9cbiAgICAgICAgICAgIGRhdGU6IGRhdGUgfSwgZGF0ZU1ldGEpLCB7IHZpZXc6IHZpZXdBcGkgfSksIHByb3BzLmV4dHJhSG9va1Byb3BzKSwgeyB0ZXh0OiB0ZXh0IH0pO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy5kYXlIZWFkZXJDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmRheUhlYWRlckNvbnRlbnQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lciQxLCBkaWRNb3VudDogb3B0aW9ucy5kYXlIZWFkZXJEaWRNb3VudCwgd2lsbFVubW91bnQ6IG9wdGlvbnMuZGF5SGVhZGVyV2lsbFVubW91bnQgfSwgZnVuY3Rpb24gKHJvb3RFbFJlZiwgY3VzdG9tQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcInRoXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiByb290RWxSZWYsIHJvbGU6IFwiY29sdW1uaGVhZGVyXCIsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jb25jYXQoY3VzdG9tQ2xhc3NOYW1lcykuam9pbignICcpLCBjb2xTcGFuOiBwcm9wcy5jb2xTcGFuIH0sIHByb3BzLmV4dHJhRGF0YUF0dHJzKSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIgfSxcbiAgICAgICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiYVwiLCB7IFwiYXJpYS1sYWJlbFwiOiBkYXRlRW52LmZvcm1hdChkYXRlLCBXRUVLREFZX0ZPUk1BVCksIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2ZjLWNvbC1oZWFkZXItY2VsbC1jdXNoaW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzLmlzU3RpY2t5ID8gJ2ZjLXN0aWNreScgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgXS5qb2luKCcgJyksIHJlZjogaW5uZXJFbFJlZiB9LCBpbm5lckNvbnRlbnQpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVEb3dDZWxsO1xufShCYXNlQ29tcG9uZW50KSk7XG5cbnZhciBOb3dUaW1lciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoTm93VGltZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm93VGltZXIocHJvcHMsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmluaXRpYWxOb3dEYXRlID0gZ2V0Tm93KGNvbnRleHQub3B0aW9ucy5ub3csIGNvbnRleHQuZGF0ZUVudik7XG4gICAgICAgIF90aGlzLmluaXRpYWxOb3dRdWVyaWVkTXMgPSBuZXcgRGF0ZSgpLnZhbHVlT2YoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5jb21wdXRlVGltaW5nKCkuY3VycmVudFN0YXRlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGU7XG4gICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbihzdGF0ZS5ub3dEYXRlLCBzdGF0ZS50b2RheVJhbmdlKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBOb3dUaW1lci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcykge1xuICAgICAgICBpZiAocHJldlByb3BzLnVuaXQgIT09IHRoaXMucHJvcHMudW5pdCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhclRpbWVvdXQoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0VGltZW91dCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBOb3dUaW1lci5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gICAgfTtcbiAgICBOb3dUaW1lci5wcm90b3R5cGUuY29tcHV0ZVRpbWluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciB1bnJvdW5kZWROb3cgPSBhZGRNcyh0aGlzLmluaXRpYWxOb3dEYXRlLCBuZXcgRGF0ZSgpLnZhbHVlT2YoKSAtIHRoaXMuaW5pdGlhbE5vd1F1ZXJpZWRNcyk7XG4gICAgICAgIHZhciBjdXJyZW50VW5pdFN0YXJ0ID0gY29udGV4dC5kYXRlRW52LnN0YXJ0T2YodW5yb3VuZGVkTm93LCBwcm9wcy51bml0KTtcbiAgICAgICAgdmFyIG5leHRVbml0U3RhcnQgPSBjb250ZXh0LmRhdGVFbnYuYWRkKGN1cnJlbnRVbml0U3RhcnQsIGNyZWF0ZUR1cmF0aW9uKDEsIHByb3BzLnVuaXQpKTtcbiAgICAgICAgdmFyIHdhaXRNcyA9IG5leHRVbml0U3RhcnQudmFsdWVPZigpIC0gdW5yb3VuZGVkTm93LnZhbHVlT2YoKTtcbiAgICAgICAgLy8gdGhlcmUgaXMgYSBtYXggc2V0VGltZW91dCBtcyB2YWx1ZSAoaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM0Njg2NTAvOTYzNDIpXG4gICAgICAgIC8vIGVuc3VyZSBubyBsb25nZXIgdGhhbiBhIGRheVxuICAgICAgICB3YWl0TXMgPSBNYXRoLm1pbigxMDAwICogNjAgKiA2MCAqIDI0LCB3YWl0TXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY3VycmVudFN0YXRlOiB7IG5vd0RhdGU6IGN1cnJlbnRVbml0U3RhcnQsIHRvZGF5UmFuZ2U6IGJ1aWxkRGF5UmFuZ2UoY3VycmVudFVuaXRTdGFydCkgfSxcbiAgICAgICAgICAgIG5leHRTdGF0ZTogeyBub3dEYXRlOiBuZXh0VW5pdFN0YXJ0LCB0b2RheVJhbmdlOiBidWlsZERheVJhbmdlKG5leHRVbml0U3RhcnQpIH0sXG4gICAgICAgICAgICB3YWl0TXM6IHdhaXRNcyxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbXB1dGVUaW1pbmcoKSwgbmV4dFN0YXRlID0gX2EubmV4dFN0YXRlLCB3YWl0TXMgPSBfYS53YWl0TXM7XG4gICAgICAgIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZShuZXh0U3RhdGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgd2FpdE1zKTtcbiAgICB9O1xuICAgIE5vd1RpbWVyLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnRpbWVvdXRJZCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm93VGltZXIuY29udGV4dFR5cGUgPSBWaWV3Q29udGV4dFR5cGU7XG4gICAgcmV0dXJuIE5vd1RpbWVyO1xufSh2ZG9tX2Nqcy5Db21wb25lbnQpKTtcbmZ1bmN0aW9uIGJ1aWxkRGF5UmFuZ2UoZGF0ZSkge1xuICAgIHZhciBzdGFydCA9IHN0YXJ0T2ZEYXkoZGF0ZSk7XG4gICAgdmFyIGVuZCA9IGFkZERheXMoc3RhcnQsIDEpO1xuICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbn1cblxudmFyIERheUhlYWRlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5SGVhZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheUhlYWRlcigpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlciA9IG1lbW9pemUoY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlIZWFkZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNvbnRleHQ7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRhdGVzID0gX2EuZGF0ZXMsIGRhdGVQcm9maWxlID0gX2EuZGF0ZVByb2ZpbGUsIGRhdGVzUmVwRGlzdGluY3REYXlzID0gX2EuZGF0ZXNSZXBEaXN0aW5jdERheXMsIHJlbmRlckludHJvID0gX2EucmVuZGVySW50cm87XG4gICAgICAgIHZhciBkYXlIZWFkZXJGb3JtYXQgPSB0aGlzLmNyZWF0ZURheUhlYWRlckZvcm1hdHRlcihjb250ZXh0Lm9wdGlvbnMuZGF5SGVhZGVyRm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZXMubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KE5vd1RpbWVyLCB7IHVuaXQ6IFwiZGF5XCIgfSwgZnVuY3Rpb24gKG5vd0RhdGUsIHRvZGF5UmFuZ2UpIHsgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwidHJcIiwgeyByb2xlOiBcInJvd1wiIH0sXG4gICAgICAgICAgICByZW5kZXJJbnRybyAmJiByZW5kZXJJbnRybygnZGF5JyksXG4gICAgICAgICAgICBkYXRlcy5tYXAoZnVuY3Rpb24gKGRhdGUpIHsgcmV0dXJuIChkYXRlc1JlcERpc3RpbmN0RGF5cyA/ICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFRhYmxlRGF0ZUNlbGwsIHsga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksIGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgY29sQ250OiBkYXRlcy5sZW5ndGgsIGRheUhlYWRlckZvcm1hdDogZGF5SGVhZGVyRm9ybWF0IH0pKSA6ICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFRhYmxlRG93Q2VsbCwgeyBrZXk6IGRhdGUuZ2V0VVRDRGF5KCksIGRvdzogZGF0ZS5nZXRVVENEYXkoKSwgZGF5SGVhZGVyRm9ybWF0OiBkYXlIZWFkZXJGb3JtYXQgfSkpKTsgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheUhlYWRlcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gY3JlYXRlRGF5SGVhZGVyRm9ybWF0dGVyKGV4cGxpY2l0Rm9ybWF0LCBkYXRlc1JlcERpc3RpbmN0RGF5cywgZGF0ZUNudCkge1xuICAgIHJldHVybiBleHBsaWNpdEZvcm1hdCB8fCBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQoZGF0ZXNSZXBEaXN0aW5jdERheXMsIGRhdGVDbnQpO1xufVxuXG52YXIgRGF5U2VyaWVzTW9kZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF5U2VyaWVzTW9kZWwocmFuZ2UsIGRhdGVQcm9maWxlR2VuZXJhdG9yKSB7XG4gICAgICAgIHZhciBkYXRlID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSByYW5nZS5lbmQ7XG4gICAgICAgIHZhciBpbmRpY2VzID0gW107XG4gICAgICAgIHZhciBkYXRlcyA9IFtdO1xuICAgICAgICB2YXIgZGF5SW5kZXggPSAtMTtcbiAgICAgICAgd2hpbGUgKGRhdGUgPCBlbmQpIHsgLy8gbG9vcCBlYWNoIGRheSBmcm9tIHN0YXJ0IHRvIGVuZFxuICAgICAgICAgICAgaWYgKGRhdGVQcm9maWxlR2VuZXJhdG9yLmlzSGlkZGVuRGF5KGRhdGUpKSB7XG4gICAgICAgICAgICAgICAgaW5kaWNlcy5wdXNoKGRheUluZGV4ICsgMC41KTsgLy8gbWFyayB0aGF0IGl0J3MgYmV0d2VlbiBpbmRpY2VzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkYXlJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgIGluZGljZXMucHVzaChkYXlJbmRleCk7XG4gICAgICAgICAgICAgICAgZGF0ZXMucHVzaChkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGUgPSBhZGREYXlzKGRhdGUsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0ZXMgPSBkYXRlcztcbiAgICAgICAgdGhpcy5pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgICAgdGhpcy5jbnQgPSBkYXRlcy5sZW5ndGg7XG4gICAgfVxuICAgIERheVNlcmllc01vZGVsLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKHJhbmdlKSB7XG4gICAgICAgIHZhciBmaXJzdEluZGV4ID0gdGhpcy5nZXREYXRlRGF5SW5kZXgocmFuZ2Uuc3RhcnQpOyAvLyBpbmNsdXNpdmUgZmlyc3QgaW5kZXhcbiAgICAgICAgdmFyIGxhc3RJbmRleCA9IHRoaXMuZ2V0RGF0ZURheUluZGV4KGFkZERheXMocmFuZ2UuZW5kLCAtMSkpOyAvLyBpbmNsdXNpdmUgbGFzdCBpbmRleFxuICAgICAgICB2YXIgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLm1heCgwLCBmaXJzdEluZGV4KTtcbiAgICAgICAgdmFyIGNsaXBwZWRMYXN0SW5kZXggPSBNYXRoLm1pbih0aGlzLmNudCAtIDEsIGxhc3RJbmRleCk7XG4gICAgICAgIC8vIGRlYWwgd2l0aCBpbi1iZXR3ZWVuIGluZGljZXNcbiAgICAgICAgY2xpcHBlZEZpcnN0SW5kZXggPSBNYXRoLmNlaWwoY2xpcHBlZEZpcnN0SW5kZXgpOyAvLyBpbi1iZXR3ZWVuIHN0YXJ0cyByb3VuZCB0byBuZXh0IGNlbGxcbiAgICAgICAgY2xpcHBlZExhc3RJbmRleCA9IE1hdGguZmxvb3IoY2xpcHBlZExhc3RJbmRleCk7IC8vIGluLWJldHdlZW4gZW5kcyByb3VuZCB0byBwcmV2IGNlbGxcbiAgICAgICAgaWYgKGNsaXBwZWRGaXJzdEluZGV4IDw9IGNsaXBwZWRMYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZmlyc3RJbmRleDogY2xpcHBlZEZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4OiBjbGlwcGVkTGFzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzU3RhcnQ6IGZpcnN0SW5kZXggPT09IGNsaXBwZWRGaXJzdEluZGV4LFxuICAgICAgICAgICAgICAgIGlzRW5kOiBsYXN0SW5kZXggPT09IGNsaXBwZWRMYXN0SW5kZXgsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgLy8gR2l2ZW4gYSBkYXRlLCByZXR1cm5zIGl0cyBjaHJvbm9sb2NpYWwgY2VsbC1pbmRleCBmcm9tIHRoZSBmaXJzdCBjZWxsIG9mIHRoZSBncmlkLlxuICAgIC8vIElmIHRoZSBkYXRlIGxpZXMgYmV0d2VlbiBjZWxscyAoYmVjYXVzZSBvZiBoaWRkZW5EYXlzKSwgcmV0dXJucyBhIGZsb2F0aW5nLXBvaW50IHZhbHVlIGJldHdlZW4gb2Zmc2V0cy5cbiAgICAvLyBJZiBiZWZvcmUgdGhlIGZpcnN0IG9mZnNldCwgcmV0dXJucyBhIG5lZ2F0aXZlIG51bWJlci5cbiAgICAvLyBJZiBhZnRlciB0aGUgbGFzdCBvZmZzZXQsIHJldHVybnMgYW4gb2Zmc2V0IHBhc3QgdGhlIGxhc3QgY2VsbCBvZmZzZXQuXG4gICAgLy8gT25seSB3b3JrcyBmb3IgKnN0YXJ0KiBkYXRlcyBvZiBjZWxscy4gV2lsbCBub3Qgd29yayBmb3IgZXhjbHVzaXZlIGVuZCBkYXRlcyBmb3IgY2VsbHMuXG4gICAgRGF5U2VyaWVzTW9kZWwucHJvdG90eXBlLmdldERhdGVEYXlJbmRleCA9IGZ1bmN0aW9uIChkYXRlKSB7XG4gICAgICAgIHZhciBpbmRpY2VzID0gdGhpcy5pbmRpY2VzO1xuICAgICAgICB2YXIgZGF5T2Zmc2V0ID0gTWF0aC5mbG9vcihkaWZmRGF5cyh0aGlzLmRhdGVzWzBdLCBkYXRlKSk7XG4gICAgICAgIGlmIChkYXlPZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5kaWNlc1swXSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRheU9mZnNldCA+PSBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGljZXNbZGF5T2Zmc2V0XTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlTZXJpZXNNb2RlbDtcbn0oKSk7XG5cbnZhciBEYXlUYWJsZU1vZGVsID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERheVRhYmxlTW9kZWwoZGF5U2VyaWVzLCBicmVha09uV2Vla3MpIHtcbiAgICAgICAgdmFyIGRhdGVzID0gZGF5U2VyaWVzLmRhdGVzO1xuICAgICAgICB2YXIgZGF5c1BlclJvdztcbiAgICAgICAgdmFyIGZpcnN0RGF5O1xuICAgICAgICB2YXIgcm93Q250O1xuICAgICAgICBpZiAoYnJlYWtPbldlZWtzKSB7XG4gICAgICAgICAgICAvLyBjb3VudCBjb2x1bW5zIHVudGlsIHRoZSBkYXktb2Ytd2VlayByZXBlYXRzXG4gICAgICAgICAgICBmaXJzdERheSA9IGRhdGVzWzBdLmdldFVUQ0RheSgpO1xuICAgICAgICAgICAgZm9yIChkYXlzUGVyUm93ID0gMTsgZGF5c1BlclJvdyA8IGRhdGVzLmxlbmd0aDsgZGF5c1BlclJvdyArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGVzW2RheXNQZXJSb3ddLmdldFVUQ0RheSgpID09PSBmaXJzdERheSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dDbnQgPSBNYXRoLmNlaWwoZGF0ZXMubGVuZ3RoIC8gZGF5c1BlclJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb3dDbnQgPSAxO1xuICAgICAgICAgICAgZGF5c1BlclJvdyA9IGRhdGVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJvd0NudCA9IHJvd0NudDtcbiAgICAgICAgdGhpcy5jb2xDbnQgPSBkYXlzUGVyUm93O1xuICAgICAgICB0aGlzLmRheVNlcmllcyA9IGRheVNlcmllcztcbiAgICAgICAgdGhpcy5jZWxscyA9IHRoaXMuYnVpbGRDZWxscygpO1xuICAgICAgICB0aGlzLmhlYWRlckRhdGVzID0gdGhpcy5idWlsZEhlYWRlckRhdGVzKCk7XG4gICAgfVxuICAgIERheVRhYmxlTW9kZWwucHJvdG90eXBlLmJ1aWxkQ2VsbHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByb3dzID0gW107XG4gICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IHRoaXMucm93Q250OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNlbGxzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCB0aGlzLmNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgICBjZWxscy5wdXNoKHRoaXMuYnVpbGRDZWxsKHJvdywgY29sKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByb3dzLnB1c2goY2VsbHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dzO1xuICAgIH07XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRDZWxsID0gZnVuY3Rpb24gKHJvdywgY29sKSB7XG4gICAgICAgIHZhciBkYXRlID0gdGhpcy5kYXlTZXJpZXMuZGF0ZXNbcm93ICogdGhpcy5jb2xDbnQgKyBjb2xdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiBkYXRlLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICBkYXRlOiBkYXRlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuYnVpbGRIZWFkZXJEYXRlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGRhdGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IHRoaXMuY29sQ250OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgZGF0ZXMucHVzaCh0aGlzLmNlbGxzWzBdW2NvbF0uZGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGVzO1xuICAgIH07XG4gICAgRGF5VGFibGVNb2RlbC5wcm90b3R5cGUuc2xpY2VSYW5nZSA9IGZ1bmN0aW9uIChyYW5nZSkge1xuICAgICAgICB2YXIgY29sQ250ID0gdGhpcy5jb2xDbnQ7XG4gICAgICAgIHZhciBzZXJpZXNTZWcgPSB0aGlzLmRheVNlcmllcy5zbGljZVJhbmdlKHJhbmdlKTtcbiAgICAgICAgdmFyIHNlZ3MgPSBbXTtcbiAgICAgICAgaWYgKHNlcmllc1NlZykge1xuICAgICAgICAgICAgdmFyIGZpcnN0SW5kZXggPSBzZXJpZXNTZWcuZmlyc3RJbmRleCwgbGFzdEluZGV4ID0gc2VyaWVzU2VnLmxhc3RJbmRleDtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGZpcnN0SW5kZXg7XG4gICAgICAgICAgICB3aGlsZSAoaW5kZXggPD0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IE1hdGguZmxvb3IoaW5kZXggLyBjb2xDbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBNYXRoLm1pbigocm93ICsgMSkgKiBjb2xDbnQsIGxhc3RJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgIHNlZ3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHJvdzogcm93LFxuICAgICAgICAgICAgICAgICAgICBmaXJzdENvbDogaW5kZXggJSBjb2xDbnQsXG4gICAgICAgICAgICAgICAgICAgIGxhc3RDb2w6IChuZXh0SW5kZXggLSAxKSAlIGNvbENudCxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VyaWVzU2VnLmlzU3RhcnQgJiYgaW5kZXggPT09IGZpcnN0SW5kZXgsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZXJpZXNTZWcuaXNFbmQgJiYgKG5leHRJbmRleCAtIDEpID09PSBsYXN0SW5kZXgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZ3M7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGVNb2RlbDtcbn0oKSk7XG5cbnZhciBTbGljZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VyKCkge1xuICAgICAgICB0aGlzLnNsaWNlQnVzaW5lc3NIb3VycyA9IG1lbW9pemUodGhpcy5fc2xpY2VCdXNpbmVzc0hvdXJzKTtcbiAgICAgICAgdGhpcy5zbGljZURhdGVTZWxlY3Rpb24gPSBtZW1vaXplKHRoaXMuX3NsaWNlRGF0ZVNwYW4pO1xuICAgICAgICB0aGlzLnNsaWNlRXZlbnRTdG9yZSA9IG1lbW9pemUodGhpcy5fc2xpY2VFdmVudFN0b3JlKTtcbiAgICAgICAgdGhpcy5zbGljZUV2ZW50RHJhZyA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuc2xpY2VFdmVudFJlc2l6ZSA9IG1lbW9pemUodGhpcy5fc2xpY2VJbnRlcmFjdGlvbik7XG4gICAgICAgIHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtID0gZmFsc2U7IC8vIGhhY2tcbiAgICB9XG4gICAgU2xpY2VyLnByb3RvdHlwZS5zbGljZVByb3BzID0gZnVuY3Rpb24gKHByb3BzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50VWlCYXNlcyA9IHByb3BzLmV2ZW50VWlCYXNlcztcbiAgICAgICAgdmFyIGV2ZW50U2VncyA9IHRoaXMuc2xpY2VFdmVudFN0b3JlLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3Byb3BzLmV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGRdLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGVTZWxlY3Rpb25TZWdzOiB0aGlzLnNsaWNlRGF0ZVNlbGVjdGlvbi5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtwcm9wcy5kYXRlU2VsZWN0aW9uLCBldmVudFVpQmFzZXMsIGNvbnRleHRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGJ1c2luZXNzSG91clNlZ3M6IHRoaXMuc2xpY2VCdXNpbmVzc0hvdXJzLmFwcGx5KHRoaXMsIHRzbGliLl9fc3ByZWFkQXJyYXkoW3Byb3BzLmJ1c2luZXNzSG91cnMsIGRhdGVQcm9maWxlLCBuZXh0RGF5VGhyZXNob2xkLCBjb250ZXh0XSwgZXh0cmFBcmdzKSksXG4gICAgICAgICAgICBmZ0V2ZW50U2VnczogZXZlbnRTZWdzLmZnLFxuICAgICAgICAgICAgYmdFdmVudFNlZ3M6IGV2ZW50U2Vncy5iZyxcbiAgICAgICAgICAgIGV2ZW50RHJhZzogdGhpcy5zbGljZUV2ZW50RHJhZy5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtwcm9wcy5ldmVudERyYWcsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGV2ZW50UmVzaXplOiB0aGlzLnNsaWNlRXZlbnRSZXNpemUuYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbcHJvcHMuZXZlbnRSZXNpemUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGRdLCBleHRyYUFyZ3MpKSxcbiAgICAgICAgICAgIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbixcbiAgICAgICAgfTsgLy8gVE9ETzogZ2l2ZSBpbnRlcmFjdGlvblNlZ3M/XG4gICAgfTtcbiAgICBTbGljZXIucHJvdG90eXBlLnNsaWNlTm93RGF0ZSA9IGZ1bmN0aW9uICgvLyBkb2VzIG5vdCBtZW1vaXplXG4gICAgZGF0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSAyXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRGF0ZVNwYW4uYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbeyByYW5nZTogeyBzdGFydDogZGF0ZSwgZW5kOiBhZGRNcyhkYXRlLCAxKSB9LCBhbGxEYXk6IGZhbHNlIH0sXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGNvbnRleHRdLCBleHRyYUFyZ3MpKTtcbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlQnVzaW5lc3NIb3VycyA9IGZ1bmN0aW9uIChidXNpbmVzc0hvdXJzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCwgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFidXNpbmVzc0hvdXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NsaWNlRXZlbnRTdG9yZS5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3VycywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgY29udGV4dCksXG4gICAgICAgICAgICB7fSxcbiAgICAgICAgICAgIGRhdGVQcm9maWxlLFxuICAgICAgICAgICAgbmV4dERheVRocmVzaG9sZF0sIGV4dHJhQXJncykpLmJnO1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VFdmVudFN0b3JlID0gZnVuY3Rpb24gKGV2ZW50U3RvcmUsIGV2ZW50VWlCYXNlcywgZGF0ZVByb2ZpbGUsIG5leHREYXlUaHJlc2hvbGQpIHtcbiAgICAgICAgdmFyIGV4dHJhQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDQ7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZXh0cmFBcmdzW19pIC0gNF0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudFN0b3JlKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2VSZXMgPSBzbGljZUV2ZW50U3RvcmUoZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzLCBjb21wdXRlQWN0aXZlUmFuZ2UoZGF0ZVByb2ZpbGUsIEJvb2xlYW4obmV4dERheVRocmVzaG9sZCkpLCBuZXh0RGF5VGhyZXNob2xkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmc6IHRoaXMuc2xpY2VFdmVudFJhbmdlcyhyYW5nZVJlcy5iZywgZXh0cmFBcmdzKSxcbiAgICAgICAgICAgICAgICBmZzogdGhpcy5zbGljZUV2ZW50UmFuZ2VzKHJhbmdlUmVzLmZnLCBleHRyYUFyZ3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBiZzogW10sIGZnOiBbXSB9O1xuICAgIH07XG4gICAgU2xpY2VyLnByb3RvdHlwZS5fc2xpY2VJbnRlcmFjdGlvbiA9IGZ1bmN0aW9uIChpbnRlcmFjdGlvbiwgZXZlbnRVaUJhc2VzLCBkYXRlUHJvZmlsZSwgbmV4dERheVRocmVzaG9sZCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gNDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSA0XSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpbnRlcmFjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhbmdlUmVzID0gc2xpY2VFdmVudFN0b3JlKGludGVyYWN0aW9uLm11dGF0ZWRFdmVudHMsIGV2ZW50VWlCYXNlcywgY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBCb29sZWFuKG5leHREYXlUaHJlc2hvbGQpKSwgbmV4dERheVRocmVzaG9sZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzZWdzOiB0aGlzLnNsaWNlRXZlbnRSYW5nZXMocmFuZ2VSZXMuZmcsIGV4dHJhQXJncyksXG4gICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzLFxuICAgICAgICAgICAgaXNFdmVudDogaW50ZXJhY3Rpb24uaXNFdmVudCxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFNsaWNlci5wcm90b3R5cGUuX3NsaWNlRGF0ZVNwYW4gPSBmdW5jdGlvbiAoZGF0ZVNwYW4sIGV2ZW50VWlCYXNlcywgY29udGV4dCkge1xuICAgICAgICB2YXIgZXh0cmFBcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBleHRyYUFyZ3NbX2kgLSAzXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkYXRlU3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFJhbmdlID0gZmFicmljYXRlRXZlbnRSYW5nZShkYXRlU3BhbiwgZXZlbnRVaUJhc2VzLCBjb250ZXh0KTtcbiAgICAgICAgdmFyIHNlZ3MgPSB0aGlzLnNsaWNlUmFuZ2UuYXBwbHkodGhpcywgdHNsaWIuX19zcHJlYWRBcnJheShbZGF0ZVNwYW4ucmFuZ2VdLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBzZWdzXzEgPSBzZWdzOyBfYSA8IHNlZ3NfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzFbX2FdO1xuICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VFdmVudFJhbmdlcyA9IGZ1bmN0aW9uIChldmVudFJhbmdlcywgZXh0cmFBcmdzKSB7XG4gICAgICAgIHZhciBzZWdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgZXZlbnRSYW5nZXNfMSA9IGV2ZW50UmFuZ2VzOyBfaSA8IGV2ZW50UmFuZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRSYW5nZSA9IGV2ZW50UmFuZ2VzXzFbX2ldO1xuICAgICAgICAgICAgc2Vncy5wdXNoLmFwcGx5KHNlZ3MsIHRoaXMuc2xpY2VFdmVudFJhbmdlKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWdzO1xuICAgIH07XG4gICAgLypcbiAgICBcImNvbXBsZXRlXCIgc2VnIG1lYW5zIGl0IGhhcyBjb21wb25lbnQgYW5kIGV2ZW50UmFuZ2VcbiAgICAqL1xuICAgIFNsaWNlci5wcm90b3R5cGUuc2xpY2VFdmVudFJhbmdlID0gZnVuY3Rpb24gKGV2ZW50UmFuZ2UsIGV4dHJhQXJncykge1xuICAgICAgICB2YXIgZGF0ZVJhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICAgICAgLy8gaGFjayB0byBtYWtlIG11bHRpLWRheSBldmVudHMgdGhhdCBhcmUgYmVpbmcgZm9yY2UtZGlzcGxheWVkIGFzIGxpc3QtaXRlbXMgdG8gdGFrZSB1cCBvbmx5IG9uZSBkYXlcbiAgICAgICAgaWYgKHRoaXMuZm9yY2VEYXlJZkxpc3RJdGVtICYmIGV2ZW50UmFuZ2UudWkuZGlzcGxheSA9PT0gJ2xpc3QtaXRlbScpIHtcbiAgICAgICAgICAgIGRhdGVSYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBzdGFydDogZGF0ZVJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIGVuZDogYWRkRGF5cyhkYXRlUmFuZ2Uuc3RhcnQsIDEpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VncyA9IHRoaXMuc2xpY2VSYW5nZS5hcHBseSh0aGlzLCB0c2xpYi5fX3NwcmVhZEFycmF5KFtkYXRlUmFuZ2VdLCBleHRyYUFyZ3MpKTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzXzJbX2ldO1xuICAgICAgICAgICAgc2VnLmV2ZW50UmFuZ2UgPSBldmVudFJhbmdlO1xuICAgICAgICAgICAgc2VnLmlzU3RhcnQgPSBldmVudFJhbmdlLmlzU3RhcnQgJiYgc2VnLmlzU3RhcnQ7XG4gICAgICAgICAgICBzZWcuaXNFbmQgPSBldmVudFJhbmdlLmlzRW5kICYmIHNlZy5pc0VuZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VncztcbiAgICB9O1xuICAgIHJldHVybiBTbGljZXI7XG59KCkpO1xuLypcbmZvciBpbmNvcnBvcmF0aW5nIHNsb3RNaW5UaW1lL3Nsb3RNYXhUaW1lIGlmIGFwcHJvcHJpYXRlXG5UT0RPOiBzaG91bGQgYmUgcGFydCBvZiBEYXRlUHJvZmlsZSFcblRpbWVsaW5lRGF0ZVByb2ZpbGUgYWxyZWFkeSBkb2VzIHRoaXMgYnR3XG4qL1xuZnVuY3Rpb24gY29tcHV0ZUFjdGl2ZVJhbmdlKGRhdGVQcm9maWxlLCBpc0NvbXBvbmVudEFsbERheSkge1xuICAgIHZhciByYW5nZSA9IGRhdGVQcm9maWxlLmFjdGl2ZVJhbmdlO1xuICAgIGlmIChpc0NvbXBvbmVudEFsbERheSkge1xuICAgICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBhZGRNcyhyYW5nZS5zdGFydCwgZGF0ZVByb2ZpbGUuc2xvdE1pblRpbWUubWlsbGlzZWNvbmRzKSxcbiAgICAgICAgZW5kOiBhZGRNcyhyYW5nZS5lbmQsIGRhdGVQcm9maWxlLnNsb3RNYXhUaW1lLm1pbGxpc2Vjb25kcyAtIDg2NGU1KSwgLy8gODY0ZTUgPSBtcyBpbiBhIGRheVxuICAgIH07XG59XG5cbi8vIGhpZ2gtbGV2ZWwgc2VnbWVudGluZy1hd2FyZSB0ZXN0ZXIgZnVuY3Rpb25zXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25WYWxpZChpbnRlcmFjdGlvbiwgZGF0ZVByb2ZpbGUsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdGFuY2VzID0gaW50ZXJhY3Rpb24ubXV0YXRlZEV2ZW50cy5pbnN0YW5jZXM7XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc05ld1Byb3BzVmFsaWQoeyBldmVudERyYWc6IGludGVyYWN0aW9uIH0sIGNvbnRleHQpOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbn1cbmZ1bmN0aW9uIGlzRGF0ZVNlbGVjdGlvblZhbGlkKGRhdGVTZWxlY3Rpb24sIGRhdGVQcm9maWxlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFyYW5nZUNvbnRhaW5zUmFuZ2UoZGF0ZVByb2ZpbGUudmFsaWRSYW5nZSwgZGF0ZVNlbGVjdGlvbi5yYW5nZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaXNOZXdQcm9wc1ZhbGlkKHsgZGF0ZVNlbGVjdGlvbjogZGF0ZVNlbGVjdGlvbiB9LCBjb250ZXh0KTtcbn1cbmZ1bmN0aW9uIGlzTmV3UHJvcHNWYWxpZChuZXdQcm9wcywgY29udGV4dCkge1xuICAgIHZhciBjYWxlbmRhclN0YXRlID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpO1xuICAgIHZhciBwcm9wcyA9IHRzbGliLl9fYXNzaWduKHsgYnVzaW5lc3NIb3VyczogY2FsZW5kYXJTdGF0ZS5idXNpbmVzc0hvdXJzLCBkYXRlU2VsZWN0aW9uOiAnJywgZXZlbnRTdG9yZTogY2FsZW5kYXJTdGF0ZS5ldmVudFN0b3JlLCBldmVudFVpQmFzZXM6IGNhbGVuZGFyU3RhdGUuZXZlbnRVaUJhc2VzLCBldmVudFNlbGVjdGlvbjogJycsIGV2ZW50RHJhZzogbnVsbCwgZXZlbnRSZXNpemU6IG51bGwgfSwgbmV3UHJvcHMpO1xuICAgIHJldHVybiAoY29udGV4dC5wbHVnaW5Ib29rcy5pc1Byb3BzVmFsaWQgfHwgaXNQcm9wc1ZhbGlkKShwcm9wcywgY29udGV4dCk7XG59XG5mdW5jdGlvbiBpc1Byb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSB7XG4gICAgaWYgKGRhdGVTcGFuTWV0YSA9PT0gdm9pZCAwKSB7IGRhdGVTcGFuTWV0YSA9IHt9OyB9XG4gICAgaWYgKHN0YXRlLmV2ZW50RHJhZyAmJiAhaXNJbnRlcmFjdGlvblByb3BzVmFsaWQoc3RhdGUsIGNvbnRleHQsIGRhdGVTcGFuTWV0YSwgZmlsdGVyQ29uZmlnKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzdGF0ZS5kYXRlU2VsZWN0aW9uICYmICFpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIE1vdmluZyBFdmVudCBWYWxpZGF0aW9uXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmZ1bmN0aW9uIGlzSW50ZXJhY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIHZhciBjdXJyZW50U3RhdGUgPSBjb250ZXh0LmdldEN1cnJlbnREYXRhKCk7XG4gICAgdmFyIGludGVyYWN0aW9uID0gc3RhdGUuZXZlbnREcmFnOyAvLyBIQUNLOiB0aGUgZXZlbnREcmFnIHByb3BzIGlzIHVzZWQgZm9yIEFMTCBpbnRlcmFjdGlvbnNcbiAgICB2YXIgc3ViamVjdEV2ZW50U3RvcmUgPSBpbnRlcmFjdGlvbi5tdXRhdGVkRXZlbnRzO1xuICAgIHZhciBzdWJqZWN0RGVmcyA9IHN1YmplY3RFdmVudFN0b3JlLmRlZnM7XG4gICAgdmFyIHN1YmplY3RJbnN0YW5jZXMgPSBzdWJqZWN0RXZlbnRTdG9yZS5pbnN0YW5jZXM7XG4gICAgdmFyIHN1YmplY3RDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKHN1YmplY3REZWZzLCBpbnRlcmFjdGlvbi5pc0V2ZW50ID9cbiAgICAgICAgc3RhdGUuZXZlbnRVaUJhc2VzIDpcbiAgICAgICAgeyAnJzogY3VycmVudFN0YXRlLnNlbGVjdGlvbkNvbmZpZyB9KTtcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHN1YmplY3RDb25maWdzID0gbWFwSGFzaChzdWJqZWN0Q29uZmlncywgZmlsdGVyQ29uZmlnKTtcbiAgICB9XG4gICAgLy8gZXhjbHVkZSB0aGUgc3ViamVjdCBldmVudHMuIFRPRE86IGV4Y2x1ZGUgZGVmcyB0b28/XG4gICAgdmFyIG90aGVyRXZlbnRTdG9yZSA9IGV4Y2x1ZGVJbnN0YW5jZXMoc3RhdGUuZXZlbnRTdG9yZSwgaW50ZXJhY3Rpb24uYWZmZWN0ZWRFdmVudHMuaW5zdGFuY2VzKTtcbiAgICB2YXIgb3RoZXJEZWZzID0gb3RoZXJFdmVudFN0b3JlLmRlZnM7XG4gICAgdmFyIG90aGVySW5zdGFuY2VzID0gb3RoZXJFdmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgb3RoZXJDb25maWdzID0gY29tcGlsZUV2ZW50VWlzKG90aGVyRGVmcywgc3RhdGUuZXZlbnRVaUJhc2VzKTtcbiAgICBmb3IgKHZhciBzdWJqZWN0SW5zdGFuY2VJZCBpbiBzdWJqZWN0SW5zdGFuY2VzKSB7XG4gICAgICAgIHZhciBzdWJqZWN0SW5zdGFuY2UgPSBzdWJqZWN0SW5zdGFuY2VzW3N1YmplY3RJbnN0YW5jZUlkXTtcbiAgICAgICAgdmFyIHN1YmplY3RSYW5nZSA9IHN1YmplY3RJbnN0YW5jZS5yYW5nZTtcbiAgICAgICAgdmFyIHN1YmplY3RDb25maWcgPSBzdWJqZWN0Q29uZmlnc1tzdWJqZWN0SW5zdGFuY2UuZGVmSWRdO1xuICAgICAgICB2YXIgc3ViamVjdERlZiA9IHN1YmplY3REZWZzW3N1YmplY3RJbnN0YW5jZS5kZWZJZF07XG4gICAgICAgIC8vIGNvbnN0cmFpbnRcbiAgICAgICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc3ViamVjdENvbmZpZy5jb25zdHJhaW50cywgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIHN0YXRlLmJ1c2luZXNzSG91cnMsIGNvbnRleHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3ZlcmxhcFxuICAgICAgICB2YXIgZXZlbnRPdmVybGFwID0gY29udGV4dC5vcHRpb25zLmV2ZW50T3ZlcmxhcDtcbiAgICAgICAgdmFyIGV2ZW50T3ZlcmxhcEZ1bmMgPSB0eXBlb2YgZXZlbnRPdmVybGFwID09PSAnZnVuY3Rpb24nID8gZXZlbnRPdmVybGFwIDogbnVsbDtcbiAgICAgICAgZm9yICh2YXIgb3RoZXJJbnN0YW5jZUlkIGluIG90aGVySW5zdGFuY2VzKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJJbnN0YW5jZSA9IG90aGVySW5zdGFuY2VzW290aGVySW5zdGFuY2VJZF07XG4gICAgICAgICAgICAvLyBpbnRlcnNlY3QhIGV2YWx1YXRlXG4gICAgICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHN1YmplY3RSYW5nZSwgb3RoZXJJbnN0YW5jZS5yYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3RoZXJPdmVybGFwID0gb3RoZXJDb25maWdzW290aGVySW5zdGFuY2UuZGVmSWRdLm92ZXJsYXA7XG4gICAgICAgICAgICAgICAgLy8gY29uc2lkZXIgdGhlIG90aGVyIGV2ZW50J3Mgb3ZlcmxhcC4gb25seSBkbyB0aGlzIGlmIHRoZSBzdWJqZWN0IGV2ZW50IGlzIGEgXCJyZWFsXCIgZXZlbnRcbiAgICAgICAgICAgICAgICBpZiAob3RoZXJPdmVybGFwID09PSBmYWxzZSAmJiBpbnRlcmFjdGlvbi5pc0V2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YmplY3RDb25maWcub3ZlcmxhcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnRPdmVybGFwRnVuYyAmJiAhZXZlbnRPdmVybGFwRnVuYyhuZXcgRXZlbnRBcGkoY29udGV4dCwgb3RoZXJEZWZzW290aGVySW5zdGFuY2UuZGVmSWRdLCBvdGhlckluc3RhbmNlKSwgLy8gc3RpbGwgZXZlbnRcbiAgICAgICAgICAgICAgICBuZXcgRXZlbnRBcGkoY29udGV4dCwgc3ViamVjdERlZiwgc3ViamVjdEluc3RhbmNlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhbGxvdyAoYSBmdW5jdGlvbilcbiAgICAgICAgdmFyIGNhbGVuZGFyRXZlbnRTdG9yZSA9IGN1cnJlbnRTdGF0ZS5ldmVudFN0b3JlOyAvLyBuZWVkIGdsb2JhbC10by1jYWxlbmRhciwgbm90IGxvY2FsIHRvIGNvbXBvbmVudCAoc3BsaXR0YWJsZSlzdGF0ZVxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gc3ViamVjdENvbmZpZy5hbGxvd3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3ViamVjdEFsbG93ID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIHN1YmplY3REYXRlU3BhbiA9IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBkYXRlU3Bhbk1ldGEpLCB7IHJhbmdlOiBzdWJqZWN0SW5zdGFuY2UucmFuZ2UsIGFsbERheTogc3ViamVjdERlZi5hbGxEYXkgfSk7XG4gICAgICAgICAgICB2YXIgb3JpZ0RlZiA9IGNhbGVuZGFyRXZlbnRTdG9yZS5kZWZzW3N1YmplY3REZWYuZGVmSWRdO1xuICAgICAgICAgICAgdmFyIG9yaWdJbnN0YW5jZSA9IGNhbGVuZGFyRXZlbnRTdG9yZS5pbnN0YW5jZXNbc3ViamVjdEluc3RhbmNlSWRdO1xuICAgICAgICAgICAgdmFyIGV2ZW50QXBpID0gdm9pZCAwO1xuICAgICAgICAgICAgaWYgKG9yaWdEZWYpIHsgLy8gd2FzIHByZXZpb3VzbHkgaW4gdGhlIGNhbGVuZGFyXG4gICAgICAgICAgICAgICAgZXZlbnRBcGkgPSBuZXcgRXZlbnRBcGkoY29udGV4dCwgb3JpZ0RlZiwgb3JpZ0luc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyB3YXMgYW4gZXh0ZXJuYWwgZXZlbnRcbiAgICAgICAgICAgICAgICBldmVudEFwaSA9IG5ldyBFdmVudEFwaShjb250ZXh0LCBzdWJqZWN0RGVmKTsgLy8gbm8gaW5zdGFuY2UsIGJlY2F1c2UgaGFkIG5vIGRhdGVzXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN1YmplY3RBbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoc3ViamVjdERhdGVTcGFuLCBjb250ZXh0KSwgZXZlbnRBcGkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLy8gRGF0ZSBTZWxlY3Rpb24gVmFsaWRhdGlvblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBpc0RhdGVTZWxlY3Rpb25Qcm9wc1ZhbGlkKHN0YXRlLCBjb250ZXh0LCBkYXRlU3Bhbk1ldGEsIGZpbHRlckNvbmZpZykge1xuICAgIHZhciByZWxldmFudEV2ZW50U3RvcmUgPSBzdGF0ZS5ldmVudFN0b3JlO1xuICAgIHZhciByZWxldmFudERlZnMgPSByZWxldmFudEV2ZW50U3RvcmUuZGVmcztcbiAgICB2YXIgcmVsZXZhbnRJbnN0YW5jZXMgPSByZWxldmFudEV2ZW50U3RvcmUuaW5zdGFuY2VzO1xuICAgIHZhciBzZWxlY3Rpb24gPSBzdGF0ZS5kYXRlU2VsZWN0aW9uO1xuICAgIHZhciBzZWxlY3Rpb25SYW5nZSA9IHNlbGVjdGlvbi5yYW5nZTtcbiAgICB2YXIgc2VsZWN0aW9uQ29uZmlnID0gY29udGV4dC5nZXRDdXJyZW50RGF0YSgpLnNlbGVjdGlvbkNvbmZpZztcbiAgICBpZiAoZmlsdGVyQ29uZmlnKSB7XG4gICAgICAgIHNlbGVjdGlvbkNvbmZpZyA9IGZpbHRlckNvbmZpZyhzZWxlY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICAvLyBjb25zdHJhaW50XG4gICAgaWYgKCFhbGxDb25zdHJhaW50c1Bhc3Moc2VsZWN0aW9uQ29uZmlnLmNvbnN0cmFpbnRzLCBzZWxlY3Rpb25SYW5nZSwgcmVsZXZhbnRFdmVudFN0b3JlLCBzdGF0ZS5idXNpbmVzc0hvdXJzLCBjb250ZXh0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG92ZXJsYXBcbiAgICB2YXIgc2VsZWN0T3ZlcmxhcCA9IGNvbnRleHQub3B0aW9ucy5zZWxlY3RPdmVybGFwO1xuICAgIHZhciBzZWxlY3RPdmVybGFwRnVuYyA9IHR5cGVvZiBzZWxlY3RPdmVybGFwID09PSAnZnVuY3Rpb24nID8gc2VsZWN0T3ZlcmxhcCA6IG51bGw7XG4gICAgZm9yICh2YXIgcmVsZXZhbnRJbnN0YW5jZUlkIGluIHJlbGV2YW50SW5zdGFuY2VzKSB7XG4gICAgICAgIHZhciByZWxldmFudEluc3RhbmNlID0gcmVsZXZhbnRJbnN0YW5jZXNbcmVsZXZhbnRJbnN0YW5jZUlkXTtcbiAgICAgICAgLy8gaW50ZXJzZWN0ISBldmFsdWF0ZVxuICAgICAgICBpZiAocmFuZ2VzSW50ZXJzZWN0KHNlbGVjdGlvblJhbmdlLCByZWxldmFudEluc3RhbmNlLnJhbmdlKSkge1xuICAgICAgICAgICAgaWYgKHNlbGVjdGlvbkNvbmZpZy5vdmVybGFwID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxlY3RPdmVybGFwRnVuYyAmJiAhc2VsZWN0T3ZlcmxhcEZ1bmMobmV3IEV2ZW50QXBpKGNvbnRleHQsIHJlbGV2YW50RGVmc1tyZWxldmFudEluc3RhbmNlLmRlZklkXSwgcmVsZXZhbnRJbnN0YW5jZSksIG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGFsbG93IChhIGZ1bmN0aW9uKVxuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBzZWxlY3Rpb25Db25maWcuYWxsb3dzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VsZWN0aW9uQWxsb3cgPSBfYVtfaV07XG4gICAgICAgIHZhciBmdWxsRGF0ZVNwYW4gPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgZGF0ZVNwYW5NZXRhKSwgc2VsZWN0aW9uKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25BbGxvdyhidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQoZnVsbERhdGVTcGFuLCBjb250ZXh0KSwgbnVsbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8vIENvbnN0cmFpbnQgVXRpbHNcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuZnVuY3Rpb24gYWxsQ29uc3RyYWludHNQYXNzKGNvbnN0cmFpbnRzLCBzdWJqZWN0UmFuZ2UsIG90aGVyRXZlbnRTdG9yZSwgYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIGNvbnRleHQpIHtcbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnN0cmFpbnRzXzEgPSBjb25zdHJhaW50czsgX2kgPCBjb25zdHJhaW50c18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29uc3RyYWludCA9IGNvbnN0cmFpbnRzXzFbX2ldO1xuICAgICAgICBpZiAoIWFueVJhbmdlc0NvbnRhaW5SYW5nZShjb25zdHJhaW50VG9SYW5nZXMoY29uc3RyYWludCwgc3ViamVjdFJhbmdlLCBvdGhlckV2ZW50U3RvcmUsIGJ1c2luZXNzSG91cnNVbmV4cGFuZGVkLCBjb250ZXh0KSwgc3ViamVjdFJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gY29uc3RyYWludFRvUmFuZ2VzKGNvbnN0cmFpbnQsIHN1YmplY3RSYW5nZSwgLy8gZm9yIGV4cGFuZGluZyBhIHJlY3VycmluZyBjb25zdHJhaW50LCBvciBleHBhbmRpbmcgYnVzaW5lc3MgaG91cnNcbm90aGVyRXZlbnRTdG9yZSwgLy8gZm9yIGlmIGNvbnN0cmFpbnQgaXMgYW4gZXZlbiBncm91cCBJRFxuYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIC8vIGZvciBpZiBjb25zdHJhaW50IGlzICdidXNpbmVzc0hvdXJzJ1xuY29udGV4dCkge1xuICAgIGlmIChjb25zdHJhaW50ID09PSAnYnVzaW5lc3NIb3VycycpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50U3RvcmVUb1JhbmdlcyhleHBhbmRSZWN1cnJpbmcoYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQsIHN1YmplY3RSYW5nZSwgY29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNvbnN0cmFpbnQgPT09ICdzdHJpbmcnKSB7IC8vIGFuIGdyb3VwIElEXG4gICAgICAgIHJldHVybiBldmVudFN0b3JlVG9SYW5nZXMoZmlsdGVyRXZlbnRTdG9yZURlZnMob3RoZXJFdmVudFN0b3JlLCBmdW5jdGlvbiAoZXZlbnREZWYpIHsgcmV0dXJuIGV2ZW50RGVmLmdyb3VwSWQgPT09IGNvbnN0cmFpbnQ7IH0pKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjb25zdHJhaW50ID09PSAnb2JqZWN0JyAmJiBjb25zdHJhaW50KSB7IC8vIG5vbi1udWxsIG9iamVjdFxuICAgICAgICByZXR1cm4gZXZlbnRTdG9yZVRvUmFuZ2VzKGV4cGFuZFJlY3VycmluZyhjb25zdHJhaW50LCBzdWJqZWN0UmFuZ2UsIGNvbnRleHQpKTtcbiAgICB9XG4gICAgcmV0dXJuIFtdOyAvLyBpZiBpdCdzIGZhbHNlXG59XG4vLyBUT0RPOiBtb3ZlIHRvIGV2ZW50LXN0b3JlIGZpbGU/XG5mdW5jdGlvbiBldmVudFN0b3JlVG9SYW5nZXMoZXZlbnRTdG9yZSkge1xuICAgIHZhciBpbnN0YW5jZXMgPSBldmVudFN0b3JlLmluc3RhbmNlcztcbiAgICB2YXIgcmFuZ2VzID0gW107XG4gICAgZm9yICh2YXIgaW5zdGFuY2VJZCBpbiBpbnN0YW5jZXMpIHtcbiAgICAgICAgcmFuZ2VzLnB1c2goaW5zdGFuY2VzW2luc3RhbmNlSWRdLnJhbmdlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlcztcbn1cbi8vIFRPRE86IG1vdmUgdG8gZ2VvbSBmaWxlP1xuZnVuY3Rpb24gYW55UmFuZ2VzQ29udGFpblJhbmdlKG91dGVyUmFuZ2VzLCBpbm5lclJhbmdlKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBvdXRlclJhbmdlc18xID0gb3V0ZXJSYW5nZXM7IF9pIDwgb3V0ZXJSYW5nZXNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIG91dGVyUmFuZ2UgPSBvdXRlclJhbmdlc18xW19pXTtcbiAgICAgICAgaWYgKHJhbmdlQ29udGFpbnNSYW5nZShvdXRlclJhbmdlLCBpbm5lclJhbmdlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgVklTSUJMRV9ISURERU5fUkUgPSAvXih2aXNpYmxlfGhpZGRlbikkLztcbnZhciBTY3JvbGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoU2Nyb2xsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2Nyb2xsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5oYW5kbGVFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgX3RoaXMuZWwgPSBlbDtcbiAgICAgICAgICAgIHNldFJlZihfdGhpcy5wcm9wcy5lbFJlZiwgZWwpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBsaXF1aWQgPSBwcm9wcy5saXF1aWQsIGxpcXVpZElzQWJzb2x1dGUgPSBwcm9wcy5saXF1aWRJc0Fic29sdXRlO1xuICAgICAgICB2YXIgaXNBYnNvbHV0ZSA9IGxpcXVpZCAmJiBsaXF1aWRJc0Fic29sdXRlO1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gWydmYy1zY3JvbGxlciddO1xuICAgICAgICBpZiAobGlxdWlkKSB7XG4gICAgICAgICAgICBpZiAobGlxdWlkSXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQtYWJzb2x1dGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZS5wdXNoKCdmYy1zY3JvbGxlci1saXF1aWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHRoaXMuaGFuZGxlRWwsIGNsYXNzTmFtZTogY2xhc3NOYW1lLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1g6IHByb3BzLm92ZXJmbG93WCxcbiAgICAgICAgICAgICAgICBvdmVyZmxvd1k6IHByb3BzLm92ZXJmbG93WSxcbiAgICAgICAgICAgICAgICBsZWZ0OiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lTGVmdCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgcmlnaHQ6IChpc0Fic29sdXRlICYmIC0ocHJvcHMub3ZlcmNvbWVSaWdodCB8fCAwKSkgfHwgJycsXG4gICAgICAgICAgICAgICAgYm90dG9tOiAoaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5MZWZ0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZUxlZnQgfHwgMCkpIHx8ICcnLFxuICAgICAgICAgICAgICAgIG1hcmdpblJpZ2h0OiAoIWlzQWJzb2x1dGUgJiYgLShwcm9wcy5vdmVyY29tZVJpZ2h0IHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXJnaW5Cb3R0b206ICghaXNBYnNvbHV0ZSAmJiAtKHByb3BzLm92ZXJjb21lQm90dG9tIHx8IDApKSB8fCAnJyxcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQ6IHByb3BzLm1heEhlaWdodCB8fCAnJyxcbiAgICAgICAgICAgIH0gfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIFNjcm9sbGVyLnByb3RvdHlwZS5uZWVkc1hTY3JvbGxpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChWSVNJQkxFX0hJRERFTl9SRS50ZXN0KHRoaXMucHJvcHMub3ZlcmZsb3dYKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRlc3Rpbmcgc2Nyb2xsV2lkdGg+Y2xpZW50V2lkdGggaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgcmVhbENsaWVudFdpZHRoID0gdGhpcy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHRoaXMuZ2V0WVNjcm9sbGJhcldpZHRoKCk7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgY2hpbGRFbCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggPiByZWFsQ2xpZW50V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBTY3JvbGxlci5wcm90b3R5cGUubmVlZHNZU2Nyb2xsaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoVklTSUJMRV9ISURERU5fUkUudGVzdCh0aGlzLnByb3BzLm92ZXJmbG93WSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0ZXN0aW5nIHNjcm9sbEhlaWdodD5jbGllbnRIZWlnaHQgaXMgdW5yZWxpYWJsZSBjcm9zcy1icm93c2VyIHdoZW4gcGl4ZWwgaGVpZ2h0cyBhcmVuJ3QgaW50ZWdlcnMuXG4gICAgICAgIC8vIG11Y2ggbW9yZSByZWxpYWJsZSB0byBzZWUgaWYgY2hpbGRyZW4gYXJlIHRhbGxlciB0aGFuIHRoZSBzY3JvbGxlciwgZXZlbiB0aG8gZG9lc24ndCBhY2NvdW50IGZvclxuICAgICAgICAvLyBpbm5lci1jaGlsZCBtYXJnaW5zIGFuZCBhYnNvbHV0ZSBwb3NpdGlvbmluZ1xuICAgICAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgICAgICB2YXIgcmVhbENsaWVudEhlaWdodCA9IHRoaXMuZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IC0gdGhpcy5nZXRYU2Nyb2xsYmFyV2lkdGgoKTtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZEVsID0gY2hpbGRyZW5baV07XG4gICAgICAgICAgICBpZiAoY2hpbGRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgPiByZWFsQ2xpZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFhTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1gpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRIZWlnaHQgLSB0aGlzLmVsLmNsaWVudEhlaWdodDsgLy8gb25seSB3b3JrcyBiZWNhdXNlIHdlIGd1YXJhbnRlZSBubyBib3JkZXJzLiBUT0RPOiBhZGQgdG8gQ1NTIHdpdGggaW1wb3J0YW50P1xuICAgIH07XG4gICAgU2Nyb2xsZXIucHJvdG90eXBlLmdldFlTY3JvbGxiYXJXaWR0aCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKFZJU0lCTEVfSElEREVOX1JFLnRlc3QodGhpcy5wcm9wcy5vdmVyZmxvd1kpKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5lbC5vZmZzZXRXaWR0aCAtIHRoaXMuZWwuY2xpZW50V2lkdGg7IC8vIG9ubHkgd29ya3MgYmVjYXVzZSB3ZSBndWFyYW50ZWUgbm8gYm9yZGVycy4gVE9ETzogYWRkIHRvIENTUyB3aXRoIGltcG9ydGFudD9cbiAgICB9O1xuICAgIHJldHVybiBTY3JvbGxlcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG4vKlxuVE9ETzogc29tZWhvdyBpbmZlciBPdGhlckFyZ3MgZnJvbSBtYXN0ZXJDYWxsYmFjaz9cblRPRE86IGluZmVyIFJlZlR5cGUgZnJvbSBtYXN0ZXJDYWxsYmFjayBpZiBwcm92aWRlZFxuKi9cbnZhciBSZWZNYXAgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVmTWFwKG1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubWFzdGVyQ2FsbGJhY2sgPSBtYXN0ZXJDYWxsYmFjaztcbiAgICAgICAgdGhpcy5jdXJyZW50TWFwID0ge307XG4gICAgICAgIHRoaXMuZGVwdGhzID0ge307XG4gICAgICAgIHRoaXMuY2FsbGJhY2tNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5oYW5kbGVWYWx1ZSA9IGZ1bmN0aW9uICh2YWwsIGtleSkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIGRlcHRocyA9IF9hLmRlcHRocywgY3VycmVudE1hcCA9IF9hLmN1cnJlbnRNYXA7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodmFsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIGJ1Zy4uLiBBQ1RVQUxMWTogY2FuIHByb2JhYmx5IGRvIGF3YXkgd2l0aCB0aGlzIG5vdyB0aGF0IGNhbGxlcnMgZG9uJ3Qgc2hhcmUgbnVtZXJpYyBpbmRpY2VzIGFueW1vcmVcbiAgICAgICAgICAgICAgICByZW1vdmVkID0gKGtleSBpbiBjdXJyZW50TWFwKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFwW2tleV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgZGVwdGhzW2tleV0gPSAoZGVwdGhzW2tleV0gfHwgMCkgKyAxO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlcHRoc1trZXldIC09IDE7XG4gICAgICAgICAgICAgICAgaWYgKCFkZXB0aHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgY3VycmVudE1hcFtrZXldO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuY2FsbGJhY2tNYXBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLm1hc3RlckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFzdGVyQ2FsbGJhY2sobnVsbCwgU3RyaW5nKGtleSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMubWFzdGVyQ2FsbGJhY2sodmFsLCBTdHJpbmcoa2V5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBSZWZNYXAucHJvdG90eXBlLmNyZWF0ZVJlZiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlZkNhbGxiYWNrID0gdGhpcy5jYWxsYmFja01hcFtrZXldO1xuICAgICAgICBpZiAoIXJlZkNhbGxiYWNrKSB7XG4gICAgICAgICAgICByZWZDYWxsYmFjayA9IHRoaXMuY2FsbGJhY2tNYXBba2V5XSA9IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVWYWx1ZSh2YWwsIFN0cmluZyhrZXkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZkNhbGxiYWNrO1xuICAgIH07XG4gICAgLy8gVE9ETzogY2hlY2sgY2FsbGVycyB0aGF0IGRvbid0IGNhcmUgYWJvdXQgb3JkZXIuIHNob3VsZCB1c2UgZ2V0QWxsIGluc3RlYWRcbiAgICAvLyBOT1RFOiB0aGlzIG1ldGhvZCBoYXMgYmVjb21lIGxlc3MgdmFsdWFibGUgbm93IHRoYXQgd2UgYXJlIGVuY291cmFnZWQgdG8gbWFwIG9yZGVyIGJ5IHNvbWUgb3RoZXIgaW5kZXhcbiAgICAvLyBUT0RPOiBwcm92aWRlIE9ORSBhcnJheS1leHBvcnQgZnVuY3Rpb24sIGJ1aWxkQXJyYXksIHdoaWNoIGZhaWxzIG9uIG5vbi1udW1lcmljIGluZGV4ZXMuIGNhbGxlciBjYW4gbWFuaXB1bGF0ZSBhbmQgXCJjb2xsZWN0XCJcbiAgICBSZWZNYXAucHJvdG90eXBlLmNvbGxlY3QgPSBmdW5jdGlvbiAoc3RhcnRJbmRleCwgZW5kSW5kZXgsIHN0ZXApIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3RGcm9tSGFzaCh0aGlzLmN1cnJlbnRNYXAsIHN0YXJ0SW5kZXgsIGVuZEluZGV4LCBzdGVwKTtcbiAgICB9O1xuICAgIFJlZk1hcC5wcm90b3R5cGUuZ2V0QWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFzaFZhbHVlc1RvQXJyYXkodGhpcy5jdXJyZW50TWFwKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWZNYXA7XG59KCkpO1xuXG5mdW5jdGlvbiBjb21wdXRlU2hyaW5rV2lkdGgoY2h1bmtFbHMpIHtcbiAgICB2YXIgc2hyaW5rQ2VsbHMgPSBmaW5kRWxlbWVudHMoY2h1bmtFbHMsICcuZmMtc2Nyb2xsZ3JpZC1zaHJpbmsnKTtcbiAgICB2YXIgbGFyZ2VzdFdpZHRoID0gMDtcbiAgICBmb3IgKHZhciBfaSA9IDAsIHNocmlua0NlbGxzXzEgPSBzaHJpbmtDZWxsczsgX2kgPCBzaHJpbmtDZWxsc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2hyaW5rQ2VsbCA9IHNocmlua0NlbGxzXzFbX2ldO1xuICAgICAgICBsYXJnZXN0V2lkdGggPSBNYXRoLm1heChsYXJnZXN0V2lkdGgsIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aChzaHJpbmtDZWxsKSk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmNlaWwobGFyZ2VzdFdpZHRoKTsgLy8gPHRhYmxlPiBlbGVtZW50cyB3b3JrIGJlc3Qgd2l0aCBpbnRlZ2Vycy4gcm91bmQgdXAgdG8gZW5zdXJlIGNvbnRlbnRzIGZpdHNcbn1cbmZ1bmN0aW9uIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gcHJvcHMubGlxdWlkICYmIHNlY3Rpb25Db25maWcubGlxdWlkOyAvLyBkb2VzIHRoZSBzZWN0aW9uIGRvIGxpcXVpZC1oZWlnaHQ/IChuZWVkIHRvIGhhdmUgd2hvbGUgc2Nyb2xsZ3JpZCBsaXF1aWQtaGVpZ2h0IGFzIHdlbGwpXG59XG5mdW5jdGlvbiBnZXRBbGxvd1lTY3JvbGxpbmcocHJvcHMsIHNlY3Rpb25Db25maWcpIHtcbiAgICByZXR1cm4gc2VjdGlvbkNvbmZpZy5tYXhIZWlnaHQgIT0gbnVsbCB8fCAvLyBpZiBpdHMgcG9zc2libGUgZm9yIHRoZSBoZWlnaHQgdG8gbWF4IG91dCwgd2UgbWlnaHQgbmVlZCBzY3JvbGxiYXJzXG4gICAgICAgIGdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQocHJvcHMsIHNlY3Rpb25Db25maWcpOyAvLyBpZiB0aGUgc2VjdGlvbiBpcyBsaXF1aWQgaGVpZ2h0LCBpdCBtaWdodCBjb25kZW5zZSBlbm91Z2ggdG8gcmVxdWlyZSBzY3JvbGxiYXJzXG59XG4vLyBUT0RPOiBPTkxZIHVzZSBgYXJnYC4gZm9yY2Ugb3V0IGludGVybmFsIGZ1bmN0aW9uIHRvIHVzZSBzYW1lIEFQSVxuZnVuY3Rpb24gcmVuZGVyQ2h1bmtDb250ZW50KHNlY3Rpb25Db25maWcsIGNodW5rQ29uZmlnLCBhcmcsIGlzSGVhZGVyKSB7XG4gICAgdmFyIGV4cGFuZFJvd3MgPSBhcmcuZXhwYW5kUm93cztcbiAgICB2YXIgY29udGVudCA9IHR5cGVvZiBjaHVua0NvbmZpZy5jb250ZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgY2h1bmtDb25maWcuY29udGVudChhcmcpIDpcbiAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudCgndGFibGUnLCB7XG4gICAgICAgICAgICByb2xlOiAncHJlc2VudGF0aW9uJyxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogW1xuICAgICAgICAgICAgICAgIGNodW5rQ29uZmlnLnRhYmxlQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHNlY3Rpb25Db25maWcuc3luY1Jvd0hlaWdodHMgPyAnZmMtc2Nyb2xsZ3JpZC1zeW5jLXRhYmxlJyA6ICcnLFxuICAgICAgICAgICAgXS5qb2luKCcgJyksXG4gICAgICAgICAgICBzdHlsZToge1xuICAgICAgICAgICAgICAgIG1pbldpZHRoOiBhcmcudGFibGVNaW5XaWR0aCxcbiAgICAgICAgICAgICAgICB3aWR0aDogYXJnLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogZXhwYW5kUm93cyA/IGFyZy5jbGllbnRIZWlnaHQgOiAnJywgLy8gY3NzIGBoZWlnaHRgIG9uIGEgPHRhYmxlPiBzZXJ2ZXMgYXMgYSBtaW4taGVpZ2h0XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LCBhcmcudGFibGVDb2xHcm91cE5vZGUsIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoaXNIZWFkZXIgPyAndGhlYWQnIDogJ3Rib2R5Jywge1xuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIHR5cGVvZiBjaHVua0NvbmZpZy5yb3dDb250ZW50ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IGNodW5rQ29uZmlnLnJvd0NvbnRlbnQoYXJnKVxuICAgICAgICAgICAgOiBjaHVua0NvbmZpZy5yb3dDb250ZW50KSk7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG59XG5mdW5jdGlvbiBpc0NvbFByb3BzRXF1YWwoY29sczAsIGNvbHMxKSB7XG4gICAgcmV0dXJuIGlzQXJyYXlzRXF1YWwoY29sczAsIGNvbHMxLCBpc1Byb3BzRXF1YWwpO1xufVxuZnVuY3Rpb24gcmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzaHJpbmtXaWR0aCkge1xuICAgIHZhciBjb2xOb2RlcyA9IFtdO1xuICAgIC8qXG4gICAgZm9yIENvbFByb3BzIHdpdGggc3BhbnMsIGl0IHdvdWxkIGhhdmUgYmVlbiBncmVhdCB0byBtYWtlIGEgc2luZ2xlIDxjb2wgc3Bhbj1cIlwiPlxuICAgIEhPV0VWRVIsIENocm9tZSB3YXMgZ2V0dGluZyBtZXNzaW5nIHVwIGRpc3RyaWJ1dGluZyB0aGUgd2lkdGggdG8gPHRkPi88dGg+IGVsZW1lbnRzIHdpdGggY29sc3BhbnMuXG4gICAgU09MVVRJT046IG1ha2luZyBpbmRpdmlkdWFsIDxjb2w+IGVsZW1lbnRzIG1ha2VzIENocm9tZSBiZWhhdmUuXG4gICAgKi9cbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvbHNfMSA9IGNvbHM7IF9pIDwgY29sc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29sUHJvcHMgPSBjb2xzXzFbX2ldO1xuICAgICAgICB2YXIgc3BhbiA9IGNvbFByb3BzLnNwYW4gfHwgMTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcGFuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbE5vZGVzLnB1c2godmRvbV9janMuY3JlYXRlRWxlbWVudChcImNvbFwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBjb2xQcm9wcy53aWR0aCA9PT0gJ3NocmluaycgPyBzYW5pdGl6ZVNocmlua1dpZHRoKHNocmlua1dpZHRoKSA6IChjb2xQcm9wcy53aWR0aCB8fCAnJyksXG4gICAgICAgICAgICAgICAgICAgIG1pbldpZHRoOiBjb2xQcm9wcy5taW5XaWR0aCB8fCAnJyxcbiAgICAgICAgICAgICAgICB9IH0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmRvbV9janMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoWydjb2xncm91cCcsIHt9XSwgY29sTm9kZXMpKTtcbn1cbmZ1bmN0aW9uIHNhbml0aXplU2hyaW5rV2lkdGgoc2hyaW5rV2lkdGgpIHtcbiAgICAvKiB3aHkgND8gaWYgd2UgZG8gMCwgaXQgd2lsbCBraWxsIGFueSBib3JkZXIsIHdoaWNoIGFyZSBuZWVkZWQgZm9yIGNvbXB1dGVTbWFsbGVzdENlbGxXaWR0aFxuICAgIDQgYWNjb3VudHMgZm9yIDIgMi1waXhlbCBib3JkZXJzLiBUT0RPOiBiZXR0ZXIgc29sdXRpb24/ICovXG4gICAgcmV0dXJuIHNocmlua1dpZHRoID09IG51bGwgPyA0IDogc2hyaW5rV2lkdGg7XG59XG5mdW5jdGlvbiBoYXNTaHJpbmtXaWR0aChjb2xzKSB7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBjb2xzXzIgPSBjb2xzOyBfaSA8IGNvbHNfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvbCA9IGNvbHNfMltfaV07XG4gICAgICAgIGlmIChjb2wud2lkdGggPT09ICdzaHJpbmsnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyhsaXF1aWQsIGNvbnRleHQpIHtcbiAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgJ2ZjLXNjcm9sbGdyaWQnLFxuICAgICAgICBjb250ZXh0LnRoZW1lLmdldENsYXNzKCd0YWJsZScpLFxuICAgIF07XG4gICAgaWYgKGxpcXVpZCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZjLXNjcm9sbGdyaWQtbGlxdWlkJyk7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWVzO1xufVxuZnVuY3Rpb24gZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgd2hvbGVUYWJsZVZHcm93KSB7XG4gICAgdmFyIGNsYXNzTmFtZXMgPSBbXG4gICAgICAgICdmYy1zY3JvbGxncmlkLXNlY3Rpb24nLFxuICAgICAgICBcImZjLXNjcm9sbGdyaWQtc2VjdGlvbi1cIiArIHNlY3Rpb25Db25maWcudHlwZSxcbiAgICAgICAgc2VjdGlvbkNvbmZpZy5jbGFzc05hbWUsIC8vIHVzZWQ/XG4gICAgXTtcbiAgICBpZiAod2hvbGVUYWJsZVZHcm93ICYmIHNlY3Rpb25Db25maWcubGlxdWlkICYmIHNlY3Rpb25Db25maWcubWF4SGVpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgY2xhc3NOYW1lcy5wdXNoKCdmYy1zY3JvbGxncmlkLXNlY3Rpb24tbGlxdWlkJyk7XG4gICAgfVxuICAgIGlmIChzZWN0aW9uQ29uZmlnLmlzU3RpY2t5KSB7XG4gICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1zZWN0aW9uLXN0aWNreScpO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lcztcbn1cbmZ1bmN0aW9uIHJlbmRlclNjcm9sbFNoaW0oYXJnKSB7XG4gICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3RpY2t5LXNoaW1cIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiBhcmcuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICBtaW5XaWR0aDogYXJnLnRhYmxlTWluV2lkdGgsXG4gICAgICAgIH0gfSkpO1xufVxuZnVuY3Rpb24gZ2V0U3RpY2t5SGVhZGVyRGF0ZXMob3B0aW9ucykge1xuICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuc3RpY2t5SGVhZGVyRGF0ZXM7XG4gICAgaWYgKHN0aWNreUhlYWRlckRhdGVzID09IG51bGwgfHwgc3RpY2t5SGVhZGVyRGF0ZXMgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lIZWFkZXJEYXRlcyA9IG9wdGlvbnMuaGVpZ2h0ID09PSAnYXV0bycgfHwgb3B0aW9ucy52aWV3SGVpZ2h0ID09PSAnYXV0byc7XG4gICAgfVxuICAgIHJldHVybiBzdGlja3lIZWFkZXJEYXRlcztcbn1cbmZ1bmN0aW9uIGdldFN0aWNreUZvb3RlclNjcm9sbGJhcihvcHRpb25zKSB7XG4gICAgdmFyIHN0aWNreUZvb3RlclNjcm9sbGJhciA9IG9wdGlvbnMuc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xuICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIgPT0gbnVsbCB8fCBzdGlja3lGb290ZXJTY3JvbGxiYXIgPT09ICdhdXRvJykge1xuICAgICAgICBzdGlja3lGb290ZXJTY3JvbGxiYXIgPSBvcHRpb25zLmhlaWdodCA9PT0gJ2F1dG8nIHx8IG9wdGlvbnMudmlld0hlaWdodCA9PT0gJ2F1dG8nO1xuICAgIH1cbiAgICByZXR1cm4gc3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xufVxuXG52YXIgU2ltcGxlU2Nyb2xsR3JpZCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoU2ltcGxlU2Nyb2xsR3JpZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaW1wbGVTY3JvbGxHcmlkKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucHJvY2Vzc0NvbHMgPSBtZW1vaXplKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhOyB9LCBpc0NvbFByb3BzRXF1YWwpOyAvLyBzbyB3ZSBnZXQgc2FtZSBgY29sc2AgcHJvcHMgZXZlcnkgdGltZVxuICAgICAgICAvLyB5dWNreSB0byBtZW1vaXplIFZOb2RlcywgYnV0IG11Y2ggbW9yZSBlZmZpY2llbnQgZm9yIGNvbnN1bWVyc1xuICAgICAgICBfdGhpcy5yZW5kZXJNaWNyb0NvbEdyb3VwID0gbWVtb2l6ZShyZW5kZXJNaWNyb0NvbEdyb3VwKTtcbiAgICAgICAgX3RoaXMuc2Nyb2xsZXJSZWZzID0gbmV3IFJlZk1hcCgpO1xuICAgICAgICBfdGhpcy5zY3JvbGxlckVsUmVmcyA9IG5ldyBSZWZNYXAoX3RoaXMuX2hhbmRsZVNjcm9sbGVyRWwuYmluZChfdGhpcykpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHNocmlua1dpZHRoOiBudWxsLFxuICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFyczogZmFsc2UsXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudFdpZHRoczoge30sXG4gICAgICAgICAgICBzY3JvbGxlckNsaWVudEhlaWdodHM6IHt9LFxuICAgICAgICB9O1xuICAgICAgICAvLyBUT0RPOiBjYW4gZG8gYSByZWFsbHkgc2ltcGxlIHByaW50LXZpZXcuIGRvbnQgbmVlZCB0byBqb2luIHJvd3NcbiAgICAgICAgX3RoaXMuaGFuZGxlU2l6aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2FmZVNldFN0YXRlKHRzbGliLl9fYXNzaWduKHsgc2hyaW5rV2lkdGg6IF90aGlzLmNvbXB1dGVTaHJpbmtXaWR0aCgpIH0sIF90aGlzLmNvbXB1dGVTY3JvbGxlckRpbXMoKSkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZSwgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzZWN0aW9uQ29uZmlncyA9IHByb3BzLnNlY3Rpb25zIHx8IFtdO1xuICAgICAgICB2YXIgY29scyA9IHRoaXMucHJvY2Vzc0NvbHMocHJvcHMuY29scyk7XG4gICAgICAgIHZhciBtaWNyb0NvbEdyb3VwTm9kZSA9IHRoaXMucmVuZGVyTWljcm9Db2xHcm91cChjb2xzLCBzdGF0ZS5zaHJpbmtXaWR0aCk7XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gZ2V0U2Nyb2xsR3JpZENsYXNzTmFtZXMocHJvcHMubGlxdWlkLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHByb3BzLmNvbGxhcHNpYmxlV2lkdGgpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZXMucHVzaCgnZmMtc2Nyb2xsZ3JpZC1jb2xsYXBzaWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IG1ha2UgRFJZXG4gICAgICAgIHZhciBjb25maWdDbnQgPSBzZWN0aW9uQ29uZmlncy5sZW5ndGg7XG4gICAgICAgIHZhciBjb25maWdJID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb25maWc7XG4gICAgICAgIHZhciBoZWFkU2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHZhciBib2R5U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHZhciBmb290U2VjdGlvbk5vZGVzID0gW107XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdoZWFkZXInKSB7XG4gICAgICAgICAgICBoZWFkU2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGNvbmZpZ0kgPCBjb25maWdDbnQgJiYgKGN1cnJlbnRDb25maWcgPSBzZWN0aW9uQ29uZmlnc1tjb25maWdJXSkudHlwZSA9PT0gJ2JvZHknKSB7XG4gICAgICAgICAgICBib2R5U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBmYWxzZSkpO1xuICAgICAgICAgICAgY29uZmlnSSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjb25maWdJIDwgY29uZmlnQ250ICYmIChjdXJyZW50Q29uZmlnID0gc2VjdGlvbkNvbmZpZ3NbY29uZmlnSV0pLnR5cGUgPT09ICdmb290ZXInKSB7XG4gICAgICAgICAgICBmb290U2VjdGlvbk5vZGVzLnB1c2godGhpcy5yZW5kZXJTZWN0aW9uKGN1cnJlbnRDb25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCB0cnVlKSk7XG4gICAgICAgICAgICBjb25maWdJICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmlyZWZveCBidWc6IHdoZW4gc2V0dGluZyBoZWlnaHQgb24gdGFibGUgYW5kIHRoZXJlIGlzIGEgdGhlYWQgb3IgdGZvb3QsXG4gICAgICAgIC8vIHRoZSBuZWNlc3NhcnkgaGVpZ2h0OjEwMCUgb24gdGhlIGxpcXVpZC1oZWlnaHQgYm9keSBzZWN0aW9uIGZvcmNlcyB0aGUgKndob2xlKiB0YWJsZSB0byBiZSB0YWxsZXIuIChidWcgIzU1MjQpXG4gICAgICAgIC8vIHVzZSBnZXRDYW5WR3Jvd1dpdGhpbkNlbGwgYXMgYSB3YXkgdG8gZGV0ZWN0IHRhYmxlLXN0dXBpZCBmaXJlZm94LlxuICAgICAgICAvLyBpZiBzbywgdXNlIGEgc2ltcGxlciBkb20gc3RydWN0dXJlLCBqYW0gZXZlcnl0aGluZyBpbnRvIGEgbG9uZSB0Ym9keS5cbiAgICAgICAgdmFyIGlzQnVnZ3kgPSAhZ2V0Q2FuVkdyb3dXaXRoaW5DZWxsKCk7XG4gICAgICAgIHZhciByb2xlQXR0cnMgPSB7IHJvbGU6ICdyb3dncm91cCcgfTtcbiAgICAgICAgcmV0dXJuIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoJ3RhYmxlJywge1xuICAgICAgICAgICAgcm9sZTogJ2dyaWQnLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSxcbiAgICAgICAgICAgIHN0eWxlOiB7IGhlaWdodDogcHJvcHMuaGVpZ2h0IH0sXG4gICAgICAgIH0sIEJvb2xlYW4oIWlzQnVnZ3kgJiYgaGVhZFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFsndGhlYWQnLCByb2xlQXR0cnNdLCBoZWFkU2VjdGlvbk5vZGVzKSksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgYm9keVNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFsndGJvZHknLCByb2xlQXR0cnNdLCBib2R5U2VjdGlvbk5vZGVzKSksIEJvb2xlYW4oIWlzQnVnZ3kgJiYgZm9vdFNlY3Rpb25Ob2Rlcy5sZW5ndGgpICYmIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQuYXBwbHkodm9pZCAwLCB0c2xpYi5fX3NwcmVhZEFycmF5KFsndGZvb3QnLCByb2xlQXR0cnNdLCBmb290U2VjdGlvbk5vZGVzKSksIGlzQnVnZ3kgJiYgdmRvbV9janMuY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkodHNsaWIuX19zcHJlYWRBcnJheSh0c2xpYi5fX3NwcmVhZEFycmF5KFsndGJvZHknLCByb2xlQXR0cnNdLCBoZWFkU2VjdGlvbk5vZGVzKSwgYm9keVNlY3Rpb25Ob2RlcyksIGZvb3RTZWN0aW9uTm9kZXMpKSk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gKHNlY3Rpb25Db25maWcsIG1pY3JvQ29sR3JvdXBOb2RlLCBpc0hlYWRlcikge1xuICAgICAgICBpZiAoJ291dGVyQ29udGVudCcgaW4gc2VjdGlvbkNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KHZkb21fY2pzLkZyYWdtZW50LCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXkgfSwgc2VjdGlvbkNvbmZpZy5vdXRlckNvbnRlbnQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IGtleTogc2VjdGlvbkNvbmZpZy5rZXksIHJvbGU6IFwicHJlc2VudGF0aW9uXCIsIGNsYXNzTmFtZTogZ2V0U2VjdGlvbkNsYXNzTmFtZXMoc2VjdGlvbkNvbmZpZywgdGhpcy5wcm9wcy5saXF1aWQpLmpvaW4oJyAnKSB9LCB0aGlzLnJlbmRlckNodW5rVGQoc2VjdGlvbkNvbmZpZywgbWljcm9Db2xHcm91cE5vZGUsIHNlY3Rpb25Db25maWcuY2h1bmssIGlzSGVhZGVyKSkpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUucmVuZGVyQ2h1bmtUZCA9IGZ1bmN0aW9uIChzZWN0aW9uQ29uZmlnLCBtaWNyb0NvbEdyb3VwTm9kZSwgY2h1bmtDb25maWcsIGlzSGVhZGVyKSB7XG4gICAgICAgIGlmICgnb3V0ZXJDb250ZW50JyBpbiBjaHVua0NvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuIGNodW5rQ29uZmlnLm91dGVyQ29udGVudDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBmb3JjZVlTY3JvbGxiYXJzID0gX2EuZm9yY2VZU2Nyb2xsYmFycywgc2Nyb2xsZXJDbGllbnRXaWR0aHMgPSBfYS5zY3JvbGxlckNsaWVudFdpZHRocywgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0gX2Euc2Nyb2xsZXJDbGllbnRIZWlnaHRzO1xuICAgICAgICB2YXIgbmVlZHNZU2Nyb2xsaW5nID0gZ2V0QWxsb3dZU2Nyb2xsaW5nKHByb3BzLCBzZWN0aW9uQ29uZmlnKTsgLy8gVE9ETzogZG8gbGF6aWx5LiBkbyBpbiBzZWN0aW9uIGNvbmZpZz9cbiAgICAgICAgdmFyIGlzTGlxdWlkID0gZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodChwcm9wcywgc2VjdGlvbkNvbmZpZyk7XG4gICAgICAgIC8vIGZvciBgIXByb3BzLmxpcXVpZGAgLSBpcyBXSE9MRSBzY3JvbGxncmlkIG5hdHVyYWwgaGVpZ2h0P1xuICAgICAgICAvLyBUT0RPOiBkbyBzYW1lIHRoaW5nIGluIGFkdmFuY2VkIHNjcm9sbGdyaWQ/IHByb2xseSBub3QgYi9jIGFsd2F5cyBoYXMgaG9yaXpvbnRhbCBzY3JvbGxiYXJzXG4gICAgICAgIHZhciBvdmVyZmxvd1kgPSAhcHJvcHMubGlxdWlkID8gJ3Zpc2libGUnIDpcbiAgICAgICAgICAgIGZvcmNlWVNjcm9sbGJhcnMgPyAnc2Nyb2xsJyA6XG4gICAgICAgICAgICAgICAgIW5lZWRzWVNjcm9sbGluZyA/ICdoaWRkZW4nIDpcbiAgICAgICAgICAgICAgICAgICAgJ2F1dG8nO1xuICAgICAgICB2YXIgc2VjdGlvbktleSA9IHNlY3Rpb25Db25maWcua2V5O1xuICAgICAgICB2YXIgY29udGVudCA9IHJlbmRlckNodW5rQ29udGVudChzZWN0aW9uQ29uZmlnLCBjaHVua0NvbmZpZywge1xuICAgICAgICAgICAgdGFibGVDb2xHcm91cE5vZGU6IG1pY3JvQ29sR3JvdXBOb2RlLFxuICAgICAgICAgICAgdGFibGVNaW5XaWR0aDogJycsXG4gICAgICAgICAgICBjbGllbnRXaWR0aDogKCFwcm9wcy5jb2xsYXBzaWJsZVdpZHRoICYmIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldICE9PSB1bmRlZmluZWQpID8gc2Nyb2xsZXJDbGllbnRXaWR0aHNbc2VjdGlvbktleV0gOiBudWxsLFxuICAgICAgICAgICAgY2xpZW50SGVpZ2h0OiBzY3JvbGxlckNsaWVudEhlaWdodHNbc2VjdGlvbktleV0gIT09IHVuZGVmaW5lZCA/IHNjcm9sbGVyQ2xpZW50SGVpZ2h0c1tzZWN0aW9uS2V5XSA6IG51bGwsXG4gICAgICAgICAgICBleHBhbmRSb3dzOiBzZWN0aW9uQ29uZmlnLmV4cGFuZFJvd3MsXG4gICAgICAgICAgICBzeW5jUm93SGVpZ2h0czogZmFsc2UsXG4gICAgICAgICAgICByb3dTeW5jSGVpZ2h0czogW10sXG4gICAgICAgICAgICByZXBvcnRSb3dIZWlnaHRDaGFuZ2U6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICAgICAgfSwgaXNIZWFkZXIpO1xuICAgICAgICByZXR1cm4gdmRvbV9janMuY3JlYXRlRWxlbWVudChpc0hlYWRlciA/ICd0aCcgOiAndGQnLCB7XG4gICAgICAgICAgICByZWY6IGNodW5rQ29uZmlnLmVsUmVmLFxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXG4gICAgICAgIH0sIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtc2Nyb2xsZXItaGFybmVzc1wiICsgKGlzTGlxdWlkID8gJyBmYy1zY3JvbGxlci1oYXJuZXNzLWxpcXVpZCcgOiAnJykgfSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoU2Nyb2xsZXIsIHsgcmVmOiB0aGlzLnNjcm9sbGVyUmVmcy5jcmVhdGVSZWYoc2VjdGlvbktleSksIGVsUmVmOiB0aGlzLnNjcm9sbGVyRWxSZWZzLmNyZWF0ZVJlZihzZWN0aW9uS2V5KSwgb3ZlcmZsb3dZOiBvdmVyZmxvd1ksIG92ZXJmbG93WDogIXByb3BzLmxpcXVpZCA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nIC8qIG5hdHVyYWwgaGVpZ2h0PyAqLywgbWF4SGVpZ2h0OiBzZWN0aW9uQ29uZmlnLm1heEhlaWdodCwgbGlxdWlkOiBpc0xpcXVpZCwgbGlxdWlkSXNBYnNvbHV0ZSAvLyBiZWNhdXNlIGl0cyB3aXRoaW4gYSBoYXJuZXNzXG4gICAgICAgICAgICAgICAgOiB0cnVlIH0sIGNvbnRlbnQpKSk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5faGFuZGxlU2Nyb2xsZXJFbCA9IGZ1bmN0aW9uIChzY3JvbGxlckVsLCBrZXkpIHtcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBnZXRTZWN0aW9uQnlLZXkodGhpcy5wcm9wcy5zZWN0aW9ucywga2V5KTtcbiAgICAgICAgaWYgKHNlY3Rpb24pIHtcbiAgICAgICAgICAgIHNldFJlZihzZWN0aW9uLmNodW5rLnNjcm9sbGVyRWxSZWYsIHNjcm9sbGVyRWwpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXppbmcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFkZFJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPOiBuZWVkIGJldHRlciBzb2x1dGlvbiB3aGVuIHN0YXRlIGNvbnRhaW5zIG5vbi1zaXppbmcgdGhpbmdzXG4gICAgICAgIHRoaXMuaGFuZGxlU2l6aW5nKCk7XG4gICAgfTtcbiAgICBTaW1wbGVTY3JvbGxHcmlkLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlbW92ZVJlc2l6ZUhhbmRsZXIodGhpcy5oYW5kbGVTaXppbmcpO1xuICAgIH07XG4gICAgU2ltcGxlU2Nyb2xsR3JpZC5wcm90b3R5cGUuY29tcHV0ZVNocmlua1dpZHRoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gaGFzU2hyaW5rV2lkdGgodGhpcy5wcm9wcy5jb2xzKVxuICAgICAgICAgICAgPyBjb21wdXRlU2hyaW5rV2lkdGgodGhpcy5zY3JvbGxlckVsUmVmcy5nZXRBbGwoKSlcbiAgICAgICAgICAgIDogMDtcbiAgICB9O1xuICAgIFNpbXBsZVNjcm9sbEdyaWQucHJvdG90eXBlLmNvbXB1dGVTY3JvbGxlckRpbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzY3JvbGxiYXJXaWR0aCA9IGdldFNjcm9sbGJhcldpZHRocygpO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBzY3JvbGxlclJlZnMgPSBfYS5zY3JvbGxlclJlZnMsIHNjcm9sbGVyRWxSZWZzID0gX2Euc2Nyb2xsZXJFbFJlZnM7XG4gICAgICAgIHZhciBmb3JjZVlTY3JvbGxiYXJzID0gZmFsc2U7XG4gICAgICAgIHZhciBzY3JvbGxlckNsaWVudFdpZHRocyA9IHt9O1xuICAgICAgICB2YXIgc2Nyb2xsZXJDbGllbnRIZWlnaHRzID0ge307XG4gICAgICAgIGZvciAodmFyIHNlY3Rpb25LZXkgaW4gc2Nyb2xsZXJSZWZzLmN1cnJlbnRNYXApIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxlciA9IHNjcm9sbGVyUmVmcy5jdXJyZW50TWFwW3NlY3Rpb25LZXldO1xuICAgICAgICAgICAgaWYgKHNjcm9sbGVyICYmIHNjcm9sbGVyLm5lZWRzWVNjcm9sbGluZygpKSB7XG4gICAgICAgICAgICAgICAgZm9yY2VZU2Nyb2xsYmFycyA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYiA9IHRoaXMucHJvcHMuc2VjdGlvbnM7IF9pIDwgX2IubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VjdGlvbiA9IF9iW19pXTtcbiAgICAgICAgICAgIHZhciBzZWN0aW9uS2V5ID0gc2VjdGlvbi5rZXk7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsZXJFbCA9IHNjcm9sbGVyRWxSZWZzLmN1cnJlbnRNYXBbc2VjdGlvbktleV07XG4gICAgICAgICAgICBpZiAoc2Nyb2xsZXJFbCkge1xuICAgICAgICAgICAgICAgIHZhciBoYXJuZXNzRWwgPSBzY3JvbGxlckVsLnBhcmVudE5vZGU7IC8vIFRPRE86IHdlaXJkIHdheSB0byBnZXQgdGhpcy4gbmVlZCBoYXJuZXNzIGIvYyBkb2Vzbid0IGluY2x1ZGUgdGFibGUgYm9yZGVyc1xuICAgICAgICAgICAgICAgIHNjcm9sbGVyQ2xpZW50V2lkdGhzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggLSAoZm9yY2VZU2Nyb2xsYmFyc1xuICAgICAgICAgICAgICAgICAgICA/IHNjcm9sbGJhcldpZHRoLnkgLy8gdXNlIGdsb2JhbCBiZWNhdXNlIHNjcm9sbGVyIG1pZ2h0IG5vdCBoYXZlIHNjcm9sbGJhcnMgeWV0IGJ1dCB3aWxsIG5lZWQgdGhlbSBpbiBmdXR1cmVcbiAgICAgICAgICAgICAgICAgICAgOiAwKSk7XG4gICAgICAgICAgICAgICAgc2Nyb2xsZXJDbGllbnRIZWlnaHRzW3NlY3Rpb25LZXldID0gTWF0aC5mbG9vcihoYXJuZXNzRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JjZVlTY3JvbGxiYXJzOiBmb3JjZVlTY3JvbGxiYXJzLCBzY3JvbGxlckNsaWVudFdpZHRoczogc2Nyb2xsZXJDbGllbnRXaWR0aHMsIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogc2Nyb2xsZXJDbGllbnRIZWlnaHRzIH07XG4gICAgfTtcbiAgICByZXR1cm4gU2ltcGxlU2Nyb2xsR3JpZDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuU2ltcGxlU2Nyb2xsR3JpZC5hZGRTdGF0ZUVxdWFsaXR5KHtcbiAgICBzY3JvbGxlckNsaWVudFdpZHRoczogaXNQcm9wc0VxdWFsLFxuICAgIHNjcm9sbGVyQ2xpZW50SGVpZ2h0czogaXNQcm9wc0VxdWFsLFxufSk7XG5mdW5jdGlvbiBnZXRTZWN0aW9uQnlLZXkoc2VjdGlvbnMsIGtleSkge1xuICAgIGZvciAodmFyIF9pID0gMCwgc2VjdGlvbnNfMSA9IHNlY3Rpb25zOyBfaSA8IHNlY3Rpb25zXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzZWN0aW9uID0gc2VjdGlvbnNfMVtfaV07XG4gICAgICAgIGlmIChzZWN0aW9uLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gc2VjdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxudmFyIEV2ZW50Um9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRXZlbnRSb290LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEV2ZW50Um9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmVsUmVmID0gdmRvbV9janMuY3JlYXRlUmVmKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXZlbnRSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIHNlZyA9IHByb3BzLnNlZztcbiAgICAgICAgdmFyIGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICAgICAgdmFyIHVpID0gZXZlbnRSYW5nZS51aTtcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgICAgIGV2ZW50OiBuZXcgRXZlbnRBcGkoY29udGV4dCwgZXZlbnRSYW5nZS5kZWYsIGV2ZW50UmFuZ2UuaW5zdGFuY2UpLFxuICAgICAgICAgICAgdmlldzogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgdGltZVRleHQ6IHByb3BzLnRpbWVUZXh0LFxuICAgICAgICAgICAgdGV4dENvbG9yOiB1aS50ZXh0Q29sb3IsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHVpLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIGJvcmRlckNvbG9yOiB1aS5ib3JkZXJDb2xvcixcbiAgICAgICAgICAgIGlzRHJhZ2dhYmxlOiAhcHJvcHMuZGlzYWJsZURyYWdnaW5nICYmIGNvbXB1dGVTZWdEcmFnZ2FibGUoc2VnLCBjb250ZXh0KSxcbiAgICAgICAgICAgIGlzU3RhcnRSZXNpemFibGU6ICFwcm9wcy5kaXNhYmxlUmVzaXppbmcgJiYgY29tcHV0ZVNlZ1N0YXJ0UmVzaXphYmxlKHNlZywgY29udGV4dCksXG4gICAgICAgICAgICBpc0VuZFJlc2l6YWJsZTogIXByb3BzLmRpc2FibGVSZXNpemluZyAmJiBjb21wdXRlU2VnRW5kUmVzaXphYmxlKHNlZyksXG4gICAgICAgICAgICBpc01pcnJvcjogQm9vbGVhbihwcm9wcy5pc0RyYWdnaW5nIHx8IHByb3BzLmlzUmVzaXppbmcgfHwgcHJvcHMuaXNEYXRlU2VsZWN0aW5nKSxcbiAgICAgICAgICAgIGlzU3RhcnQ6IEJvb2xlYW4oc2VnLmlzU3RhcnQpLFxuICAgICAgICAgICAgaXNFbmQ6IEJvb2xlYW4oc2VnLmlzRW5kKSxcbiAgICAgICAgICAgIGlzUGFzdDogQm9vbGVhbihwcm9wcy5pc1Bhc3QpLFxuICAgICAgICAgICAgaXNGdXR1cmU6IEJvb2xlYW4ocHJvcHMuaXNGdXR1cmUpLFxuICAgICAgICAgICAgaXNUb2RheTogQm9vbGVhbihwcm9wcy5pc1RvZGF5KSxcbiAgICAgICAgICAgIGlzU2VsZWN0ZWQ6IEJvb2xlYW4ocHJvcHMuaXNTZWxlY3RlZCksXG4gICAgICAgICAgICBpc0RyYWdnaW5nOiBCb29sZWFuKHByb3BzLmlzRHJhZ2dpbmcpLFxuICAgICAgICAgICAgaXNSZXNpemluZzogQm9vbGVhbihwcm9wcy5pc1Jlc2l6aW5nKSxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0YW5kYXJkQ2xhc3NOYW1lcyA9IGdldEV2ZW50Q2xhc3NOYW1lcyhob29rUHJvcHMpLmNvbmNhdCh1aS5jbGFzc05hbWVzKTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFJlbmRlckhvb2ssIHsgaG9va1Byb3BzOiBob29rUHJvcHMsIGNsYXNzTmFtZXM6IG9wdGlvbnMuZXZlbnRDbGFzc05hbWVzLCBjb250ZW50OiBvcHRpb25zLmV2ZW50Q29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50LCBkaWRNb3VudDogb3B0aW9ucy5ldmVudERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5ldmVudFdpbGxVbm1vdW50LCBlbFJlZjogdGhpcy5lbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjdXN0b21DbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQpIHsgcmV0dXJuIHByb3BzLmNoaWxkcmVuKHJvb3RFbFJlZiwgc3RhbmRhcmRDbGFzc05hbWVzLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBob29rUHJvcHMpOyB9KSk7XG4gICAgfTtcbiAgICBFdmVudFJvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHRoaXMucHJvcHMuc2VnKTtcbiAgICB9O1xuICAgIC8qXG4gICAgbmVlZCB0byByZS1hc3NpZ24gc2VnIHRvIHRoZSBlbGVtZW50IGlmIHNlZyBjaGFuZ2VzLCBldmVuIGlmIHRoZSBlbGVtZW50IGlzIHRoZSBzYW1lXG4gICAgKi9cbiAgICBFdmVudFJvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIChwcmV2UHJvcHMpIHtcbiAgICAgICAgdmFyIHNlZyA9IHRoaXMucHJvcHMuc2VnO1xuICAgICAgICBpZiAoc2VnICE9PSBwcmV2UHJvcHMuc2VnKSB7XG4gICAgICAgICAgICBzZXRFbFNlZyh0aGlzLmVsUmVmLmN1cnJlbnQsIHNlZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBFdmVudFJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuLy8gc2hvdWxkIG5vdCBiZSBhIHB1cmVjb21wb25lbnRcbnZhciBTdGFuZGFyZEV2ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhTdGFuZGFyZEV2ZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN0YW5kYXJkRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU3RhbmRhcmRFdmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIHNlZyA9IHByb3BzLnNlZztcbiAgICAgICAgdmFyIHRpbWVGb3JtYXQgPSBjb250ZXh0Lm9wdGlvbnMuZXZlbnRUaW1lRm9ybWF0IHx8IHByb3BzLmRlZmF1bHRUaW1lRm9ybWF0O1xuICAgICAgICB2YXIgdGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0KHNlZywgdGltZUZvcm1hdCwgY29udGV4dCwgcHJvcHMuZGVmYXVsdERpc3BsYXlFdmVudFRpbWUsIHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQpO1xuICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoRXZlbnRSb290LCB7IHNlZzogc2VnLCB0aW1lVGV4dDogdGltZVRleHQsIGRpc2FibGVEcmFnZ2luZzogcHJvcHMuZGlzYWJsZURyYWdnaW5nLCBkaXNhYmxlUmVzaXppbmc6IHByb3BzLmRpc2FibGVSZXNpemluZywgZGVmYXVsdENvbnRlbnQ6IHByb3BzLmRlZmF1bHRDb250ZW50IHx8IHJlbmRlcklubmVyQ29udGVudCQxLCBpc0RyYWdnaW5nOiBwcm9wcy5pc0RyYWdnaW5nLCBpc1Jlc2l6aW5nOiBwcm9wcy5pc1Jlc2l6aW5nLCBpc0RhdGVTZWxlY3Rpbmc6IHByb3BzLmlzRGF0ZVNlbGVjdGluZywgaXNTZWxlY3RlZDogcHJvcHMuaXNTZWxlY3RlZCwgaXNQYXN0OiBwcm9wcy5pc1Bhc3QsIGlzRnV0dXJlOiBwcm9wcy5pc0Z1dHVyZSwgaXNUb2RheTogcHJvcHMuaXNUb2RheSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhvb2tQcm9wcykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgY2xhc3NOYW1lOiBwcm9wcy5leHRyYUNsYXNzTmFtZXMuY29uY2F0KGNsYXNzTmFtZXMpLmpvaW4oJyAnKSwgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogaG9va1Byb3BzLmJvcmRlckNvbG9yLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogaG9va1Byb3BzLmJhY2tncm91bmRDb2xvcixcbiAgICAgICAgICAgIH0sIHJlZjogcm9vdEVsUmVmIH0sIGdldFNlZ0FuY2hvckF0dHJzKHNlZywgY29udGV4dCkpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1tYWluXCIsIHJlZjogaW5uZXJFbFJlZiwgc3R5bGU6IHsgY29sb3I6IGhvb2tQcm9wcy50ZXh0Q29sb3IgfSB9LCBpbm5lckNvbnRlbnQpLFxuICAgICAgICAgICAgaG9va1Byb3BzLmlzU3RhcnRSZXNpemFibGUgJiZcbiAgICAgICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXJlc2l6ZXIgZmMtZXZlbnQtcmVzaXplci1zdGFydFwiIH0pLFxuICAgICAgICAgICAgaG9va1Byb3BzLmlzRW5kUmVzaXphYmxlICYmXG4gICAgICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC1yZXNpemVyIGZjLWV2ZW50LXJlc2l6ZXItZW5kXCIgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFN0YW5kYXJkRXZlbnQ7XG59KEJhc2VDb21wb25lbnQpKTtcbmZ1bmN0aW9uIHJlbmRlcklubmVyQ29udGVudCQxKGlubmVyUHJvcHMpIHtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtbWFpbi1mcmFtZVwiIH0sXG4gICAgICAgIGlubmVyUHJvcHMudGltZVRleHQgJiYgKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZXZlbnQtdGltZVwiIH0sIGlubmVyUHJvcHMudGltZVRleHQpKSxcbiAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZS1jb250YWluZXJcIiB9LFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZSBmYy1zdGlja3lcIiB9LCBpbm5lclByb3BzLmV2ZW50LnRpdGxlIHx8IHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQodmRvbV9janMuRnJhZ21lbnQsIG51bGwsIFwiXFx1MDBBMFwiKSkpKSk7XG59XG5cbnZhciBOb3dJbmRpY2F0b3JSb290ID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGhvb2tQcm9wcyA9IHtcbiAgICAgICAgaXNBeGlzOiBwcm9wcy5pc0F4aXMsXG4gICAgICAgIGRhdGU6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocHJvcHMuZGF0ZSksXG4gICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICB9O1xuICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLm5vd0luZGljYXRvckNsYXNzTmFtZXMsIGNvbnRlbnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yQ29udGVudCwgZGlkTW91bnQ6IG9wdGlvbnMubm93SW5kaWNhdG9yRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLm5vd0luZGljYXRvcldpbGxVbm1vdW50IH0sIHByb3BzLmNoaWxkcmVuKSk7XG59KSk7IH07XG5cbnZhciBEQVlfTlVNX0ZPUk1BVCA9IGNyZWF0ZUZvcm1hdHRlcih7IGRheTogJ251bWVyaWMnIH0pO1xudmFyIERheUNlbGxDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlDZWxsQ29udGVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlDZWxsQ29udGVudCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEYXlDZWxsQ29udGVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBob29rUHJvcHMgPSByZWZpbmVEYXlDZWxsSG9va1Byb3BzKHtcbiAgICAgICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KENvbnRlbnRIb29rLCB7IGhvb2tQcm9wczogaG9va1Byb3BzLCBjb250ZW50OiBvcHRpb25zLmRheUNlbGxDb250ZW50LCBkZWZhdWx0Q29udGVudDogcHJvcHMuZGVmYXVsdENvbnRlbnQgfSwgcHJvcHMuY2hpbGRyZW4pKTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlDZWxsQ29udGVudDtcbn0oQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVmaW5lRGF5Q2VsbEhvb2tQcm9wcyhyYXcpIHtcbiAgICB2YXIgZGF0ZSA9IHJhdy5kYXRlLCBkYXRlRW52ID0gcmF3LmRhdGVFbnY7XG4gICAgdmFyIGRheU1ldGEgPSBnZXREYXRlTWV0YShkYXRlLCByYXcudG9kYXlSYW5nZSwgbnVsbCwgcmF3LmRhdGVQcm9maWxlKTtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oeyBkYXRlOiBkYXRlRW52LnRvRGF0ZShkYXRlKSwgdmlldzogcmF3LnZpZXdBcGkgfSwgZGF5TWV0YSksIHsgZGF5TnVtYmVyVGV4dDogcmF3LnNob3dEYXlOdW1iZXIgPyBkYXRlRW52LmZvcm1hdChkYXRlLCBEQVlfTlVNX0ZPUk1BVCkgOiAnJyB9KSwgcmF3LmV4dHJhUHJvcHMpO1xufVxuXG52YXIgRGF5Q2VsbFJvb3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKERheUNlbGxSb290LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheUNlbGxSb290KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVmaW5lSG9va1Byb3BzID0gbWVtb2l6ZU9iakFyZyhyZWZpbmVEYXlDZWxsSG9va1Byb3BzKTtcbiAgICAgICAgX3RoaXMubm9ybWFsaXplQ2xhc3NOYW1lcyA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheUNlbGxSb290LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGNvbnRleHQub3B0aW9ucztcbiAgICAgICAgdmFyIGhvb2tQcm9wcyA9IHRoaXMucmVmaW5lSG9va1Byb3BzKHtcbiAgICAgICAgICAgIGRhdGU6IHByb3BzLmRhdGUsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsXG4gICAgICAgICAgICB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLFxuICAgICAgICAgICAgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcixcbiAgICAgICAgICAgIGV4dHJhUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLFxuICAgICAgICAgICAgdmlld0FwaTogY29udGV4dC52aWV3QXBpLFxuICAgICAgICAgICAgZGF0ZUVudjogY29udGV4dC5kYXRlRW52LFxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBnZXREYXlDbGFzc05hbWVzKGhvb2tQcm9wcywgY29udGV4dC50aGVtZSkuY29uY2F0KGhvb2tQcm9wcy5pc0Rpc2FibGVkXG4gICAgICAgICAgICA/IFtdIC8vIGRvbid0IHVzZSBjdXN0b20gY2xhc3NOYW1lcyBpZiBkaXNhYmxlZFxuICAgICAgICAgICAgOiB0aGlzLm5vcm1hbGl6ZUNsYXNzTmFtZXMob3B0aW9ucy5kYXlDZWxsQ2xhc3NOYW1lcywgaG9va1Byb3BzKSk7XG4gICAgICAgIHZhciBkYXRhQXR0cnMgPSBob29rUHJvcHMuaXNEaXNhYmxlZCA/IHt9IDoge1xuICAgICAgICAgICAgJ2RhdGEtZGF0ZSc6IGZvcm1hdERheVN0cmluZyhwcm9wcy5kYXRlKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KE1vdW50SG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgZGlkTW91bnQ6IG9wdGlvbnMuZGF5Q2VsbERpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5kYXlDZWxsV2lsbFVubW91bnQsIGVsUmVmOiBwcm9wcy5lbFJlZiB9LCBmdW5jdGlvbiAocm9vdEVsUmVmKSB7IHJldHVybiBwcm9wcy5jaGlsZHJlbihyb290RWxSZWYsIGNsYXNzTmFtZXMsIGRhdGFBdHRycywgaG9va1Byb3BzLmlzRGlzYWJsZWQpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5Q2VsbFJvb3Q7XG59KEJhc2VDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gcmVuZGVyRmlsbChmaWxsVHlwZSkge1xuICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1cIiArIGZpbGxUeXBlIH0pKTtcbn1cbnZhciBCZ0V2ZW50ID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChFdmVudFJvb3QsIHsgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyQ29udGVudCwgc2VnOiBwcm9wcy5zZWcgLyogdXNlbGVzc3MgaSB0aGluayAqLywgdGltZVRleHQ6IFwiXCIsIGRpc2FibGVEcmFnZ2luZzogdHJ1ZSwgZGlzYWJsZVJlc2l6aW5nOiB0cnVlLCBpc0RyYWdnaW5nOiBmYWxzZSwgaXNSZXNpemluZzogZmFsc2UsIGlzRGF0ZVNlbGVjdGluZzogZmFsc2UsIGlzU2VsZWN0ZWQ6IGZhbHNlLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCwgaG9va1Byb3BzKSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogcm9vdEVsUmVmLCBjbGFzc05hbWU6IFsnZmMtYmctZXZlbnQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpLCBzdHlsZToge1xuICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGhvb2tQcm9wcy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgfSB9LCBpbm5lckNvbnRlbnQpKTsgfSkpOyB9O1xuZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KHByb3BzKSB7XG4gICAgdmFyIHRpdGxlID0gcHJvcHMuZXZlbnQudGl0bGU7XG4gICAgcmV0dXJuIHRpdGxlICYmICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWV2ZW50LXRpdGxlXCIgfSwgcHJvcHMuZXZlbnQudGl0bGUpKTtcbn1cblxudmFyIFdlZWtOdW1iZXJSb290ID0gZnVuY3Rpb24gKHByb3BzKSB7IHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChWaWV3Q29udGV4dFR5cGUuQ29uc3VtZXIsIG51bGwsIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgdmFyIGRhdGVFbnYgPSBjb250ZXh0LmRhdGVFbnYsIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlO1xuICAgIHZhciBmb3JtYXQgPSBvcHRpb25zLndlZWtOdW1iZXJGb3JtYXQgfHwgcHJvcHMuZGVmYXVsdEZvcm1hdDtcbiAgICB2YXIgbnVtID0gZGF0ZUVudi5jb21wdXRlV2Vla051bWJlcihkYXRlKTsgLy8gVE9ETzogc29tZWhvdyB1c2UgZm9yIGZvcm1hdHRpbmcgYXMgd2VsbD9cbiAgICB2YXIgdGV4dCA9IGRhdGVFbnYuZm9ybWF0KGRhdGUsIGZvcm1hdCk7XG4gICAgdmFyIGhvb2tQcm9wcyA9IHsgbnVtOiBudW0sIHRleHQ6IHRleHQsIGRhdGU6IGRhdGUgfTtcbiAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUmVuZGVySG9vaywgeyBob29rUHJvcHM6IGhvb2tQcm9wcywgY2xhc3NOYW1lczogb3B0aW9ucy53ZWVrTnVtYmVyQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy53ZWVrTnVtYmVyQ29udGVudCwgZGVmYXVsdENvbnRlbnQ6IHJlbmRlcklubmVyLCBkaWRNb3VudDogb3B0aW9ucy53ZWVrTnVtYmVyRGlkTW91bnQsIHdpbGxVbm1vdW50OiBvcHRpb25zLndlZWtOdW1iZXJXaWxsVW5tb3VudCB9LCBwcm9wcy5jaGlsZHJlbikpO1xufSkpOyB9O1xuZnVuY3Rpb24gcmVuZGVySW5uZXIoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiBpbm5lclByb3BzLnRleHQ7XG59XG5cbnZhciBQQURESU5HX0ZST01fVklFV1BPUlQgPSAxMDtcbnZhciBQb3BvdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhQb3BvdmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFBvcG92ZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHRpdGxlSWQ6IGdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gZWw7XG4gICAgICAgICAgICBpZiAoX3RoaXMucHJvcHMuZWxSZWYpIHtcbiAgICAgICAgICAgICAgICBzZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gVHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgY2xpY2tzICphbnl3aGVyZSogaW4gdGhlIGRvY3VtZW50LCBmb3IgdGhlIGF1dG9IaWRlIGZlYXR1cmVcbiAgICAgICAgX3RoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIC8vIG9ubHkgaGlkZSB0aGUgcG9wb3ZlciBpZiB0aGUgY2xpY2sgaGFwcGVuZWQgb3V0c2lkZSB0aGUgcG9wb3ZlclxuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldEV2ZW50VGFyZ2V0VmlhUm9vdChldik7XG4gICAgICAgICAgICBpZiAoIV90aGlzLnJvb3RFbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24gPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlQ2xvc2VDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbG9zZUNsaWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9uQ2xvc2UgPSBfdGhpcy5wcm9wcy5vbkNsb3NlO1xuICAgICAgICAgICAgaWYgKG9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUG9wb3Zlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbnRleHQsIHRoZW1lID0gX2EudGhlbWUsIG9wdGlvbnMgPSBfYS5vcHRpb25zO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLCBwcm9wcyA9IF9iLnByb3BzLCBzdGF0ZSA9IF9iLnN0YXRlO1xuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IFtcbiAgICAgICAgICAgICdmYy1wb3BvdmVyJyxcbiAgICAgICAgICAgIHRoZW1lLmdldENsYXNzKCdwb3BvdmVyJyksXG4gICAgICAgIF0uY29uY2F0KHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSk7XG4gICAgICAgIHJldHVybiB2ZG9tX2Nqcy5jcmVhdGVQb3J0YWwodmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB0c2xpYi5fX2Fzc2lnbih7IGlkOiBwcm9wcy5pZCwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmpvaW4oJyAnKSwgXCJhcmlhLWxhYmVsbGVkYnlcIjogc3RhdGUudGl0bGVJZCB9LCBwcm9wcy5leHRyYUF0dHJzLCB7IHJlZjogdGhpcy5oYW5kbGVSb290RWwgfSksXG4gICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmMtcG9wb3Zlci1oZWFkZXIgJyArIHRoZW1lLmdldENsYXNzKCdwb3BvdmVySGVhZGVyJykgfSxcbiAgICAgICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogXCJmYy1wb3BvdmVyLXRpdGxlXCIsIGlkOiBzdGF0ZS50aXRsZUlkIH0sIHByb3BzLnRpdGxlKSxcbiAgICAgICAgICAgICAgICB2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItY2xvc2UgJyArIHRoZW1lLmdldEljb25DbGFzcygnY2xvc2UnKSwgdGl0bGU6IG9wdGlvbnMuY2xvc2VIaW50LCBvbkNsaWNrOiB0aGlzLmhhbmRsZUNsb3NlQ2xpY2sgfSkpLFxuICAgICAgICAgICAgdmRvbV9janMuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLXBvcG92ZXItYm9keSAnICsgdGhlbWUuZ2V0Q2xhc3MoJ3BvcG92ZXJDb250ZW50JykgfSwgcHJvcHMuY2hpbGRyZW4pKSwgcHJvcHMucGFyZW50RWwpO1xuICAgIH07XG4gICAgUG9wb3Zlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRNb3VzZURvd24pO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVEb2N1bWVudEtleURvd24pO1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLmhhbmRsZURvY3VtZW50TW91c2VEb3duKTtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRG9jdW1lbnRLZXlEb3duKTtcbiAgICB9O1xuICAgIFBvcG92ZXIucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpc1J0bCA9IHRoaXMuY29udGV4dC5pc1J0bDtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgYWxpZ25tZW50RWwgPSBfYS5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wID0gX2EuYWxpZ25HcmlkVG9wO1xuICAgICAgICB2YXIgcm9vdEVsID0gdGhpcy5yb290RWw7XG4gICAgICAgIHZhciBhbGlnbm1lbnRSZWN0ID0gY29tcHV0ZUNsaXBwZWRDbGllbnRSZWN0KGFsaWdubWVudEVsKTtcbiAgICAgICAgaWYgKGFsaWdubWVudFJlY3QpIHtcbiAgICAgICAgICAgIHZhciBwb3BvdmVyRGltcyA9IHJvb3RFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIHJlbGF0aXZlIHRvIHZpZXdwb3J0XG4gICAgICAgICAgICB2YXIgcG9wb3ZlclRvcCA9IGFsaWduR3JpZFRvcFxuICAgICAgICAgICAgICAgID8gZWxlbWVudENsb3Nlc3QoYWxpZ25tZW50RWwsICcuZmMtc2Nyb2xsZ3JpZCcpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcFxuICAgICAgICAgICAgICAgIDogYWxpZ25tZW50UmVjdC50b3A7XG4gICAgICAgICAgICB2YXIgcG9wb3ZlckxlZnQgPSBpc1J0bCA/IGFsaWdubWVudFJlY3QucmlnaHQgLSBwb3BvdmVyRGltcy53aWR0aCA6IGFsaWdubWVudFJlY3QubGVmdDtcbiAgICAgICAgICAgIC8vIGNvbnN0cmFpblxuICAgICAgICAgICAgcG9wb3ZlclRvcCA9IE1hdGgubWF4KHBvcG92ZXJUb3AsIFBBRERJTkdfRlJPTV9WSUVXUE9SVCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWluKHBvcG92ZXJMZWZ0LCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGggLSBQQURESU5HX0ZST01fVklFV1BPUlQgLSBwb3BvdmVyRGltcy53aWR0aCk7XG4gICAgICAgICAgICBwb3BvdmVyTGVmdCA9IE1hdGgubWF4KHBvcG92ZXJMZWZ0LCBQQURESU5HX0ZST01fVklFV1BPUlQpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbl8xID0gcm9vdEVsLm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGFwcGx5U3R5bGUocm9vdEVsLCB7XG4gICAgICAgICAgICAgICAgdG9wOiBwb3BvdmVyVG9wIC0gb3JpZ2luXzEudG9wLFxuICAgICAgICAgICAgICAgIGxlZnQ6IHBvcG92ZXJMZWZ0IC0gb3JpZ2luXzEubGVmdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUG9wb3Zlcjtcbn0oQmFzZUNvbXBvbmVudCkpO1xuXG52YXIgTW9yZVBvcG92ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKE1vcmVQb3BvdmVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vcmVQb3BvdmVyKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaGFuZGxlUm9vdEVsID0gZnVuY3Rpb24gKHJvb3RFbCkge1xuICAgICAgICAgICAgX3RoaXMucm9vdEVsID0gcm9vdEVsO1xuICAgICAgICAgICAgaWYgKHJvb3RFbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcywge1xuICAgICAgICAgICAgICAgICAgICBlbDogcm9vdEVsLFxuICAgICAgICAgICAgICAgICAgICB1c2VFdmVudENlbnRlcjogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jb250ZXh0LnVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudChfdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTW9yZVBvcG92ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZGF0ZUVudiA9IF9hLmRhdGVFbnY7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHZhciBzdGFydERhdGUgPSBwcm9wcy5zdGFydERhdGUsIHRvZGF5UmFuZ2UgPSBwcm9wcy50b2RheVJhbmdlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgdGl0bGUgPSBkYXRlRW52LmZvcm1hdChzdGFydERhdGUsIG9wdGlvbnMuZGF5UG9wb3ZlckZvcm1hdCk7XG4gICAgICAgIHJldHVybiAodmRvbV9janMuY3JlYXRlRWxlbWVudChEYXlDZWxsUm9vdCwgeyBkYXRlOiBzdGFydERhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogdG9kYXlSYW5nZSwgZWxSZWY6IHRoaXMuaGFuZGxlUm9vdEVsIH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGRheUNsYXNzTmFtZXMsIGRhdGFBdHRycykgeyByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoUG9wb3ZlciwgeyBlbFJlZjogcm9vdEVsUmVmLCBpZDogcHJvcHMuaWQsIHRpdGxlOiB0aXRsZSwgZXh0cmFDbGFzc05hbWVzOiBbJ2ZjLW1vcmUtcG9wb3ZlciddLmNvbmNhdChkYXlDbGFzc05hbWVzKSwgZXh0cmFBdHRyczogZGF0YUF0dHJzIC8qIFRPRE86IG1ha2UgdGhlc2UgdGltZS1iYXNlZCB3aGVuIG5vdCB3aG9sZS1kYXk/ICovLCBwYXJlbnRFbDogcHJvcHMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbCwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIG9uQ2xvc2U6IHByb3BzLm9uQ2xvc2UgfSxcbiAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoRGF5Q2VsbENvbnRlbnQsIHsgZGF0ZTogc3RhcnREYXRlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHRvZGF5UmFuZ2UgfSwgZnVuY3Rpb24gKGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKGlubmVyQ29udGVudCAmJlxuICAgICAgICAgICAgICAgIHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtbW9yZS1wb3BvdmVyLW1pc2NcIiwgcmVmOiBpbm5lckVsUmVmIH0sIGlubmVyQ29udGVudCkpOyB9KSxcbiAgICAgICAgICAgIHByb3BzLmNoaWxkcmVuKSk7IH0pKTtcbiAgICB9O1xuICAgIE1vcmVQb3BvdmVyLnByb3RvdHlwZS5xdWVyeUhpdCA9IGZ1bmN0aW9uIChwb3NpdGlvbkxlZnQsIHBvc2l0aW9uVG9wLCBlbFdpZHRoLCBlbEhlaWdodCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCByb290RWwgPSBfYS5yb290RWwsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmIChwb3NpdGlvbkxlZnQgPj0gMCAmJiBwb3NpdGlvbkxlZnQgPCBlbFdpZHRoICYmXG4gICAgICAgICAgICBwb3NpdGlvblRvcCA+PSAwICYmIHBvc2l0aW9uVG9wIDwgZWxIZWlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLFxuICAgICAgICAgICAgICAgIGRhdGVTcGFuOiB0c2xpYi5fX2Fzc2lnbih7IGFsbERheTogdHJ1ZSwgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBwcm9wcy5zdGFydERhdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmQ6IHByb3BzLmVuZERhdGUsXG4gICAgICAgICAgICAgICAgICAgIH0gfSwgcHJvcHMuZXh0cmFEYXRlU3BhbiksXG4gICAgICAgICAgICAgICAgZGF5RWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgICByZWN0OiB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IGVsV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogZWxIZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBsYXllcjogMSwgLy8gaW1wb3J0YW50IHdoZW4gY29tcGFyaW5nIHdpdGggaGl0cyBmcm9tIG90aGVyIGNvbXBvbmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gTW9yZVBvcG92ZXI7XG59KERhdGVDb21wb25lbnQpKTtcblxudmFyIE1vcmVMaW5rUm9vdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoTW9yZUxpbmtSb290LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1vcmVMaW5rUm9vdCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxpbmtFbFJlZiA9IHZkb21fY2pzLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGlzUG9wb3Zlck9wZW46IGZhbHNlLFxuICAgICAgICAgICAgcG9wb3ZlcklkOiBnZXRVbmlxdWVEb21JZCgpLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICAgICAgdmFyIG1vcmVMaW5rQ2xpY2sgPSBjb250ZXh0Lm9wdGlvbnMubW9yZUxpbmtDbGljaztcbiAgICAgICAgICAgIHZhciBkYXRlID0gY29tcHV0ZVJhbmdlKHByb3BzKS5zdGFydDtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGJ1aWxkUHVibGljU2VnKHNlZykge1xuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNlZy5ldmVudFJhbmdlLCBkZWYgPSBfYS5kZWYsIGluc3RhbmNlID0gX2EuaW5zdGFuY2UsIHJhbmdlID0gX2EucmFuZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6IG5ldyBFdmVudEFwaShjb250ZXh0LCBkZWYsIGluc3RhbmNlKSxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2Uuc3RhcnQpLFxuICAgICAgICAgICAgICAgICAgICBlbmQ6IGNvbnRleHQuZGF0ZUVudi50b0RhdGUocmFuZ2UuZW5kKSxcbiAgICAgICAgICAgICAgICAgICAgaXNTdGFydDogc2VnLmlzU3RhcnQsXG4gICAgICAgICAgICAgICAgICAgIGlzRW5kOiBzZWcuaXNFbmQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIG1vcmVMaW5rQ2xpY2sgPSBtb3JlTGlua0NsaWNrKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0ZTogZGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgYWxsRGF5OiBCb29sZWFuKHByb3BzLmFsbERheURhdGUpLFxuICAgICAgICAgICAgICAgICAgICBhbGxTZWdzOiBwcm9wcy5hbGxTZWdzLm1hcChidWlsZFB1YmxpY1NlZyksXG4gICAgICAgICAgICAgICAgICAgIGhpZGRlblNlZ3M6IHByb3BzLmhpZGRlblNlZ3MubWFwKGJ1aWxkUHVibGljU2VnKSxcbiAgICAgICAgICAgICAgICAgICAganNFdmVudDogZXYsXG4gICAgICAgICAgICAgICAgICAgIHZpZXc6IGNvbnRleHQudmlld0FwaSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbW9yZUxpbmtDbGljayB8fCBtb3JlTGlua0NsaWNrID09PSAncG9wb3ZlcicpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7IGlzUG9wb3Zlck9wZW46IHRydWUgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbW9yZUxpbmtDbGljayA9PT0gJ3N0cmluZycpIHsgLy8gYSB2aWV3IG5hbWVcbiAgICAgICAgICAgICAgICBjb250ZXh0LmNhbGVuZGFyQXBpLnpvb21UbyhkYXRlLCBtb3JlTGlua0NsaWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuaGFuZGxlUG9wb3ZlckNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoeyBpc1BvcG92ZXJPcGVuOiBmYWxzZSB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgc3RhdGUgPSBfYS5zdGF0ZTtcbiAgICAgICAgcmV0dXJuICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KFZpZXdDb250ZXh0VHlwZS5Db25zdW1lciwgbnVsbCwgZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciB2aWV3QXBpID0gY29udGV4dC52aWV3QXBpLCBvcHRpb25zID0gY29udGV4dC5vcHRpb25zLCBjYWxlbmRhckFwaSA9IGNvbnRleHQuY2FsZW5kYXJBcGk7XG4gICAgICAgICAgICB2YXIgbW9yZUxpbmtUZXh0ID0gb3B0aW9ucy5tb3JlTGlua1RleHQ7XG4gICAgICAgICAgICB2YXIgbW9yZUNudCA9IHByb3BzLm1vcmVDbnQ7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSBjb21wdXRlUmFuZ2UocHJvcHMpO1xuICAgICAgICAgICAgdmFyIHRleHQgPSB0eXBlb2YgbW9yZUxpbmtUZXh0ID09PSAnZnVuY3Rpb24nIC8vIFRPRE86IGV2ZW50dWFsbHkgdXNlIGZvcm1hdFdpdGhPcmRpbmFsc1xuICAgICAgICAgICAgICAgID8gbW9yZUxpbmtUZXh0LmNhbGwoY2FsZW5kYXJBcGksIG1vcmVDbnQpXG4gICAgICAgICAgICAgICAgOiBcIitcIiArIG1vcmVDbnQgKyBcIiBcIiArIG1vcmVMaW5rVGV4dDtcbiAgICAgICAgICAgIHZhciB0aXRsZSA9IGZvcm1hdFdpdGhPcmRpbmFscyhvcHRpb25zLm1vcmVMaW5rSGludCwgW21vcmVDbnRdLCB0ZXh0KTtcbiAgICAgICAgICAgIHZhciBob29rUHJvcHMgPSB7XG4gICAgICAgICAgICAgICAgbnVtOiBtb3JlQ250LFxuICAgICAgICAgICAgICAgIHNob3J0VGV4dDogXCIrXCIgKyBtb3JlQ250LFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHQsXG4gICAgICAgICAgICAgICAgdmlldzogdmlld0FwaSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKHZkb21fY2pzLmNyZWF0ZUVsZW1lbnQodmRvbV9janMuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgQm9vbGVhbihwcm9wcy5tb3JlQ250KSAmJiAodmRvbV9janMuY3JlYXRlRWxlbWVudChSZW5kZXJIb29rLCB7IGVsUmVmOiBfdGhpcy5saW5rRWxSZWYsIGhvb2tQcm9wczogaG9va1Byb3BzLCBjbGFzc05hbWVzOiBvcHRpb25zLm1vcmVMaW5rQ2xhc3NOYW1lcywgY29udGVudDogb3B0aW9ucy5tb3JlTGlua0NvbnRlbnQsIGRlZmF1bHRDb250ZW50OiBwcm9wcy5kZWZhdWx0Q29udGVudCB8fCByZW5kZXJNb3JlTGlua0lubmVyLCBkaWRNb3VudDogb3B0aW9ucy5tb3JlTGlua0RpZE1vdW50LCB3aWxsVW5tb3VudDogb3B0aW9ucy5tb3JlTGlua1dpbGxVbm1vdW50IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGN1c3RvbUNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gcHJvcHMuY2hpbGRyZW4ocm9vdEVsUmVmLCBbJ2ZjLW1vcmUtbGluayddLmNvbmNhdChjdXN0b21DbGFzc05hbWVzKSwgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50LCBfdGhpcy5oYW5kbGVDbGljaywgdGl0bGUsIHN0YXRlLmlzUG9wb3Zlck9wZW4sIHN0YXRlLmlzUG9wb3Zlck9wZW4gPyBzdGF0ZS5wb3BvdmVySWQgOiAnJyk7IH0pKSxcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc1BvcG92ZXJPcGVuICYmICh2ZG9tX2Nqcy5jcmVhdGVFbGVtZW50KE1vcmVQb3BvdmVyLCB7IGlkOiBzdGF0ZS5wb3BvdmVySWQsIHN0YXJ0RGF0ZTogcmFuZ2Uuc3RhcnQsIGVuZERhdGU6IHJhbmdlLmVuZCwgZGF0ZVByb2ZpbGU6IHByb3BzLmRhdGVQcm9maWxlLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlLCBleHRyYURhdGVTcGFuOiBwcm9wcy5leHRyYURhdGVTcGFuLCBwYXJlbnRFbDogX3RoaXMucGFyZW50RWwsIGFsaWdubWVudEVsOiBwcm9wcy5hbGlnbm1lbnRFbFJlZi5jdXJyZW50LCBhbGlnbkdyaWRUb3A6IHByb3BzLmFsaWduR3JpZFRvcCwgb25DbG9zZTogX3RoaXMuaGFuZGxlUG9wb3ZlckNsb3NlIH0sIHByb3BzLnBvcG92ZXJDb250ZW50KCkpKSkpO1xuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVBhcmVudEVsKCk7XG4gICAgfTtcbiAgICBNb3JlTGlua1Jvb3QucHJvdG90eXBlLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVQYXJlbnRFbCgpO1xuICAgIH07XG4gICAgTW9yZUxpbmtSb290LnByb3RvdHlwZS51cGRhdGVQYXJlbnRFbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGlua0VsUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50RWwgPSBlbGVtZW50Q2xvc2VzdCh0aGlzLmxpbmtFbFJlZi5jdXJyZW50LCAnLmZjLXZpZXctaGFybmVzcycpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTW9yZUxpbmtSb290O1xufShCYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJNb3JlTGlua0lubmVyKHByb3BzKSB7XG4gICAgcmV0dXJuIHByb3BzLnRleHQ7XG59XG5mdW5jdGlvbiBjb21wdXRlUmFuZ2UocHJvcHMpIHtcbiAgICBpZiAocHJvcHMuYWxsRGF5RGF0ZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHByb3BzLmFsbERheURhdGUsXG4gICAgICAgICAgICBlbmQ6IGFkZERheXMocHJvcHMuYWxsRGF5RGF0ZSwgMSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIHZhciBoaWRkZW5TZWdzID0gcHJvcHMuaGlkZGVuU2VncztcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDogY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoaGlkZGVuU2VncyksXG4gICAgICAgIGVuZDogY29tcHV0ZUxhdGVzdFNlZ0VuZChoaWRkZW5TZWdzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQoc2Vncykge1xuICAgIHJldHVybiBzZWdzLnJlZHVjZShwaWNrRWFybGllc3RTdGFydCkuZXZlbnRSYW5nZS5yYW5nZS5zdGFydDtcbn1cbmZ1bmN0aW9uIHBpY2tFYXJsaWVzdFN0YXJ0KHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0IDwgc2VnMS5ldmVudFJhbmdlLnJhbmdlLnN0YXJ0ID8gc2VnMCA6IHNlZzE7XG59XG5mdW5jdGlvbiBjb21wdXRlTGF0ZXN0U2VnRW5kKHNlZ3MpIHtcbiAgICByZXR1cm4gc2Vncy5yZWR1Y2UocGlja0xhdGVzdEVuZCkuZXZlbnRSYW5nZS5yYW5nZS5lbmQ7XG59XG5mdW5jdGlvbiBwaWNrTGF0ZXN0RW5kKHNlZzAsIHNlZzEpIHtcbiAgICByZXR1cm4gc2VnMC5ldmVudFJhbmdlLnJhbmdlLmVuZCA+IHNlZzEuZXZlbnRSYW5nZS5yYW5nZS5lbmQgPyBzZWcwIDogc2VnMTtcbn1cblxuLy8gZXhwb3J0c1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbnZhciB2ZXJzaW9uID0gJzUuMTEuMyc7IC8vIGltcG9ydGFudCB0byB0eXBlIGl0LCBzbyAuZC50cyBoYXMgZ2VuZXJpYyBzdHJpbmdcblxuZXhwb3J0cy5CQVNFX09QVElPTl9ERUZBVUxUUyA9IEJBU0VfT1BUSU9OX0RFRkFVTFRTO1xuZXhwb3J0cy5CQVNFX09QVElPTl9SRUZJTkVSUyA9IEJBU0VfT1BUSU9OX1JFRklORVJTO1xuZXhwb3J0cy5CYXNlQ29tcG9uZW50ID0gQmFzZUNvbXBvbmVudDtcbmV4cG9ydHMuQmdFdmVudCA9IEJnRXZlbnQ7XG5leHBvcnRzLkNhbGVuZGFyQXBpID0gQ2FsZW5kYXJBcGk7XG5leHBvcnRzLkNhbGVuZGFyQ29udGVudCA9IENhbGVuZGFyQ29udGVudDtcbmV4cG9ydHMuQ2FsZW5kYXJEYXRhTWFuYWdlciA9IENhbGVuZGFyRGF0YU1hbmFnZXI7XG5leHBvcnRzLkNhbGVuZGFyRGF0YVByb3ZpZGVyID0gQ2FsZW5kYXJEYXRhUHJvdmlkZXI7XG5leHBvcnRzLkNhbGVuZGFyUm9vdCA9IENhbGVuZGFyUm9vdDtcbmV4cG9ydHMuQ29udGVudEhvb2sgPSBDb250ZW50SG9vaztcbmV4cG9ydHMuQ3VzdG9tQ29udGVudFJlbmRlckNvbnRleHQgPSBDdXN0b21Db250ZW50UmVuZGVyQ29udGV4dDtcbmV4cG9ydHMuRGF0ZUNvbXBvbmVudCA9IERhdGVDb21wb25lbnQ7XG5leHBvcnRzLkRhdGVFbnYgPSBEYXRlRW52O1xuZXhwb3J0cy5EYXRlUHJvZmlsZUdlbmVyYXRvciA9IERhdGVQcm9maWxlR2VuZXJhdG9yO1xuZXhwb3J0cy5EYXlDZWxsQ29udGVudCA9IERheUNlbGxDb250ZW50O1xuZXhwb3J0cy5EYXlDZWxsUm9vdCA9IERheUNlbGxSb290O1xuZXhwb3J0cy5EYXlIZWFkZXIgPSBEYXlIZWFkZXI7XG5leHBvcnRzLkRheVNlcmllc01vZGVsID0gRGF5U2VyaWVzTW9kZWw7XG5leHBvcnRzLkRheVRhYmxlTW9kZWwgPSBEYXlUYWJsZU1vZGVsO1xuZXhwb3J0cy5EZWxheWVkUnVubmVyID0gRGVsYXllZFJ1bm5lcjtcbmV4cG9ydHMuRWxlbWVudERyYWdnaW5nID0gRWxlbWVudERyYWdnaW5nO1xuZXhwb3J0cy5FbGVtZW50U2Nyb2xsQ29udHJvbGxlciA9IEVsZW1lbnRTY3JvbGxDb250cm9sbGVyO1xuZXhwb3J0cy5FbWl0dGVyID0gRW1pdHRlcjtcbmV4cG9ydHMuRXZlbnRBcGkgPSBFdmVudEFwaTtcbmV4cG9ydHMuRXZlbnRSb290ID0gRXZlbnRSb290O1xuZXhwb3J0cy5FdmVudFNvdXJjZUFwaSA9IEV2ZW50U291cmNlQXBpO1xuZXhwb3J0cy5JbnRlcmFjdGlvbiA9IEludGVyYWN0aW9uO1xuZXhwb3J0cy5Nb3JlTGlua1Jvb3QgPSBNb3JlTGlua1Jvb3Q7XG5leHBvcnRzLk1vdW50SG9vayA9IE1vdW50SG9vaztcbmV4cG9ydHMuTmFtZWRUaW1lWm9uZUltcGwgPSBOYW1lZFRpbWVab25lSW1wbDtcbmV4cG9ydHMuTm93SW5kaWNhdG9yUm9vdCA9IE5vd0luZGljYXRvclJvb3Q7XG5leHBvcnRzLk5vd1RpbWVyID0gTm93VGltZXI7XG5leHBvcnRzLlBvc2l0aW9uQ2FjaGUgPSBQb3NpdGlvbkNhY2hlO1xuZXhwb3J0cy5SZWZNYXAgPSBSZWZNYXA7XG5leHBvcnRzLlJlbmRlckhvb2sgPSBSZW5kZXJIb29rO1xuZXhwb3J0cy5TY3JvbGxDb250cm9sbGVyID0gU2Nyb2xsQ29udHJvbGxlcjtcbmV4cG9ydHMuU2Nyb2xsUmVzcG9uZGVyID0gU2Nyb2xsUmVzcG9uZGVyO1xuZXhwb3J0cy5TY3JvbGxlciA9IFNjcm9sbGVyO1xuZXhwb3J0cy5TZWdIaWVyYXJjaHkgPSBTZWdIaWVyYXJjaHk7XG5leHBvcnRzLlNpbXBsZVNjcm9sbEdyaWQgPSBTaW1wbGVTY3JvbGxHcmlkO1xuZXhwb3J0cy5TbGljZXIgPSBTbGljZXI7XG5leHBvcnRzLlNwbGl0dGVyID0gU3BsaXR0ZXI7XG5leHBvcnRzLlN0YW5kYXJkRXZlbnQgPSBTdGFuZGFyZEV2ZW50O1xuZXhwb3J0cy5UYWJsZURhdGVDZWxsID0gVGFibGVEYXRlQ2VsbDtcbmV4cG9ydHMuVGFibGVEb3dDZWxsID0gVGFibGVEb3dDZWxsO1xuZXhwb3J0cy5UaGVtZSA9IFRoZW1lO1xuZXhwb3J0cy5WaWV3QXBpID0gVmlld0FwaTtcbmV4cG9ydHMuVmlld0NvbnRleHRUeXBlID0gVmlld0NvbnRleHRUeXBlO1xuZXhwb3J0cy5WaWV3Um9vdCA9IFZpZXdSb290O1xuZXhwb3J0cy5XZWVrTnVtYmVyUm9vdCA9IFdlZWtOdW1iZXJSb290O1xuZXhwb3J0cy5XaW5kb3dTY3JvbGxDb250cm9sbGVyID0gV2luZG93U2Nyb2xsQ29udHJvbGxlcjtcbmV4cG9ydHMuYWRkRGF5cyA9IGFkZERheXM7XG5leHBvcnRzLmFkZER1cmF0aW9ucyA9IGFkZER1cmF0aW9ucztcbmV4cG9ydHMuYWRkTXMgPSBhZGRNcztcbmV4cG9ydHMuYWRkV2Vla3MgPSBhZGRXZWVrcztcbmV4cG9ydHMuYWxsb3dDb250ZXh0TWVudSA9IGFsbG93Q29udGV4dE1lbnU7XG5leHBvcnRzLmFsbG93U2VsZWN0aW9uID0gYWxsb3dTZWxlY3Rpb247XG5leHBvcnRzLmFwcGx5TXV0YXRpb25Ub0V2ZW50U3RvcmUgPSBhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlO1xuZXhwb3J0cy5hcHBseVN0eWxlID0gYXBwbHlTdHlsZTtcbmV4cG9ydHMuYXBwbHlTdHlsZVByb3AgPSBhcHBseVN0eWxlUHJvcDtcbmV4cG9ydHMuYXNDbGVhbkRheXMgPSBhc0NsZWFuRGF5cztcbmV4cG9ydHMuYXNSb3VnaE1pbnV0ZXMgPSBhc1JvdWdoTWludXRlcztcbmV4cG9ydHMuYXNSb3VnaE1zID0gYXNSb3VnaE1zO1xuZXhwb3J0cy5hc1JvdWdoU2Vjb25kcyA9IGFzUm91Z2hTZWNvbmRzO1xuZXhwb3J0cy5iaW5hcnlTZWFyY2ggPSBiaW5hcnlTZWFyY2g7XG5leHBvcnRzLmJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciA9IGJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplcjtcbmV4cG9ydHMuYnVpbGRFbnRyeUtleSA9IGJ1aWxkRW50cnlLZXk7XG5leHBvcnRzLmJ1aWxkRXZlbnRBcGlzID0gYnVpbGRFdmVudEFwaXM7XG5leHBvcnRzLmJ1aWxkRXZlbnRSYW5nZUtleSA9IGJ1aWxkRXZlbnRSYW5nZUtleTtcbmV4cG9ydHMuYnVpbGRIYXNoRnJvbUFycmF5ID0gYnVpbGRIYXNoRnJvbUFycmF5O1xuZXhwb3J0cy5idWlsZElzb1N0cmluZyA9IGJ1aWxkSXNvU3RyaW5nO1xuZXhwb3J0cy5idWlsZE5hdkxpbmtBdHRycyA9IGJ1aWxkTmF2TGlua0F0dHJzO1xuZXhwb3J0cy5idWlsZFNlZ0NvbXBhcmVPYmogPSBidWlsZFNlZ0NvbXBhcmVPYmo7XG5leHBvcnRzLmJ1aWxkU2VnVGltZVRleHQgPSBidWlsZFNlZ1RpbWVUZXh0O1xuZXhwb3J0cy5jb2xsZWN0RnJvbUhhc2ggPSBjb2xsZWN0RnJvbUhhc2g7XG5leHBvcnRzLmNvbWJpbmVFdmVudFVpcyA9IGNvbWJpbmVFdmVudFVpcztcbmV4cG9ydHMuY29tcGFyZUJ5RmllbGRTcGVjID0gY29tcGFyZUJ5RmllbGRTcGVjO1xuZXhwb3J0cy5jb21wYXJlQnlGaWVsZFNwZWNzID0gY29tcGFyZUJ5RmllbGRTcGVjcztcbmV4cG9ydHMuY29tcGFyZU51bWJlcnMgPSBjb21wYXJlTnVtYmVycztcbmV4cG9ydHMuY29tcGFyZU9ianMgPSBjb21wYXJlT2JqcztcbmV4cG9ydHMuY29tcHV0ZUVhcmxpZXN0U2VnU3RhcnQgPSBjb21wdXRlRWFybGllc3RTZWdTdGFydDtcbmV4cG9ydHMuY29tcHV0ZUVkZ2VzID0gY29tcHV0ZUVkZ2VzO1xuZXhwb3J0cy5jb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQgPSBjb21wdXRlRmFsbGJhY2tIZWFkZXJGb3JtYXQ7XG5leHBvcnRzLmNvbXB1dGVIZWlnaHRBbmRNYXJnaW5zID0gY29tcHV0ZUhlaWdodEFuZE1hcmdpbnM7XG5leHBvcnRzLmNvbXB1dGVJbm5lclJlY3QgPSBjb21wdXRlSW5uZXJSZWN0O1xuZXhwb3J0cy5jb21wdXRlUmVjdCA9IGNvbXB1dGVSZWN0O1xuZXhwb3J0cy5jb21wdXRlU2VnRHJhZ2dhYmxlID0gY29tcHV0ZVNlZ0RyYWdnYWJsZTtcbmV4cG9ydHMuY29tcHV0ZVNlZ0VuZFJlc2l6YWJsZSA9IGNvbXB1dGVTZWdFbmRSZXNpemFibGU7XG5leHBvcnRzLmNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSA9IGNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZTtcbmV4cG9ydHMuY29tcHV0ZVNocmlua1dpZHRoID0gY29tcHV0ZVNocmlua1dpZHRoO1xuZXhwb3J0cy5jb21wdXRlU21hbGxlc3RDZWxsV2lkdGggPSBjb21wdXRlU21hbGxlc3RDZWxsV2lkdGg7XG5leHBvcnRzLmNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UgPSBjb21wdXRlVmlzaWJsZURheVJhbmdlO1xuZXhwb3J0cy5jb25maWcgPSBjb25maWc7XG5leHBvcnRzLmNvbnN0cmFpblBvaW50ID0gY29uc3RyYWluUG9pbnQ7XG5leHBvcnRzLmNyZWF0ZUFyaWFDbGlja0F0dHJzID0gY3JlYXRlQXJpYUNsaWNrQXR0cnM7XG5leHBvcnRzLmNyZWF0ZUR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb247XG5leHBvcnRzLmNyZWF0ZUVtcHR5RXZlbnRTdG9yZSA9IGNyZWF0ZUVtcHR5RXZlbnRTdG9yZTtcbmV4cG9ydHMuY3JlYXRlRXZlbnRJbnN0YW5jZSA9IGNyZWF0ZUV2ZW50SW5zdGFuY2U7XG5leHBvcnRzLmNyZWF0ZUV2ZW50VWkgPSBjcmVhdGVFdmVudFVpO1xuZXhwb3J0cy5jcmVhdGVGb3JtYXR0ZXIgPSBjcmVhdGVGb3JtYXR0ZXI7XG5leHBvcnRzLmNyZWF0ZVBsdWdpbiA9IGNyZWF0ZVBsdWdpbjtcbmV4cG9ydHMuZGlmZkRhdGVzID0gZGlmZkRhdGVzO1xuZXhwb3J0cy5kaWZmRGF5QW5kVGltZSA9IGRpZmZEYXlBbmRUaW1lO1xuZXhwb3J0cy5kaWZmRGF5cyA9IGRpZmZEYXlzO1xuZXhwb3J0cy5kaWZmUG9pbnRzID0gZGlmZlBvaW50cztcbmV4cG9ydHMuZGlmZldlZWtzID0gZGlmZldlZWtzO1xuZXhwb3J0cy5kaWZmV2hvbGVEYXlzID0gZGlmZldob2xlRGF5cztcbmV4cG9ydHMuZGlmZldob2xlV2Vla3MgPSBkaWZmV2hvbGVXZWVrcztcbmV4cG9ydHMuZGlzYWJsZUN1cnNvciA9IGRpc2FibGVDdXJzb3I7XG5leHBvcnRzLmVsZW1lbnRDbG9zZXN0ID0gZWxlbWVudENsb3Nlc3Q7XG5leHBvcnRzLmVsZW1lbnRNYXRjaGVzID0gZWxlbWVudE1hdGNoZXM7XG5leHBvcnRzLmVuYWJsZUN1cnNvciA9IGVuYWJsZUN1cnNvcjtcbmV4cG9ydHMuZXZlbnRUdXBsZVRvU3RvcmUgPSBldmVudFR1cGxlVG9TdG9yZTtcbmV4cG9ydHMuZmlsdGVyRXZlbnRTdG9yZURlZnMgPSBmaWx0ZXJFdmVudFN0b3JlRGVmcztcbmV4cG9ydHMuZmlsdGVySGFzaCA9IGZpbHRlckhhc2g7XG5leHBvcnRzLmZpbmREaXJlY3RDaGlsZHJlbiA9IGZpbmREaXJlY3RDaGlsZHJlbjtcbmV4cG9ydHMuZmluZEVsZW1lbnRzID0gZmluZEVsZW1lbnRzO1xuZXhwb3J0cy5mbGV4aWJsZUNvbXBhcmUgPSBmbGV4aWJsZUNvbXBhcmU7XG5leHBvcnRzLmZvcm1hdERhdGUgPSBmb3JtYXREYXRlO1xuZXhwb3J0cy5mb3JtYXREYXlTdHJpbmcgPSBmb3JtYXREYXlTdHJpbmc7XG5leHBvcnRzLmZvcm1hdElzb1RpbWVTdHJpbmcgPSBmb3JtYXRJc29UaW1lU3RyaW5nO1xuZXhwb3J0cy5mb3JtYXRSYW5nZSA9IGZvcm1hdFJhbmdlO1xuZXhwb3J0cy5nZXRBbGxvd1lTY3JvbGxpbmcgPSBnZXRBbGxvd1lTY3JvbGxpbmc7XG5leHBvcnRzLmdldENhblZHcm93V2l0aGluQ2VsbCA9IGdldENhblZHcm93V2l0aGluQ2VsbDtcbmV4cG9ydHMuZ2V0Q2xpcHBpbmdQYXJlbnRzID0gZ2V0Q2xpcHBpbmdQYXJlbnRzO1xuZXhwb3J0cy5nZXREYXRlTWV0YSA9IGdldERhdGVNZXRhO1xuZXhwb3J0cy5nZXREYXlDbGFzc05hbWVzID0gZ2V0RGF5Q2xhc3NOYW1lcztcbmV4cG9ydHMuZ2V0RGVmYXVsdEV2ZW50RW5kID0gZ2V0RGVmYXVsdEV2ZW50RW5kO1xuZXhwb3J0cy5nZXRFbFJvb3QgPSBnZXRFbFJvb3Q7XG5leHBvcnRzLmdldEVsU2VnID0gZ2V0RWxTZWc7XG5leHBvcnRzLmdldEVudHJ5U3BhbkVuZCA9IGdldEVudHJ5U3BhbkVuZDtcbmV4cG9ydHMuZ2V0RXZlbnRDbGFzc05hbWVzID0gZ2V0RXZlbnRDbGFzc05hbWVzO1xuZXhwb3J0cy5nZXRFdmVudFRhcmdldFZpYVJvb3QgPSBnZXRFdmVudFRhcmdldFZpYVJvb3Q7XG5leHBvcnRzLmdldElzUnRsU2Nyb2xsYmFyT25MZWZ0ID0gZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQ7XG5leHBvcnRzLmdldFJlY3RDZW50ZXIgPSBnZXRSZWN0Q2VudGVyO1xuZXhwb3J0cy5nZXRSZWxldmFudEV2ZW50cyA9IGdldFJlbGV2YW50RXZlbnRzO1xuZXhwb3J0cy5nZXRTY3JvbGxHcmlkQ2xhc3NOYW1lcyA9IGdldFNjcm9sbEdyaWRDbGFzc05hbWVzO1xuZXhwb3J0cy5nZXRTY3JvbGxiYXJXaWR0aHMgPSBnZXRTY3JvbGxiYXJXaWR0aHM7XG5leHBvcnRzLmdldFNlY3Rpb25DbGFzc05hbWVzID0gZ2V0U2VjdGlvbkNsYXNzTmFtZXM7XG5leHBvcnRzLmdldFNlY3Rpb25IYXNMaXF1aWRIZWlnaHQgPSBnZXRTZWN0aW9uSGFzTGlxdWlkSGVpZ2h0O1xuZXhwb3J0cy5nZXRTZWdBbmNob3JBdHRycyA9IGdldFNlZ0FuY2hvckF0dHJzO1xuZXhwb3J0cy5nZXRTZWdNZXRhID0gZ2V0U2VnTWV0YTtcbmV4cG9ydHMuZ2V0U2xvdENsYXNzTmFtZXMgPSBnZXRTbG90Q2xhc3NOYW1lcztcbmV4cG9ydHMuZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyID0gZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyO1xuZXhwb3J0cy5nZXRTdGlja3lIZWFkZXJEYXRlcyA9IGdldFN0aWNreUhlYWRlckRhdGVzO1xuZXhwb3J0cy5nZXRVbmVxdWFsUHJvcHMgPSBnZXRVbmVxdWFsUHJvcHM7XG5leHBvcnRzLmdldFVuaXF1ZURvbUlkID0gZ2V0VW5pcXVlRG9tSWQ7XG5leHBvcnRzLmdsb2JhbExvY2FsZXMgPSBnbG9iYWxMb2NhbGVzO1xuZXhwb3J0cy5nbG9iYWxQbHVnaW5zID0gZ2xvYmFsUGx1Z2lucztcbmV4cG9ydHMuZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yID0gZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yO1xuZXhwb3J0cy5ncm91cEludGVyc2VjdGluZ0VudHJpZXMgPSBncm91cEludGVyc2VjdGluZ0VudHJpZXM7XG5leHBvcnRzLmd1aWQgPSBndWlkO1xuZXhwb3J0cy5oYXNCZ1JlbmRlcmluZyA9IGhhc0JnUmVuZGVyaW5nO1xuZXhwb3J0cy5oYXNTaHJpbmtXaWR0aCA9IGhhc1Nocmlua1dpZHRoO1xuZXhwb3J0cy5pZGVudGl0eSA9IGlkZW50aXR5O1xuZXhwb3J0cy5pbnRlcmFjdGlvblNldHRpbmdzU3RvcmUgPSBpbnRlcmFjdGlvblNldHRpbmdzU3RvcmU7XG5leHBvcnRzLmludGVyYWN0aW9uU2V0dGluZ3NUb1N0b3JlID0gaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmU7XG5leHBvcnRzLmludGVyc2VjdFJhbmdlcyA9IGludGVyc2VjdFJhbmdlcztcbmV4cG9ydHMuaW50ZXJzZWN0UmVjdHMgPSBpbnRlcnNlY3RSZWN0cztcbmV4cG9ydHMuaW50ZXJzZWN0U3BhbnMgPSBpbnRlcnNlY3RTcGFucztcbmV4cG9ydHMuaXNBcnJheXNFcXVhbCA9IGlzQXJyYXlzRXF1YWw7XG5leHBvcnRzLmlzQ29sUHJvcHNFcXVhbCA9IGlzQ29sUHJvcHNFcXVhbDtcbmV4cG9ydHMuaXNEYXRlU2VsZWN0aW9uVmFsaWQgPSBpc0RhdGVTZWxlY3Rpb25WYWxpZDtcbmV4cG9ydHMuaXNEYXRlU3BhbnNFcXVhbCA9IGlzRGF0ZVNwYW5zRXF1YWw7XG5leHBvcnRzLmlzSW50ID0gaXNJbnQ7XG5leHBvcnRzLmlzSW50ZXJhY3Rpb25WYWxpZCA9IGlzSW50ZXJhY3Rpb25WYWxpZDtcbmV4cG9ydHMuaXNNdWx0aURheVJhbmdlID0gaXNNdWx0aURheVJhbmdlO1xuZXhwb3J0cy5pc1Byb3BzRXF1YWwgPSBpc1Byb3BzRXF1YWw7XG5leHBvcnRzLmlzUHJvcHNWYWxpZCA9IGlzUHJvcHNWYWxpZDtcbmV4cG9ydHMuaXNWYWxpZERhdGUgPSBpc1ZhbGlkRGF0ZTtcbmV4cG9ydHMuam9pblNwYW5zID0gam9pblNwYW5zO1xuZXhwb3J0cy5saXN0ZW5CeVNlbGVjdG9yID0gbGlzdGVuQnlTZWxlY3RvcjtcbmV4cG9ydHMubWFwSGFzaCA9IG1hcEhhc2g7XG5leHBvcnRzLm1lbW9pemUgPSBtZW1vaXplO1xuZXhwb3J0cy5tZW1vaXplQXJyYXlsaWtlID0gbWVtb2l6ZUFycmF5bGlrZTtcbmV4cG9ydHMubWVtb2l6ZUhhc2hsaWtlID0gbWVtb2l6ZUhhc2hsaWtlO1xuZXhwb3J0cy5tZW1vaXplT2JqQXJnID0gbWVtb2l6ZU9iakFyZztcbmV4cG9ydHMubWVyZ2VFdmVudFN0b3JlcyA9IG1lcmdlRXZlbnRTdG9yZXM7XG5leHBvcnRzLm11bHRpcGx5RHVyYXRpb24gPSBtdWx0aXBseUR1cmF0aW9uO1xuZXhwb3J0cy5wYWRTdGFydCA9IHBhZFN0YXJ0O1xuZXhwb3J0cy5wYXJzZUJ1c2luZXNzSG91cnMgPSBwYXJzZUJ1c2luZXNzSG91cnM7XG5leHBvcnRzLnBhcnNlQ2xhc3NOYW1lcyA9IHBhcnNlQ2xhc3NOYW1lcztcbmV4cG9ydHMucGFyc2VEcmFnTWV0YSA9IHBhcnNlRHJhZ01ldGE7XG5leHBvcnRzLnBhcnNlRXZlbnREZWYgPSBwYXJzZUV2ZW50RGVmO1xuZXhwb3J0cy5wYXJzZUZpZWxkU3BlY3MgPSBwYXJzZUZpZWxkU3BlY3M7XG5leHBvcnRzLnBhcnNlTWFya2VyID0gcGFyc2U7XG5leHBvcnRzLnBvaW50SW5zaWRlUmVjdCA9IHBvaW50SW5zaWRlUmVjdDtcbmV4cG9ydHMucHJldmVudENvbnRleHRNZW51ID0gcHJldmVudENvbnRleHRNZW51O1xuZXhwb3J0cy5wcmV2ZW50RGVmYXVsdCA9IHByZXZlbnREZWZhdWx0O1xuZXhwb3J0cy5wcmV2ZW50U2VsZWN0aW9uID0gcHJldmVudFNlbGVjdGlvbjtcbmV4cG9ydHMucmFuZ2VDb250YWluc01hcmtlciA9IHJhbmdlQ29udGFpbnNNYXJrZXI7XG5leHBvcnRzLnJhbmdlQ29udGFpbnNSYW5nZSA9IHJhbmdlQ29udGFpbnNSYW5nZTtcbmV4cG9ydHMucmFuZ2VzRXF1YWwgPSByYW5nZXNFcXVhbDtcbmV4cG9ydHMucmFuZ2VzSW50ZXJzZWN0ID0gcmFuZ2VzSW50ZXJzZWN0O1xuZXhwb3J0cy5yZWZpbmVFdmVudERlZiA9IHJlZmluZUV2ZW50RGVmO1xuZXhwb3J0cy5yZWZpbmVQcm9wcyA9IHJlZmluZVByb3BzO1xuZXhwb3J0cy5yZW1vdmVFbGVtZW50ID0gcmVtb3ZlRWxlbWVudDtcbmV4cG9ydHMucmVtb3ZlRXhhY3QgPSByZW1vdmVFeGFjdDtcbmV4cG9ydHMucmVuZGVyQ2h1bmtDb250ZW50ID0gcmVuZGVyQ2h1bmtDb250ZW50O1xuZXhwb3J0cy5yZW5kZXJGaWxsID0gcmVuZGVyRmlsbDtcbmV4cG9ydHMucmVuZGVyTWljcm9Db2xHcm91cCA9IHJlbmRlck1pY3JvQ29sR3JvdXA7XG5leHBvcnRzLnJlbmRlclNjcm9sbFNoaW0gPSByZW5kZXJTY3JvbGxTaGltO1xuZXhwb3J0cy5yZXF1ZXN0SnNvbiA9IHJlcXVlc3RKc29uO1xuZXhwb3J0cy5zYW5pdGl6ZVNocmlua1dpZHRoID0gc2FuaXRpemVTaHJpbmtXaWR0aDtcbmV4cG9ydHMuc2V0RWxTZWcgPSBzZXRFbFNlZztcbmV4cG9ydHMuc2V0UmVmID0gc2V0UmVmO1xuZXhwb3J0cy5zbGljZUV2ZW50U3RvcmUgPSBzbGljZUV2ZW50U3RvcmU7XG5leHBvcnRzLnNsaWNlRXZlbnRzID0gc2xpY2VFdmVudHM7XG5leHBvcnRzLnNvcnRFdmVudFNlZ3MgPSBzb3J0RXZlbnRTZWdzO1xuZXhwb3J0cy5zdGFydE9mRGF5ID0gc3RhcnRPZkRheTtcbmV4cG9ydHMudHJhbnNsYXRlUmVjdCA9IHRyYW5zbGF0ZVJlY3Q7XG5leHBvcnRzLnRyaWdnZXJEYXRlU2VsZWN0ID0gdHJpZ2dlckRhdGVTZWxlY3Q7XG5leHBvcnRzLnVucHJvbWlzaWZ5ID0gdW5wcm9taXNpZnk7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuZXhwb3J0cy53aGVuVHJhbnNpdGlvbkRvbmUgPSB3aGVuVHJhbnNpdGlvbkRvbmU7XG5leHBvcnRzLndob2xlRGl2aWRlRHVyYXRpb25zID0gd2hvbGVEaXZpZGVEdXJhdGlvbnM7XG5PYmplY3Qua2V5cyh2ZG9tX2NqcykuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnZGVmYXVsdCcgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkoaykpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHZkb21fY2pzW2tdO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcbiJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsInRzbGliIiwicmVxdWlyZSIsInZkb21fY2pzIiwiRXZlbnRTb3VyY2VBcGkiLCJjb250ZXh0IiwiaW50ZXJuYWxFdmVudFNvdXJjZSIsInByb3RvdHlwZSIsInJlbW92ZSIsImRpc3BhdGNoIiwidHlwZSIsInNvdXJjZUlkIiwicmVmZXRjaCIsInNvdXJjZUlkcyIsImlzUmVmZXRjaCIsImdldCIsInB1YmxpY0lkIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsIm1ldGEiLCJ1cmwiLCJmb3JtYXQiLCJyZW1vdmVFbGVtZW50IiwiZWwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJlbGVtZW50Q2xvc2VzdCIsInNlbGVjdG9yIiwiY2xvc2VzdCIsImRvY3VtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiY29udGFpbnMiLCJlbGVtZW50TWF0Y2hlcyIsInBhcmVudEVsZW1lbnQiLCJub2RlVHlwZSIsIm1ldGhvZCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsImNhbGwiLCJmaW5kRWxlbWVudHMiLCJjb250YWluZXIiLCJjb250YWluZXJzIiwiSFRNTEVsZW1lbnQiLCJhbGxNYXRjaGVzIiwiaSIsImxlbmd0aCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJqIiwicHVzaCIsImZpbmREaXJlY3RDaGlsZHJlbiIsInBhcmVudCIsInBhcmVudHMiLCJjaGlsZE5vZGVzIiwiY2hpbGRyZW4iLCJjaGlsZE5vZGUiLCJQSVhFTF9QUk9QX1JFIiwiYXBwbHlTdHlsZSIsInByb3BzIiwicHJvcE5hbWUiLCJhcHBseVN0eWxlUHJvcCIsIm5hbWUiLCJ2YWwiLCJzdHlsZSIsInRlc3QiLCJnZXRFdmVudFRhcmdldFZpYVJvb3QiLCJldiIsIl9hIiwiX2IiLCJjb21wb3NlZFBhdGgiLCJ0YXJnZXQiLCJnZXRFbFJvb3QiLCJnZXRSb290Tm9kZSIsImd1aWQkMSIsImdldFVuaXF1ZURvbUlkIiwicHJldmVudERlZmF1bHQiLCJidWlsZERlbGVnYXRpb25IYW5kbGVyIiwiaGFuZGxlciIsIm1hdGNoZWRDaGlsZCIsImxpc3RlbkJ5U2VsZWN0b3IiLCJldmVudFR5cGUiLCJhdHRhY2hlZEhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImxpc3RlblRvSG92ZXJCeVNlbGVjdG9yIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZUxlYXZlIiwiY3VycmVudE1hdGNoZWRDaGlsZCIsIm1vdXNlT3ZlckV2IiwicmVhbE9uTW91c2VMZWF2ZV8xIiwibW91c2VMZWF2ZUV2IiwidHJhbnNpdGlvbkV2ZW50TmFtZXMiLCJ3aGVuVHJhbnNpdGlvbkRvbmUiLCJjYWxsYmFjayIsInJlYWxDYWxsYmFjayIsImZvckVhY2giLCJldmVudE5hbWUiLCJjcmVhdGVBcmlhQ2xpY2tBdHRycyIsIl9fYXNzaWduIiwib25DbGljayIsImNyZWF0ZUFyaWFLZXlib2FyZEF0dHJzIiwidGFiSW5kZXgiLCJvbktleURvd24iLCJrZXkiLCJndWlkTnVtYmVyIiwiZ3VpZCIsIlN0cmluZyIsImRpc2FibGVDdXJzb3IiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwiZW5hYmxlQ3Vyc29yIiwicHJldmVudFNlbGVjdGlvbiIsImFsbG93U2VsZWN0aW9uIiwicHJldmVudENvbnRleHRNZW51IiwiYWxsb3dDb250ZXh0TWVudSIsInBhcnNlRmllbGRTcGVjcyIsImlucHV0Iiwic3BlY3MiLCJ0b2tlbnMiLCJ0b2tlbiIsInNwbGl0IiwiQXJyYXkiLCJpc0FycmF5IiwiY2hhckF0IiwiZmllbGQiLCJzdWJzdHJpbmciLCJvcmRlciIsImZ1bmMiLCJjb21wYXJlQnlGaWVsZFNwZWNzIiwib2JqMCIsIm9iajEiLCJmaWVsZFNwZWNzIiwiY21wIiwiY29tcGFyZUJ5RmllbGRTcGVjIiwiZmllbGRTcGVjIiwiZmxleGlibGVDb21wYXJlIiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwicGFkU3RhcnQiLCJsZW4iLCJzIiwic3Vic3RyIiwiZm9ybWF0V2l0aE9yZGluYWxzIiwiZm9ybWF0dGVyIiwiYXJncyIsImZhbGxiYWNrVGV4dCIsImFwcGx5IiwicmVkdWNlIiwic3RyIiwiYXJnIiwiaW5kZXgiLCJyZXBsYWNlIiwiY29tcGFyZU51bWJlcnMiLCJpc0ludCIsIm4iLCJjb21wdXRlU21hbGxlc3RDZWxsV2lkdGgiLCJjZWxsRWwiLCJhbGxXaWR0aEVsIiwicXVlcnlTZWxlY3RvciIsImNvbnRlbnRXaWR0aEVsIiwiRXJyb3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ3aWR0aCIsIkRBWV9JRFMiLCJhZGRXZWVrcyIsIm0iLCJkYXRlVG9VdGNBcnJheSIsImFycmF5VG9VdGNEYXRlIiwiYWRkRGF5cyIsImFkZE1zIiwiZGlmZldlZWtzIiwibTAiLCJtMSIsImRpZmZEYXlzIiwidmFsdWVPZiIsImRpZmZIb3VycyIsImRpZmZNaW51dGVzIiwiZGlmZlNlY29uZHMiLCJkaWZmRGF5QW5kVGltZSIsIm0wZGF5Iiwic3RhcnRPZkRheSIsIm0xZGF5IiwieWVhcnMiLCJtb250aHMiLCJkYXlzIiwiTWF0aCIsInJvdW5kIiwibWlsbGlzZWNvbmRzIiwiZGlmZldob2xlV2Vla3MiLCJkIiwiZGlmZldob2xlRGF5cyIsInRpbWVBc01zIiwiZ2V0VVRDRnVsbFllYXIiLCJnZXRVVENNb250aCIsImdldFVUQ0RhdGUiLCJzdGFydE9mSG91ciIsImdldFVUQ0hvdXJzIiwic3RhcnRPZk1pbnV0ZSIsImdldFVUQ01pbnV0ZXMiLCJzdGFydE9mU2Vjb25kIiwiZ2V0VVRDU2Vjb25kcyIsIndlZWtPZlllYXIiLCJtYXJrZXIiLCJkb3ciLCJkb3kiLCJ5IiwidyIsIndlZWtPZkdpdmVuWWVhciIsIm5leHRXIiwibWluIiwieWVhciIsImZpcnN0V2Vla1N0YXJ0IiwiZmlyc3RXZWVrT2Zmc2V0IiwiZGF5U3RhcnQiLCJmbG9vciIsImZ3ZCIsImZ3ZGx3IiwiZ2V0VVRDRGF5IiwiZGF0ZVRvTG9jYWxBcnJheSIsImRhdGUiLCJnZXRGdWxsWWVhciIsImdldE1vbnRoIiwiZ2V0RGF0ZSIsImdldEhvdXJzIiwiZ2V0TWludXRlcyIsImdldFNlY29uZHMiLCJnZXRNaWxsaXNlY29uZHMiLCJhcnJheVRvTG9jYWxEYXRlIiwiRGF0ZSIsImdldFVUQ01pbGxpc2Vjb25kcyIsImNvbmNhdCIsIlVUQyIsImlzVmFsaWREYXRlIiwiaXNOYU4iLCJjcmVhdGVFdmVudEluc3RhbmNlIiwiZGVmSWQiLCJyYW5nZSIsImZvcmNlZFN0YXJ0VHpvIiwiZm9yY2VkRW5kVHpvIiwiaW5zdGFuY2VJZCIsImhhc093blByb3BlcnR5IiwibWVyZ2VQcm9wcyIsInByb3BPYmpzIiwiY29tcGxleFByb3BzTWFwIiwiZGVzdCIsIm5hbWVfMSIsImNvbXBsZXhPYmpzIiwidW5zaGlmdCIsInVuZGVmaW5lZCIsIm5hbWVfMiIsImZpbHRlckhhc2giLCJoYXNoIiwiZmlsdGVyZWQiLCJtYXBIYXNoIiwibmV3SGFzaCIsImFycmF5VG9IYXNoIiwiX2kiLCJhXzEiLCJpdGVtIiwiYnVpbGRIYXNoRnJvbUFycmF5IiwidHVwbGUiLCJoYXNoVmFsdWVzVG9BcnJheSIsIm9iaiIsImlzUHJvcHNFcXVhbCIsImdldFVuZXF1YWxQcm9wcyIsImtleXMiLCJjb21wYXJlT2JqcyIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJlcXVhbGl0eUZ1bmNzIiwiaXNPYmpWYWxzRXF1YWwiLCJ2YWwwIiwidmFsMSIsImNvbXBhcmF0b3IiLCJjb2xsZWN0RnJvbUhhc2giLCJzdGFydEluZGV4IiwiZW5kSW5kZXgiLCJzdGVwIiwicmVzIiwicGFyc2VSZWN1cnJpbmciLCJyZWZpbmVkIiwiZGVmYXVsdEFsbERheSIsImRhdGVFbnYiLCJyZWN1cnJpbmdUeXBlcyIsInBhcnNlZCIsInBhcnNlIiwiYWxsRGF5IiwiYWxsRGF5R3Vlc3MiLCJkdXJhdGlvbiIsInR5cGVEYXRhIiwidHlwZUlkIiwiZXhwYW5kUmVjdXJyaW5nIiwiZXZlbnRTdG9yZSIsImZyYW1pbmdSYW5nZSIsInBsdWdpbkhvb2tzIiwib3B0aW9ucyIsImRlZnMiLCJpbnN0YW5jZXMiLCJpbnN0YW5jZSIsInJlY3VycmluZ0RlZiIsImRlZiIsImRlZmF1bHRBbGxEYXlFdmVudER1cmF0aW9uIiwiZGVmYXVsdFRpbWVkRXZlbnREdXJhdGlvbiIsInN0YXJ0cyIsImV4cGFuZFJlY3VycmluZ1JhbmdlcyIsInN0YXJ0c18xIiwic3RhcnQiLCJlbmQiLCJldmVudERlZiIsInR5cGVEZWYiLCJtYXJrZXJzIiwiZXhwYW5kIiwic3VidHJhY3QiLCJtYXAiLCJJTlRFUk5BTF9VTklUUyIsIlBBUlNFX1JFIiwiY3JlYXRlRHVyYXRpb24iLCJ1bml0IiwicGFyc2VTdHJpbmciLCJwYXJzZU9iamVjdCIsImV4ZWMiLCJzaWduIiwicGFyc2VJbnQiLCJtb250aCIsImRheSIsImhvdXJzIiwiaG91ciIsIm1pbnV0ZXMiLCJtaW51dGUiLCJzZWNvbmRzIiwic2Vjb25kIiwibWlsbGlzZWNvbmQiLCJtcyIsIndlZWtzIiwid2VlayIsInNwZWNpZmllZFdlZWtzIiwiZHVyYXRpb25zRXF1YWwiLCJkMCIsImQxIiwiYXNDbGVhbkRheXMiLCJkdXIiLCJhZGREdXJhdGlvbnMiLCJzdWJ0cmFjdER1cmF0aW9ucyIsIm11bHRpcGx5RHVyYXRpb24iLCJhc1JvdWdoWWVhcnMiLCJhc1JvdWdoRGF5cyIsImFzUm91Z2hNb250aHMiLCJhc1JvdWdoTXMiLCJhc1JvdWdoTWludXRlcyIsImFzUm91Z2hTZWNvbmRzIiwid2hvbGVEaXZpZGVEdXJhdGlvbnMiLCJudW1lcmF0b3IiLCJkZW5vbWluYXRvciIsImxvY2FsUmVzIiwiZ3JlYXRlc3REdXJhdGlvbkRlbm9taW5hdG9yIiwiYnVpbGRJc29TdHJpbmciLCJ0aW1lWm9uZU9mZnNldCIsInN0cmlwWmVyb1RpbWUiLCJ0b0lTT1N0cmluZyIsImZvcm1hdFRpbWVab25lT2Zmc2V0IiwiZm9ybWF0RGF5U3RyaW5nIiwiZm9ybWF0SXNvVGltZVN0cmluZyIsImRvSXNvIiwiYWJzIiwibWlucyIsInJlbW92ZUV4YWN0IiwiYXJyYXkiLCJleGFjdFZhbCIsInJlbW92ZUNudCIsInNwbGljZSIsImlzQXJyYXlzRXF1YWwiLCJhMCIsImExIiwiZXF1YWxpdHlGdW5jIiwibWVtb2l6ZSIsIndvcmtlckZ1bmMiLCJyZXNFcXVhbGl0eSIsInRlYXJkb3duRnVuYyIsImN1cnJlbnRBcmdzIiwiY3VycmVudFJlcyIsIm5ld0FyZ3MiLCJhcmd1bWVudHMiLCJtZW1vaXplT2JqQXJnIiwiX3RoaXMiLCJjdXJyZW50QXJnIiwibmV3QXJnIiwibWVtb2l6ZUFycmF5bGlrZSIsImN1cnJlbnRBcmdTZXRzIiwiY3VycmVudFJlc3VsdHMiLCJuZXdBcmdTZXRzIiwiY3VycmVudExlbiIsIm5ld0xlbiIsIm1lbW9pemVIYXNobGlrZSIsImN1cnJlbnRBcmdIYXNoIiwiY3VycmVudFJlc0hhc2giLCJuZXdBcmdIYXNoIiwibmV3UmVzSGFzaCIsIkVYVEVOREVEX1NFVFRJTkdTX0FORF9TRVZFUklUSUVTIiwic2VwYXJhdG9yIiwib21pdFplcm9NaW51dGUiLCJtZXJpZGllbSIsIm9taXRDb21tYXMiLCJTVEFOREFSRF9EQVRFX1BST1BfU0VWRVJJVElFUyIsInRpbWVab25lTmFtZSIsImVyYSIsIndlZWtkYXkiLCJNRVJJRElFTV9SRSIsIkNPTU1BX1JFIiwiTVVMVElfU1BBQ0VfUkUiLCJMVFJfUkUiLCJVVENfUkUiLCJOYXRpdmVGb3JtYXR0ZXIiLCJmb3JtYXRTZXR0aW5ncyIsInN0YW5kYXJkRGF0ZVByb3BzIiwiZXh0ZW5kZWRTZXR0aW5ncyIsInNldmVyaXR5IiwibWF4IiwiYnVpbGRGb3JtYXR0aW5nRnVuYyIsImZvcm1hdFJhbmdlIiwiYmV0dGVyRGVmYXVsdFNlcGFyYXRvciIsImRpZmZTZXZlcml0eSIsImNvbXB1dGVNYXJrZXJEaWZmU2V2ZXJpdHkiLCJjYWxlbmRhclN5c3RlbSIsImJpZ2dlc3RVbml0Rm9yUGFydGlhbCIsImZ1bGwwIiwiZnVsbDEiLCJwYXJ0aWFsRGF0ZVByb3BzIiwiY29tcHV0ZVBhcnRpYWxGb3JtYXR0aW5nT3B0aW9ucyIsInBhcnRpYWxGb3JtYXR0aW5nRnVuYyIsInBhcnRpYWwwIiwicGFydGlhbDEiLCJpbnNlcnRpb24iLCJmaW5kQ29tbW9uSW5zZXJ0aW9uIiwiZGVmYXVsdFNlcGFyYXRvciIsImJlZm9yZSIsImFmdGVyIiwiZ2V0TGFyZ2VzdFVuaXQiLCJzdGFuZGFyZERhdGVQcm9wQ250IiwiZm9ybWF0V2Vla051bWJlciIsImNvbXB1dGVXZWVrTnVtYmVyIiwid2Vla1RleHQiLCJ3ZWVrVGV4dExvbmciLCJsb2NhbGUiLCJidWlsZE5hdGl2ZUZvcm1hdHRpbmdGdW5jIiwic2FuaXRpemVTZXR0aW5ncyIsInRpbWVab25lIiwibm9ybWFsRm9ybWF0IiwiSW50bCIsIkRhdGVUaW1lRm9ybWF0IiwiY29kZXMiLCJ6ZXJvRm9ybWF0IiwiemVyb1Byb3BzIiwicG9zdFByb2Nlc3MiLCJpbmplY3RUem9TdHIiLCJ0cmltIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJ0em9TdHIiLCJyZXBsYWNlZCIsIm51bSIsImRpc3BsYXkiLCJwYXJ0cyIsInNpbXBsZU51bWJlckZvcm1hdCIsImRpcmVjdGlvbiIsInJldmVyc2UiLCJqb2luIiwiY2EiLCJnZXRNYXJrZXJZZWFyIiwiZ2V0TWFya2VyTW9udGgiLCJnZXRNYXJrZXJEYXkiLCJiaWdnZXN0VW5pdCIsInBhcnRpYWxPcHRpb25zIiwiaTAiLCJmb3VuZDAiLCJpbmRleE9mIiwiYmVmb3JlMCIsImFmdGVyMCIsImkxIiwiZm91bmQxIiwiYmVmb3JlMSIsImFmdGVyMSIsImV4cGFuZFpvbmVkTWFya2VyIiwiZGF0ZUluZm8iLCJtYXJrZXJUb0FycmF5IiwiY3JlYXRlVmVyYm9zZUZvcm1hdHRpbmdBcmciLCJzdGFydEluZm8iLCJlbmRJbmZvIiwibG9jYWxlQ29kZXMiLCJDbWRGb3JtYXR0ZXIiLCJjbWRTdHIiLCJjbWRGb3JtYXR0ZXIiLCJGdW5jRm9ybWF0dGVyIiwiY3JlYXRlRm9ybWF0dGVyIiwiQkFTRV9PUFRJT05fUkVGSU5FUlMiLCJuYXZMaW5rRGF5Q2xpY2siLCJpZGVudGl0eSIsIm5hdkxpbmtXZWVrQ2xpY2siLCJib290c3RyYXBGb250QXdlc29tZSIsImJ1dHRvbkljb25zIiwiY3VzdG9tQnV0dG9ucyIsIm5leHREYXlUaHJlc2hvbGQiLCJzY3JvbGxUaW1lIiwic2Nyb2xsVGltZVJlc2V0IiwiQm9vbGVhbiIsInNsb3RNaW5UaW1lIiwic2xvdE1heFRpbWUiLCJkYXlQb3BvdmVyRm9ybWF0Iiwic2xvdER1cmF0aW9uIiwic25hcER1cmF0aW9uIiwiaGVhZGVyVG9vbGJhciIsImZvb3RlclRvb2xiYXIiLCJkZWZhdWx0UmFuZ2VTZXBhcmF0b3IiLCJ0aXRsZVJhbmdlU2VwYXJhdG9yIiwiZm9yY2VFdmVudER1cmF0aW9uIiwiZGF5SGVhZGVycyIsImRheUhlYWRlckZvcm1hdCIsImRheUhlYWRlckNsYXNzTmFtZXMiLCJkYXlIZWFkZXJDb250ZW50IiwiZGF5SGVhZGVyRGlkTW91bnQiLCJkYXlIZWFkZXJXaWxsVW5tb3VudCIsImRheUNlbGxDbGFzc05hbWVzIiwiZGF5Q2VsbENvbnRlbnQiLCJkYXlDZWxsRGlkTW91bnQiLCJkYXlDZWxsV2lsbFVubW91bnQiLCJpbml0aWFsVmlldyIsImFzcGVjdFJhdGlvIiwiTnVtYmVyIiwid2Vla2VuZHMiLCJ3ZWVrTnVtYmVyQ2FsY3VsYXRpb24iLCJ3ZWVrTnVtYmVycyIsIndlZWtOdW1iZXJDbGFzc05hbWVzIiwid2Vla051bWJlckNvbnRlbnQiLCJ3ZWVrTnVtYmVyRGlkTW91bnQiLCJ3ZWVrTnVtYmVyV2lsbFVubW91bnQiLCJlZGl0YWJsZSIsInZpZXdDbGFzc05hbWVzIiwidmlld0RpZE1vdW50Iiwidmlld1dpbGxVbm1vdW50Iiwibm93SW5kaWNhdG9yIiwibm93SW5kaWNhdG9yQ2xhc3NOYW1lcyIsIm5vd0luZGljYXRvckNvbnRlbnQiLCJub3dJbmRpY2F0b3JEaWRNb3VudCIsIm5vd0luZGljYXRvcldpbGxVbm1vdW50Iiwic2hvd05vbkN1cnJlbnREYXRlcyIsImxhenlGZXRjaGluZyIsInN0YXJ0UGFyYW0iLCJlbmRQYXJhbSIsInRpbWVab25lUGFyYW0iLCJsb2NhbGVzIiwidGhlbWVTeXN0ZW0iLCJkcmFnUmV2ZXJ0RHVyYXRpb24iLCJkcmFnU2Nyb2xsIiwiYWxsRGF5TWFpbnRhaW5EdXJhdGlvbiIsInVuc2VsZWN0QXV0byIsImRyb3BBY2NlcHQiLCJldmVudE9yZGVyIiwiZXZlbnRPcmRlclN0cmljdCIsImhhbmRsZVdpbmRvd1Jlc2l6ZSIsIndpbmRvd1Jlc2l6ZURlbGF5IiwibG9uZ1ByZXNzRGVsYXkiLCJldmVudERyYWdNaW5EaXN0YW5jZSIsImV4cGFuZFJvd3MiLCJoZWlnaHQiLCJjb250ZW50SGVpZ2h0Iiwid2Vla051bWJlckZvcm1hdCIsImV2ZW50UmVzaXphYmxlRnJvbVN0YXJ0IiwiZGlzcGxheUV2ZW50VGltZSIsImRpc3BsYXlFdmVudEVuZCIsInByb2dyZXNzaXZlRXZlbnRSZW5kZXJpbmciLCJidXNpbmVzc0hvdXJzIiwiaW5pdGlhbERhdGUiLCJub3ciLCJldmVudERhdGFUcmFuc2Zvcm0iLCJzdGlja3lIZWFkZXJEYXRlcyIsInN0aWNreUZvb3RlclNjcm9sbGJhciIsInZpZXdIZWlnaHQiLCJldmVudFNvdXJjZUZhaWx1cmUiLCJldmVudFNvdXJjZVN1Y2Nlc3MiLCJldmVudERpc3BsYXkiLCJldmVudFN0YXJ0RWRpdGFibGUiLCJldmVudER1cmF0aW9uRWRpdGFibGUiLCJldmVudE92ZXJsYXAiLCJldmVudENvbnN0cmFpbnQiLCJldmVudEFsbG93IiwiZXZlbnRCYWNrZ3JvdW5kQ29sb3IiLCJldmVudEJvcmRlckNvbG9yIiwiZXZlbnRUZXh0Q29sb3IiLCJldmVudENvbG9yIiwiZXZlbnRDbGFzc05hbWVzIiwiZXZlbnRDb250ZW50IiwiZXZlbnREaWRNb3VudCIsImV2ZW50V2lsbFVubW91bnQiLCJzZWxlY3RDb25zdHJhaW50Iiwic2VsZWN0T3ZlcmxhcCIsInNlbGVjdEFsbG93IiwiZHJvcHBhYmxlIiwidW5zZWxlY3RDYW5jZWwiLCJzbG90TGFiZWxGb3JtYXQiLCJzbG90TGFuZUNsYXNzTmFtZXMiLCJzbG90TGFuZUNvbnRlbnQiLCJzbG90TGFuZURpZE1vdW50Iiwic2xvdExhbmVXaWxsVW5tb3VudCIsInNsb3RMYWJlbENsYXNzTmFtZXMiLCJzbG90TGFiZWxDb250ZW50Iiwic2xvdExhYmVsRGlkTW91bnQiLCJzbG90TGFiZWxXaWxsVW5tb3VudCIsImRheU1heEV2ZW50cyIsImRheU1heEV2ZW50Um93cyIsImRheU1pbldpZHRoIiwic2xvdExhYmVsSW50ZXJ2YWwiLCJhbGxEYXlUZXh0IiwiYWxsRGF5Q2xhc3NOYW1lcyIsImFsbERheUNvbnRlbnQiLCJhbGxEYXlEaWRNb3VudCIsImFsbERheVdpbGxVbm1vdW50Iiwic2xvdE1pbldpZHRoIiwibmF2TGlua3MiLCJldmVudFRpbWVGb3JtYXQiLCJyZXJlbmRlckRlbGF5IiwibW9yZUxpbmtUZXh0IiwibW9yZUxpbmtIaW50Iiwic2VsZWN0TWluRGlzdGFuY2UiLCJzZWxlY3RhYmxlIiwic2VsZWN0TG9uZ1ByZXNzRGVsYXkiLCJldmVudExvbmdQcmVzc0RlbGF5Iiwic2VsZWN0TWlycm9yIiwiZXZlbnRNYXhTdGFjayIsImV2ZW50TWluSGVpZ2h0IiwiZXZlbnRNaW5XaWR0aCIsImV2ZW50U2hvcnRIZWlnaHQiLCJzbG90RXZlbnRPdmVybGFwIiwicGx1Z2lucyIsImZpcnN0RGF5IiwiZGF5Q291bnQiLCJkYXRlQWxpZ25tZW50IiwiZGF0ZUluY3JlbWVudCIsImhpZGRlbkRheXMiLCJtb250aE1vZGUiLCJmaXhlZFdlZWtDb3VudCIsInZhbGlkUmFuZ2UiLCJ2aXNpYmxlUmFuZ2UiLCJ0aXRsZUZvcm1hdCIsImV2ZW50SW50ZXJhY3RpdmUiLCJub0V2ZW50c1RleHQiLCJ2aWV3SGludCIsIm5hdkxpbmtIaW50IiwiY2xvc2VIaW50IiwidGltZUhpbnQiLCJldmVudEhpbnQiLCJtb3JlTGlua0NsaWNrIiwibW9yZUxpbmtDbGFzc05hbWVzIiwibW9yZUxpbmtDb250ZW50IiwibW9yZUxpbmtEaWRNb3VudCIsIm1vcmVMaW5rV2lsbFVubW91bnQiLCJCQVNFX09QVElPTl9ERUZBVUxUUyIsImNlbnRlciIsIkNBTEVOREFSX0xJU1RFTkVSX1JFRklORVJTIiwiZGF0ZXNTZXQiLCJldmVudHNTZXQiLCJldmVudEFkZCIsImV2ZW50Q2hhbmdlIiwiZXZlbnRSZW1vdmUiLCJ3aW5kb3dSZXNpemUiLCJldmVudENsaWNrIiwiZXZlbnRNb3VzZUVudGVyIiwiZXZlbnRNb3VzZUxlYXZlIiwic2VsZWN0IiwidW5zZWxlY3QiLCJsb2FkaW5nIiwiX3VubW91bnQiLCJfYmVmb3JlcHJpbnQiLCJfYWZ0ZXJwcmludCIsIl9ub0V2ZW50RHJvcCIsIl9ub0V2ZW50UmVzaXplIiwiX3Jlc2l6ZSIsIl9zY3JvbGxSZXF1ZXN0IiwiQ0FMRU5EQVJfT1BUSU9OX1JFRklORVJTIiwiYnV0dG9uVGV4dCIsImJ1dHRvbkhpbnRzIiwidmlld3MiLCJpbml0aWFsRXZlbnRzIiwiZXZlbnRzIiwiZXZlbnRTb3VyY2VzIiwiQ09NUExFWF9PUFRJT05fQ09NUEFSQVRPUlMiLCJpc01heWJlT2JqZWN0c0VxdWFsIiwiVklFV19PUFRJT05fUkVGSU5FUlMiLCJjb21wb25lbnQiLCJidXR0b25UZXh0S2V5IiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3JDbGFzcyIsInVzZXNNaW5NYXhUaW1lIiwiY2xhc3NOYW1lcyIsImNvbnRlbnQiLCJkaWRNb3VudCIsIndpbGxVbm1vdW50IiwibWVyZ2VSYXdPcHRpb25zIiwib3B0aW9uU2V0cyIsInJlZmluZVByb3BzIiwicmVmaW5lcnMiLCJleHRyYSIsInJhdyIsInBhcnNlRXZlbnRzIiwicmF3RXZlbnRzIiwiZXZlbnRTb3VyY2UiLCJhbGxvd09wZW5SYW5nZSIsImNyZWF0ZUVtcHR5RXZlbnRTdG9yZSIsImV2ZW50UmVmaW5lcnMiLCJidWlsZEV2ZW50UmVmaW5lcnMiLCJyYXdFdmVudHNfMSIsInJhd0V2ZW50IiwicGFyc2VFdmVudCIsImV2ZW50VHVwbGVUb1N0b3JlIiwiZ2V0UmVsZXZhbnRFdmVudHMiLCJkZWZfMSIsIm5ld1N0b3JlIiwiZmlsdGVyRXZlbnRTdG9yZURlZnMiLCJsb29rRGVmIiwiaXNFdmVudERlZnNHcm91cGVkIiwiZGVmMCIsImRlZjEiLCJncm91cElkIiwibWVyZ2VFdmVudFN0b3JlcyIsInN0b3JlMCIsInN0b3JlMSIsImZpbHRlckZ1bmMiLCJleGNsdWRlU3ViRXZlbnRTdG9yZSIsIm1hc3RlciIsInN1YiIsImZpbHRlcmVkRGVmcyIsImZpbHRlcmVkSW5zdGFuY2VzIiwibm9ybWFsaXplQ29uc3RyYWludCIsInBhcnNlQ2xhc3NOYW1lcyIsIkVWRU5UX1VJX1JFRklORVJTIiwic3RhcnRFZGl0YWJsZSIsImR1cmF0aW9uRWRpdGFibGUiLCJjb25zdHJhaW50Iiwib3ZlcmxhcCIsImFsbG93IiwiY2xhc3NOYW1lIiwiY29sb3IiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXJDb2xvciIsInRleHRDb2xvciIsIkVNUFRZX0VWRU5UX1VJIiwiY29uc3RyYWludHMiLCJhbGxvd3MiLCJjcmVhdGVFdmVudFVpIiwiY29tYmluZUV2ZW50VWlzIiwidWlzIiwiY29tYmluZVR3b0V2ZW50VWlzIiwiaXRlbTAiLCJpdGVtMSIsIkVWRU5UX05PTl9EQVRFX1JFRklORVJTIiwiaWQiLCJ0aXRsZSIsImludGVyYWN0aXZlIiwiRVZFTlRfREFURV9SRUZJTkVSUyIsIkVWRU5UX1JFRklORVJTIiwiZXh0ZW5kZWRQcm9wcyIsInJlZmluZUV2ZW50RGVmIiwiY29tcHV0ZUlzRGVmYXVsdEFsbERheSIsInJlY3VycmluZ1JlcyIsInBhcnNlRXZlbnREZWYiLCJzaW5nbGVSZXMiLCJwYXJzZVNpbmdsZSIsImhhc0VuZCIsInVpIiwiZXZlbnREZWZNZW1iZXJBZGRlcnMiLCJtZW1iZXJBZGRlciIsImZyZWV6ZSIsInN0YXJ0TWV0YSIsInN0YXJ0TWFya2VyIiwiZW5kTWV0YSIsImVuZE1hcmtlciIsInN0YXJ0SW5wdXQiLCJjcmVhdGVNYXJrZXJNZXRhIiwiaXNUaW1lVW5zcGVjaWZpZWQiLCJmb3JjZWRUem8iLCJjb21wdXRlQWxpZ25lZERheVJhbmdlIiwidGltZWRSYW5nZSIsImRheUNudCIsImNvbXB1dGVWaXNpYmxlRGF5UmFuZ2UiLCJzdGFydERheSIsImVuZERheSIsImVuZFRpbWVNUyIsImlzTXVsdGlEYXlSYW5nZSIsImRpZmZEYXRlcyIsImRhdGUwIiwiZGF0ZTEiLCJsYXJnZVVuaXQiLCJkaWZmV2hvbGVZZWFycyIsImRpZmZXaG9sZU1vbnRocyIsInBhcnNlUmFuZ2UiLCJjcmVhdGVNYXJrZXIiLCJpbnZlcnRSYW5nZXMiLCJyYW5nZXMiLCJjb25zdHJhaW50UmFuZ2UiLCJpbnZlcnRlZFJhbmdlcyIsImRhdGVSYW5nZSIsInNvcnQiLCJjb21wYXJlUmFuZ2VzIiwicmFuZ2UwIiwicmFuZ2UxIiwiaW50ZXJzZWN0UmFuZ2VzIiwibmV3UmFuZ2UiLCJyYW5nZXNFcXVhbCIsInJhbmdlc0ludGVyc2VjdCIsInJhbmdlQ29udGFpbnNSYW5nZSIsIm91dGVyUmFuZ2UiLCJpbm5lclJhbmdlIiwicmFuZ2VDb250YWluc01hcmtlciIsImNvbnN0cmFpbk1hcmtlclRvUmFuZ2UiLCJzbGljZUV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJpbnZlcnNlQmdCeUdyb3VwSWQiLCJpbnZlcnNlQmdCeURlZklkIiwiZGVmQnlHcm91cElkIiwiYmdSYW5nZXMiLCJmZ1JhbmdlcyIsImV2ZW50VWlzIiwiY29tcGlsZUV2ZW50VWlzIiwib3JpZ1JhbmdlIiwibm9ybWFsUmFuZ2UiLCJzbGljZWRSYW5nZSIsImlzU3RhcnQiLCJpc0VuZCIsImludmVydGVkUmFuZ2VzXzEiLCJpbnZlcnRlZFJhbmdlIiwiaW52ZXJ0ZWRSYW5nZXNfMiIsImJnIiwiZmciLCJoYXNCZ1JlbmRlcmluZyIsInNldEVsU2VnIiwic2VnIiwiZmNTZWciLCJnZXRFbFNlZyIsImV2ZW50RGVmcyIsImNvbXBpbGVFdmVudFVpIiwic29ydEV2ZW50U2VncyIsInNlZ3MiLCJldmVudE9yZGVyU3BlY3MiLCJvYmpzIiwiYnVpbGRTZWdDb21wYXJlT2JqIiwiYyIsIl9zZWciLCJldmVudFJhbmdlIiwiY29tcHV0ZVNlZ0RyYWdnYWJsZSIsInRyYW5zZm9ybWVycyIsImlzRHJhZ2dhYmxlVHJhbnNmb3JtZXJzIiwidHJhbnNmb3JtZXJzXzEiLCJ0cmFuc2Zvcm1lciIsImNvbXB1dGVTZWdTdGFydFJlc2l6YWJsZSIsImNvbXB1dGVTZWdFbmRSZXNpemFibGUiLCJidWlsZFNlZ1RpbWVUZXh0IiwidGltZUZvcm1hdCIsImRlZmF1bHREaXNwbGF5RXZlbnRUaW1lIiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsInN0YXJ0T3ZlcnJpZGUiLCJlbmRPdmVycmlkZSIsImV2ZW50SW5zdGFuY2UiLCJ3aG9sZUV2ZW50U3RhcnQiLCJ3aG9sZUV2ZW50RW5kIiwic2VnU3RhcnQiLCJzZWdFbmQiLCJpc1N0YXJ0RGF5IiwiaXNFbmREYXkiLCJnZXRTZWdNZXRhIiwidG9kYXlSYW5nZSIsIm5vd0RhdGUiLCJzZWdSYW5nZSIsImlzUGFzdCIsImlzRnV0dXJlIiwiaXNUb2RheSIsImdldEV2ZW50Q2xhc3NOYW1lcyIsImlzTWlycm9yIiwiaXNEcmFnZ2FibGUiLCJpc1N0YXJ0UmVzaXphYmxlIiwiaXNFbmRSZXNpemFibGUiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImlzU2VsZWN0ZWQiLCJidWlsZEV2ZW50UmFuZ2VLZXkiLCJnZXRTZWdBbmNob3JBdHRycyIsImhyZWYiLCJlbWl0dGVyIiwiaGFzSGFuZGxlcnMiLCJ0cmlnZ2VyIiwiZXZlbnQiLCJFdmVudEFwaSIsImpzRXZlbnQiLCJ2aWV3Iiwidmlld0FwaSIsIlNUQU5EQVJEX1BST1BTIiwicGFyc2VEYXRlU3BhbiIsImRlZmF1bHREdXJhdGlvbiIsInNwYW4iLCJwYXJzZU9wZW5EYXRlU3BhbiIsInN0YW5kYXJkUHJvcHMiLCJpc0RhdGVTcGFuc0VxdWFsIiwic3BhbjAiLCJzcGFuMSIsImlzU3BhblByb3BzRXF1YWwiLCJidWlsZERhdGVTcGFuQXBpIiwiYnVpbGRSYW5nZUFwaSIsImJ1aWxkUmFuZ2VBcGlXaXRoVGltZVpvbmUiLCJvbWl0VGltZSIsInRvRGF0ZSIsInN0YXJ0U3RyIiwiZm9ybWF0SXNvIiwiZW5kU3RyIiwiZmFicmljYXRlRXZlbnRSYW5nZSIsImRhdGVTcGFuIiwidHJpZ2dlckRhdGVTZWxlY3QiLCJzZWxlY3Rpb24iLCJwZXYiLCJidWlsZERhdGVTcGFuQXBpV2l0aENvbnRleHQiLCJvcmlnRXZlbnQiLCJjYWxlbmRhckFwaSIsInRyaWdnZXJEYXRlVW5zZWxlY3QiLCJkYXRlU3BhblRyYW5zZm9ybXMiLCJ0cmFuc2Zvcm0iLCJnZXREZWZhdWx0RXZlbnRFbmQiLCJhcHBseU11dGF0aW9uVG9FdmVudFN0b3JlIiwiZXZlbnRDb25maWdCYXNlIiwibXV0YXRpb24iLCJldmVudENvbmZpZ3MiLCJhcHBseU11dGF0aW9uVG9FdmVudERlZiIsImFwcGx5TXV0YXRpb25Ub0V2ZW50SW5zdGFuY2UiLCJldmVudENvbmZpZyIsInN0YXJ0RGVsdGEiLCJlbmREZWx0YSIsImNvcHkiLCJldmVudERlZk11dGF0aW9uQXBwbGllcnMiLCJhcHBsaWVyIiwiZm9yY2VBbGxEYXkiLCJjbGVhckVuZCIsImRhdGVzRGVsdGEiLCJWaWV3QXBpIiwiZ2V0Q3VycmVudERhdGEiLCJ2aWV3VGl0bGUiLCJkYXRlUHJvZmlsZSIsImFjdGl2ZVJhbmdlIiwiY3VycmVudFJhbmdlIiwiZ2V0T3B0aW9uIiwiRVZFTlRfU09VUkNFX1JFRklORVJTIiwic3VjY2VzcyIsImZhaWx1cmUiLCJwYXJzZUV2ZW50U291cmNlIiwiYnVpbGRFdmVudFNvdXJjZVJlZmluZXJzIiwicmF3T2JqIiwibWV0YVJlcyIsImJ1aWxkRXZlbnRTb3VyY2VNZXRhIiwiX3JhdyIsImlzRmV0Y2hpbmciLCJsYXRlc3RGZXRjaElkIiwiZmV0Y2hSYW5nZSIsInNvdXJjZURlZklkIiwiZXZlbnRTb3VyY2VSZWZpbmVycyIsImV2ZW50U291cmNlRGVmcyIsInBhcnNlTWV0YSIsInJlZHVjZUN1cnJlbnREYXRlIiwiY3VycmVudERhdGUiLCJhY3Rpb24iLCJkYXRlTWFya2VyIiwiZ2V0SW5pdGlhbERhdGUiLCJpbml0aWFsRGF0ZUlucHV0IiwiZ2V0Tm93Iiwibm93SW5wdXQiLCJjcmVhdGVOb3dNYXJrZXIiLCJDYWxlbmRhckFwaSIsImN1cnJlbnREYXRhTWFuYWdlciIsImJhdGNoUmVuZGVyaW5nIiwidXBkYXRlU2l6ZSIsInNldE9wdGlvbiIsIm9wdGlvbk5hbWUiLCJyYXdPcHRpb25WYWx1ZSIsImN1cnJlbnRDYWxlbmRhck9wdGlvbnNJbnB1dCIsImdldEF2YWlsYWJsZUxvY2FsZUNvZGVzIiwiYXZhaWxhYmxlUmF3TG9jYWxlcyIsIm9uIiwiaGFuZGxlck5hbWUiLCJjdXJyZW50Q2FsZW5kYXJPcHRpb25zUmVmaW5lcnMiLCJjb25zb2xlIiwid2FybiIsIm9mZiIsIl9fc3ByZWFkQXJyYXkiLCJjaGFuZ2VWaWV3Iiwidmlld1R5cGUiLCJkYXRlT3JSYW5nZSIsInpvb21UbyIsInN0YXRlIiwic3BlYyIsInZpZXdTcGVjcyIsImdldFVuaXRWaWV3U3BlYyIsInRvb2xiYXJDb25maWciLCJ2aWV3VHlwZXMiLCJoZWFkZXIiLCJ2aWV3c1dpdGhCdXR0b25zIiwiZm9vdGVyIiwic2luZ2xlVW5pdCIsInByZXYiLCJuZXh0IiwicHJldlllYXIiLCJhZGRZZWFycyIsIm5leHRZZWFyIiwidG9kYXkiLCJjYWxlbmRhck9wdGlvbnMiLCJnb3RvRGF0ZSIsInpvbmVkRGF0ZUlucHV0IiwiaW5jcmVtZW50RGF0ZSIsImRlbHRhSW5wdXQiLCJkZWx0YSIsImZvcm1hdERhdGUiLCJzZXR0aW5ncyIsImRhdGVPck9iaiIsImVuZERhdGUiLCJzZWxlY3Rpb25JbnB1dCIsImRhdGVTZWxlY3Rpb24iLCJhZGRFdmVudCIsImV2ZW50SW5wdXQiLCJzb3VyY2VJbnB1dCIsIl9kZWYiLCJfaW5zdGFuY2UiLCJjdXJyZW50RGF0YSIsInRyaWdnZXJFdmVudEFkZCIsInNvdXJjZUFwaSIsImdldEV2ZW50U291cmNlQnlJZCIsIm5ld0V2ZW50QXBpIiwiZXZlbnRBcGkiLCJyZWxhdGVkRXZlbnRzIiwicmV2ZXJ0IiwiZXZlbnRBcGlUb1N0b3JlIiwiZ2V0RXZlbnRCeUlkIiwiZ2V0RXZlbnRzIiwiYnVpbGRFdmVudEFwaXMiLCJyZW1vdmVBbGxFdmVudHMiLCJnZXRFdmVudFNvdXJjZXMiLCJzb3VyY2VIYXNoIiwic291cmNlQXBpcyIsImludGVybmFsSWQiLCJhZGRFdmVudFNvdXJjZSIsInNvdXJjZXMiLCJyZW1vdmVBbGxFdmVudFNvdXJjZXMiLCJyZWZldGNoRXZlbnRzIiwic2Nyb2xsVG9UaW1lIiwidGltZUlucHV0IiwidGltZSIsIl9jb250ZXh0Iiwic2V0UHJvcCIsIm11dGF0ZSIsInNldEV4dGVuZGVkUHJvcCIsInNldFN0YXJ0IiwiaW5zdGFuY2VSYW5nZSIsImdyYW51bGFyaXR5IiwibWFpbnRhaW5EdXJhdGlvbiIsInNldEVuZCIsImVuZElucHV0Iiwic2V0RGF0ZXMiLCJtb3ZlU3RhcnQiLCJtb3ZlRW5kIiwibW92ZURhdGVzIiwic2V0QWxsRGF5IiwiZm9ybWF0SW5wdXQiLCJjb250ZXh0XzEiLCJldmVudFN0b3JlXzEiLCJyZWxldmFudEV2ZW50cyIsIm9sZEV2ZW50IiwiYXNTdG9yZSIsInRvUGxhaW5PYmplY3QiLCJjb2xsYXBzZUNvbG9yIiwiY29sbGFwc2VFeHRlbmRlZFByb3BzIiwidG9KU09OIiwiZXhjbHVkZUluc3RhbmNlIiwiZXZlbnRBcGlzIiwiZXhjbHVkZUluc3RhbmNlSWQiLCJjYWxlbmRhclN5c3RlbUNsYXNzTWFwIiwicmVnaXN0ZXJDYWxlbmRhclN5c3RlbSIsInRoZUNsYXNzIiwiY3JlYXRlQ2FsZW5kYXJTeXN0ZW0iLCJHcmVnb3JpYW5DYWxlbmRhclN5c3RlbSIsImFycmF5VG9NYXJrZXIiLCJhcnIiLCJJU09fUkUiLCJEYXRlRW52IiwiaXNOYW1lZFRpbWVab25lIiwibmFtZWRUaW1lWm9uZUltcGwiLCJjYW5Db21wdXRlT2Zmc2V0Iiwid2Vla0RvdyIsIndlZWtEb3kiLCJ3ZWVrTnVtYmVyRnVuYyIsInRpbWVzdGFtcFRvTWFya2VyIiwiZ2V0WWVhciIsImFkZE1vbnRocyIsImdyZWF0ZXN0V2hvbGVVbml0IiwiY291bnREdXJhdGlvbnNCZXR3ZWVuIiwiZGlmZiIsInN0YXJ0T2YiLCJzdGFydE9mWWVhciIsInN0YXJ0T2ZNb250aCIsInN0YXJ0T2ZXZWVrIiwiZGF0ZU9wdGlvbnMiLCJvZmZzZXRGb3JNYXJrZXIiLCJpc0VuZEV4Y2x1c2l2ZSIsImV4dHJhT3B0aW9ucyIsIm9taXRUaW1lWm9uZU9mZnNldCIsInRpbWVzdGFtcFRvQXJyYXkiLCJnZXRUaW1lem9uZU9mZnNldCIsIm9mZnNldEZvckFycmF5IiwiZ2xvYmFsTG9jYWxlcyIsIk1JTklNQUxfUkFXX0VOX0xPQ0FMRSIsImNvZGUiLCJsaXN0IiwiUkFXX0VOX0xPQ0FMRSIsImV2ZW50Q250Iiwib3JnYW5pemVSYXdMb2NhbGVzIiwiZXhwbGljaXRSYXdMb2NhbGVzIiwiZGVmYXVsdENvZGUiLCJhbGxSYXdMb2NhbGVzIiwicmF3TG9jYWxlTWFwIiwiZW4iLCJhbGxSYXdMb2NhbGVzXzEiLCJyYXdMb2NhbGUiLCJidWlsZExvY2FsZSIsImlucHV0U2luZ3VsYXIiLCJhdmFpbGFibGUiLCJwYXJzZUxvY2FsZSIsInF1ZXJ5TG9jYWxlIiwiY29kZUFyZyIsInF1ZXJ5UmF3TG9jYWxlIiwic2ltcGxlSWQiLCJzbGljZSIsIm1lcmdlZCIsIk51bWJlckZvcm1hdCIsImRhdGVJbnB1dCIsImJ1aWxkRGF0ZUVudiQxIiwiZGF0ZU1ldGEiLCJERUZfREVGQVVMVFMiLCJzdGFydFRpbWUiLCJlbmRUaW1lIiwiZGF5c09mV2VlayIsInBhcnNlQnVzaW5lc3NIb3VycyIsInJlZmluZUlucHV0cyIsInJhd0RlZnMiLCJmaWx0ZXIiLCJyYXdEZWYiLCJwb2ludEluc2lkZVJlY3QiLCJwb2ludCIsInJlY3QiLCJsZWZ0IiwicmlnaHQiLCJ0b3AiLCJib3R0b20iLCJpbnRlcnNlY3RSZWN0cyIsInJlY3QxIiwicmVjdDIiLCJ0cmFuc2xhdGVSZWN0IiwiZGVsdGFYIiwiZGVsdGFZIiwiY29uc3RyYWluUG9pbnQiLCJnZXRSZWN0Q2VudGVyIiwiZGlmZlBvaW50cyIsInBvaW50MSIsInBvaW50MiIsImNhblZHcm93V2l0aGluQ2VsbCIsImdldENhblZHcm93V2l0aGluQ2VsbCIsImNvbXB1dGVDYW5WR3Jvd1dpdGhpbkNlbGwiLCJjcmVhdGVFbGVtZW50IiwicG9zaXRpb24iLCJpbm5lckhUTUwiLCJhcHBlbmRDaGlsZCIsImRpdiIsInBvc3NpYmxlIiwib2Zmc2V0SGVpZ2h0IiwiRU1QVFlfRVZFTlRfU1RPUkUiLCJTcGxpdHRlciIsImdldEtleXNGb3JFdmVudERlZnMiLCJfZ2V0S2V5c0ZvckV2ZW50RGVmcyIsInNwbGl0RGF0ZVNlbGVjdGlvbiIsIl9zcGxpdERhdGVTcGFuIiwic3BsaXRFdmVudFN0b3JlIiwiX3NwbGl0RXZlbnRTdG9yZSIsInNwbGl0SW5kaXZpZHVhbFVpIiwiX3NwbGl0SW5kaXZpZHVhbFVpIiwic3BsaXRFdmVudERyYWciLCJfc3BsaXRJbnRlcmFjdGlvbiIsInNwbGl0RXZlbnRSZXNpemUiLCJldmVudFVpQnVpbGRlcnMiLCJzcGxpdFByb3BzIiwia2V5SW5mb3MiLCJnZXRLZXlJbmZvIiwiZGVmS2V5cyIsImRhdGVTZWxlY3Rpb25zIiwiaW5kaXZpZHVhbFVpIiwiZXZlbnRTdG9yZXMiLCJldmVudERyYWdzIiwiZXZlbnREcmFnIiwiZXZlbnRSZXNpemVzIiwiZXZlbnRSZXNpemUiLCJpbmZvIiwiYnVpbGRFdmVudFVpRm9yS2V5Iiwia2V5SW5mbyIsImJ1aWxkRXZlbnRVaSIsImV2ZW50U2VsZWN0aW9uIiwiZGF0ZVNwYW5zIiwiZ2V0S2V5c0ZvckRhdGVTcGFuIiwia2V5c18xIiwiZ2V0S2V5c0ZvckV2ZW50RGVmIiwic3BsaXRTdG9yZXMiLCJfYyIsInNwbGl0SGFzaGVzIiwiaW50ZXJhY3Rpb24iLCJzcGxpdFN0YXRlcyIsImFmZmVjdGVkU3RvcmVzXzEiLCJhZmZlY3RlZEV2ZW50cyIsIm11dGF0ZWRLZXlzQnlEZWZJZCIsIm11dGF0ZWRFdmVudHMiLCJtdXRhdGVkU3RvcmVzXzEiLCJwb3B1bGF0ZSIsImlzRXZlbnQiLCJhbGxVaSIsImV2ZW50VWlGb3JLZXkiLCJiYXNlUGFydHMiLCJzdHVmZiIsImdldERhdGVNZXRhIiwiaXNEaXNhYmxlZCIsImlzT3RoZXIiLCJnZXREYXlDbGFzc05hbWVzIiwidGhlbWUiLCJnZXRDbGFzcyIsImdldFNsb3RDbGFzc05hbWVzIiwiREFZX0ZPUk1BVCIsIldFRUtfRk9STUFUIiwiYnVpbGROYXZMaW5rQXR0cnMiLCJpc1RhYmJhYmxlIiwiZGF0ZVN0ciIsInpvbmVkRGF0ZSIsImhhbmRsZUludGVyYWN0aW9uIiwiY3VzdG9tQWN0aW9uIiwiX2lzUnRsU2Nyb2xsYmFyT25MZWZ0IiwiZ2V0SXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJjb21wdXRlSXNSdGxTY3JvbGxiYXJPbkxlZnQiLCJvdXRlckVsIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiaW5uZXJFbCIsImZpcnN0Q2hpbGQiLCJfc2Nyb2xsYmFyV2lkdGhzIiwiZ2V0U2Nyb2xsYmFyV2lkdGhzIiwiY29tcHV0ZVNjcm9sbGJhcldpZHRocyIsImNvbXB1dGVTY3JvbGxiYXJXaWR0aHNGb3JFbCIsIngiLCJjbGllbnRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsImNsaWVudFdpZHRoIiwiY29tcHV0ZUVkZ2VzIiwiZ2V0UGFkZGluZyIsImNvbXB1dGVkU3R5bGUiLCJ3aW5kb3ciLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclRvcCIsImJvcmRlclRvcFdpZHRoIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJiYWRTY3JvbGxiYXJXaWR0aHMiLCJzY3JvbGxiYXJMZWZ0UmlnaHQiLCJzY3JvbGxiYXJCb3R0b20iLCJzY3JvbGxiYXJMZWZ0Iiwic2Nyb2xsYmFyUmlnaHQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdUb3AiLCJwYWRkaW5nQm90dG9tIiwiY29tcHV0ZUlubmVyUmVjdCIsImdvV2l0aGluUGFkZGluZyIsImRvRnJvbVdpbmRvd1ZpZXdwb3J0Iiwib3V0ZXJSZWN0IiwiY29tcHV0ZVJlY3QiLCJlZGdlcyIsInBhZ2VYT2Zmc2V0IiwicGFnZVlPZmZzZXQiLCJjb21wdXRlQ2xpcHBlZENsaWVudFJlY3QiLCJjbGlwcGluZ1BhcmVudHMiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjbGlwcGluZ1BhcmVudHNfMSIsImNsaXBwaW5nUGFyZW50IiwiaW50ZXJzZWN0aW9uIiwiY29tcHV0ZUhlaWdodEFuZE1hcmdpbnMiLCJjb21wdXRlVk1hcmdpbnMiLCJjb21wdXRlZCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIm92ZXJmbG93WSIsIm92ZXJmbG93WCIsInVucHJvbWlzaWZ5IiwiaXNSZXNvbHZlZCIsIndyYXBwZWRTdWNjZXNzIiwid3JhcHBlZEZhaWx1cmUiLCJ0aGVuIiwiRW1pdHRlciIsImhhbmRsZXJzIiwidGhpc0NvbnRleHQiLCJzZXRUaGlzQ29udGV4dCIsInNldE9wdGlvbnMiLCJhZGRUb0hhc2giLCJyZW1vdmVGcm9tSGFzaCIsImF0dGFjaGVkSGFuZGxlcnMiLCJvcHRpb25IYW5kbGVyIiwiaGFuZGxlcnNfMSIsIlBvc2l0aW9uQ2FjaGUiLCJvcmlnaW5FbCIsImVscyIsImlzSG9yaXpvbnRhbCIsImlzVmVydGljYWwiLCJvcmlnaW5DbGllbnRSZWN0IiwiYnVpbGRFbEhvcml6b250YWxzIiwiYnVpbGRFbFZlcnRpY2FscyIsIm9yaWdpbkNsaWVudExlZnQiLCJsZWZ0cyIsInJpZ2h0cyIsIm9yaWdpbkNsaWVudFRvcCIsInRvcHMiLCJib3R0b21zIiwibGVmdFRvSW5kZXgiLCJsZWZ0UG9zaXRpb24iLCJ0b3BUb0luZGV4IiwidG9wUG9zaXRpb24iLCJnZXRXaWR0aCIsImxlZnRJbmRleCIsImdldEhlaWdodCIsInRvcEluZGV4IiwiU2Nyb2xsQ29udHJvbGxlciIsImdldE1heFNjcm9sbFRvcCIsImdldFNjcm9sbEhlaWdodCIsImdldENsaWVudEhlaWdodCIsImdldE1heFNjcm9sbExlZnQiLCJnZXRTY3JvbGxXaWR0aCIsImdldENsaWVudFdpZHRoIiwiY2FuU2Nyb2xsVmVydGljYWxseSIsImNhblNjcm9sbEhvcml6b250YWxseSIsImNhblNjcm9sbFVwIiwiZ2V0U2Nyb2xsVG9wIiwiY2FuU2Nyb2xsRG93biIsImNhblNjcm9sbExlZnQiLCJnZXRTY3JvbGxMZWZ0IiwiY2FuU2Nyb2xsUmlnaHQiLCJFbGVtZW50U2Nyb2xsQ29udHJvbGxlciIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsInNjcm9sbFRvcCIsInNjcm9sbExlZnQiLCJzZXRTY3JvbGxUb3AiLCJzZXRTY3JvbGxMZWZ0Iiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJXaW5kb3dTY3JvbGxDb250cm9sbGVyIiwic2Nyb2xsIiwiVGhlbWUiLCJpY29uT3ZlcnJpZGVPcHRpb24iLCJzZXRJY29uT3ZlcnJpZGUiLCJpY29uT3ZlcnJpZGVIYXNoIiwiaWNvbkNsYXNzZXNDb3B5IiwiYnV0dG9uTmFtZSIsImljb25DbGFzc2VzIiwiYXBwbHlJY29uT3ZlcnJpZGVQcmVmaXgiLCJwcmVmaXgiLCJpY29uT3ZlcnJpZGVQcmVmaXgiLCJjbGFzc2VzIiwiZ2V0SWNvbkNsYXNzIiwiaXNSdGwiLCJydGxJY29uQ2xhc3NlcyIsImJhc2VJY29uQ2xhc3MiLCJnZXRDdXN0b21CdXR0b25JY29uQ2xhc3MiLCJjdXN0b21CdXR0b25Qcm9wcyIsImljb25PdmVycmlkZUN1c3RvbUJ1dHRvbk9wdGlvbiIsIlNjcm9sbFJlc3BvbmRlciIsImV4ZWNGdW5jIiwiaGFuZGxlU2Nyb2xsUmVxdWVzdCIsInJlcXVlc3QiLCJxdWV1ZWRSZXF1ZXN0IiwiZHJhaW4iLCJmaXJlSW5pdGlhbFNjcm9sbCIsImRldGFjaCIsInVwZGF0ZSIsImlzRGF0ZXNOZXciLCJWaWV3Q29udGV4dFR5cGUiLCJjcmVhdGVDb250ZXh0IiwiYnVpbGRWaWV3Q29udGV4dCIsInZpZXdTcGVjIiwidmlld09wdGlvbnMiLCJkYXRlUHJvZmlsZUdlbmVyYXRvciIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJ1bnJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJhZGRSZXNpemVIYW5kbGVyIiwicmVtb3ZlUmVzaXplSGFuZGxlciIsImNyZWF0ZVNjcm9sbFJlc3BvbmRlciIsIlB1cmVDb21wb25lbnQiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJuZXh0UHJvcHMiLCJuZXh0U3RhdGUiLCJkZWJ1ZyIsImxvZyIsInByb3BFcXVhbGl0eSIsInN0YXRlRXF1YWxpdHkiLCJzYWZlU2V0U3RhdGUiLCJuZXdTdGF0ZSIsInNldFN0YXRlIiwiYWRkUHJvcHNFcXVhbGl0eSIsImFkZFN0YXRlRXF1YWxpdHkiLCJjb250ZXh0VHlwZSIsIkNvbXBvbmVudCIsIkJhc2VDb21wb25lbnQiLCJjcmVhdGUiLCJzZXRSZWYiLCJyZWYiLCJjdXJyZW50IiwiRGF0ZUNvbXBvbmVudCIsInVpZCIsInByZXBhcmVIaXRzIiwicXVlcnlIaXQiLCJwb3NpdGlvbkxlZnQiLCJwb3NpdGlvblRvcCIsImVsV2lkdGgiLCJlbEhlaWdodCIsImlzVmFsaWRTZWdEb3duRWwiLCJpc1ZhbGlkRGF0ZURvd25FbCIsImNyZWF0ZVBsdWdpbiIsImRlcHMiLCJyZWR1Y2VycyIsImlzTG9hZGluZ0Z1bmNzIiwiY29udGV4dEluaXQiLCJldmVudERyYWdNdXRhdGlvbk1hc3NhZ2VycyIsImRhdGVTZWxlY3Rpb25UcmFuc2Zvcm1lcnMiLCJkYXRlUG9pbnRUcmFuc2Zvcm1zIiwidmlld1Byb3BzVHJhbnNmb3JtZXJzIiwiaXNQcm9wc1ZhbGlkIiwiZXh0ZXJuYWxEZWZUcmFuc2Zvcm1zIiwidmlld0NvbnRhaW5lckFwcGVuZHMiLCJldmVudERyb3BUcmFuc2Zvcm1lcnMiLCJjb21wb25lbnRJbnRlcmFjdGlvbnMiLCJjYWxlbmRhckludGVyYWN0aW9ucyIsInRoZW1lQ2xhc3NlcyIsIm5hbWVkVGltZVpvbmVkSW1wbCIsImVsZW1lbnREcmFnZ2luZ0ltcGwiLCJvcHRpb25DaGFuZ2VIYW5kbGVycyIsInNjcm9sbEdyaWRJbXBsIiwiY29udGVudFR5cGVIYW5kbGVycyIsImxpc3RlbmVyUmVmaW5lcnMiLCJvcHRpb25SZWZpbmVycyIsInByb3BTZXRIYW5kbGVycyIsImJ1aWxkUGx1Z2luSG9va3MiLCJwbHVnaW5EZWZzIiwiZ2xvYmFsRGVmcyIsImlzQWRkZWQiLCJob29rcyIsImFkZERlZnMiLCJkZWZzXzEiLCJjb21iaW5lSG9va3MiLCJidWlsZEJ1aWxkUGx1Z2luSG9va3MiLCJjdXJyZW50T3ZlcnJpZGVEZWZzIiwiY3VycmVudEdsb2JhbERlZnMiLCJjdXJyZW50SG9va3MiLCJvdmVycmlkZURlZnMiLCJob29rczAiLCJob29rczEiLCJTdGFuZGFyZFRoZW1lIiwicm9vdCIsInRhYmxlQ2VsbFNoYWRlZCIsImJ1dHRvbkdyb3VwIiwiYnV0dG9uIiwiYnV0dG9uQWN0aXZlIiwiY2xvc2UiLCJjb21waWxlVmlld0RlZnMiLCJkZWZhdWx0Q29uZmlncyIsIm92ZXJyaWRlQ29uZmlncyIsImVuc3VyZVZpZXdEZWYiLCJ2aWV3RGVmIiwiYnVpbGRWaWV3RGVmIiwiZGVmYXVsdENvbmZpZyIsIm92ZXJyaWRlQ29uZmlnIiwicXVlcnlQcm9wIiwidGhlQ29tcG9uZW50Iiwic3VwZXJUeXBlIiwic3VwZXJEZWYiLCJkZWZhdWx0cyIsInJhd09wdGlvbnMiLCJvdmVycmlkZXMiLCJSZW5kZXJIb29rIiwicm9vdEVsUmVmIiwiY3JlYXRlUmVmIiwiaGFuZGxlUm9vdEVsIiwiZWxSZWYiLCJyZW5kZXIiLCJob29rUHJvcHMiLCJNb3VudEhvb2siLCJDb250ZW50SG9vayIsImRlZmF1bHRDb250ZW50IiwiYmFja3VwRWxSZWYiLCJpbm5lckVsUmVmIiwiaW5uZXJDb250ZW50Iiwibm9ybWFsaXplQ2xhc3NOYW1lcyIsIkN1c3RvbUNvbnRlbnRSZW5kZXJDb250ZXh0IiwiQ29uc3VtZXIiLCJyZW5kZXJJZCIsIkNvbnRlbnRIb29rSW5uZXIiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZUN1c3RvbUNvbnRlbnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsImN1c3RvbUNvbnRlbnRJbmZvIiwiZGVzdHJveSIsImdldElubmVyQ29udGVudCIsImdldENvbnRlbnRNZXRhIiwiY29udGVudEtleSIsImNvbnRlbnRWYWwiLCJidWlsZExpZmVjeWNsZUZ1bmNzIiwibm9ybWFsaXplQ29udGVudCIsInNlYXJjaEtleSIsInJvb3RFbCIsImJ1aWxkQ2xhc3NOYW1lTm9ybWFsaXplciIsImN1cnJlbnRHZW5lcmF0b3IiLCJjdXJyZW50SG9va1Byb3BzIiwiY3VycmVudENsYXNzTmFtZXMiLCJnZW5lcmF0b3IiLCJWaWV3Um9vdCIsImN1c3RvbUNsYXNzTmFtZXMiLCJwYXJzZVZpZXdDb25maWdzIiwiaW5wdXRzIiwicGFyc2VWaWV3Q29uZmlnIiwiY3JlYXRlVmlld0hvb2tDb21wb25lbnQiLCJ2aWV3UHJvcHMiLCJ2aWV3RWxSZWYiLCJidWlsZFZpZXdTcGVjcyIsImRlZmF1bHRJbnB1dHMiLCJvcHRpb25PdmVycmlkZXMiLCJkeW5hbWljT3B0aW9uT3ZlcnJpZGVzIiwibG9jYWxlRGVmYXVsdHMiLCJ2aWV3RGVmcyIsImJ1aWxkVmlld1NwZWMiLCJkdXJhdGlvbklucHV0IiwiZHVyYXRpb25Vbml0Iiwic2luZ2xlVW5pdE92ZXJyaWRlcyIsImNyZWF0ZUR1cmF0aW9uQ2FjaGVkIiwiZGVub20iLCJxdWVyeUJ1dHRvblRleHQiLCJvcHRpb25zU3Vic2V0IiwiYnV0dG9uVGV4dE1hcCIsInF1ZXJ5QnV0dG9uVGl0bGUiLCJidXR0b25LZXkiLCJvcHRpb25EZWZhdWx0cyIsImJ1dHRvblRleHRPdmVycmlkZSIsImJ1dHRvblRleHREZWZhdWx0IiwiYnV0dG9uVGl0bGVPdmVycmlkZSIsImJ1dHRvbkhpbnQiLCJidXR0b25UaXRsZURlZmF1bHQiLCJkdXJhdGlvbklucHV0TWFwIiwianNvbiIsIkpTT04iLCJzdHJpbmdpZnkiLCJEYXRlUHJvZmlsZUdlbmVyYXRvciIsImluaXRIaWRkZW5EYXlzIiwiYnVpbGRQcmV2IiwiY3VycmVudERhdGVQcm9maWxlIiwiZm9yY2VUb1ZhbGlkIiwicHJldkRhdGUiLCJjdXJyZW50UmFuZ2VVbml0IiwiYnVpbGQiLCJidWlsZE5leHQiLCJuZXh0RGF0ZSIsImN1cnJlbnRJbmZvIiwiaXNSYW5nZUFsbERheSIsInJlbmRlclJhbmdlIiwiaXNWYWxpZCIsImJ1aWxkVmFsaWRSYW5nZSIsInRyaW1IaWRkZW5EYXlzIiwiYnVpbGRDdXJyZW50UmFuZ2VJbmZvIiwiYnVpbGRSZW5kZXJSYW5nZSIsImFkanVzdEFjdGl2ZVJhbmdlIiwiYnVpbGREYXRlSW5jcmVtZW50IiwidmFsaWRSYW5nZUlucHV0Iiwic2ltcGxlSW5wdXQiLCJyZWZpbmVSYW5nZSIsImJ1aWxkUmFuZ2VGcm9tRHVyYXRpb24iLCJidWlsZFJhbmdlRnJvbURheUNvdW50IiwiYnVpbGRDdXN0b21WaXNpYmxlUmFuZ2UiLCJnZXRGYWxsYmFja0R1cmF0aW9uIiwiaXNIaWRkZW5EYXkiLCJza2lwSGlkZGVuRGF5cyIsImNvbXB1dGVSZXMiLCJydW5uaW5nQ291bnQiLCJ2aXNpYmxlUmFuZ2VJbnB1dCIsImZhbGxiYWNrIiwiY3VzdG9tQWxpZ25tZW50IiwicmFuZ2VJbnB1dCIsImlzSGlkZGVuRGF5SGFzaCIsImluYyIsImlzRXhjbHVzaXZlIiwicmVkdWNlVmlld1R5cGUiLCJyZWR1Y2VEeW5hbWljT3B0aW9uT3ZlcnJpZGVzIiwicmVkdWNlRGF0ZVByb2ZpbGUiLCJkcCIsImluaXRFdmVudFNvdXJjZXMiLCJhZGRTb3VyY2VzIiwicGFyc2VJbml0aWFsU291cmNlcyIsInJlZHVjZUV2ZW50U291cmNlcyIsInJlbW92ZVNvdXJjZSIsImZldGNoRGlydHlTb3VyY2VzIiwiZmV0Y2hTb3VyY2VzQnlJZHMiLCJleGNsdWRlU3RhdGljU291cmNlcyIsInJlY2VpdmVSZXNwb25zZSIsImZldGNoSWQiLCJyZWR1Y2VFdmVudFNvdXJjZXNOZXdUaW1lWm9uZSIsImNvbXB1dGVFdmVudFNvdXJjZXNMb2FkaW5nIiwiZXZlbnRTb3VyY2VIYXNoIiwic291cmNlc18xIiwic291cmNlIiwiaXNTb3VyY2VEaXJ0eSIsImRvZXNTb3VyY2VOZWVkUmFuZ2UiLCJwcmV2U291cmNlcyIsInNvdXJjZUlkSGFzaCIsIm5leHRTb3VyY2VzIiwiZmV0Y2hTb3VyY2UiLCJzb3VyY2VEZWYiLCJmZXRjaCIsInhociIsImVycm9yIiwibWVzc2FnZSIsInJhd1NvdXJjZXMiLCJyYXdTb3VyY2VzXzEiLCJyYXdTb3VyY2UiLCJpZ25vcmVSYW5nZSIsInJlZHVjZUV2ZW50U3RvcmUiLCJyZWNlaXZlUmF3RXZlbnRzIiwiZXhjbHVkZUV2ZW50c0J5U291cmNlSWQiLCJzdWJzZXQiLCJ0cmFuc2Zvcm1SYXdFdmVudHMiLCJjYWxFYWNoVHJhbnNmb3JtIiwic291cmNlRWFjaFRyYW5zZm9ybSIsInRyYW5zZm9ybUVhY2hSYXdFdmVudCIsInJlZmluZWRFdmVudHMiLCJyZWZpbmVkRXZlbnQiLCJleHBhbmRSYW5nZSIsInJlem9uZUV2ZW50U3RvcmVEYXRlcyIsIm9sZERhdGVFbnYiLCJuZXdEYXRlRW52IiwiZXhjbHVkZUluc3RhbmNlcyIsInJlbW92YWxzIiwicmVkdWNlRGF0ZVNlbGVjdGlvbiIsImN1cnJlbnRTZWxlY3Rpb24iLCJyZWR1Y2VTZWxlY3RlZEV2ZW50IiwiY3VycmVudEluc3RhbmNlSWQiLCJldmVudEluc3RhbmNlSWQiLCJyZWR1Y2VFdmVudERyYWciLCJjdXJyZW50RHJhZyIsIm5ld0RyYWciLCJyZWR1Y2VFdmVudFJlc2l6ZSIsImN1cnJlbnRSZXNpemUiLCJuZXdSZXNpemUiLCJwYXJzZVRvb2xiYXJzIiwiY2FsZW5kYXJPcHRpb25PdmVycmlkZXMiLCJwYXJzZVRvb2xiYXIiLCJzZWN0aW9uU3RySGFzaCIsInNlY3Rpb25XaWRnZXRzIiwiaGFzVGl0bGUiLCJzZWN0aW9uTmFtZSIsInNlY3Rpb25TdHIiLCJzZWN0aW9uUmVzIiwicGFyc2VTZWN0aW9uIiwid2lkZ2V0cyIsImNhbGVuZGFyQ3VzdG9tQnV0dG9ucyIsImNhbGVuZGFyQnV0dG9uVGV4dE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uVGV4dCIsImNhbGVuZGFyQnV0dG9uSGludE92ZXJyaWRlcyIsImNhbGVuZGFyQnV0dG9uSGludHMiLCJzZWN0aW9uU3Vic3RycyIsImJ1dHRvbkdyb3VwU3RyIiwiYnV0dG9uQ2xpY2siLCJidXR0b25JY29uIiwiY2xpY2siLCJ0ZXh0IiwiaGludCIsInRleHRGYWxsYmFjayIsInByZXZPck5leHQiLCJuYXZVbml0IiwiZXZlbnRTb3VyY2VEZWYkMiIsImFycmF5RXZlbnRTb3VyY2VQbHVnaW4iLCJldmVudFNvdXJjZURlZiQxIiwiYmluZCIsImZ1bmNFdmVudFNvdXJjZVBsdWdpbiIsInJlcXVlc3RKc29uIiwicGFyYW1zIiwic3VjY2Vzc0NhbGxiYWNrIiwiZmFpbHVyZUNhbGxiYWNrIiwidG9VcHBlckNhc2UiLCJpbmplY3RRdWVyeVN0cmluZ1BhcmFtcyIsImVuY29kZVBhcmFtcyIsIlhNTEh0dHBSZXF1ZXN0Iiwib3BlbiIsInNldFJlcXVlc3RIZWFkZXIiLCJvbmxvYWQiLCJzdGF0dXMiLCJyZXNwb25zZVRleHQiLCJlcnIiLCJvbmVycm9yIiwic2VuZCIsImVuY29kZVVSSUNvbXBvbmVudCIsIkpTT05fRkVFRF9FVkVOVF9TT1VSQ0VfUkVGSU5FUlMiLCJleHRyYVBhcmFtcyIsImV2ZW50U291cmNlRGVmIiwicmVxdWVzdFBhcmFtcyIsImJ1aWxkUmVxdWVzdFBhcmFtcyIsImVycm9yTWVzc2FnZSIsImpzb25GZWVkRXZlbnRTb3VyY2VQbHVnaW4iLCJjdXN0b21SZXF1ZXN0UGFyYW1zIiwiU0lNUExFX1JFQ1VSUklOR19SRUZJTkVSUyIsInN0YXJ0UmVjdXIiLCJlbmRSZWN1ciIsInJlY3VycmluZyIsInJlY3VycmluZ0RhdGEiLCJjbGlwcGVkRnJhbWluZ1JhbmdlIiwiZXhwYW5kUmFuZ2VzIiwic2ltcGxlUmVjdXJyaW5nRXZlbnRzUGx1Z2luIiwiZG93SGFzaCIsImRheU1hcmtlciIsImluc3RhbmNlU3RhcnRzIiwiaW5zdGFuY2VTdGFydCIsImNoYW5nZUhhbmRsZXJQbHVnaW4iLCJoYW5kbGVFdmVudFNvdXJjZXMiLCJ1bmZvdW5kU291cmNlcyIsIm5ld0lucHV0cyIsImlucHV0c18xIiwiaW5wdXRGb3VuZCIsInVuZm91bmRTb3VyY2VzXzEiLCJ1bmZvdW5kU291cmNlIiwibmV3SW5wdXRzXzEiLCJuZXdJbnB1dCIsImhhbmRsZURhdGVQcm9maWxlIiwiaGFuZGxlRXZlbnRTdG9yZSIsImdsb2JhbFBsdWdpbnMiLCJodG1sIiwiYnVpbGRIdG1sUmVuZGVyZXIiLCJkb21Ob2RlcyIsImJ1aWxkRG9tTm9kZVJlbmRlcmVyIiwiY3VycmVudEVsIiwiY3VycmVudEh0bWwiLCJjdXJyZW50RG9tTm9kZXMiLCJuZXdEb21Ob2RlcyIsIm5ld0RvbU5vZGVzXzEiLCJuZXdOb2RlIiwiRGVsYXllZFJ1bm5lciIsImRyYWluZWRPcHRpb24iLCJpc1J1bm5pbmciLCJpc0RpcnR5IiwicGF1c2VEZXB0aHMiLCJ0aW1lb3V0SWQiLCJkZWxheSIsImlzUGF1c2VkIiwiY2xlYXJUaW1lb3V0IiwidHJ5RHJhaW4iLCJzZXRUaW1lb3V0IiwicGF1c2UiLCJzY29wZSIsInJlc3VtZSIsImZvcmNlIiwiZGVwdGgiLCJkcmFpbmVkIiwiY2xlYXIiLCJUYXNrUnVubmVyIiwicnVuVGFza09wdGlvbiIsInF1ZXVlIiwiZGVsYXllZFJ1bm5lciIsInRhc2siLCJjb21wbGV0ZWRUYXNrcyIsInNoaWZ0IiwicnVuVGFzayIsImJ1aWxkVGl0bGUiLCJidWlsZFRpdGxlRm9ybWF0IiwiQ2FsZW5kYXJEYXRhTWFuYWdlciIsImNvbXB1dGVPcHRpb25zRGF0YSIsIl9jb21wdXRlT3B0aW9uc0RhdGEiLCJjb21wdXRlQ3VycmVudFZpZXdEYXRhIiwiX2NvbXB1dGVDdXJyZW50Vmlld0RhdGEiLCJidWlsZERhdGVFbnYiLCJidWlsZFRoZW1lIiwiYnVpbGREYXRlUHJvZmlsZUdlbmVyYXRvciIsImJ1aWxkVmlld0FwaSIsImJ1aWxkVmlld1VpUHJvcHMiLCJidWlsZEV2ZW50VWlCeVNvdXJjZSIsImJ1aWxkRXZlbnRVaUJhc2VzIiwicGFyc2VDb250ZXh0QnVzaW5lc3NIb3VycyIsImFjdGlvblJ1bm5lciIsIl9oYW5kbGVBY3Rpb24iLCJ1cGRhdGVEYXRhIiwiY3VycmVudENhbGVuZGFyT3B0aW9uc1JlZmluZWQiLCJjdXJyZW50Vmlld09wdGlvbnNJbnB1dCIsImN1cnJlbnRWaWV3T3B0aW9uc1JlZmluZWQiLCJkYXRhIiwib3B0aW9uc0RhdGEiLCJjdXJyZW50Vmlld1R5cGUiLCJjdXJyZW50Vmlld0RhdGEiLCJjYWxlbmRhckNvbnRleHQiLCJpbml0aWFsU3RhdGUiLCJyZW5kZXJhYmxlRXZlbnRTdG9yZSIsInNlbGVjdGlvbkNvbmZpZyIsImNvbnRleHRBbmRTdGF0ZSIsInJlZHVjZXIiLCJjb21wdXRlSXNMb2FkaW5nIiwicmVzZXRPcHRpb25zIiwiYXBwZW5kIiwiaXNFdmVudHNMb2FkaW5nIiwiZXZlbnRVaVNpbmdsZUJhc2UiLCJldmVudFVpQnlTb3VyY2UiLCJ3YXNMb2FkaW5nIiwiaXNMb2FkaW5nIiwib25BY3Rpb24iLCJvbGREYXRhIiwiY2hhbmdlSGFuZGxlcnMiLCJvbGRDYWxlbmRhck9wdGlvbnMiLCJuZXdDYWxlbmRhck9wdGlvbnMiLCJvbkRhdGEiLCJwcm9jZXNzUmF3Q2FsZW5kYXJPcHRpb25zIiwicmVmaW5lZE9wdGlvbnMiLCJhdmFpbGFibGVMb2NhbGVEYXRhIiwid2FyblVua25vd25PcHRpb25zIiwiY3VycmVudFJhdyIsImN1cnJlbnRSZWZpbmVkIiwiYW55Q2hhbmdlcyIsInByb2Nlc3NSYXdWaWV3T3B0aW9ucyIsImV4cGxpY2l0TG9jYWxlIiwiVGhlbWVDbGFzcyIsIkRhdGVQcm9maWxlR2VuZXJhdG9yQ2xhc3MiLCJpc0xvYWRpbmdGdW5jIiwidmlld05hbWUiLCJDYWxlbmRhckRhdGFQcm92aWRlciIsImhhbmRsZURhdGEiLCJkYXRhTWFuYWdlciIsInByZXZQcm9wcyIsIm5ld09wdGlvbk92ZXJyaWRlcyIsInNsaWNlRXZlbnRzIiwiTmFtZWRUaW1lWm9uZUltcGwiLCJTZWdIaWVyYXJjaHkiLCJzdHJpY3RPcmRlciIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJtYXhTdGFja0NudCIsImxldmVsQ29vcmRzIiwiZW50cmllc0J5TGV2ZWwiLCJzdGFja0NudHMiLCJhZGRTZWdzIiwiaGlkZGVuRW50cmllcyIsImluc2VydEVudHJ5IiwiZW50cnkiLCJmaW5kSW5zZXJ0aW9uIiwiaXNJbnNlcnRpb25WYWxpZCIsImluc2VydEVudHJ5QXQiLCJoYW5kbGVJbnZhbGlkSW5zZXJ0aW9uIiwibGV2ZWxDb29yZCIsInRoaWNrbmVzcyIsInN0YWNrQ250IiwidG91Y2hpbmdFbnRyeSIsInNwbGl0RW50cnkiLCJiYXJyaWVyIiwicGFydENudCIsInNwbGl0SGlkZGVuRW50cmllcyIsImVudHJ5U3BhbiIsImJhcnJpZXJTcGFuIiwiaW50ZXJzZWN0U3BhbnMiLCJsYXRlcmFsIiwiaW5zZXJ0QXQiLCJsZXZlbCIsImJ1aWxkRW50cnlLZXkiLCJuZXdFbnRyeSIsImxldmVsQ250IiwiY2FuZGlkYXRlQ29vcmQiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidHJhY2tpbmdMZXZlbCIsInRyYWNraW5nQ29vcmQiLCJ0cmFja2luZ0VudHJpZXMiLCJ0cmFja2luZ0VudHJ5Iiwic2VhcmNoUmVzIiwiYmluYXJ5U2VhcmNoIiwiZ2V0RW50cnlTcGFuRW5kIiwibGF0ZXJhbEluZGV4IiwidHJhY2tpbmdFbnRyeUJvdHRvbSIsImRlc3RMZXZlbCIsImRlc3RMYXRlcmFsIiwidG9SZWN0cyIsInJlY3RzIiwiZW50cmllcyIsImVudHJpZXNfMSIsImdyb3VwSW50ZXJzZWN0aW5nRW50cmllcyIsIm1lcmdlcyIsImVudHJpZXNfMiIsImZpbHRlcmVkTWVyZ2VzIiwiaHVuZ3J5TWVyZ2UiLCJtZXJnZXNfMSIsIm1lcmdlIiwiam9pblNwYW5zIiwic2VhcmNoVmFsIiwiZ2V0SXRlbVZhbCIsIm1pZGRsZUluZGV4IiwibWlkZGxlVmFsIiwiSW50ZXJhY3Rpb24iLCJpc0hpdENvbWJvQWxsb3dlZCIsInBhcnNlSW50ZXJhY3Rpb25TZXR0aW5ncyIsInVzZUV2ZW50Q2VudGVyIiwiaW50ZXJhY3Rpb25TZXR0aW5nc1RvU3RvcmUiLCJpbnRlcmFjdGlvblNldHRpbmdzU3RvcmUiLCJFbGVtZW50RHJhZ2dpbmciLCJzZXRNaXJyb3JJc1Zpc2libGUiLCJib29sIiwic2V0TWlycm9yTmVlZHNSZXZlcnQiLCJzZXRBdXRvU2Nyb2xsRW5hYmxlZCIsImNvbmZpZyIsIkRSQUdfTUVUQV9SRUZJTkVSUyIsInBhcnNlRHJhZ01ldGEiLCJsZWZ0b3ZlclByb3BzIiwiVG9vbGJhclNlY3Rpb24iLCJ3aWRnZXRHcm91cHMiLCJ3aWRnZXRHcm91cCIsInJlbmRlcldpZGdldEdyb3VwIiwiaXNPbmx5QnV0dG9ucyIsIndpZGdldEdyb3VwXzEiLCJ3aWRnZXQiLCJ0aXRsZUlkIiwiaXNQcmVzc2VkIiwiYWN0aXZlQnV0dG9uIiwiaXNUb2RheUVuYWJsZWQiLCJpc1ByZXZFbmFibGVkIiwiaXNOZXh0RW5hYmxlZCIsImJ1dHRvbkNsYXNzZXMiLCJkaXNhYmxlZCIsImdyb3VwQ2xhc3NOYW1lIiwiVG9vbGJhciIsIm1vZGVsIiwiZXh0cmFDbGFzc05hbWUiLCJmb3JjZUx0ciIsInN0YXJ0Q29udGVudCIsImVuZENvbnRlbnQiLCJjZW50ZXJDb250ZW50IiwicmVuZGVyU2VjdGlvbiIsIlZpZXdDb250YWluZXIiLCJhdmFpbGFibGVXaWR0aCIsImhhbmRsZUVsIiwidXBkYXRlQXZhaWxhYmxlV2lkdGgiLCJoYW5kbGVSZXNpemUiLCJsaXF1aWQiLCJsYWJlbGVkQnlJZCIsIkV2ZW50Q2xpY2tpbmciLCJoYW5kbGVTZWdDbGljayIsInNlZ0VsIiwiaGFzVXJsQ29udGFpbmVyIiwiZGVmYXVsdFByZXZlbnRlZCIsImxvY2F0aW9uIiwiRXZlbnRIb3ZlcmluZyIsImhhbmRsZUV2ZW50RWxSZW1vdmUiLCJjdXJyZW50U2VnRWwiLCJoYW5kbGVTZWdMZWF2ZSIsImhhbmRsZVNlZ0VudGVyIiwidHJpZ2dlckV2ZW50IiwicmVtb3ZlSG92ZXJMaXN0ZW5lcnMiLCJwdWJsaWNFdk5hbWUiLCJDYWxlbmRhckNvbnRlbnQiLCJidWlsZFZpZXdQcm9wVHJhbnNmb3JtZXJzIiwiYnVpbGRUb29sYmFyUHJvcHMiLCJoZWFkZXJSZWYiLCJmb290ZXJSZWYiLCJpbnRlcmFjdGlvbnNTdG9yZSIsInZpZXdMYWJlbElkIiwic2V0dGluZ3NJbnB1dCIsIkRFRkFVTFRfSU5URVJBQ1RJT05TIiwiaW50ZXJhY3Rpb25DbGFzc2VzIiwiaW50ZXJhY3Rpb25zIiwiVGhlSW50ZXJhY3Rpb25DbGFzcyIsImxpc3RlbmVycyIsImxpc3RlbmVyc18xIiwibGlzdGVuZXIiLCJyZXNpemVSdW5uZXIiLCJ0b29sYmFyUHJvcHMiLCJ2aWV3Vkdyb3ciLCJ2aWV3QXNwZWN0UmF0aW8iLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsInZpZXdDb250ZXh0IiwiUHJvdmlkZXIiLCJyZW5kZXJWaWV3IiwiYnVpbGRBcHBlbmRDb250ZW50IiwiQ2FsZW5kYXJJbnRlcmFjdGlvbkNsYXNzIiwiRnJhZ21lbnQiLCJWaWV3Q29tcG9uZW50IiwidG9kYXlJbmZvIiwicHJldkluZm8iLCJuZXh0SW5mbyIsInRoZUNsYXNzZXMiLCJUaGVDbGFzcyIsIkNhbGVuZGFyUm9vdCIsImhhbmRsZUJlZm9yZVByaW50IiwiaGFuZGxlQWZ0ZXJQcmludCIsImNvbXB1dGVGYWxsYmFja0hlYWRlckZvcm1hdCIsImRhdGVzUmVwRGlzdGluY3REYXlzIiwiQ0xBU1NfTkFNRSIsInJlbmRlcklubmVyJDEiLCJUYWJsZURhdGVDZWxsIiwiZGF5TWV0YSIsIm5hdkxpbmtBdHRycyIsImNvbENudCIsImV4dHJhSG9va1Byb3BzIiwicm9sZSIsImNvbFNwYW4iLCJleHRyYURhdGFBdHRycyIsImlzU3RpY2t5IiwiV0VFS0RBWV9GT1JNQVQiLCJUYWJsZURvd0NlbGwiLCJleHRyYUNsYXNzTmFtZXMiLCJOb3dUaW1lciIsImluaXRpYWxOb3dEYXRlIiwiaW5pdGlhbE5vd1F1ZXJpZWRNcyIsImNvbXB1dGVUaW1pbmciLCJjdXJyZW50U3RhdGUiLCJ1bnJvdW5kZWROb3ciLCJjdXJyZW50VW5pdFN0YXJ0IiwibmV4dFVuaXRTdGFydCIsIndhaXRNcyIsImJ1aWxkRGF5UmFuZ2UiLCJEYXlIZWFkZXIiLCJjcmVhdGVEYXlIZWFkZXJGb3JtYXR0ZXIiLCJkYXRlcyIsInJlbmRlckludHJvIiwiZXhwbGljaXRGb3JtYXQiLCJkYXRlQ250IiwiRGF5U2VyaWVzTW9kZWwiLCJpbmRpY2VzIiwiZGF5SW5kZXgiLCJjbnQiLCJzbGljZVJhbmdlIiwiZmlyc3RJbmRleCIsImdldERhdGVEYXlJbmRleCIsImxhc3RJbmRleCIsImNsaXBwZWRGaXJzdEluZGV4IiwiY2xpcHBlZExhc3RJbmRleCIsImNlaWwiLCJkYXlPZmZzZXQiLCJEYXlUYWJsZU1vZGVsIiwiZGF5U2VyaWVzIiwiYnJlYWtPbldlZWtzIiwiZGF5c1BlclJvdyIsInJvd0NudCIsImNlbGxzIiwiYnVpbGRDZWxscyIsImhlYWRlckRhdGVzIiwiYnVpbGRIZWFkZXJEYXRlcyIsInJvd3MiLCJyb3ciLCJjb2wiLCJidWlsZENlbGwiLCJzZXJpZXNTZWciLCJuZXh0SW5kZXgiLCJmaXJzdENvbCIsImxhc3RDb2wiLCJTbGljZXIiLCJzbGljZUJ1c2luZXNzSG91cnMiLCJfc2xpY2VCdXNpbmVzc0hvdXJzIiwic2xpY2VEYXRlU2VsZWN0aW9uIiwiX3NsaWNlRGF0ZVNwYW4iLCJfc2xpY2VFdmVudFN0b3JlIiwic2xpY2VFdmVudERyYWciLCJfc2xpY2VJbnRlcmFjdGlvbiIsInNsaWNlRXZlbnRSZXNpemUiLCJmb3JjZURheUlmTGlzdEl0ZW0iLCJzbGljZVByb3BzIiwiZXh0cmFBcmdzIiwiZXZlbnRTZWdzIiwiZGF0ZVNlbGVjdGlvblNlZ3MiLCJidXNpbmVzc0hvdXJTZWdzIiwiZmdFdmVudFNlZ3MiLCJiZ0V2ZW50U2VncyIsInNsaWNlTm93RGF0ZSIsImNvbXB1dGVBY3RpdmVSYW5nZSIsInJhbmdlUmVzIiwic2xpY2VFdmVudFJhbmdlcyIsImFmZmVjdGVkSW5zdGFuY2VzIiwic2Vnc18xIiwiZXZlbnRSYW5nZXMiLCJldmVudFJhbmdlc18xIiwic2xpY2VFdmVudFJhbmdlIiwic2Vnc18yIiwiaXNDb21wb25lbnRBbGxEYXkiLCJpc0ludGVyYWN0aW9uVmFsaWQiLCJpc05ld1Byb3BzVmFsaWQiLCJpc0RhdGVTZWxlY3Rpb25WYWxpZCIsImNhbGVuZGFyU3RhdGUiLCJkYXRlU3Bhbk1ldGEiLCJmaWx0ZXJDb25maWciLCJpc0ludGVyYWN0aW9uUHJvcHNWYWxpZCIsImlzRGF0ZVNlbGVjdGlvblByb3BzVmFsaWQiLCJzdWJqZWN0RXZlbnRTdG9yZSIsInN1YmplY3REZWZzIiwic3ViamVjdEluc3RhbmNlcyIsInN1YmplY3RDb25maWdzIiwib3RoZXJFdmVudFN0b3JlIiwib3RoZXJEZWZzIiwib3RoZXJJbnN0YW5jZXMiLCJvdGhlckNvbmZpZ3MiLCJzdWJqZWN0SW5zdGFuY2VJZCIsInN1YmplY3RJbnN0YW5jZSIsInN1YmplY3RSYW5nZSIsInN1YmplY3RDb25maWciLCJzdWJqZWN0RGVmIiwiYWxsQ29uc3RyYWludHNQYXNzIiwiZXZlbnRPdmVybGFwRnVuYyIsIm90aGVySW5zdGFuY2VJZCIsIm90aGVySW5zdGFuY2UiLCJvdGhlck92ZXJsYXAiLCJjYWxlbmRhckV2ZW50U3RvcmUiLCJzdWJqZWN0QWxsb3ciLCJzdWJqZWN0RGF0ZVNwYW4iLCJvcmlnRGVmIiwib3JpZ0luc3RhbmNlIiwicmVsZXZhbnRFdmVudFN0b3JlIiwicmVsZXZhbnREZWZzIiwicmVsZXZhbnRJbnN0YW5jZXMiLCJzZWxlY3Rpb25SYW5nZSIsInNlbGVjdE92ZXJsYXBGdW5jIiwicmVsZXZhbnRJbnN0YW5jZUlkIiwicmVsZXZhbnRJbnN0YW5jZSIsInNlbGVjdGlvbkFsbG93IiwiZnVsbERhdGVTcGFuIiwiYnVzaW5lc3NIb3Vyc1VuZXhwYW5kZWQiLCJjb25zdHJhaW50c18xIiwiYW55UmFuZ2VzQ29udGFpblJhbmdlIiwiY29uc3RyYWludFRvUmFuZ2VzIiwiZXZlbnRTdG9yZVRvUmFuZ2VzIiwib3V0ZXJSYW5nZXMiLCJvdXRlclJhbmdlc18xIiwiVklTSUJMRV9ISURERU5fUkUiLCJTY3JvbGxlciIsImxpcXVpZElzQWJzb2x1dGUiLCJpc0Fic29sdXRlIiwib3ZlcmNvbWVMZWZ0Iiwib3ZlcmNvbWVSaWdodCIsIm92ZXJjb21lQm90dG9tIiwibWFyZ2luTGVmdCIsIm1hcmdpblJpZ2h0IiwibWF4SGVpZ2h0IiwibmVlZHNYU2Nyb2xsaW5nIiwicmVhbENsaWVudFdpZHRoIiwiZ2V0WVNjcm9sbGJhcldpZHRoIiwiY2hpbGRFbCIsIm5lZWRzWVNjcm9sbGluZyIsInJlYWxDbGllbnRIZWlnaHQiLCJnZXRYU2Nyb2xsYmFyV2lkdGgiLCJSZWZNYXAiLCJtYXN0ZXJDYWxsYmFjayIsImN1cnJlbnRNYXAiLCJkZXB0aHMiLCJjYWxsYmFja01hcCIsImhhbmRsZVZhbHVlIiwicmVtb3ZlZCIsImFkZGVkIiwicmVmQ2FsbGJhY2siLCJjb2xsZWN0IiwiZ2V0QWxsIiwiY29tcHV0ZVNocmlua1dpZHRoIiwiY2h1bmtFbHMiLCJzaHJpbmtDZWxscyIsImxhcmdlc3RXaWR0aCIsInNocmlua0NlbGxzXzEiLCJzaHJpbmtDZWxsIiwiZ2V0U2VjdGlvbkhhc0xpcXVpZEhlaWdodCIsInNlY3Rpb25Db25maWciLCJnZXRBbGxvd1lTY3JvbGxpbmciLCJyZW5kZXJDaHVua0NvbnRlbnQiLCJjaHVua0NvbmZpZyIsImlzSGVhZGVyIiwidGFibGVDbGFzc05hbWUiLCJzeW5jUm93SGVpZ2h0cyIsIm1pbldpZHRoIiwidGFibGVNaW5XaWR0aCIsInRhYmxlQ29sR3JvdXBOb2RlIiwicm93Q29udGVudCIsImlzQ29sUHJvcHNFcXVhbCIsImNvbHMwIiwiY29sczEiLCJyZW5kZXJNaWNyb0NvbEdyb3VwIiwiY29scyIsInNocmlua1dpZHRoIiwiY29sTm9kZXMiLCJjb2xzXzEiLCJjb2xQcm9wcyIsInNhbml0aXplU2hyaW5rV2lkdGgiLCJoYXNTaHJpbmtXaWR0aCIsImNvbHNfMiIsImdldFNjcm9sbEdyaWRDbGFzc05hbWVzIiwiZ2V0U2VjdGlvbkNsYXNzTmFtZXMiLCJ3aG9sZVRhYmxlVkdyb3ciLCJyZW5kZXJTY3JvbGxTaGltIiwiZ2V0U3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lGb290ZXJTY3JvbGxiYXIiLCJTaW1wbGVTY3JvbGxHcmlkIiwicHJvY2Vzc0NvbHMiLCJzY3JvbGxlclJlZnMiLCJzY3JvbGxlckVsUmVmcyIsIl9oYW5kbGVTY3JvbGxlckVsIiwiZm9yY2VZU2Nyb2xsYmFycyIsInNjcm9sbGVyQ2xpZW50V2lkdGhzIiwic2Nyb2xsZXJDbGllbnRIZWlnaHRzIiwiaGFuZGxlU2l6aW5nIiwiY29tcHV0ZVNjcm9sbGVyRGltcyIsInNlY3Rpb25Db25maWdzIiwic2VjdGlvbnMiLCJtaWNyb0NvbEdyb3VwTm9kZSIsImNvbGxhcHNpYmxlV2lkdGgiLCJjb25maWdDbnQiLCJjb25maWdJIiwiY3VycmVudENvbmZpZyIsImhlYWRTZWN0aW9uTm9kZXMiLCJib2R5U2VjdGlvbk5vZGVzIiwiZm9vdFNlY3Rpb25Ob2RlcyIsImlzQnVnZ3kiLCJyb2xlQXR0cnMiLCJvdXRlckNvbnRlbnQiLCJyZW5kZXJDaHVua1RkIiwiY2h1bmsiLCJpc0xpcXVpZCIsInNlY3Rpb25LZXkiLCJyb3dTeW5jSGVpZ2h0cyIsInJlcG9ydFJvd0hlaWdodENoYW5nZSIsInNjcm9sbGVyRWwiLCJzZWN0aW9uIiwiZ2V0U2VjdGlvbkJ5S2V5Iiwic2Nyb2xsZXJFbFJlZiIsInNjcm9sbGJhcldpZHRoIiwic2Nyb2xsZXIiLCJoYXJuZXNzRWwiLCJzZWN0aW9uc18xIiwiRXZlbnRSb290IiwidGltZVRleHQiLCJkaXNhYmxlRHJhZ2dpbmciLCJkaXNhYmxlUmVzaXppbmciLCJpc0RhdGVTZWxlY3RpbmciLCJzdGFuZGFyZENsYXNzTmFtZXMiLCJTdGFuZGFyZEV2ZW50IiwiZGVmYXVsdFRpbWVGb3JtYXQiLCJyZW5kZXJJbm5lckNvbnRlbnQkMSIsImlubmVyUHJvcHMiLCJOb3dJbmRpY2F0b3JSb290IiwiaXNBeGlzIiwiREFZX05VTV9GT1JNQVQiLCJEYXlDZWxsQ29udGVudCIsInJlZmluZURheUNlbGxIb29rUHJvcHMiLCJzaG93RGF5TnVtYmVyIiwiZXh0cmFQcm9wcyIsImRheU51bWJlclRleHQiLCJEYXlDZWxsUm9vdCIsInJlZmluZUhvb2tQcm9wcyIsImRhdGFBdHRycyIsInJlbmRlckZpbGwiLCJmaWxsVHlwZSIsIkJnRXZlbnQiLCJXZWVrTnVtYmVyUm9vdCIsImRlZmF1bHRGb3JtYXQiLCJyZW5kZXJJbm5lciIsIlBBRERJTkdfRlJPTV9WSUVXUE9SVCIsIlBvcG92ZXIiLCJoYW5kbGVEb2N1bWVudE1vdXNlRG93biIsImhhbmRsZUNsb3NlQ2xpY2siLCJoYW5kbGVEb2N1bWVudEtleURvd24iLCJvbkNsb3NlIiwiY3JlYXRlUG9ydGFsIiwiZXh0cmFBdHRycyIsInBhcmVudEVsIiwiYWxpZ25tZW50RWwiLCJhbGlnbkdyaWRUb3AiLCJhbGlnbm1lbnRSZWN0IiwicG9wb3ZlckRpbXMiLCJwb3BvdmVyVG9wIiwicG9wb3ZlckxlZnQiLCJvcmlnaW5fMSIsIm9mZnNldFBhcmVudCIsIk1vcmVQb3BvdmVyIiwic3RhcnREYXRlIiwiZGF5Q2xhc3NOYW1lcyIsImV4dHJhRGF0ZVNwYW4iLCJkYXlFbCIsImxheWVyIiwiTW9yZUxpbmtSb290IiwibGlua0VsUmVmIiwiaXNQb3BvdmVyT3BlbiIsInBvcG92ZXJJZCIsImhhbmRsZUNsaWNrIiwiY29tcHV0ZVJhbmdlIiwiYnVpbGRQdWJsaWNTZWciLCJhbGxEYXlEYXRlIiwiYWxsU2VncyIsImhpZGRlblNlZ3MiLCJoYW5kbGVQb3BvdmVyQ2xvc2UiLCJtb3JlQ250Iiwic2hvcnRUZXh0IiwicmVuZGVyTW9yZUxpbmtJbm5lciIsImFsaWdubWVudEVsUmVmIiwicG9wb3ZlckNvbnRlbnQiLCJ1cGRhdGVQYXJlbnRFbCIsImNvbXB1dGVFYXJsaWVzdFNlZ1N0YXJ0IiwiY29tcHV0ZUxhdGVzdFNlZ0VuZCIsInBpY2tFYXJsaWVzdFN0YXJ0Iiwic2VnMCIsInNlZzEiLCJwaWNrTGF0ZXN0RW5kIiwidmVyc2lvbiIsInBhcnNlTWFya2VyIiwiayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/common/vdom.cjs.js":
/*!*******************************************************!*\
  !*** ./node_modules/@fullcalendar/common/vdom.cjs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n/// <reference types=\"@fullcalendar/core-preact\" />\nif (typeof FullCalendarVDom === \"undefined\") {\n    throw new Error(\"Please import the top-level fullcalendar lib before attempting to import a plugin.\");\n}\nvar Component = FullCalendarVDom.Component;\nvar createElement = FullCalendarVDom.createElement;\nvar render = FullCalendarVDom.render;\nvar createRef = FullCalendarVDom.createRef;\nvar Fragment = FullCalendarVDom.Fragment;\nvar createContext = FullCalendarVDom.createContext;\nvar createPortal = FullCalendarVDom.createPortal;\nvar flushSync = FullCalendarVDom.flushSync;\nvar unmountComponentAtNode = FullCalendarVDom.unmountComponentAtNode;\n/* eslint-enable */ exports.Component = Component;\nexports.Fragment = Fragment;\nexports.createContext = createContext;\nexports.createElement = createElement;\nexports.createPortal = createPortal;\nexports.createRef = createRef;\nexports.flushSync = flushSync;\nexports.render = render;\nexports.unmountComponentAtNode = unmountComponentAtNode;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9jb21tb24vdmRvbS5janMuanMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQUEsOENBQTZDO0lBQUVHLE9BQU8sSUFBSTtBQUFDLENBQUMsRUFBQztBQUU3RCxtREFBbUQ7QUFDbkQsSUFBSSxPQUFPQyxxQkFBcUIsYUFBYTtJQUN6QyxNQUFNLElBQUlDLE1BQU0sc0ZBQXNGO0FBQzFHLENBQUM7QUFDRCxJQUFJQyxZQUFZRixpQkFBaUJFLFNBQVM7QUFDMUMsSUFBSUMsZ0JBQWdCSCxpQkFBaUJHLGFBQWE7QUFDbEQsSUFBSUMsU0FBU0osaUJBQWlCSSxNQUFNO0FBQ3BDLElBQUlDLFlBQVlMLGlCQUFpQkssU0FBUztBQUMxQyxJQUFJQyxXQUFXTixpQkFBaUJNLFFBQVE7QUFDeEMsSUFBSUMsZ0JBQWdCUCxpQkFBaUJPLGFBQWE7QUFDbEQsSUFBSUMsZUFBZVIsaUJBQWlCUSxZQUFZO0FBQ2hELElBQUlDLFlBQVlULGlCQUFpQlMsU0FBUztBQUMxQyxJQUFJQyx5QkFBeUJWLGlCQUFpQlUsc0JBQXNCO0FBQ3BFLGlCQUFpQixHQUVqQlosaUJBQWlCLEdBQUdJO0FBQ3BCSixnQkFBZ0IsR0FBR1E7QUFDbkJSLHFCQUFxQixHQUFHUztBQUN4QlQscUJBQXFCLEdBQUdLO0FBQ3hCTCxvQkFBb0IsR0FBR1U7QUFDdkJWLGlCQUFpQixHQUFHTztBQUNwQlAsaUJBQWlCLEdBQUdXO0FBQ3BCWCxjQUFjLEdBQUdNO0FBQ2pCTiw4QkFBOEIsR0FBR1kiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL2NvbW1vbi92ZG9tLmNqcy5qcz8zNzI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJAZnVsbGNhbGVuZGFyL2NvcmUtcHJlYWN0XCIgLz5cbmlmICh0eXBlb2YgRnVsbENhbGVuZGFyVkRvbSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBpbXBvcnQgdGhlIHRvcC1sZXZlbCBmdWxsY2FsZW5kYXIgbGliIGJlZm9yZSBhdHRlbXB0aW5nIHRvIGltcG9ydCBhIHBsdWdpbi4nKTtcbn1cbnZhciBDb21wb25lbnQgPSBGdWxsQ2FsZW5kYXJWRG9tLkNvbXBvbmVudDtcbnZhciBjcmVhdGVFbGVtZW50ID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVFbGVtZW50O1xudmFyIHJlbmRlciA9IEZ1bGxDYWxlbmRhclZEb20ucmVuZGVyO1xudmFyIGNyZWF0ZVJlZiA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlUmVmO1xudmFyIEZyYWdtZW50ID0gRnVsbENhbGVuZGFyVkRvbS5GcmFnbWVudDtcbnZhciBjcmVhdGVDb250ZXh0ID0gRnVsbENhbGVuZGFyVkRvbS5jcmVhdGVDb250ZXh0O1xudmFyIGNyZWF0ZVBvcnRhbCA9IEZ1bGxDYWxlbmRhclZEb20uY3JlYXRlUG9ydGFsO1xudmFyIGZsdXNoU3luYyA9IEZ1bGxDYWxlbmRhclZEb20uZmx1c2hTeW5jO1xudmFyIHVubW91bnRDb21wb25lbnRBdE5vZGUgPSBGdWxsQ2FsZW5kYXJWRG9tLnVubW91bnRDb21wb25lbnRBdE5vZGU7XG4vKiBlc2xpbnQtZW5hYmxlICovXG5cbmV4cG9ydHMuQ29tcG9uZW50ID0gQ29tcG9uZW50O1xuZXhwb3J0cy5GcmFnbWVudCA9IEZyYWdtZW50O1xuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gY3JlYXRlQ29udGV4dDtcbmV4cG9ydHMuY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQ7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuY3JlYXRlUmVmID0gY3JlYXRlUmVmO1xuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG5leHBvcnRzLnJlbmRlciA9IHJlbmRlcjtcbmV4cG9ydHMudW5tb3VudENvbXBvbmVudEF0Tm9kZSA9IHVubW91bnRDb21wb25lbnRBdE5vZGU7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJGdWxsQ2FsZW5kYXJWRG9tIiwiRXJyb3IiLCJDb21wb25lbnQiLCJjcmVhdGVFbGVtZW50IiwicmVuZGVyIiwiY3JlYXRlUmVmIiwiRnJhZ21lbnQiLCJjcmVhdGVDb250ZXh0IiwiY3JlYXRlUG9ydGFsIiwiZmx1c2hTeW5jIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/common/vdom.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/daygrid/main.cjs.js":
/*!********************************************************!*\
  !*** ./node_modules/@fullcalendar/daygrid/main.cjs.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\nFullCalendar v5.11.3\nDocs & License: https://fullcalendar.io/\n(c) 2022 Adam Shaw\n*/ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\nvar tslib = __webpack_require__(/*! tslib */ \"./node_modules/@fullcalendar/daygrid/node_modules/tslib/tslib.es6.js\");\n;\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/ // It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\nvar TableView = /** @class */ function(_super) {\n    tslib.__extends(TableView, _super);\n    function TableView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.headerElRef = common.createRef();\n        return _this;\n    }\n    TableView.prototype.renderSimpleLayout = function(headerRowContent, bodyContent) {\n        var _a = this, props = _a.props, context = _a.context;\n        var sections = [];\n        var stickyHeaderDates = common.getStickyHeaderDates(context.options);\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunk: {\n                    elRef: this.headerElRef,\n                    tableClassName: \"fc-col-header\",\n                    rowContent: headerRowContent\n                }\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunk: {\n                content: bodyContent\n            }\n        });\n        return common.createElement(common.ViewRoot, {\n            viewSpec: context.viewSpec\n        }, function(rootElRef, classNames) {\n            return common.createElement(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid\"\n                ].concat(classNames).join(\" \")\n            }, common.createElement(common.SimpleScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                cols: [],\n                sections: sections\n            }));\n        });\n    };\n    TableView.prototype.renderHScrollLayout = function(headerRowContent, bodyContent, colCnt, dayMinWidth) {\n        var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n        if (!ScrollGrid) {\n            throw new Error(\"No ScrollGrid implementation\");\n        }\n        var _a = this, props = _a.props, context = _a.context;\n        var stickyHeaderDates = !props.forPrint && common.getStickyHeaderDates(context.options);\n        var stickyFooterScrollbar = !props.forPrint && common.getStickyFooterScrollbar(context.options);\n        var sections = [];\n        if (headerRowContent) {\n            sections.push({\n                type: \"header\",\n                key: \"header\",\n                isSticky: stickyHeaderDates,\n                chunks: [\n                    {\n                        key: \"main\",\n                        elRef: this.headerElRef,\n                        tableClassName: \"fc-col-header\",\n                        rowContent: headerRowContent\n                    }\n                ]\n            });\n        }\n        sections.push({\n            type: \"body\",\n            key: \"body\",\n            liquid: true,\n            chunks: [\n                {\n                    key: \"main\",\n                    content: bodyContent\n                }\n            ]\n        });\n        if (stickyFooterScrollbar) {\n            sections.push({\n                type: \"footer\",\n                key: \"footer\",\n                isSticky: true,\n                chunks: [\n                    {\n                        key: \"main\",\n                        content: common.renderScrollShim\n                    }\n                ]\n            });\n        }\n        return common.createElement(common.ViewRoot, {\n            viewSpec: context.viewSpec\n        }, function(rootElRef, classNames) {\n            return common.createElement(\"div\", {\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid\"\n                ].concat(classNames).join(\" \")\n            }, common.createElement(ScrollGrid, {\n                liquid: !props.isHeightAuto && !props.forPrint,\n                collapsibleWidth: props.forPrint,\n                colGroups: [\n                    {\n                        cols: [\n                            {\n                                span: colCnt,\n                                minWidth: dayMinWidth\n                            }\n                        ]\n                    }\n                ],\n                sections: sections\n            }));\n        });\n    };\n    return TableView;\n}(common.DateComponent);\nfunction splitSegsByRow(segs, rowCnt) {\n    var byRow = [];\n    for(var i = 0; i < rowCnt; i += 1){\n        byRow[i] = [];\n    }\n    for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){\n        var seg = segs_1[_i];\n        byRow[seg.row].push(seg);\n    }\n    return byRow;\n}\nfunction splitSegsByFirstCol(segs, colCnt) {\n    var byCol = [];\n    for(var i = 0; i < colCnt; i += 1){\n        byCol[i] = [];\n    }\n    for(var _i = 0, segs_2 = segs; _i < segs_2.length; _i++){\n        var seg = segs_2[_i];\n        byCol[seg.firstCol].push(seg);\n    }\n    return byCol;\n}\nfunction splitInteractionByRow(ui, rowCnt) {\n    var byRow = [];\n    if (!ui) {\n        for(var i = 0; i < rowCnt; i += 1){\n            byRow[i] = null;\n        }\n    } else {\n        for(var i = 0; i < rowCnt; i += 1){\n            byRow[i] = {\n                affectedInstances: ui.affectedInstances,\n                isEvent: ui.isEvent,\n                segs: []\n            };\n        }\n        for(var _i = 0, _a = ui.segs; _i < _a.length; _i++){\n            var seg = _a[_i];\n            byRow[seg.row].segs.push(seg);\n        }\n    }\n    return byRow;\n}\nvar TableCellTop = /** @class */ function(_super) {\n    tslib.__extends(TableCellTop, _super);\n    function TableCellTop() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableCellTop.prototype.render = function() {\n        var props = this.props;\n        var navLinkAttrs = common.buildNavLinkAttrs(this.context, props.date);\n        return common.createElement(common.DayCellContent, {\n            date: props.date,\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraHookProps: props.extraHookProps,\n            defaultContent: renderTopInner\n        }, function(innerElRef, innerContent) {\n            return (innerContent || props.forceDayTop) && common.createElement(\"div\", {\n                className: \"fc-daygrid-day-top\",\n                ref: innerElRef\n            }, common.createElement(\"a\", tslib.__assign({\n                id: props.dayNumberId,\n                className: \"fc-daygrid-day-number\"\n            }, navLinkAttrs), innerContent || common.createElement(common.Fragment, null, \"\\xa0\")));\n        });\n    };\n    return TableCellTop;\n}(common.BaseComponent);\nfunction renderTopInner(props) {\n    return props.dayNumberText;\n}\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = common.createFormatter({\n    hour: \"numeric\",\n    minute: \"2-digit\",\n    omitZeroMinute: true,\n    meridiem: \"narrow\"\n});\nfunction hasListItemDisplay(seg) {\n    var display = seg.eventRange.ui.display;\n    return display === \"list-item\" || display === \"auto\" && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n    seg.isStart && // \"\n    seg.isEnd // \"\n    ;\n}\nvar TableBlockEvent = /** @class */ function(_super) {\n    tslib.__extends(TableBlockEvent, _super);\n    function TableBlockEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableBlockEvent.prototype.render = function() {\n        var props = this.props;\n        return common.createElement(common.StandardEvent, tslib.__assign({}, props, {\n            extraClassNames: [\n                \"fc-daygrid-event\",\n                \"fc-daygrid-block-event\",\n                \"fc-h-event\"\n            ],\n            defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n            defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n            disableResizing: !props.seg.eventRange.def.allDay\n        }));\n    };\n    return TableBlockEvent;\n}(common.BaseComponent);\nvar TableListItemEvent = /** @class */ function(_super) {\n    tslib.__extends(TableListItemEvent, _super);\n    function TableListItemEvent() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    TableListItemEvent.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n        var timeText = common.buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n        return common.createElement(common.EventRoot, {\n            seg: props.seg,\n            timeText: timeText,\n            defaultContent: renderInnerContent,\n            isDragging: props.isDragging,\n            isResizing: false,\n            isDateSelecting: false,\n            isSelected: props.isSelected,\n            isPast: props.isPast,\n            isFuture: props.isFuture,\n            isToday: props.isToday\n        }, function(rootElRef, classNames, innerElRef, innerContent) {\n            return common.createElement(\"a\", tslib.__assign({\n                className: [\n                    \"fc-daygrid-event\",\n                    \"fc-daygrid-dot-event\"\n                ].concat(classNames).join(\" \"),\n                ref: rootElRef\n            }, common.getSegAnchorAttrs(props.seg, context)), innerContent);\n        });\n    };\n    return TableListItemEvent;\n}(common.BaseComponent);\nfunction renderInnerContent(innerProps) {\n    return common.createElement(common.Fragment, null, common.createElement(\"div\", {\n        className: \"fc-daygrid-event-dot\",\n        style: {\n            borderColor: innerProps.borderColor || innerProps.backgroundColor\n        }\n    }), innerProps.timeText && common.createElement(\"div\", {\n        className: \"fc-event-time\"\n    }, innerProps.timeText), common.createElement(\"div\", {\n        className: \"fc-event-title\"\n    }, innerProps.event.title || common.createElement(common.Fragment, null, \"\\xa0\")));\n}\nvar TableCellMoreLink = /** @class */ function(_super) {\n    tslib.__extends(TableCellMoreLink, _super);\n    function TableCellMoreLink() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.compileSegs = common.memoize(compileSegs);\n        return _this;\n    }\n    TableCellMoreLink.prototype.render = function() {\n        var props = this.props;\n        var _a = this.compileSegs(props.singlePlacements), allSegs = _a.allSegs, invisibleSegs = _a.invisibleSegs;\n        return common.createElement(common.MoreLinkRoot, {\n            dateProfile: props.dateProfile,\n            todayRange: props.todayRange,\n            allDayDate: props.allDayDate,\n            moreCnt: props.moreCnt,\n            allSegs: allSegs,\n            hiddenSegs: invisibleSegs,\n            alignmentElRef: props.alignmentElRef,\n            alignGridTop: props.alignGridTop,\n            extraDateSpan: props.extraDateSpan,\n            popoverContent: function() {\n                var isForcedInvisible = (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {};\n                return common.createElement(common.Fragment, null, allSegs.map(function(seg) {\n                    var instanceId = seg.eventRange.instance.instanceId;\n                    return common.createElement(\"div\", {\n                        className: \"fc-daygrid-event-harness\",\n                        key: instanceId,\n                        style: {\n                            visibility: isForcedInvisible[instanceId] ? \"hidden\" : \"\"\n                        }\n                    }, hasListItemDisplay(seg) ? common.createElement(TableListItemEvent, tslib.__assign({\n                        seg: seg,\n                        isDragging: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, common.getSegMeta(seg, props.todayRange))) : common.createElement(TableBlockEvent, tslib.__assign({\n                        seg: seg,\n                        isDragging: false,\n                        isResizing: false,\n                        isDateSelecting: false,\n                        isSelected: instanceId === props.eventSelection,\n                        defaultDisplayEventEnd: false\n                    }, common.getSegMeta(seg, props.todayRange))));\n                }));\n            }\n        }, function(rootElRef, classNames, innerElRef, innerContent, handleClick, title, isExpanded, popoverId) {\n            return common.createElement(\"a\", tslib.__assign({\n                ref: rootElRef,\n                className: [\n                    \"fc-daygrid-more-link\"\n                ].concat(classNames).join(\" \"),\n                title: title,\n                \"aria-expanded\": isExpanded,\n                \"aria-controls\": popoverId\n            }, common.createAriaClickAttrs(handleClick)), innerContent);\n        });\n    };\n    return TableCellMoreLink;\n}(common.BaseComponent);\nfunction compileSegs(singlePlacements) {\n    var allSegs = [];\n    var invisibleSegs = [];\n    for(var _i = 0, singlePlacements_1 = singlePlacements; _i < singlePlacements_1.length; _i++){\n        var placement = singlePlacements_1[_i];\n        allSegs.push(placement.seg);\n        if (!placement.isVisible) {\n            invisibleSegs.push(placement.seg);\n        }\n    }\n    return {\n        allSegs: allSegs,\n        invisibleSegs: invisibleSegs\n    };\n}\nvar DEFAULT_WEEK_NUM_FORMAT = common.createFormatter({\n    week: \"narrow\"\n});\nvar TableCell = /** @class */ function(_super) {\n    tslib.__extends(TableCell, _super);\n    function TableCell() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.rootElRef = common.createRef();\n        _this.state = {\n            dayNumberId: common.getUniqueDomId()\n        };\n        _this.handleRootEl = function(el) {\n            common.setRef(_this.rootElRef, el);\n            common.setRef(_this.props.elRef, el);\n        };\n        return _this;\n    }\n    TableCell.prototype.render = function() {\n        var _a = this, context = _a.context, props = _a.props, state = _a.state, rootElRef = _a.rootElRef;\n        var date = props.date, dateProfile = props.dateProfile;\n        var navLinkAttrs = common.buildNavLinkAttrs(context, date, \"week\");\n        return common.createElement(common.DayCellRoot, {\n            date: date,\n            dateProfile: dateProfile,\n            todayRange: props.todayRange,\n            showDayNumber: props.showDayNumber,\n            extraHookProps: props.extraHookProps,\n            elRef: this.handleRootEl\n        }, function(dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n            return common.createElement(\"td\", tslib.__assign({\n                ref: dayElRef,\n                role: \"gridcell\",\n                className: [\n                    \"fc-daygrid-day\"\n                ].concat(dayClassNames, props.extraClassNames || []).join(\" \")\n            }, rootDataAttrs, props.extraDataAttrs, props.showDayNumber ? {\n                \"aria-labelledby\": state.dayNumberId\n            } : {}), common.createElement(\"div\", {\n                className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n                ref: props.innerElRef /* different from hook system! RENAME */ \n            }, props.showWeekNumber && common.createElement(common.WeekNumberRoot, {\n                date: date,\n                defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n            }, function(weekElRef, weekClassNames, innerElRef, innerContent) {\n                return common.createElement(\"a\", tslib.__assign({\n                    ref: weekElRef,\n                    className: [\n                        \"fc-daygrid-week-number\"\n                    ].concat(weekClassNames).join(\" \")\n                }, navLinkAttrs), innerContent);\n            }), !isDisabled && common.createElement(TableCellTop, {\n                date: date,\n                dateProfile: dateProfile,\n                showDayNumber: props.showDayNumber,\n                dayNumberId: state.dayNumberId,\n                forceDayTop: props.forceDayTop,\n                todayRange: props.todayRange,\n                extraHookProps: props.extraHookProps\n            }), common.createElement(\"div\", {\n                className: \"fc-daygrid-day-events\",\n                ref: props.fgContentElRef\n            }, props.fgContent, common.createElement(\"div\", {\n                className: \"fc-daygrid-day-bottom\",\n                style: {\n                    marginTop: props.moreMarginTop\n                }\n            }, common.createElement(TableCellMoreLink, {\n                allDayDate: date,\n                singlePlacements: props.singlePlacements,\n                moreCnt: props.moreCnt,\n                alignmentElRef: rootElRef,\n                alignGridTop: !props.showDayNumber,\n                extraDateSpan: props.extraDateSpan,\n                dateProfile: props.dateProfile,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                todayRange: props.todayRange\n            }))), common.createElement(\"div\", {\n                className: \"fc-daygrid-day-bg\"\n            }, props.bgContent)));\n        });\n    };\n    return TableCell;\n}(common.DateComponent);\nfunction computeFgSegPlacement(segs, dayMaxEvents, dayMaxEventRows, strictOrder, eventInstanceHeights, maxContentHeight, cells) {\n    var hierarchy = new DayGridSegHierarchy();\n    hierarchy.allowReslicing = true;\n    hierarchy.strictOrder = strictOrder;\n    if (dayMaxEvents === true || dayMaxEventRows === true) {\n        hierarchy.maxCoord = maxContentHeight;\n        hierarchy.hiddenConsumes = true;\n    } else if (typeof dayMaxEvents === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEvents;\n    } else if (typeof dayMaxEventRows === \"number\") {\n        hierarchy.maxStackCnt = dayMaxEventRows;\n        hierarchy.hiddenConsumes = true;\n    }\n    // create segInputs only for segs with known heights\n    var segInputs = [];\n    var unknownHeightSegs = [];\n    for(var i = 0; i < segs.length; i += 1){\n        var seg = segs[i];\n        var instanceId = seg.eventRange.instance.instanceId;\n        var eventHeight = eventInstanceHeights[instanceId];\n        if (eventHeight != null) {\n            segInputs.push({\n                index: i,\n                thickness: eventHeight,\n                span: {\n                    start: seg.firstCol,\n                    end: seg.lastCol + 1\n                }\n            });\n        } else {\n            unknownHeightSegs.push(seg);\n        }\n    }\n    var hiddenEntries = hierarchy.addSegs(segInputs);\n    var segRects = hierarchy.toRects();\n    var _a = placeRects(segRects, segs, cells), singleColPlacements = _a.singleColPlacements, multiColPlacements = _a.multiColPlacements, leftoverMargins = _a.leftoverMargins;\n    var moreCnts = [];\n    var moreMarginTops = [];\n    // add segs with unknown heights\n    for(var _i = 0, unknownHeightSegs_1 = unknownHeightSegs; _i < unknownHeightSegs_1.length; _i++){\n        var seg = unknownHeightSegs_1[_i];\n        multiColPlacements[seg.firstCol].push({\n            seg: seg,\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(var col = seg.firstCol; col <= seg.lastCol; col += 1){\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // add the hidden entries\n    for(var col = 0; col < cells.length; col += 1){\n        moreCnts.push(0);\n    }\n    for(var _b = 0, hiddenEntries_1 = hiddenEntries; _b < hiddenEntries_1.length; _b++){\n        var hiddenEntry = hiddenEntries_1[_b];\n        var seg = segs[hiddenEntry.index];\n        var hiddenSpan = hiddenEntry.span;\n        multiColPlacements[hiddenSpan.start].push({\n            seg: resliceSeg(seg, hiddenSpan.start, hiddenSpan.end, cells),\n            isVisible: false,\n            isAbsolute: true,\n            absoluteTop: 0,\n            marginTop: 0\n        });\n        for(var col = hiddenSpan.start; col < hiddenSpan.end; col += 1){\n            moreCnts[col] += 1;\n            singleColPlacements[col].push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: false,\n                isAbsolute: false,\n                absoluteTop: 0,\n                marginTop: 0\n            });\n        }\n    }\n    // deal with leftover margins\n    for(var col = 0; col < cells.length; col += 1){\n        moreMarginTops.push(leftoverMargins[col]);\n    }\n    return {\n        singleColPlacements: singleColPlacements,\n        multiColPlacements: multiColPlacements,\n        moreCnts: moreCnts,\n        moreMarginTops: moreMarginTops\n    };\n}\n// rects ordered by top coord, then left\nfunction placeRects(allRects, segs, cells) {\n    var rectsByEachCol = groupRectsByEachCol(allRects, cells.length);\n    var singleColPlacements = [];\n    var multiColPlacements = [];\n    var leftoverMargins = [];\n    for(var col = 0; col < cells.length; col += 1){\n        var rects = rectsByEachCol[col];\n        // compute all static segs in singlePlacements\n        var singlePlacements = [];\n        var currentHeight = 0;\n        var currentMarginTop = 0;\n        for(var _i = 0, rects_1 = rects; _i < rects_1.length; _i++){\n            var rect = rects_1[_i];\n            var seg = segs[rect.index];\n            singlePlacements.push({\n                seg: resliceSeg(seg, col, col + 1, cells),\n                isVisible: true,\n                isAbsolute: false,\n                absoluteTop: rect.levelCoord,\n                marginTop: rect.levelCoord - currentHeight\n            });\n            currentHeight = rect.levelCoord + rect.thickness;\n        }\n        // compute mixed static/absolute segs in multiPlacements\n        var multiPlacements = [];\n        currentHeight = 0;\n        currentMarginTop = 0;\n        for(var _a = 0, rects_2 = rects; _a < rects_2.length; _a++){\n            var rect = rects_2[_a];\n            var seg = segs[rect.index];\n            var isAbsolute = rect.span.end - rect.span.start > 1; // multi-column?\n            var isFirstCol = rect.span.start === col;\n            currentMarginTop += rect.levelCoord - currentHeight; // amount of space since bottom of previous seg\n            currentHeight = rect.levelCoord + rect.thickness; // height will now be bottom of current seg\n            if (isAbsolute) {\n                currentMarginTop += rect.thickness;\n                if (isFirstCol) {\n                    multiPlacements.push({\n                        seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                        isVisible: true,\n                        isAbsolute: true,\n                        absoluteTop: rect.levelCoord,\n                        marginTop: 0\n                    });\n                }\n            } else if (isFirstCol) {\n                multiPlacements.push({\n                    seg: resliceSeg(seg, rect.span.start, rect.span.end, cells),\n                    isVisible: true,\n                    isAbsolute: false,\n                    absoluteTop: rect.levelCoord,\n                    marginTop: currentMarginTop\n                });\n                currentMarginTop = 0;\n            }\n        }\n        singleColPlacements.push(singlePlacements);\n        multiColPlacements.push(multiPlacements);\n        leftoverMargins.push(currentMarginTop);\n    }\n    return {\n        singleColPlacements: singleColPlacements,\n        multiColPlacements: multiColPlacements,\n        leftoverMargins: leftoverMargins\n    };\n}\nfunction groupRectsByEachCol(rects, colCnt) {\n    var rectsByEachCol = [];\n    for(var col = 0; col < colCnt; col += 1){\n        rectsByEachCol.push([]);\n    }\n    for(var _i = 0, rects_3 = rects; _i < rects_3.length; _i++){\n        var rect = rects_3[_i];\n        for(var col = rect.span.start; col < rect.span.end; col += 1){\n            rectsByEachCol[col].push(rect);\n        }\n    }\n    return rectsByEachCol;\n}\nfunction resliceSeg(seg, spanStart, spanEnd, cells) {\n    if (seg.firstCol === spanStart && seg.lastCol === spanEnd - 1) {\n        return seg;\n    }\n    var eventRange = seg.eventRange;\n    var origRange = eventRange.range;\n    var slicedRange = common.intersectRanges(origRange, {\n        start: cells[spanStart].date,\n        end: common.addDays(cells[spanEnd - 1].date, 1)\n    });\n    return tslib.__assign(tslib.__assign({}, seg), {\n        firstCol: spanStart,\n        lastCol: spanEnd - 1,\n        eventRange: {\n            def: eventRange.def,\n            ui: tslib.__assign(tslib.__assign({}, eventRange.ui), {\n                durationEditable: false\n            }),\n            instance: eventRange.instance,\n            range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n    });\n}\nvar DayGridSegHierarchy = /** @class */ function(_super) {\n    tslib.__extends(DayGridSegHierarchy, _super);\n    function DayGridSegHierarchy() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        // config\n        _this.hiddenConsumes = false;\n        // allows us to keep hidden entries in the hierarchy so they take up space\n        _this.forceHidden = {};\n        return _this;\n    }\n    DayGridSegHierarchy.prototype.addSegs = function(segInputs) {\n        var _this = this;\n        var hiddenSegs = _super.prototype.addSegs.call(this, segInputs);\n        var entriesByLevel = this.entriesByLevel;\n        var excludeHidden = function(entry) {\n            return !_this.forceHidden[common.buildEntryKey(entry)];\n        };\n        // remove the forced-hidden segs\n        for(var level = 0; level < entriesByLevel.length; level += 1){\n            entriesByLevel[level] = entriesByLevel[level].filter(excludeHidden);\n        }\n        return hiddenSegs;\n    };\n    DayGridSegHierarchy.prototype.handleInvalidInsertion = function(insertion, entry, hiddenEntries) {\n        var _a = this, entriesByLevel = _a.entriesByLevel, forceHidden = _a.forceHidden;\n        var touchingEntry = insertion.touchingEntry, touchingLevel = insertion.touchingLevel, touchingLateral = insertion.touchingLateral;\n        if (this.hiddenConsumes && touchingEntry) {\n            var touchingEntryId = common.buildEntryKey(touchingEntry);\n            // if not already hidden\n            if (!forceHidden[touchingEntryId]) {\n                if (this.allowReslicing) {\n                    var placeholderEntry = tslib.__assign(tslib.__assign({}, touchingEntry), {\n                        span: common.intersectSpans(touchingEntry.span, entry.span)\n                    });\n                    var placeholderEntryId = common.buildEntryKey(placeholderEntry);\n                    forceHidden[placeholderEntryId] = true;\n                    entriesByLevel[touchingLevel][touchingLateral] = placeholderEntry; // replace touchingEntry with our placeholder\n                    this.splitEntry(touchingEntry, entry, hiddenEntries); // split up the touchingEntry, reinsert it\n                } else {\n                    forceHidden[touchingEntryId] = true;\n                    hiddenEntries.push(touchingEntry);\n                }\n            }\n        }\n        return _super.prototype.handleInvalidInsertion.call(this, insertion, entry, hiddenEntries);\n    };\n    return DayGridSegHierarchy;\n}(common.SegHierarchy);\nvar TableRow = /** @class */ function(_super) {\n    tslib.__extends(TableRow, _super);\n    function TableRow() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.cellElRefs = new common.RefMap(); // the <td>\n        _this.frameElRefs = new common.RefMap(); // the fc-daygrid-day-frame\n        _this.fgElRefs = new common.RefMap(); // the fc-daygrid-day-events\n        _this.segHarnessRefs = new common.RefMap(); // indexed by \"instanceId:firstCol\"\n        _this.rootElRef = common.createRef();\n        _this.state = {\n            framePositions: null,\n            maxContentHeight: null,\n            eventInstanceHeights: {}\n        };\n        return _this;\n    }\n    TableRow.prototype.render = function() {\n        var _this = this;\n        var _a = this, props = _a.props, state = _a.state, context = _a.context;\n        var options = context.options;\n        var colCnt = props.cells.length;\n        var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n        var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n        var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n        var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n        var _b = computeFgSegPlacement(common.sortEventSegs(props.fgEventSegs, options.eventOrder), props.dayMaxEvents, props.dayMaxEventRows, options.eventOrderStrict, state.eventInstanceHeights, state.maxContentHeight, props.cells), singleColPlacements = _b.singleColPlacements, multiColPlacements = _b.multiColPlacements, moreCnts = _b.moreCnts, moreMarginTops = _b.moreMarginTops;\n        var isForcedInvisible = props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n        return common.createElement(\"tr\", {\n            ref: this.rootElRef,\n            role: \"row\"\n        }, props.renderIntro && props.renderIntro(), props.cells.map(function(cell, col) {\n            var normalFgNodes = _this.renderFgSegs(col, props.forPrint ? singleColPlacements[col] : multiColPlacements[col], props.todayRange, isForcedInvisible);\n            var mirrorFgNodes = _this.renderFgSegs(col, buildMirrorPlacements(mirrorSegsByCol[col], multiColPlacements), props.todayRange, {}, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n            return common.createElement(TableCell, {\n                key: cell.key,\n                elRef: _this.cellElRefs.createRef(cell.key),\n                innerElRef: _this.frameElRefs.createRef(cell.key),\n                dateProfile: props.dateProfile,\n                date: cell.date,\n                showDayNumber: props.showDayNumbers,\n                showWeekNumber: props.showWeekNumbers && col === 0,\n                forceDayTop: props.showWeekNumbers /* even displaying weeknum for row, not necessarily day */ ,\n                todayRange: props.todayRange,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                extraHookProps: cell.extraHookProps,\n                extraDataAttrs: cell.extraDataAttrs,\n                extraClassNames: cell.extraClassNames,\n                extraDateSpan: cell.extraDateSpan,\n                moreCnt: moreCnts[col],\n                moreMarginTop: moreMarginTops[col],\n                singlePlacements: singleColPlacements[col],\n                fgContentElRef: _this.fgElRefs.createRef(cell.key),\n                fgContent: common.createElement(common.Fragment, null, common.createElement(common.Fragment, null, normalFgNodes), common.createElement(common.Fragment, null, mirrorFgNodes)),\n                bgContent: common.createElement(common.Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], \"highlight\"), _this.renderFillSegs(businessHoursByCol[col], \"non-business\"), _this.renderFillSegs(bgEventSegsByCol[col], \"bg-event\"))\n            });\n        }));\n    };\n    TableRow.prototype.componentDidMount = function() {\n        this.updateSizing(true);\n    };\n    TableRow.prototype.componentDidUpdate = function(prevProps, prevState) {\n        var currentProps = this.props;\n        this.updateSizing(!common.isPropsEqual(prevProps, currentProps));\n    };\n    TableRow.prototype.getHighlightSegs = function() {\n        var props = this.props;\n        if (props.eventDrag && props.eventDrag.segs.length) {\n            return props.eventDrag.segs;\n        }\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return props.dateSelectionSegs;\n    };\n    TableRow.prototype.getMirrorSegs = function() {\n        var props = this.props;\n        if (props.eventResize && props.eventResize.segs.length) {\n            return props.eventResize.segs;\n        }\n        return [];\n    };\n    TableRow.prototype.renderFgSegs = function(col, segPlacements, todayRange, isForcedInvisible, isDragging, isResizing, isDateSelecting) {\n        var context = this.context;\n        var eventSelection = this.props.eventSelection;\n        var framePositions = this.state.framePositions;\n        var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var nodes = [];\n        if (framePositions) {\n            for(var _i = 0, segPlacements_1 = segPlacements; _i < segPlacements_1.length; _i++){\n                var placement = segPlacements_1[_i];\n                var seg = placement.seg;\n                var instanceId = seg.eventRange.instance.instanceId;\n                var key = instanceId + \":\" + col;\n                var isVisible = placement.isVisible && !isForcedInvisible[instanceId];\n                var isAbsolute = placement.isAbsolute;\n                var left = \"\";\n                var right = \"\";\n                if (isAbsolute) {\n                    if (context.isRtl) {\n                        right = 0;\n                        left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n                    } else {\n                        left = 0;\n                        right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n                    }\n                }\n                /*\n                known bug: events that are force to be list-item but span multiple days still take up space in later columns\n                todo: in print view, for multi-day events, don't display title within non-start/end segs\n                */ nodes.push(common.createElement(\"div\", {\n                    className: \"fc-daygrid-event-harness\" + (isAbsolute ? \" fc-daygrid-event-harness-abs\" : \"\"),\n                    key: key,\n                    ref: isMirror ? null : this.segHarnessRefs.createRef(key),\n                    style: {\n                        visibility: isVisible ? \"\" : \"hidden\",\n                        marginTop: isAbsolute ? \"\" : placement.marginTop,\n                        top: isAbsolute ? placement.absoluteTop : \"\",\n                        left: left,\n                        right: right\n                    }\n                }, hasListItemDisplay(seg) ? common.createElement(TableListItemEvent, tslib.__assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, common.getSegMeta(seg, todayRange))) : common.createElement(TableBlockEvent, tslib.__assign({\n                    seg: seg,\n                    isDragging: isDragging,\n                    isResizing: isResizing,\n                    isDateSelecting: isDateSelecting,\n                    isSelected: instanceId === eventSelection,\n                    defaultDisplayEventEnd: defaultDisplayEventEnd\n                }, common.getSegMeta(seg, todayRange)))));\n            }\n        }\n        return nodes;\n    };\n    TableRow.prototype.renderFillSegs = function(segs, fillType) {\n        var isRtl = this.context.isRtl;\n        var todayRange = this.props.todayRange;\n        var framePositions = this.state.framePositions;\n        var nodes = [];\n        if (framePositions) {\n            for(var _i = 0, segs_1 = segs; _i < segs_1.length; _i++){\n                var seg = segs_1[_i];\n                var leftRightCss = isRtl ? {\n                    right: 0,\n                    left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n                } : {\n                    left: 0,\n                    right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n                };\n                nodes.push(common.createElement(\"div\", {\n                    key: common.buildEventRangeKey(seg.eventRange),\n                    className: \"fc-daygrid-bg-harness\",\n                    style: leftRightCss\n                }, fillType === \"bg-event\" ? common.createElement(common.BgEvent, tslib.__assign({\n                    seg: seg\n                }, common.getSegMeta(seg, todayRange))) : common.renderFill(fillType)));\n            }\n        }\n        return common.createElement.apply(void 0, tslib.__spreadArray([\n            common.Fragment,\n            {}\n        ], nodes));\n    };\n    TableRow.prototype.updateSizing = function(isExternalSizingChange) {\n        var _a = this, props = _a.props, frameElRefs = _a.frameElRefs;\n        if (!props.forPrint && props.clientWidth !== null // positioning ready?\n        ) {\n            if (isExternalSizingChange) {\n                var frameEls = props.cells.map(function(cell) {\n                    return frameElRefs.currentMap[cell.key];\n                });\n                if (frameEls.length) {\n                    var originEl = this.rootElRef.current;\n                    this.setState({\n                        framePositions: new common.PositionCache(originEl, frameEls, true, false)\n                    });\n                }\n            }\n            var oldInstanceHeights = this.state.eventInstanceHeights;\n            var newInstanceHeights = this.queryEventInstanceHeights();\n            var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n            this.safeSetState({\n                // HACK to prevent oscillations of events being shown/hidden from max-event-rows\n                // Essentially, once you compute an element's height, never null-out.\n                // TODO: always display all events, as visibility:hidden?\n                eventInstanceHeights: tslib.__assign(tslib.__assign({}, oldInstanceHeights), newInstanceHeights),\n                maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n            });\n        }\n    };\n    TableRow.prototype.queryEventInstanceHeights = function() {\n        var segElMap = this.segHarnessRefs.currentMap;\n        var eventInstanceHeights = {};\n        // get the max height amongst instance segs\n        for(var key in segElMap){\n            var height = Math.round(segElMap[key].getBoundingClientRect().height);\n            var instanceId = key.split(\":\")[0]; // deconstruct how renderFgSegs makes the key\n            eventInstanceHeights[instanceId] = Math.max(eventInstanceHeights[instanceId] || 0, height);\n        }\n        return eventInstanceHeights;\n    };\n    TableRow.prototype.computeMaxContentHeight = function() {\n        var firstKey = this.props.cells[0].key;\n        var cellEl = this.cellElRefs.currentMap[firstKey];\n        var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n        return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n    };\n    TableRow.prototype.getCellEls = function() {\n        var elMap = this.cellElRefs.currentMap;\n        return this.props.cells.map(function(cell) {\n            return elMap[cell.key];\n        });\n    };\n    return TableRow;\n}(common.DateComponent);\nTableRow.addStateEquality({\n    eventInstanceHeights: common.isPropsEqual\n});\nfunction buildMirrorPlacements(mirrorSegs, colPlacements) {\n    if (!mirrorSegs.length) {\n        return [];\n    }\n    var topsByInstanceId = buildAbsoluteTopHash(colPlacements); // TODO: cache this at first render?\n    return mirrorSegs.map(function(seg) {\n        return {\n            seg: seg,\n            isVisible: true,\n            isAbsolute: true,\n            absoluteTop: topsByInstanceId[seg.eventRange.instance.instanceId],\n            marginTop: 0\n        };\n    });\n}\nfunction buildAbsoluteTopHash(colPlacements) {\n    var topsByInstanceId = {};\n    for(var _i = 0, colPlacements_1 = colPlacements; _i < colPlacements_1.length; _i++){\n        var placements = colPlacements_1[_i];\n        for(var _a = 0, placements_1 = placements; _a < placements_1.length; _a++){\n            var placement = placements_1[_a];\n            topsByInstanceId[placement.seg.eventRange.instance.instanceId] = placement.absoluteTop;\n        }\n    }\n    return topsByInstanceId;\n}\nvar Table = /** @class */ function(_super) {\n    tslib.__extends(Table, _super);\n    function Table() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.splitBusinessHourSegs = common.memoize(splitSegsByRow);\n        _this.splitBgEventSegs = common.memoize(splitSegsByRow);\n        _this.splitFgEventSegs = common.memoize(splitSegsByRow);\n        _this.splitDateSelectionSegs = common.memoize(splitSegsByRow);\n        _this.splitEventDrag = common.memoize(splitInteractionByRow);\n        _this.splitEventResize = common.memoize(splitInteractionByRow);\n        _this.rowRefs = new common.RefMap();\n        _this.handleRootEl = function(rootEl) {\n            _this.rootEl = rootEl;\n            if (rootEl) {\n                _this.context.registerInteractiveComponent(_this, {\n                    el: rootEl,\n                    isHitComboAllowed: _this.props.isHitComboAllowed\n                });\n            } else {\n                _this.context.unregisterInteractiveComponent(_this);\n            }\n        };\n        return _this;\n    }\n    Table.prototype.render = function() {\n        var _this = this;\n        var props = this.props;\n        var dateProfile = props.dateProfile, dayMaxEventRows = props.dayMaxEventRows, dayMaxEvents = props.dayMaxEvents, expandRows = props.expandRows;\n        var rowCnt = props.cells.length;\n        var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n        var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n        var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n        var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n        var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n        var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n        var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true;\n        // if rows can't expand to fill fixed height, can't do balanced-height event limit\n        // TODO: best place to normalize these options?\n        if (limitViaBalanced && !expandRows) {\n            limitViaBalanced = false;\n            dayMaxEventRows = null;\n            dayMaxEvents = null;\n        }\n        var classNames = [\n            \"fc-daygrid-body\",\n            limitViaBalanced ? \"fc-daygrid-body-balanced\" : \"fc-daygrid-body-unbalanced\",\n            expandRows ? \"\" : \"fc-daygrid-body-natural\"\n        ];\n        return common.createElement(\"div\", {\n            className: classNames.join(\" \"),\n            ref: this.handleRootEl,\n            style: {\n                // these props are important to give this wrapper correct dimensions for interactions\n                // TODO: if we set it here, can we avoid giving to inner tables?\n                width: props.clientWidth,\n                minWidth: props.tableMinWidth\n            }\n        }, common.createElement(common.NowTimer, {\n            unit: \"day\"\n        }, function(nowDate, todayRange) {\n            return common.createElement(common.Fragment, null, common.createElement(\"table\", {\n                role: \"presentation\",\n                className: \"fc-scrollgrid-sync-table\",\n                style: {\n                    width: props.clientWidth,\n                    minWidth: props.tableMinWidth,\n                    height: expandRows ? props.clientHeight : \"\"\n                }\n            }, props.colGroupNode, common.createElement(\"tbody\", {\n                role: \"presentation\"\n            }, props.cells.map(function(cells, row) {\n                return common.createElement(TableRow, {\n                    ref: _this.rowRefs.createRef(row),\n                    key: cells.length ? cells[0].date.toISOString() : row // in case there are no cells (like when resource view is loading)\n                    ,\n                    showDayNumbers: rowCnt > 1,\n                    showWeekNumbers: props.showWeekNumbers,\n                    todayRange: todayRange,\n                    dateProfile: dateProfile,\n                    cells: cells,\n                    renderIntro: props.renderRowIntro,\n                    businessHourSegs: businessHourSegsByRow[row],\n                    eventSelection: props.eventSelection,\n                    bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay),\n                    fgEventSegs: fgEventSegsByRow[row],\n                    dateSelectionSegs: dateSelectionSegsByRow[row],\n                    eventDrag: eventDragByRow[row],\n                    eventResize: eventResizeByRow[row],\n                    dayMaxEvents: dayMaxEvents,\n                    dayMaxEventRows: dayMaxEventRows,\n                    clientWidth: props.clientWidth,\n                    clientHeight: props.clientHeight,\n                    forPrint: props.forPrint\n                });\n            }))));\n        }));\n    };\n    // Hit System\n    // ----------------------------------------------------------------------------------------------------\n    Table.prototype.prepareHits = function() {\n        this.rowPositions = new common.PositionCache(this.rootEl, this.rowRefs.collect().map(function(rowObj) {\n            return rowObj.getCellEls()[0];\n        }), false, true);\n        this.colPositions = new common.PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), true, false);\n    };\n    Table.prototype.queryHit = function(positionLeft, positionTop) {\n        var _a = this, colPositions = _a.colPositions, rowPositions = _a.rowPositions;\n        var col = colPositions.leftToIndex(positionLeft);\n        var row = rowPositions.topToIndex(positionTop);\n        if (row != null && col != null) {\n            var cell = this.props.cells[row][col];\n            return {\n                dateProfile: this.props.dateProfile,\n                dateSpan: tslib.__assign({\n                    range: this.getCellRange(row, col),\n                    allDay: true\n                }, cell.extraDateSpan),\n                dayEl: this.getCellEl(row, col),\n                rect: {\n                    left: colPositions.lefts[col],\n                    right: colPositions.rights[col],\n                    top: rowPositions.tops[row],\n                    bottom: rowPositions.bottoms[row]\n                },\n                layer: 0\n            };\n        }\n        return null;\n    };\n    Table.prototype.getCellEl = function(row, col) {\n        return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n    };\n    Table.prototype.getCellRange = function(row, col) {\n        var start = this.props.cells[row][col].date;\n        var end = common.addDays(start, 1);\n        return {\n            start: start,\n            end: end\n        };\n    };\n    return Table;\n}(common.DateComponent);\nfunction isSegAllDay(seg) {\n    return seg.eventRange.def.allDay;\n}\nvar DayTableSlicer = /** @class */ function(_super) {\n    tslib.__extends(DayTableSlicer, _super);\n    function DayTableSlicer() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.forceDayIfListItem = true;\n        return _this;\n    }\n    DayTableSlicer.prototype.sliceRange = function(dateRange, dayTableModel) {\n        return dayTableModel.sliceRange(dateRange);\n    };\n    return DayTableSlicer;\n}(common.Slicer);\nvar DayTable = /** @class */ function(_super) {\n    tslib.__extends(DayTable, _super);\n    function DayTable() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.slicer = new DayTableSlicer();\n        _this.tableRef = common.createRef();\n        return _this;\n    }\n    DayTable.prototype.render = function() {\n        var _a = this, props = _a.props, context = _a.context;\n        return common.createElement(Table, tslib.__assign({\n            ref: this.tableRef\n        }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n            dateProfile: props.dateProfile,\n            cells: props.dayTableModel.cells,\n            colGroupNode: props.colGroupNode,\n            tableMinWidth: props.tableMinWidth,\n            renderRowIntro: props.renderRowIntro,\n            dayMaxEvents: props.dayMaxEvents,\n            dayMaxEventRows: props.dayMaxEventRows,\n            showWeekNumbers: props.showWeekNumbers,\n            expandRows: props.expandRows,\n            headerAlignElRef: props.headerAlignElRef,\n            clientWidth: props.clientWidth,\n            clientHeight: props.clientHeight,\n            forPrint: props.forPrint\n        }));\n    };\n    return DayTable;\n}(common.DateComponent);\nvar DayTableView = /** @class */ function(_super) {\n    tslib.__extends(DayTableView, _super);\n    function DayTableView() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.buildDayTableModel = common.memoize(buildDayTableModel);\n        _this.headerRef = common.createRef();\n        _this.tableRef = common.createRef();\n        return _this;\n    }\n    DayTableView.prototype.render = function() {\n        var _this = this;\n        var _a = this.context, options = _a.options, dateProfileGenerator = _a.dateProfileGenerator;\n        var props = this.props;\n        var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n        var headerContent = options.dayHeaders && common.createElement(common.DayHeader, {\n            ref: this.headerRef,\n            dateProfile: props.dateProfile,\n            dates: dayTableModel.headerDates,\n            datesRepDistinctDays: dayTableModel.rowCnt === 1\n        });\n        var bodyContent = function(contentArg) {\n            return common.createElement(DayTable, {\n                ref: _this.tableRef,\n                dateProfile: props.dateProfile,\n                dayTableModel: dayTableModel,\n                businessHours: props.businessHours,\n                dateSelection: props.dateSelection,\n                eventStore: props.eventStore,\n                eventUiBases: props.eventUiBases,\n                eventSelection: props.eventSelection,\n                eventDrag: props.eventDrag,\n                eventResize: props.eventResize,\n                nextDayThreshold: options.nextDayThreshold,\n                colGroupNode: contentArg.tableColGroupNode,\n                tableMinWidth: contentArg.tableMinWidth,\n                dayMaxEvents: options.dayMaxEvents,\n                dayMaxEventRows: options.dayMaxEventRows,\n                showWeekNumbers: options.weekNumbers,\n                expandRows: !props.isHeightAuto,\n                headerAlignElRef: _this.headerElRef,\n                clientWidth: contentArg.clientWidth,\n                clientHeight: contentArg.clientHeight,\n                forPrint: props.forPrint\n            });\n        };\n        return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n    };\n    return DayTableView;\n}(TableView);\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n    var daySeries = new common.DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n    return new common.DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\nvar TableDateProfileGenerator = /** @class */ function(_super) {\n    tslib.__extends(TableDateProfileGenerator, _super);\n    function TableDateProfileGenerator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    // Computes the date range that will be rendered.\n    TableDateProfileGenerator.prototype.buildRenderRange = function(currentRange, currentRangeUnit, isRangeAllDay) {\n        var dateEnv = this.props.dateEnv;\n        var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n        var start = renderRange.start;\n        var end = renderRange.end;\n        var endOfWeek;\n        // year and month views should be aligned with weeks. this is already done for week\n        if (/^(year|month)$/.test(currentRangeUnit)) {\n            start = dateEnv.startOfWeek(start);\n            // make end-of-week if not already\n            endOfWeek = dateEnv.startOfWeek(end);\n            if (endOfWeek.valueOf() !== end.valueOf()) {\n                end = common.addWeeks(endOfWeek, 1);\n            }\n        }\n        // ensure 6 weeks\n        if (this.props.monthMode && this.props.fixedWeekCount) {\n            var rowCnt = Math.ceil(common.diffWeeks(start, end));\n            end = common.addWeeks(end, 6 - rowCnt);\n        }\n        return {\n            start: start,\n            end: end\n        };\n    };\n    return TableDateProfileGenerator;\n}(common.DateProfileGenerator);\nvar main = common.createPlugin({\n    initialView: \"dayGridMonth\",\n    views: {\n        dayGrid: {\n            component: DayTableView,\n            dateProfileGeneratorClass: TableDateProfileGenerator\n        },\n        dayGridDay: {\n            type: \"dayGrid\",\n            duration: {\n                days: 1\n            }\n        },\n        dayGridWeek: {\n            type: \"dayGrid\",\n            duration: {\n                weeks: 1\n            }\n        },\n        dayGridMonth: {\n            type: \"dayGrid\",\n            duration: {\n                months: 1\n            },\n            monthMode: true,\n            fixedWeekCount: true\n        }\n    }\n});\nexports.DayGridView = DayTableView;\nexports.DayTable = DayTable;\nexports.DayTableSlicer = DayTableSlicer;\nexports.Table = Table;\nexports.TableView = TableView;\nexports.buildDayTableModel = buildDayTableModel;\nexports[\"default\"] = main;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBOzs7O0FBSUEsR0FDQTtBQUVBQSw4Q0FBNkM7SUFBRUcsT0FBTyxJQUFJO0FBQUMsQ0FBQyxFQUFDO0FBRTdELElBQUlDLFNBQVNDLG1CQUFPQSxDQUFDO0FBQ3JCLElBQUlDLFFBQVFELG1CQUFPQSxDQUFDOztBQUdwQjtzSEFDc0gsR0FDdEgsa0ZBQWtGO0FBQ2xGLCtDQUErQztBQUMvQyxJQUFJRSxZQUFZLFdBQVcsR0FBSSxTQUFVQyxNQUFNLEVBQUU7SUFDN0NGLE1BQU1HLFNBQVMsQ0FBQ0YsV0FBV0M7SUFDM0IsU0FBU0QsWUFBWTtRQUNqQixJQUFJRyxRQUFRRixXQUFXLElBQUksSUFBSUEsT0FBT0csS0FBSyxDQUFDLElBQUksRUFBRUMsY0FBYyxJQUFJO1FBQ3BFRixNQUFNRyxXQUFXLEdBQUdULE9BQU9VLFNBQVM7UUFDcEMsT0FBT0o7SUFDWDtJQUNBSCxVQUFVUSxTQUFTLENBQUNDLGtCQUFrQixHQUFHLFNBQVVDLGdCQUFnQixFQUFFQyxXQUFXLEVBQUU7UUFDOUUsSUFBSUMsS0FBSyxJQUFJLEVBQUVDLFFBQVFELEdBQUdDLEtBQUssRUFBRUMsVUFBVUYsR0FBR0UsT0FBTztRQUNyRCxJQUFJQyxXQUFXLEVBQUU7UUFDakIsSUFBSUMsb0JBQW9CbkIsT0FBT29CLG9CQUFvQixDQUFDSCxRQUFRSSxPQUFPO1FBQ25FLElBQUlSLGtCQUFrQjtZQUNsQkssU0FBU0ksSUFBSSxDQUFDO2dCQUNWQyxNQUFNO2dCQUNOQyxLQUFLO2dCQUNMQyxVQUFVTjtnQkFDVk8sT0FBTztvQkFDSEMsT0FBTyxJQUFJLENBQUNsQixXQUFXO29CQUN2Qm1CLGdCQUFnQjtvQkFDaEJDLFlBQVloQjtnQkFDaEI7WUFDSjtRQUNKLENBQUM7UUFDREssU0FBU0ksSUFBSSxDQUFDO1lBQ1ZDLE1BQU07WUFDTkMsS0FBSztZQUNMTSxRQUFRLElBQUk7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QWM7WUFDVmhjLE1BQU07WUFDTjRiLFVBQVU7Z0JBQUVLLFFBQVE7WUFBRTtZQUN0QmxCLFdBQVcsSUFBSTtZQUNmQyxnQkFBZ0IsSUFBSTtRQUN4QjtJQUNKO0FBQ0o7QUFFQXpjLG1CQUFtQixHQUFHeWE7QUFDdEJ6YSxnQkFBZ0IsR0FBR21hO0FBQ25CbmEsc0JBQXNCLEdBQUc2WjtBQUN6QjdaLGFBQWEsR0FBRzhXO0FBQ2hCOVcsaUJBQWlCLEdBQUdLO0FBQ3BCTCwwQkFBMEIsR0FBRzBhO0FBQzdCMWEsa0JBQWUsR0FBRzZjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdHlwZXNjcmlwdC1wb3J0Zm9saW8vLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9kYXlncmlkL21haW4uY2pzLmpzP2I3YTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG5GdWxsQ2FsZW5kYXIgdjUuMTEuM1xuRG9jcyAmIExpY2Vuc2U6IGh0dHBzOi8vZnVsbGNhbGVuZGFyLmlvL1xuKGMpIDIwMjIgQWRhbSBTaGF3XG4qL1xuJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgY29tbW9uID0gcmVxdWlyZSgnQGZ1bGxjYWxlbmRhci9jb21tb24nKTtcbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG47XG5cbi8qIEFuIGFic3RyYWN0IGNsYXNzIGZvciB0aGUgZGF5Z3JpZCB2aWV3cywgYXMgd2VsbCBhcyBtb250aCB2aWV3LiBSZW5kZXJzIG9uZSBvciBtb3JlIHJvd3Mgb2YgZGF5IGNlbGxzLlxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG4vLyBJdCBpcyBhIG1hbmFnZXIgZm9yIGEgVGFibGUgc3ViY29tcG9uZW50LCB3aGljaCBkb2VzIG1vc3Qgb2YgdGhlIGhlYXZ5IGxpZnRpbmcuXG4vLyBJdCBpcyByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgd2lkdGgvaGVpZ2h0LlxudmFyIFRhYmxlVmlldyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVWaWV3LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlVmlldygpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmhlYWRlckVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRhYmxlVmlldy5wcm90b3R5cGUucmVuZGVyU2ltcGxlTGF5b3V0ID0gZnVuY3Rpb24gKGhlYWRlclJvd0NvbnRlbnQsIGJvZHlDb250ZW50KSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgc2VjdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHN0aWNreUhlYWRlckRhdGVzID0gY29tbW9uLmdldFN0aWNreUhlYWRlckRhdGVzKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIGlmIChoZWFkZXJSb3dDb250ZW50KSB7XG4gICAgICAgICAgICBzZWN0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdoZWFkZXInLFxuICAgICAgICAgICAgICAgIGlzU3RpY2t5OiBzdGlja3lIZWFkZXJEYXRlcyxcbiAgICAgICAgICAgICAgICBjaHVuazoge1xuICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgdGFibGVDbGFzc05hbWU6ICdmYy1jb2wtaGVhZGVyJyxcbiAgICAgICAgICAgICAgICAgICAgcm93Q29udGVudDogaGVhZGVyUm93Q29udGVudCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAnYm9keScsXG4gICAgICAgICAgICBrZXk6ICdib2R5JyxcbiAgICAgICAgICAgIGxpcXVpZDogdHJ1ZSxcbiAgICAgICAgICAgIGNodW5rOiB7IGNvbnRlbnQ6IGJvZHlDb250ZW50IH0sXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5WaWV3Um9vdCwgeyB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uU2ltcGxlU2Nyb2xsR3JpZCwgeyBsaXF1aWQ6ICFwcm9wcy5pc0hlaWdodEF1dG8gJiYgIXByb3BzLmZvclByaW50LCBjb2xsYXBzaWJsZVdpZHRoOiBwcm9wcy5mb3JQcmludCwgY29sczogW10gLyogVE9ETzogbWFrZSBvcHRpb25hbD8gKi8sIHNlY3Rpb25zOiBzZWN0aW9ucyB9KSkpOyB9KSk7XG4gICAgfTtcbiAgICBUYWJsZVZpZXcucHJvdG90eXBlLnJlbmRlckhTY3JvbGxMYXlvdXQgPSBmdW5jdGlvbiAoaGVhZGVyUm93Q29udGVudCwgYm9keUNvbnRlbnQsIGNvbENudCwgZGF5TWluV2lkdGgpIHtcbiAgICAgICAgdmFyIFNjcm9sbEdyaWQgPSB0aGlzLmNvbnRleHQucGx1Z2luSG9va3Muc2Nyb2xsR3JpZEltcGw7XG4gICAgICAgIGlmICghU2Nyb2xsR3JpZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBTY3JvbGxHcmlkIGltcGxlbWVudGF0aW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gdGhpcywgcHJvcHMgPSBfYS5wcm9wcywgY29udGV4dCA9IF9hLmNvbnRleHQ7XG4gICAgICAgIHZhciBzdGlja3lIZWFkZXJEYXRlcyA9ICFwcm9wcy5mb3JQcmludCAmJiBjb21tb24uZ2V0U3RpY2t5SGVhZGVyRGF0ZXMoY29udGV4dC5vcHRpb25zKTtcbiAgICAgICAgdmFyIHN0aWNreUZvb3RlclNjcm9sbGJhciA9ICFwcm9wcy5mb3JQcmludCAmJiBjb21tb24uZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyKGNvbnRleHQub3B0aW9ucyk7XG4gICAgICAgIHZhciBzZWN0aW9ucyA9IFtdO1xuICAgICAgICBpZiAoaGVhZGVyUm93Q29udGVudCkge1xuICAgICAgICAgICAgc2VjdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2hlYWRlcicsXG4gICAgICAgICAgICAgICAga2V5OiAnaGVhZGVyJyxcbiAgICAgICAgICAgICAgICBpc1N0aWNreTogc3RpY2t5SGVhZGVyRGF0ZXMsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbFJlZjogdGhpcy5oZWFkZXJFbFJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYmxlQ2xhc3NOYW1lOiAnZmMtY29sLWhlYWRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3dDb250ZW50OiBoZWFkZXJSb3dDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogJ2JvZHknLFxuICAgICAgICAgICAga2V5OiAnYm9keScsXG4gICAgICAgICAgICBsaXF1aWQ6IHRydWUsXG4gICAgICAgICAgICBjaHVua3M6IFt7XG4gICAgICAgICAgICAgICAgICAgIGtleTogJ21haW4nLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBib2R5Q29udGVudCxcbiAgICAgICAgICAgICAgICB9XSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGlja3lGb290ZXJTY3JvbGxiYXIpIHtcbiAgICAgICAgICAgIHNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdmb290ZXInLFxuICAgICAgICAgICAgICAgIGtleTogJ2Zvb3RlcicsXG4gICAgICAgICAgICAgICAgaXNTdGlja3k6IHRydWUsXG4gICAgICAgICAgICAgICAgY2h1bmtzOiBbe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiAnbWFpbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBjb21tb24ucmVuZGVyU2Nyb2xsU2hpbSxcbiAgICAgICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5WaWV3Um9vdCwgeyB2aWV3U3BlYzogY29udGV4dC52aWV3U3BlYyB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyByZWY6IHJvb3RFbFJlZiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQnXS5jb25jYXQoY2xhc3NOYW1lcykuam9pbignICcpIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChTY3JvbGxHcmlkLCB7IGxpcXVpZDogIXByb3BzLmlzSGVpZ2h0QXV0byAmJiAhcHJvcHMuZm9yUHJpbnQsIGNvbGxhcHNpYmxlV2lkdGg6IHByb3BzLmZvclByaW50LCBjb2xHcm91cHM6IFt7IGNvbHM6IFt7IHNwYW46IGNvbENudCwgbWluV2lkdGg6IGRheU1pbldpZHRoIH1dIH1dLCBzZWN0aW9uczogc2VjdGlvbnMgfSkpKTsgfSkpO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlVmlldztcbn0oY29tbW9uLkRhdGVDb21wb25lbnQpKTtcblxuZnVuY3Rpb24gc3BsaXRTZWdzQnlSb3coc2Vncywgcm93Q250KSB7XG4gICAgdmFyIGJ5Um93ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICBieVJvd1tpXSA9IFtdO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIHNlZ3NfMSA9IHNlZ3M7IF9pIDwgc2Vnc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgc2VnID0gc2Vnc18xW19pXTtcbiAgICAgICAgYnlSb3dbc2VnLnJvd10ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlSb3c7XG59XG5mdW5jdGlvbiBzcGxpdFNlZ3NCeUZpcnN0Q29sKHNlZ3MsIGNvbENudCkge1xuICAgIHZhciBieUNvbCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29sQ250OyBpICs9IDEpIHtcbiAgICAgICAgYnlDb2xbaV0gPSBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwLCBzZWdzXzIgPSBzZWdzOyBfaSA8IHNlZ3NfMi5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMltfaV07XG4gICAgICAgIGJ5Q29sW3NlZy5maXJzdENvbF0ucHVzaChzZWcpO1xuICAgIH1cbiAgICByZXR1cm4gYnlDb2w7XG59XG5mdW5jdGlvbiBzcGxpdEludGVyYWN0aW9uQnlSb3codWksIHJvd0NudCkge1xuICAgIHZhciBieVJvdyA9IFtdO1xuICAgIGlmICghdWkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDbnQ7IGkgKz0gMSkge1xuICAgICAgICAgICAgYnlSb3dbaV0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJvd0NudDsgaSArPSAxKSB7XG4gICAgICAgICAgICBieVJvd1tpXSA9IHtcbiAgICAgICAgICAgICAgICBhZmZlY3RlZEluc3RhbmNlczogdWkuYWZmZWN0ZWRJbnN0YW5jZXMsXG4gICAgICAgICAgICAgICAgaXNFdmVudDogdWkuaXNFdmVudCxcbiAgICAgICAgICAgICAgICBzZWdzOiBbXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IHVpLnNlZ3M7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnID0gX2FbX2ldO1xuICAgICAgICAgICAgYnlSb3dbc2VnLnJvd10uc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJ5Um93O1xufVxuXG52YXIgVGFibGVDZWxsVG9wID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhUYWJsZUNlbGxUb3AsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsVG9wKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFRhYmxlQ2VsbFRvcC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgbmF2TGlua0F0dHJzID0gY29tbW9uLmJ1aWxkTmF2TGlua0F0dHJzKHRoaXMuY29udGV4dCwgcHJvcHMuZGF0ZSk7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUNlbGxDb250ZW50LCB7IGRhdGU6IHByb3BzLmRhdGUsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLCBkZWZhdWx0Q29udGVudDogcmVuZGVyVG9wSW5uZXIgfSwgZnVuY3Rpb24gKGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKChpbm5lckNvbnRlbnQgfHwgcHJvcHMuZm9yY2VEYXlUb3ApICYmIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS10b3BcIiwgcmVmOiBpbm5lckVsUmVmIH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyBpZDogcHJvcHMuZGF5TnVtYmVySWQsIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1udW1iZXJcIiB9LCBuYXZMaW5rQXR0cnMpLCBpbm5lckNvbnRlbnQgfHwgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsVG9wO1xufShjb21tb24uQmFzZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gcmVuZGVyVG9wSW5uZXIocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuZGF5TnVtYmVyVGV4dDtcbn1cblxudmFyIERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQgPSBjb21tb24uY3JlYXRlRm9ybWF0dGVyKHtcbiAgICBob3VyOiAnbnVtZXJpYycsXG4gICAgbWludXRlOiAnMi1kaWdpdCcsXG4gICAgb21pdFplcm9NaW51dGU6IHRydWUsXG4gICAgbWVyaWRpZW06ICduYXJyb3cnLFxufSk7XG5mdW5jdGlvbiBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSB7XG4gICAgdmFyIGRpc3BsYXkgPSBzZWcuZXZlbnRSYW5nZS51aS5kaXNwbGF5O1xuICAgIHJldHVybiBkaXNwbGF5ID09PSAnbGlzdC1pdGVtJyB8fCAoZGlzcGxheSA9PT0gJ2F1dG8nICYmXG4gICAgICAgICFzZWcuZXZlbnRSYW5nZS5kZWYuYWxsRGF5ICYmXG4gICAgICAgIHNlZy5maXJzdENvbCA9PT0gc2VnLmxhc3RDb2wgJiYgLy8gY2FuJ3QgYmUgbXVsdGktZGF5XG4gICAgICAgIHNlZy5pc1N0YXJ0ICYmIC8vIFwiXG4gICAgICAgIHNlZy5pc0VuZCAvLyBcIlxuICAgICk7XG59XG5cbnZhciBUYWJsZUJsb2NrRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlQmxvY2tFdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUJsb2NrRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFibGVCbG9ja0V2ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLlN0YW5kYXJkRXZlbnQsIHRzbGliLl9fYXNzaWduKHt9LCBwcm9wcywgeyBleHRyYUNsYXNzTmFtZXM6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWJsb2NrLWV2ZW50JywgJ2ZjLWgtZXZlbnQnXSwgZGVmYXVsdFRpbWVGb3JtYXQ6IERFRkFVTFRfVEFCTEVfRVZFTlRfVElNRV9GT1JNQVQsIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IHByb3BzLmRlZmF1bHREaXNwbGF5RXZlbnRFbmQsIGRpc2FibGVSZXNpemluZzogIXByb3BzLnNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXkgfSkpKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUJsb2NrRXZlbnQ7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5cbnZhciBUYWJsZUxpc3RJdGVtRXZlbnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlTGlzdEl0ZW1FdmVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZUxpc3RJdGVtRXZlbnQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGFibGVMaXN0SXRlbUV2ZW50LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGNvbnRleHQgPSBfYS5jb250ZXh0O1xuICAgICAgICB2YXIgdGltZUZvcm1hdCA9IGNvbnRleHQub3B0aW9ucy5ldmVudFRpbWVGb3JtYXQgfHwgREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVDtcbiAgICAgICAgdmFyIHRpbWVUZXh0ID0gY29tbW9uLmJ1aWxkU2VnVGltZVRleHQocHJvcHMuc2VnLCB0aW1lRm9ybWF0LCBjb250ZXh0LCB0cnVlLCBwcm9wcy5kZWZhdWx0RGlzcGxheUV2ZW50RW5kKTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRXZlbnRSb290LCB7IHNlZzogcHJvcHMuc2VnLCB0aW1lVGV4dDogdGltZVRleHQsIGRlZmF1bHRDb250ZW50OiByZW5kZXJJbm5lckNvbnRlbnQsIGlzRHJhZ2dpbmc6IHByb3BzLmlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGZhbHNlLCBpc0RhdGVTZWxlY3Rpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBwcm9wcy5pc1NlbGVjdGVkLCBpc1Bhc3Q6IHByb3BzLmlzUGFzdCwgaXNGdXR1cmU6IHByb3BzLmlzRnV0dXJlLCBpc1RvZGF5OiBwcm9wcy5pc1RvZGF5IH0sIGZ1bmN0aW9uIChyb290RWxSZWYsIGNsYXNzTmFtZXMsIGlubmVyRWxSZWYsIGlubmVyQ29udGVudCkgeyByZXR1cm4gKCAvLyB3ZSBkb24ndCB1c2Ugc3R5bGVzIVxuICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImFcIiwgdHNsaWIuX19hc3NpZ24oeyBjbGFzc05hbWU6IFsnZmMtZGF5Z3JpZC1ldmVudCcsICdmYy1kYXlncmlkLWRvdC1ldmVudCddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHJlZjogcm9vdEVsUmVmIH0sIGNvbW1vbi5nZXRTZWdBbmNob3JBdHRycyhwcm9wcy5zZWcsIGNvbnRleHQpKSwgaW5uZXJDb250ZW50KSk7IH0pKTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZUxpc3RJdGVtRXZlbnQ7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiByZW5kZXJJbm5lckNvbnRlbnQoaW5uZXJQcm9wcykge1xuICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLFxuICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWV2ZW50LWRvdFwiLCBzdHlsZTogeyBib3JkZXJDb2xvcjogaW5uZXJQcm9wcy5ib3JkZXJDb2xvciB8fCBpbm5lclByb3BzLmJhY2tncm91bmRDb2xvciB9IH0pLFxuICAgICAgICBpbm5lclByb3BzLnRpbWVUZXh0ICYmIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aW1lXCIgfSwgaW5uZXJQcm9wcy50aW1lVGV4dCkpLFxuICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1ldmVudC10aXRsZVwiIH0sIGlubmVyUHJvcHMuZXZlbnQudGl0bGUgfHwgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLCBcIlxcdTAwQTBcIikpKSk7XG59XG5cbnZhciBUYWJsZUNlbGxNb3JlTGluayA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVDZWxsTW9yZUxpbmssIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGVDZWxsTW9yZUxpbmsoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5jb21waWxlU2VncyA9IGNvbW1vbi5tZW1vaXplKGNvbXBpbGVTZWdzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZUNlbGxNb3JlTGluay5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmNvbXBpbGVTZWdzKHByb3BzLnNpbmdsZVBsYWNlbWVudHMpLCBhbGxTZWdzID0gX2EuYWxsU2VncywgaW52aXNpYmxlU2VncyA9IF9hLmludmlzaWJsZVNlZ3M7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLk1vcmVMaW5rUm9vdCwgeyBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGFsbERheURhdGU6IHByb3BzLmFsbERheURhdGUsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsbFNlZ3M6IGFsbFNlZ3MsIGhpZGRlblNlZ3M6IGludmlzaWJsZVNlZ3MsIGFsaWdubWVudEVsUmVmOiBwcm9wcy5hbGlnbm1lbnRFbFJlZiwgYWxpZ25HcmlkVG9wOiBwcm9wcy5hbGlnbkdyaWRUb3AsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIHBvcG92ZXJDb250ZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzRm9yY2VkSW52aXNpYmxlID0gKHByb3BzLmV2ZW50RHJhZyA/IHByb3BzLmV2ZW50RHJhZy5hZmZlY3RlZEluc3RhbmNlcyA6IG51bGwpIHx8XG4gICAgICAgICAgICAgICAgICAgIChwcm9wcy5ldmVudFJlc2l6ZSA/IHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzIDogbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAgICAge307XG4gICAgICAgICAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsIGFsbFNlZ3MubWFwKGZ1bmN0aW9uIChzZWcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcImZjLWRheWdyaWQtZXZlbnQtaGFybmVzc1wiLCBrZXk6IGluc3RhbmNlSWQsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlzaWJpbGl0eTogaXNGb3JjZWRJbnZpc2libGVbaW5zdGFuY2VJZF0gPyAnaGlkZGVuJyA6ICcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSB9LCBoYXNMaXN0SXRlbURpc3BsYXkoc2VnKSA/IChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUxpc3RJdGVtRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZmFsc2UgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCBwcm9wcy50b2RheVJhbmdlKSkpKSA6IChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGZhbHNlLCBpc1Jlc2l6aW5nOiBmYWxzZSwgaXNEYXRlU2VsZWN0aW5nOiBmYWxzZSwgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gcHJvcHMuZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGZhbHNlIH0sIGNvbW1vbi5nZXRTZWdNZXRhKHNlZywgcHJvcHMudG9kYXlSYW5nZSkpKSkpKTtcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfSB9LCBmdW5jdGlvbiAocm9vdEVsUmVmLCBjbGFzc05hbWVzLCBpbm5lckVsUmVmLCBpbm5lckNvbnRlbnQsIGhhbmRsZUNsaWNrLCB0aXRsZSwgaXNFeHBhbmRlZCwgcG9wb3ZlcklkKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiByb290RWxSZWYsIGNsYXNzTmFtZTogWydmYy1kYXlncmlkLW1vcmUtbGluayddLmNvbmNhdChjbGFzc05hbWVzKS5qb2luKCcgJyksIHRpdGxlOiB0aXRsZSwgXCJhcmlhLWV4cGFuZGVkXCI6IGlzRXhwYW5kZWQsIFwiYXJpYS1jb250cm9sc1wiOiBwb3BvdmVySWQgfSwgY29tbW9uLmNyZWF0ZUFyaWFDbGlja0F0dHJzKGhhbmRsZUNsaWNrKSksIGlubmVyQ29udGVudCkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsTW9yZUxpbms7XG59KGNvbW1vbi5CYXNlQ29tcG9uZW50KSk7XG5mdW5jdGlvbiBjb21waWxlU2VncyhzaW5nbGVQbGFjZW1lbnRzKSB7XG4gICAgdmFyIGFsbFNlZ3MgPSBbXTtcbiAgICB2YXIgaW52aXNpYmxlU2VncyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMCwgc2luZ2xlUGxhY2VtZW50c18xID0gc2luZ2xlUGxhY2VtZW50czsgX2kgPCBzaW5nbGVQbGFjZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBzaW5nbGVQbGFjZW1lbnRzXzFbX2ldO1xuICAgICAgICBhbGxTZWdzLnB1c2gocGxhY2VtZW50LnNlZyk7XG4gICAgICAgIGlmICghcGxhY2VtZW50LmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgaW52aXNpYmxlU2Vncy5wdXNoKHBsYWNlbWVudC5zZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGFsbFNlZ3M6IGFsbFNlZ3MsIGludmlzaWJsZVNlZ3M6IGludmlzaWJsZVNlZ3MgfTtcbn1cblxudmFyIERFRkFVTFRfV0VFS19OVU1fRk9STUFUID0gY29tbW9uLmNyZWF0ZUZvcm1hdHRlcih7IHdlZWs6ICduYXJyb3cnIH0pO1xudmFyIFRhYmxlQ2VsbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVDZWxsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlQ2VsbCgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnJvb3RFbFJlZiA9IGNvbW1vbi5jcmVhdGVSZWYoKTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICAgICAgICBkYXlOdW1iZXJJZDogY29tbW9uLmdldFVuaXF1ZURvbUlkKCksXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLmhhbmRsZVJvb3RFbCA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgY29tbW9uLnNldFJlZihfdGhpcy5yb290RWxSZWYsIGVsKTtcbiAgICAgICAgICAgIGNvbW1vbi5zZXRSZWYoX3RoaXMucHJvcHMuZWxSZWYsIGVsKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZUNlbGwucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29udGV4dCA9IF9hLmNvbnRleHQsIHByb3BzID0gX2EucHJvcHMsIHN0YXRlID0gX2Euc3RhdGUsIHJvb3RFbFJlZiA9IF9hLnJvb3RFbFJlZjtcbiAgICAgICAgdmFyIGRhdGUgPSBwcm9wcy5kYXRlLCBkYXRlUHJvZmlsZSA9IHByb3BzLmRhdGVQcm9maWxlO1xuICAgICAgICB2YXIgbmF2TGlua0F0dHJzID0gY29tbW9uLmJ1aWxkTmF2TGlua0F0dHJzKGNvbnRleHQsIGRhdGUsICd3ZWVrJyk7XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUNlbGxSb290LCB7IGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgdG9kYXlSYW5nZTogcHJvcHMudG9kYXlSYW5nZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZXh0cmFIb29rUHJvcHM6IHByb3BzLmV4dHJhSG9va1Byb3BzLCBlbFJlZjogdGhpcy5oYW5kbGVSb290RWwgfSwgZnVuY3Rpb24gKGRheUVsUmVmLCBkYXlDbGFzc05hbWVzLCByb290RGF0YUF0dHJzLCBpc0Rpc2FibGVkKSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0ZFwiLCB0c2xpYi5fX2Fzc2lnbih7IHJlZjogZGF5RWxSZWYsIHJvbGU6IFwiZ3JpZGNlbGxcIiwgY2xhc3NOYW1lOiBbJ2ZjLWRheWdyaWQtZGF5J10uY29uY2F0KGRheUNsYXNzTmFtZXMsIHByb3BzLmV4dHJhQ2xhc3NOYW1lcyB8fCBbXSkuam9pbignICcpIH0sIHJvb3REYXRhQXR0cnMsIHByb3BzLmV4dHJhRGF0YUF0dHJzLCAocHJvcHMuc2hvd0RheU51bWJlciA/IHsgJ2FyaWEtbGFiZWxsZWRieSc6IHN0YXRlLmRheU51bWJlcklkIH0gOiB7fSkpLFxuICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZnJhbWUgZmMtc2Nyb2xsZ3JpZC1zeW5jLWlubmVyXCIsIHJlZjogcHJvcHMuaW5uZXJFbFJlZiAvKiBkaWZmZXJlbnQgZnJvbSBob29rIHN5c3RlbSEgUkVOQU1FICovIH0sXG4gICAgICAgICAgICAgICAgcHJvcHMuc2hvd1dlZWtOdW1iZXIgJiYgKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5XZWVrTnVtYmVyUm9vdCwgeyBkYXRlOiBkYXRlLCBkZWZhdWx0Rm9ybWF0OiBERUZBVUxUX1dFRUtfTlVNX0ZPUk1BVCB9LCBmdW5jdGlvbiAod2Vla0VsUmVmLCB3ZWVrQ2xhc3NOYW1lcywgaW5uZXJFbFJlZiwgaW5uZXJDb250ZW50KSB7IHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJhXCIsIHRzbGliLl9fYXNzaWduKHsgcmVmOiB3ZWVrRWxSZWYsIGNsYXNzTmFtZTogWydmYy1kYXlncmlkLXdlZWstbnVtYmVyJ10uY29uY2F0KHdlZWtDbGFzc05hbWVzKS5qb2luKCcgJykgfSwgbmF2TGlua0F0dHJzKSwgaW5uZXJDb250ZW50KSk7IH0pKSxcbiAgICAgICAgICAgICAgICAhaXNEaXNhYmxlZCAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsVG9wLCB7IGRhdGU6IGRhdGUsIGRhdGVQcm9maWxlOiBkYXRlUHJvZmlsZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlciwgZGF5TnVtYmVySWQ6IHN0YXRlLmRheU51bWJlcklkLCBmb3JjZURheVRvcDogcHJvcHMuZm9yY2VEYXlUb3AsIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV4dHJhSG9va1Byb3BzOiBwcm9wcy5leHRyYUhvb2tQcm9wcyB9KSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktZXZlbnRzXCIsIHJlZjogcHJvcHMuZmdDb250ZW50RWxSZWYgfSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcHMuZmdDb250ZW50LFxuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWRheS1ib3R0b21cIiwgc3R5bGU6IHsgbWFyZ2luVG9wOiBwcm9wcy5tb3JlTWFyZ2luVG9wIH0gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlQ2VsbE1vcmVMaW5rLCB7IGFsbERheURhdGU6IGRhdGUsIHNpbmdsZVBsYWNlbWVudHM6IHByb3BzLnNpbmdsZVBsYWNlbWVudHMsIG1vcmVDbnQ6IHByb3BzLm1vcmVDbnQsIGFsaWdubWVudEVsUmVmOiByb290RWxSZWYsIGFsaWduR3JpZFRvcDogIXByb3BzLnNob3dEYXlOdW1iZXIsIGV4dHJhRGF0ZVNwYW46IHByb3BzLmV4dHJhRGF0ZVNwYW4sIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBldmVudERyYWc6IHByb3BzLmV2ZW50RHJhZywgZXZlbnRSZXNpemU6IHByb3BzLmV2ZW50UmVzaXplLCB0b2RheVJhbmdlOiBwcm9wcy50b2RheVJhbmdlIH0pKSksXG4gICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwiZmMtZGF5Z3JpZC1kYXktYmdcIiB9LCBwcm9wcy5iZ0NvbnRlbnQpKSkpOyB9KSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGFibGVDZWxsO1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBjb21wdXRlRmdTZWdQbGFjZW1lbnQoc2VncywgLy8gYXNzdW1lZCBhbHJlYWR5IHNvcnRlZFxuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3MsIHN0cmljdE9yZGVyLCBldmVudEluc3RhbmNlSGVpZ2h0cywgbWF4Q29udGVudEhlaWdodCwgY2VsbHMpIHtcbiAgICB2YXIgaGllcmFyY2h5ID0gbmV3IERheUdyaWRTZWdIaWVyYXJjaHkoKTtcbiAgICBoaWVyYXJjaHkuYWxsb3dSZXNsaWNpbmcgPSB0cnVlO1xuICAgIGhpZXJhcmNoeS5zdHJpY3RPcmRlciA9IHN0cmljdE9yZGVyO1xuICAgIGlmIChkYXlNYXhFdmVudHMgPT09IHRydWUgfHwgZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhDb29yZCA9IG1heENvbnRlbnRIZWlnaHQ7XG4gICAgICAgIGhpZXJhcmNoeS5oaWRkZW5Db25zdW1lcyA9IHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXlNYXhFdmVudHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGhpZXJhcmNoeS5tYXhTdGFja0NudCA9IGRheU1heEV2ZW50cztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRheU1heEV2ZW50Um93cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaGllcmFyY2h5Lm1heFN0YWNrQ250ID0gZGF5TWF4RXZlbnRSb3dzO1xuICAgICAgICBoaWVyYXJjaHkuaGlkZGVuQ29uc3VtZXMgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBjcmVhdGUgc2VnSW5wdXRzIG9ubHkgZm9yIHNlZ3Mgd2l0aCBrbm93biBoZWlnaHRzXG4gICAgdmFyIHNlZ0lucHV0cyA9IFtdO1xuICAgIHZhciB1bmtub3duSGVpZ2h0U2VncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2Vncy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2VnID0gc2Vnc1tpXTtcbiAgICAgICAgdmFyIGluc3RhbmNlSWQgPSBzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkO1xuICAgICAgICB2YXIgZXZlbnRIZWlnaHQgPSBldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXTtcbiAgICAgICAgaWYgKGV2ZW50SGVpZ2h0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlZ0lucHV0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbmRleDogaSxcbiAgICAgICAgICAgICAgICB0aGlja25lc3M6IGV2ZW50SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNwYW46IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHNlZy5maXJzdENvbCxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiBzZWcubGFzdENvbCArIDEsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdW5rbm93bkhlaWdodFNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBoaWRkZW5FbnRyaWVzID0gaGllcmFyY2h5LmFkZFNlZ3Moc2VnSW5wdXRzKTtcbiAgICB2YXIgc2VnUmVjdHMgPSBoaWVyYXJjaHkudG9SZWN0cygpO1xuICAgIHZhciBfYSA9IHBsYWNlUmVjdHMoc2VnUmVjdHMsIHNlZ3MsIGNlbGxzKSwgc2luZ2xlQ29sUGxhY2VtZW50cyA9IF9hLnNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50cyA9IF9hLm11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zID0gX2EubGVmdG92ZXJNYXJnaW5zO1xuICAgIHZhciBtb3JlQ250cyA9IFtdO1xuICAgIHZhciBtb3JlTWFyZ2luVG9wcyA9IFtdO1xuICAgIC8vIGFkZCBzZWdzIHdpdGggdW5rbm93biBoZWlnaHRzXG4gICAgZm9yICh2YXIgX2kgPSAwLCB1bmtub3duSGVpZ2h0U2Vnc18xID0gdW5rbm93bkhlaWdodFNlZ3M7IF9pIDwgdW5rbm93bkhlaWdodFNlZ3NfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIHNlZyA9IHVua25vd25IZWlnaHRTZWdzXzFbX2ldO1xuICAgICAgICBtdWx0aUNvbFBsYWNlbWVudHNbc2VnLmZpcnN0Q29sXS5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogc2VnLFxuICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzQWJzb2x1dGU6IHRydWUsXG4gICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IHNlZy5maXJzdENvbDsgY29sIDw9IHNlZy5sYXN0Q29sOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgc2luZ2xlQ29sUGxhY2VtZW50c1tjb2xdLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgYWJzb2x1dGVUb3A6IDAsXG4gICAgICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gYWRkIHRoZSBoaWRkZW4gZW50cmllc1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZUNudHMucHVzaCgwKTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2IgPSAwLCBoaWRkZW5FbnRyaWVzXzEgPSBoaWRkZW5FbnRyaWVzOyBfYiA8IGhpZGRlbkVudHJpZXNfMS5sZW5ndGg7IF9iKyspIHtcbiAgICAgICAgdmFyIGhpZGRlbkVudHJ5ID0gaGlkZGVuRW50cmllc18xW19iXTtcbiAgICAgICAgdmFyIHNlZyA9IHNlZ3NbaGlkZGVuRW50cnkuaW5kZXhdO1xuICAgICAgICB2YXIgaGlkZGVuU3BhbiA9IGhpZGRlbkVudHJ5LnNwYW47XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50c1toaWRkZW5TcGFuLnN0YXJ0XS5wdXNoKHtcbiAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGhpZGRlblNwYW4uc3RhcnQsIGhpZGRlblNwYW4uZW5kLCBjZWxscyksXG4gICAgICAgICAgICBpc1Zpc2libGU6IGZhbHNlLFxuICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgIGFic29sdXRlVG9wOiAwLFxuICAgICAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgICAgICB9KTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gaGlkZGVuU3Bhbi5zdGFydDsgY29sIDwgaGlkZGVuU3Bhbi5lbmQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgICBtb3JlQ250c1tjb2xdICs9IDE7XG4gICAgICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0ucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VnOiByZXNsaWNlU2VnKHNlZywgY29sLCBjb2wgKyAxLCBjZWxscyksXG4gICAgICAgICAgICAgICAgaXNWaXNpYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogMCxcbiAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkZWFsIHdpdGggbGVmdG92ZXIgbWFyZ2luc1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNlbGxzLmxlbmd0aDsgY29sICs9IDEpIHtcbiAgICAgICAgbW9yZU1hcmdpblRvcHMucHVzaChsZWZ0b3Zlck1hcmdpbnNbY29sXSk7XG4gICAgfVxuICAgIHJldHVybiB7IHNpbmdsZUNvbFBsYWNlbWVudHM6IHNpbmdsZUNvbFBsYWNlbWVudHMsIG11bHRpQ29sUGxhY2VtZW50czogbXVsdGlDb2xQbGFjZW1lbnRzLCBtb3JlQ250czogbW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzOiBtb3JlTWFyZ2luVG9wcyB9O1xufVxuLy8gcmVjdHMgb3JkZXJlZCBieSB0b3AgY29vcmQsIHRoZW4gbGVmdFxuZnVuY3Rpb24gcGxhY2VSZWN0cyhhbGxSZWN0cywgc2VncywgY2VsbHMpIHtcbiAgICB2YXIgcmVjdHNCeUVhY2hDb2wgPSBncm91cFJlY3RzQnlFYWNoQ29sKGFsbFJlY3RzLCBjZWxscy5sZW5ndGgpO1xuICAgIHZhciBzaW5nbGVDb2xQbGFjZW1lbnRzID0gW107XG4gICAgdmFyIG11bHRpQ29sUGxhY2VtZW50cyA9IFtdO1xuICAgIHZhciBsZWZ0b3Zlck1hcmdpbnMgPSBbXTtcbiAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBjZWxscy5sZW5ndGg7IGNvbCArPSAxKSB7XG4gICAgICAgIHZhciByZWN0cyA9IHJlY3RzQnlFYWNoQ29sW2NvbF07XG4gICAgICAgIC8vIGNvbXB1dGUgYWxsIHN0YXRpYyBzZWdzIGluIHNpbmdsZVBsYWNlbWVudHNcbiAgICAgICAgdmFyIHNpbmdsZVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgdmFyIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICB2YXIgY3VycmVudE1hcmdpblRvcCA9IDA7XG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcmVjdHNfMSA9IHJlY3RzOyBfaSA8IHJlY3RzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IHJlY3RzXzFbX2ldO1xuICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NbcmVjdC5pbmRleF07XG4gICAgICAgICAgICBzaW5nbGVQbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIGNvbCwgY29sICsgMSwgY2VsbHMpLFxuICAgICAgICAgICAgICAgIGlzVmlzaWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0Fic29sdXRlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgIG1hcmdpblRvcDogcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCA9IHJlY3QubGV2ZWxDb29yZCArIHJlY3QudGhpY2tuZXNzO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbXB1dGUgbWl4ZWQgc3RhdGljL2Fic29sdXRlIHNlZ3MgaW4gbXVsdGlQbGFjZW1lbnRzXG4gICAgICAgIHZhciBtdWx0aVBsYWNlbWVudHMgPSBbXTtcbiAgICAgICAgY3VycmVudEhlaWdodCA9IDA7XG4gICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgPSAwO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHJlY3RzXzIgPSByZWN0czsgX2EgPCByZWN0c18yLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIHJlY3QgPSByZWN0c18yW19hXTtcbiAgICAgICAgICAgIHZhciBzZWcgPSBzZWdzW3JlY3QuaW5kZXhdO1xuICAgICAgICAgICAgdmFyIGlzQWJzb2x1dGUgPSByZWN0LnNwYW4uZW5kIC0gcmVjdC5zcGFuLnN0YXJ0ID4gMTsgLy8gbXVsdGktY29sdW1uP1xuICAgICAgICAgICAgdmFyIGlzRmlyc3RDb2wgPSByZWN0LnNwYW4uc3RhcnQgPT09IGNvbDtcbiAgICAgICAgICAgIGN1cnJlbnRNYXJnaW5Ub3AgKz0gcmVjdC5sZXZlbENvb3JkIC0gY3VycmVudEhlaWdodDsgLy8gYW1vdW50IG9mIHNwYWNlIHNpbmNlIGJvdHRvbSBvZiBwcmV2aW91cyBzZWdcbiAgICAgICAgICAgIGN1cnJlbnRIZWlnaHQgPSByZWN0LmxldmVsQ29vcmQgKyByZWN0LnRoaWNrbmVzczsgLy8gaGVpZ2h0IHdpbGwgbm93IGJlIGJvdHRvbSBvZiBjdXJyZW50IHNlZ1xuICAgICAgICAgICAgaWYgKGlzQWJzb2x1dGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wICs9IHJlY3QudGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpcnN0Q29sKSB7XG4gICAgICAgICAgICAgICAgICAgIG11bHRpUGxhY2VtZW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYnNvbHV0ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFic29sdXRlVG9wOiByZWN0LmxldmVsQ29vcmQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RDb2wpIHtcbiAgICAgICAgICAgICAgICBtdWx0aVBsYWNlbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHNlZzogcmVzbGljZVNlZyhzZWcsIHJlY3Quc3Bhbi5zdGFydCwgcmVjdC5zcGFuLmVuZCwgY2VsbHMpLFxuICAgICAgICAgICAgICAgICAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzQWJzb2x1dGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBhYnNvbHV0ZVRvcDogcmVjdC5sZXZlbENvb3JkLFxuICAgICAgICAgICAgICAgICAgICBtYXJnaW5Ub3A6IGN1cnJlbnRNYXJnaW5Ub3AsIC8vIGNsYWltIHRoZSBtYXJnaW5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFyZ2luVG9wID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzaW5nbGVDb2xQbGFjZW1lbnRzLnB1c2goc2luZ2xlUGxhY2VtZW50cyk7XG4gICAgICAgIG11bHRpQ29sUGxhY2VtZW50cy5wdXNoKG11bHRpUGxhY2VtZW50cyk7XG4gICAgICAgIGxlZnRvdmVyTWFyZ2lucy5wdXNoKGN1cnJlbnRNYXJnaW5Ub3ApO1xuICAgIH1cbiAgICByZXR1cm4geyBzaW5nbGVDb2xQbGFjZW1lbnRzOiBzaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHM6IG11bHRpQ29sUGxhY2VtZW50cywgbGVmdG92ZXJNYXJnaW5zOiBsZWZ0b3Zlck1hcmdpbnMgfTtcbn1cbmZ1bmN0aW9uIGdyb3VwUmVjdHNCeUVhY2hDb2wocmVjdHMsIGNvbENudCkge1xuICAgIHZhciByZWN0c0J5RWFjaENvbCA9IFtdO1xuICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IGNvbENudDsgY29sICs9IDEpIHtcbiAgICAgICAgcmVjdHNCeUVhY2hDb2wucHVzaChbXSk7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMCwgcmVjdHNfMyA9IHJlY3RzOyBfaSA8IHJlY3RzXzMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByZWN0ID0gcmVjdHNfM1tfaV07XG4gICAgICAgIGZvciAodmFyIGNvbCA9IHJlY3Quc3Bhbi5zdGFydDsgY29sIDwgcmVjdC5zcGFuLmVuZDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHJlY3RzQnlFYWNoQ29sW2NvbF0ucHVzaChyZWN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjdHNCeUVhY2hDb2w7XG59XG5mdW5jdGlvbiByZXNsaWNlU2VnKHNlZywgc3BhblN0YXJ0LCBzcGFuRW5kLCBjZWxscykge1xuICAgIGlmIChzZWcuZmlyc3RDb2wgPT09IHNwYW5TdGFydCAmJiBzZWcubGFzdENvbCA9PT0gc3BhbkVuZCAtIDEpIHtcbiAgICAgICAgcmV0dXJuIHNlZztcbiAgICB9XG4gICAgdmFyIGV2ZW50UmFuZ2UgPSBzZWcuZXZlbnRSYW5nZTtcbiAgICB2YXIgb3JpZ1JhbmdlID0gZXZlbnRSYW5nZS5yYW5nZTtcbiAgICB2YXIgc2xpY2VkUmFuZ2UgPSBjb21tb24uaW50ZXJzZWN0UmFuZ2VzKG9yaWdSYW5nZSwge1xuICAgICAgICBzdGFydDogY2VsbHNbc3BhblN0YXJ0XS5kYXRlLFxuICAgICAgICBlbmQ6IGNvbW1vbi5hZGREYXlzKGNlbGxzW3NwYW5FbmQgLSAxXS5kYXRlLCAxKSxcbiAgICB9KTtcbiAgICByZXR1cm4gdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIHNlZyksIHsgZmlyc3RDb2w6IHNwYW5TdGFydCwgbGFzdENvbDogc3BhbkVuZCAtIDEsIGV2ZW50UmFuZ2U6IHtcbiAgICAgICAgICAgIGRlZjogZXZlbnRSYW5nZS5kZWYsXG4gICAgICAgICAgICB1aTogdHNsaWIuX19hc3NpZ24odHNsaWIuX19hc3NpZ24oe30sIGV2ZW50UmFuZ2UudWkpLCB7IGR1cmF0aW9uRWRpdGFibGU6IGZhbHNlIH0pLFxuICAgICAgICAgICAgaW5zdGFuY2U6IGV2ZW50UmFuZ2UuaW5zdGFuY2UsXG4gICAgICAgICAgICByYW5nZTogc2xpY2VkUmFuZ2UsXG4gICAgICAgIH0sIGlzU3RhcnQ6IHNlZy5pc1N0YXJ0ICYmIHNsaWNlZFJhbmdlLnN0YXJ0LnZhbHVlT2YoKSA9PT0gb3JpZ1JhbmdlLnN0YXJ0LnZhbHVlT2YoKSwgaXNFbmQ6IHNlZy5pc0VuZCAmJiBzbGljZWRSYW5nZS5lbmQudmFsdWVPZigpID09PSBvcmlnUmFuZ2UuZW5kLnZhbHVlT2YoKSB9KTtcbn1cbnZhciBEYXlHcmlkU2VnSGllcmFyY2h5ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlHcmlkU2VnSGllcmFyY2h5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERheUdyaWRTZWdIaWVyYXJjaHkoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICAvLyBjb25maWdcbiAgICAgICAgX3RoaXMuaGlkZGVuQ29uc3VtZXMgPSBmYWxzZTtcbiAgICAgICAgLy8gYWxsb3dzIHVzIHRvIGtlZXAgaGlkZGVuIGVudHJpZXMgaW4gdGhlIGhpZXJhcmNoeSBzbyB0aGV5IHRha2UgdXAgc3BhY2VcbiAgICAgICAgX3RoaXMuZm9yY2VIaWRkZW4gPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlHcmlkU2VnSGllcmFyY2h5LnByb3RvdHlwZS5hZGRTZWdzID0gZnVuY3Rpb24gKHNlZ0lucHV0cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgaGlkZGVuU2VncyA9IF9zdXBlci5wcm90b3R5cGUuYWRkU2Vncy5jYWxsKHRoaXMsIHNlZ0lucHV0cyk7XG4gICAgICAgIHZhciBlbnRyaWVzQnlMZXZlbCA9IHRoaXMuZW50cmllc0J5TGV2ZWw7XG4gICAgICAgIHZhciBleGNsdWRlSGlkZGVuID0gZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiAhX3RoaXMuZm9yY2VIaWRkZW5bY29tbW9uLmJ1aWxkRW50cnlLZXkoZW50cnkpXTsgfTtcbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBmb3JjZWQtaGlkZGVuIHNlZ3NcbiAgICAgICAgZm9yICh2YXIgbGV2ZWwgPSAwOyBsZXZlbCA8IGVudHJpZXNCeUxldmVsLmxlbmd0aDsgbGV2ZWwgKz0gMSkge1xuICAgICAgICAgICAgZW50cmllc0J5TGV2ZWxbbGV2ZWxdID0gZW50cmllc0J5TGV2ZWxbbGV2ZWxdLmZpbHRlcihleGNsdWRlSGlkZGVuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlkZGVuU2VncztcbiAgICB9O1xuICAgIERheUdyaWRTZWdIaWVyYXJjaHkucHJvdG90eXBlLmhhbmRsZUludmFsaWRJbnNlcnRpb24gPSBmdW5jdGlvbiAoaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcykge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBlbnRyaWVzQnlMZXZlbCA9IF9hLmVudHJpZXNCeUxldmVsLCBmb3JjZUhpZGRlbiA9IF9hLmZvcmNlSGlkZGVuO1xuICAgICAgICB2YXIgdG91Y2hpbmdFbnRyeSA9IGluc2VydGlvbi50b3VjaGluZ0VudHJ5LCB0b3VjaGluZ0xldmVsID0gaW5zZXJ0aW9uLnRvdWNoaW5nTGV2ZWwsIHRvdWNoaW5nTGF0ZXJhbCA9IGluc2VydGlvbi50b3VjaGluZ0xhdGVyYWw7XG4gICAgICAgIGlmICh0aGlzLmhpZGRlbkNvbnN1bWVzICYmIHRvdWNoaW5nRW50cnkpIHtcbiAgICAgICAgICAgIHZhciB0b3VjaGluZ0VudHJ5SWQgPSBjb21tb24uYnVpbGRFbnRyeUtleSh0b3VjaGluZ0VudHJ5KTtcbiAgICAgICAgICAgIC8vIGlmIG5vdCBhbHJlYWR5IGhpZGRlblxuICAgICAgICAgICAgaWYgKCFmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dSZXNsaWNpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBsYWNlaG9sZGVyRW50cnkgPSB0c2xpYi5fX2Fzc2lnbih0c2xpYi5fX2Fzc2lnbih7fSwgdG91Y2hpbmdFbnRyeSksIHsgc3BhbjogY29tbW9uLmludGVyc2VjdFNwYW5zKHRvdWNoaW5nRW50cnkuc3BhbiwgZW50cnkuc3BhbikgfSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwbGFjZWhvbGRlckVudHJ5SWQgPSBjb21tb24uYnVpbGRFbnRyeUtleShwbGFjZWhvbGRlckVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VIaWRkZW5bcGxhY2Vob2xkZXJFbnRyeUlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGVudHJpZXNCeUxldmVsW3RvdWNoaW5nTGV2ZWxdW3RvdWNoaW5nTGF0ZXJhbF0gPSBwbGFjZWhvbGRlckVudHJ5OyAvLyByZXBsYWNlIHRvdWNoaW5nRW50cnkgd2l0aCBvdXIgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zcGxpdEVudHJ5KHRvdWNoaW5nRW50cnksIGVudHJ5LCBoaWRkZW5FbnRyaWVzKTsgLy8gc3BsaXQgdXAgdGhlIHRvdWNoaW5nRW50cnksIHJlaW5zZXJ0IGl0XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZUhpZGRlblt0b3VjaGluZ0VudHJ5SWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaGlkZGVuRW50cmllcy5wdXNoKHRvdWNoaW5nRW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5oYW5kbGVJbnZhbGlkSW5zZXJ0aW9uLmNhbGwodGhpcywgaW5zZXJ0aW9uLCBlbnRyeSwgaGlkZGVuRW50cmllcyk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5R3JpZFNlZ0hpZXJhcmNoeTtcbn0oY29tbW9uLlNlZ0hpZXJhcmNoeSkpO1xuXG52YXIgVGFibGVSb3cgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKFRhYmxlUm93LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhYmxlUm93KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuY2VsbEVsUmVmcyA9IG5ldyBjb21tb24uUmVmTWFwKCk7IC8vIHRoZSA8dGQ+XG4gICAgICAgIF90aGlzLmZyYW1lRWxSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWZyYW1lXG4gICAgICAgIF90aGlzLmZnRWxSZWZzID0gbmV3IGNvbW1vbi5SZWZNYXAoKTsgLy8gdGhlIGZjLWRheWdyaWQtZGF5LWV2ZW50c1xuICAgICAgICBfdGhpcy5zZWdIYXJuZXNzUmVmcyA9IG5ldyBjb21tb24uUmVmTWFwKCk7IC8vIGluZGV4ZWQgYnkgXCJpbnN0YW5jZUlkOmZpcnN0Q29sXCJcbiAgICAgICAgX3RoaXMucm9vdEVsUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgbWF4Q29udGVudEhlaWdodDogbnVsbCxcbiAgICAgICAgICAgIGV2ZW50SW5zdGFuY2VIZWlnaHRzOiB7fSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBzdGF0ZSA9IF9hLnN0YXRlLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBjb250ZXh0Lm9wdGlvbnM7XG4gICAgICAgIHZhciBjb2xDbnQgPSBwcm9wcy5jZWxscy5sZW5ndGg7XG4gICAgICAgIHZhciBidXNpbmVzc0hvdXJzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHByb3BzLmJ1c2luZXNzSG91clNlZ3MsIGNvbENudCk7XG4gICAgICAgIHZhciBiZ0V2ZW50U2Vnc0J5Q29sID0gc3BsaXRTZWdzQnlGaXJzdENvbChwcm9wcy5iZ0V2ZW50U2VncywgY29sQ250KTtcbiAgICAgICAgdmFyIGhpZ2hsaWdodFNlZ3NCeUNvbCA9IHNwbGl0U2Vnc0J5Rmlyc3RDb2wodGhpcy5nZXRIaWdobGlnaHRTZWdzKCksIGNvbENudCk7XG4gICAgICAgIHZhciBtaXJyb3JTZWdzQnlDb2wgPSBzcGxpdFNlZ3NCeUZpcnN0Q29sKHRoaXMuZ2V0TWlycm9yU2VncygpLCBjb2xDbnQpO1xuICAgICAgICB2YXIgX2IgPSBjb21wdXRlRmdTZWdQbGFjZW1lbnQoY29tbW9uLnNvcnRFdmVudFNlZ3MocHJvcHMuZmdFdmVudFNlZ3MsIG9wdGlvbnMuZXZlbnRPcmRlciksIHByb3BzLmRheU1heEV2ZW50cywgcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBvcHRpb25zLmV2ZW50T3JkZXJTdHJpY3QsIHN0YXRlLmV2ZW50SW5zdGFuY2VIZWlnaHRzLCBzdGF0ZS5tYXhDb250ZW50SGVpZ2h0LCBwcm9wcy5jZWxscyksIHNpbmdsZUNvbFBsYWNlbWVudHMgPSBfYi5zaW5nbGVDb2xQbGFjZW1lbnRzLCBtdWx0aUNvbFBsYWNlbWVudHMgPSBfYi5tdWx0aUNvbFBsYWNlbWVudHMsIG1vcmVDbnRzID0gX2IubW9yZUNudHMsIG1vcmVNYXJnaW5Ub3BzID0gX2IubW9yZU1hcmdpblRvcHM7XG4gICAgICAgIHZhciBpc0ZvcmNlZEludmlzaWJsZSA9IC8vIFRPRE86IG1lc3N5IHdheSB0byBjb21wdXRlIHRoaXNcbiAgICAgICAgIChwcm9wcy5ldmVudERyYWcgJiYgcHJvcHMuZXZlbnREcmFnLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAgKHByb3BzLmV2ZW50UmVzaXplICYmIHByb3BzLmV2ZW50UmVzaXplLmFmZmVjdGVkSW5zdGFuY2VzKSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoXCJ0clwiLCB7IHJlZjogdGhpcy5yb290RWxSZWYsIHJvbGU6IFwicm93XCIgfSxcbiAgICAgICAgICAgIHByb3BzLnJlbmRlckludHJvICYmIHByb3BzLnJlbmRlckludHJvKCksXG4gICAgICAgICAgICBwcm9wcy5jZWxscy5tYXAoZnVuY3Rpb24gKGNlbGwsIGNvbCkge1xuICAgICAgICAgICAgICAgIHZhciBub3JtYWxGZ05vZGVzID0gX3RoaXMucmVuZGVyRmdTZWdzKGNvbCwgcHJvcHMuZm9yUHJpbnQgPyBzaW5nbGVDb2xQbGFjZW1lbnRzW2NvbF0gOiBtdWx0aUNvbFBsYWNlbWVudHNbY29sXSwgcHJvcHMudG9kYXlSYW5nZSwgaXNGb3JjZWRJbnZpc2libGUpO1xuICAgICAgICAgICAgICAgIHZhciBtaXJyb3JGZ05vZGVzID0gX3RoaXMucmVuZGVyRmdTZWdzKGNvbCwgYnVpbGRNaXJyb3JQbGFjZW1lbnRzKG1pcnJvclNlZ3NCeUNvbFtjb2xdLCBtdWx0aUNvbFBsYWNlbWVudHMpLCBwcm9wcy50b2RheVJhbmdlLCB7fSwgQm9vbGVhbihwcm9wcy5ldmVudERyYWcpLCBCb29sZWFuKHByb3BzLmV2ZW50UmVzaXplKSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoVGFibGVDZWxsLCB7IGtleTogY2VsbC5rZXksIGVsUmVmOiBfdGhpcy5jZWxsRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGlubmVyRWxSZWY6IF90aGlzLmZyYW1lRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSkgLyogRkYgPHRkPiBwcm9ibGVtLCBidXQgb2theSB0byB1c2UgZm9yIGxlZnQvcmlnaHQuIFRPRE86IHJlbmFtZSBwcm9wICovLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGU6IGNlbGwuZGF0ZSwgc2hvd0RheU51bWJlcjogcHJvcHMuc2hvd0RheU51bWJlcnMsIHNob3dXZWVrTnVtYmVyOiBwcm9wcy5zaG93V2Vla051bWJlcnMgJiYgY29sID09PSAwLCBmb3JjZURheVRvcDogcHJvcHMuc2hvd1dlZWtOdW1iZXJzIC8qIGV2ZW4gZGlzcGxheWluZyB3ZWVrbnVtIGZvciByb3csIG5vdCBuZWNlc3NhcmlseSBkYXkgKi8sIHRvZGF5UmFuZ2U6IHByb3BzLnRvZGF5UmFuZ2UsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgZXh0cmFIb29rUHJvcHM6IGNlbGwuZXh0cmFIb29rUHJvcHMsIGV4dHJhRGF0YUF0dHJzOiBjZWxsLmV4dHJhRGF0YUF0dHJzLCBleHRyYUNsYXNzTmFtZXM6IGNlbGwuZXh0cmFDbGFzc05hbWVzLCBleHRyYURhdGVTcGFuOiBjZWxsLmV4dHJhRGF0ZVNwYW4sIG1vcmVDbnQ6IG1vcmVDbnRzW2NvbF0sIG1vcmVNYXJnaW5Ub3A6IG1vcmVNYXJnaW5Ub3BzW2NvbF0sIHNpbmdsZVBsYWNlbWVudHM6IHNpbmdsZUNvbFBsYWNlbWVudHNbY29sXSwgZmdDb250ZW50RWxSZWY6IF90aGlzLmZnRWxSZWZzLmNyZWF0ZVJlZihjZWxsLmtleSksIGZnQ29udGVudDogKCAvLyBGcmFnbWVudCBzY29wZXMgdGhlIGtleXNcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkZyYWdtZW50LCBudWxsLCBub3JtYWxGZ05vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCwgbWlycm9yRmdOb2RlcykpKSwgYmdDb250ZW50OiAoIC8vIEZyYWdtZW50IHNjb3BlcyB0aGUga2V5c1xuICAgICAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW5kZXJGaWxsU2VncyhoaWdobGlnaHRTZWdzQnlDb2xbY29sXSwgJ2hpZ2hsaWdodCcpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyRmlsbFNlZ3MoYnVzaW5lc3NIb3Vyc0J5Q29sW2NvbF0sICdub24tYnVzaW5lc3MnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbmRlckZpbGxTZWdzKGJnRXZlbnRTZWdzQnlDb2xbY29sXSwgJ2JnLWV2ZW50JykpKSB9KSk7XG4gICAgICAgICAgICB9KSkpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemluZyh0cnVlKTtcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMudXBkYXRlU2l6aW5nKCFjb21tb24uaXNQcm9wc0VxdWFsKHByZXZQcm9wcywgY3VycmVudFByb3BzKSk7XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUuZ2V0SGlnaGxpZ2h0U2VncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKHByb3BzLmV2ZW50RHJhZyAmJiBwcm9wcy5ldmVudERyYWcuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudERyYWcuc2VncztcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wcy5kYXRlU2VsZWN0aW9uU2VncztcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5nZXRNaXJyb3JTZWdzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICBpZiAocHJvcHMuZXZlbnRSZXNpemUgJiYgcHJvcHMuZXZlbnRSZXNpemUuc2Vncy5sZW5ndGgpIHsgLy8gbWVzc3kgY2hlY2tcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy5ldmVudFJlc2l6ZS5zZWdzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5yZW5kZXJGZ1NlZ3MgPSBmdW5jdGlvbiAoY29sLCBzZWdQbGFjZW1lbnRzLCB0b2RheVJhbmdlLCBpc0ZvcmNlZEludmlzaWJsZSwgaXNEcmFnZ2luZywgaXNSZXNpemluZywgaXNEYXRlU2VsZWN0aW5nKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICB2YXIgZXZlbnRTZWxlY3Rpb24gPSB0aGlzLnByb3BzLmV2ZW50U2VsZWN0aW9uO1xuICAgICAgICB2YXIgZnJhbWVQb3NpdGlvbnMgPSB0aGlzLnN0YXRlLmZyYW1lUG9zaXRpb25zO1xuICAgICAgICB2YXIgZGVmYXVsdERpc3BsYXlFdmVudEVuZCA9IHRoaXMucHJvcHMuY2VsbHMubGVuZ3RoID09PSAxOyAvLyBjb2xDbnQgPT09IDFcbiAgICAgICAgdmFyIGlzTWlycm9yID0gaXNEcmFnZ2luZyB8fCBpc1Jlc2l6aW5nIHx8IGlzRGF0ZVNlbGVjdGluZztcbiAgICAgICAgdmFyIG5vZGVzID0gW107XG4gICAgICAgIGlmIChmcmFtZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBzZWdQbGFjZW1lbnRzXzEgPSBzZWdQbGFjZW1lbnRzOyBfaSA8IHNlZ1BsYWNlbWVudHNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgcGxhY2VtZW50ID0gc2VnUGxhY2VtZW50c18xW19pXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VnID0gcGxhY2VtZW50LnNlZztcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2VJZCA9IHNlZy5ldmVudFJhbmdlLmluc3RhbmNlLmluc3RhbmNlSWQ7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IGluc3RhbmNlSWQgKyAnOicgKyBjb2w7XG4gICAgICAgICAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHBsYWNlbWVudC5pc1Zpc2libGUgJiYgIWlzRm9yY2VkSW52aXNpYmxlW2luc3RhbmNlSWRdO1xuICAgICAgICAgICAgICAgIHZhciBpc0Fic29sdXRlID0gcGxhY2VtZW50LmlzQWJzb2x1dGU7XG4gICAgICAgICAgICAgICAgdmFyIGxlZnQgPSAnJztcbiAgICAgICAgICAgICAgICB2YXIgcmlnaHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoaXNBYnNvbHV0ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5pc1J0bCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdCA9IGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5sYXN0Q29sXSAtIGZyYW1lUG9zaXRpb25zLmxlZnRzW3NlZy5maXJzdENvbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0ID0gZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAga25vd24gYnVnOiBldmVudHMgdGhhdCBhcmUgZm9yY2UgdG8gYmUgbGlzdC1pdGVtIGJ1dCBzcGFuIG11bHRpcGxlIGRheXMgc3RpbGwgdGFrZSB1cCBzcGFjZSBpbiBsYXRlciBjb2x1bW5zXG4gICAgICAgICAgICAgICAgdG9kbzogaW4gcHJpbnQgdmlldywgZm9yIG11bHRpLWRheSBldmVudHMsIGRvbid0IGRpc3BsYXkgdGl0bGUgd2l0aGluIG5vbi1zdGFydC9lbmQgc2Vnc1xuICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZjLWRheWdyaWQtZXZlbnQtaGFybmVzcycgKyAoaXNBYnNvbHV0ZSA/ICcgZmMtZGF5Z3JpZC1ldmVudC1oYXJuZXNzLWFicycgOiAnJyksIGtleToga2V5LCByZWY6IGlzTWlycm9yID8gbnVsbCA6IHRoaXMuc2VnSGFybmVzc1JlZnMuY3JlYXRlUmVmKGtleSksIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2aXNpYmlsaXR5OiBpc1Zpc2libGUgPyAnJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWFyZ2luVG9wOiBpc0Fic29sdXRlID8gJycgOiBwbGFjZW1lbnQubWFyZ2luVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiBpc0Fic29sdXRlID8gcGxhY2VtZW50LmFic29sdXRlVG9wIDogJycsXG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB9IH0sIGhhc0xpc3RJdGVtRGlzcGxheShzZWcpID8gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlTGlzdEl0ZW1FdmVudCwgdHNsaWIuX19hc3NpZ24oeyBzZWc6IHNlZywgaXNEcmFnZ2luZzogaXNEcmFnZ2luZywgaXNTZWxlY3RlZDogaW5zdGFuY2VJZCA9PT0gZXZlbnRTZWxlY3Rpb24sIGRlZmF1bHREaXNwbGF5RXZlbnRFbmQ6IGRlZmF1bHREaXNwbGF5RXZlbnRFbmQgfSwgY29tbW9uLmdldFNlZ01ldGEoc2VnLCB0b2RheVJhbmdlKSkpKSA6IChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZUJsb2NrRXZlbnQsIHRzbGliLl9fYXNzaWduKHsgc2VnOiBzZWcsIGlzRHJhZ2dpbmc6IGlzRHJhZ2dpbmcsIGlzUmVzaXppbmc6IGlzUmVzaXppbmcsIGlzRGF0ZVNlbGVjdGluZzogaXNEYXRlU2VsZWN0aW5nLCBpc1NlbGVjdGVkOiBpbnN0YW5jZUlkID09PSBldmVudFNlbGVjdGlvbiwgZGVmYXVsdERpc3BsYXlFdmVudEVuZDogZGVmYXVsdERpc3BsYXlFdmVudEVuZCB9LCBjb21tb24uZ2V0U2VnTWV0YShzZWcsIHRvZGF5UmFuZ2UpKSkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGVzO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnJlbmRlckZpbGxTZWdzID0gZnVuY3Rpb24gKHNlZ3MsIGZpbGxUeXBlKSB7XG4gICAgICAgIHZhciBpc1J0bCA9IHRoaXMuY29udGV4dC5pc1J0bDtcbiAgICAgICAgdmFyIHRvZGF5UmFuZ2UgPSB0aGlzLnByb3BzLnRvZGF5UmFuZ2U7XG4gICAgICAgIHZhciBmcmFtZVBvc2l0aW9ucyA9IHRoaXMuc3RhdGUuZnJhbWVQb3NpdGlvbnM7XG4gICAgICAgIHZhciBub2RlcyA9IFtdO1xuICAgICAgICBpZiAoZnJhbWVQb3NpdGlvbnMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgc2Vnc18xID0gc2VnczsgX2kgPCBzZWdzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZyA9IHNlZ3NfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGxlZnRSaWdodENzcyA9IGlzUnRsID8ge1xuICAgICAgICAgICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmxhc3RDb2xdIC0gZnJhbWVQb3NpdGlvbnMubGVmdHNbc2VnLmZpcnN0Q29sXSxcbiAgICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgICAgICAgICByaWdodDogZnJhbWVQb3NpdGlvbnMucmlnaHRzW3NlZy5maXJzdENvbF0gLSBmcmFtZVBvc2l0aW9ucy5yaWdodHNbc2VnLmxhc3RDb2xdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogY29tbW9uLmJ1aWxkRXZlbnRSYW5nZUtleShzZWcuZXZlbnRSYW5nZSksIGNsYXNzTmFtZTogXCJmYy1kYXlncmlkLWJnLWhhcm5lc3NcIiwgc3R5bGU6IGxlZnRSaWdodENzcyB9LCBmaWxsVHlwZSA9PT0gJ2JnLWV2ZW50JyA/XG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5CZ0V2ZW50LCB0c2xpYi5fX2Fzc2lnbih7IHNlZzogc2VnIH0sIGNvbW1vbi5nZXRTZWdNZXRhKHNlZywgdG9kYXlSYW5nZSkpKSA6XG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5yZW5kZXJGaWxsKGZpbGxUeXBlKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tb24uY3JlYXRlRWxlbWVudC5hcHBseSh2b2lkIDAsIHRzbGliLl9fc3ByZWFkQXJyYXkoW2NvbW1vbi5GcmFnbWVudCwge31dLCBub2RlcykpO1xuICAgIH07XG4gICAgVGFibGVSb3cucHJvdG90eXBlLnVwZGF0ZVNpemluZyA9IGZ1bmN0aW9uIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgIHZhciBfYSA9IHRoaXMsIHByb3BzID0gX2EucHJvcHMsIGZyYW1lRWxSZWZzID0gX2EuZnJhbWVFbFJlZnM7XG4gICAgICAgIGlmICghcHJvcHMuZm9yUHJpbnQgJiZcbiAgICAgICAgICAgIHByb3BzLmNsaWVudFdpZHRoICE9PSBudWxsIC8vIHBvc2l0aW9uaW5nIHJlYWR5P1xuICAgICAgICApIHtcbiAgICAgICAgICAgIGlmIChpc0V4dGVybmFsU2l6aW5nQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZyYW1lRWxzID0gcHJvcHMuY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7IHJldHVybiBmcmFtZUVsUmVmcy5jdXJyZW50TWFwW2NlbGwua2V5XTsgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGZyYW1lRWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZ2luRWwgPSB0aGlzLnJvb3RFbFJlZi5jdXJyZW50O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYW1lUG9zaXRpb25zOiBuZXcgY29tbW9uLlBvc2l0aW9uQ2FjaGUob3JpZ2luRWwsIGZyYW1lRWxzLCB0cnVlLCAvLyBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhbHNlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9sZEluc3RhbmNlSGVpZ2h0cyA9IHRoaXMuc3RhdGUuZXZlbnRJbnN0YW5jZUhlaWdodHM7XG4gICAgICAgICAgICB2YXIgbmV3SW5zdGFuY2VIZWlnaHRzID0gdGhpcy5xdWVyeUV2ZW50SW5zdGFuY2VIZWlnaHRzKCk7XG4gICAgICAgICAgICB2YXIgbGltaXRCeUNvbnRlbnRIZWlnaHQgPSBwcm9wcy5kYXlNYXhFdmVudHMgPT09IHRydWUgfHwgcHJvcHMuZGF5TWF4RXZlbnRSb3dzID09PSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zYWZlU2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgIC8vIEhBQ0sgdG8gcHJldmVudCBvc2NpbGxhdGlvbnMgb2YgZXZlbnRzIGJlaW5nIHNob3duL2hpZGRlbiBmcm9tIG1heC1ldmVudC1yb3dzXG4gICAgICAgICAgICAgICAgLy8gRXNzZW50aWFsbHksIG9uY2UgeW91IGNvbXB1dGUgYW4gZWxlbWVudCdzIGhlaWdodCwgbmV2ZXIgbnVsbC1vdXQuXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogYWx3YXlzIGRpc3BsYXkgYWxsIGV2ZW50cywgYXMgdmlzaWJpbGl0eTpoaWRkZW4/XG4gICAgICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IHRzbGliLl9fYXNzaWduKHRzbGliLl9fYXNzaWduKHt9LCBvbGRJbnN0YW5jZUhlaWdodHMpLCBuZXdJbnN0YW5jZUhlaWdodHMpLFxuICAgICAgICAgICAgICAgIG1heENvbnRlbnRIZWlnaHQ6IGxpbWl0QnlDb250ZW50SGVpZ2h0ID8gdGhpcy5jb21wdXRlTWF4Q29udGVudEhlaWdodCgpIDogbnVsbCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWJsZVJvdy5wcm90b3R5cGUucXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlZ0VsTWFwID0gdGhpcy5zZWdIYXJuZXNzUmVmcy5jdXJyZW50TWFwO1xuICAgICAgICB2YXIgZXZlbnRJbnN0YW5jZUhlaWdodHMgPSB7fTtcbiAgICAgICAgLy8gZ2V0IHRoZSBtYXggaGVpZ2h0IGFtb25nc3QgaW5zdGFuY2Ugc2Vnc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc2VnRWxNYXApIHtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBNYXRoLnJvdW5kKHNlZ0VsTWFwW2tleV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZUlkID0ga2V5LnNwbGl0KCc6JylbMF07IC8vIGRlY29uc3RydWN0IGhvdyByZW5kZXJGZ1NlZ3MgbWFrZXMgdGhlIGtleVxuICAgICAgICAgICAgZXZlbnRJbnN0YW5jZUhlaWdodHNbaW5zdGFuY2VJZF0gPSBNYXRoLm1heChldmVudEluc3RhbmNlSGVpZ2h0c1tpbnN0YW5jZUlkXSB8fCAwLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVudEluc3RhbmNlSGVpZ2h0cztcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5jb21wdXRlTWF4Q29udGVudEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpcnN0S2V5ID0gdGhpcy5wcm9wcy5jZWxsc1swXS5rZXk7XG4gICAgICAgIHZhciBjZWxsRWwgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcFtmaXJzdEtleV07XG4gICAgICAgIHZhciBmY0NvbnRhaW5lckVsID0gdGhpcy5mZ0VsUmVmcy5jdXJyZW50TWFwW2ZpcnN0S2V5XTtcbiAgICAgICAgcmV0dXJuIGNlbGxFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b20gLSBmY0NvbnRhaW5lckVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9O1xuICAgIFRhYmxlUm93LnByb3RvdHlwZS5nZXRDZWxsRWxzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZWxNYXAgPSB0aGlzLmNlbGxFbFJlZnMuY3VycmVudE1hcDtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvcHMuY2VsbHMubWFwKGZ1bmN0aW9uIChjZWxsKSB7IHJldHVybiBlbE1hcFtjZWxsLmtleV07IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlUm93O1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuVGFibGVSb3cuYWRkU3RhdGVFcXVhbGl0eSh7XG4gICAgZXZlbnRJbnN0YW5jZUhlaWdodHM6IGNvbW1vbi5pc1Byb3BzRXF1YWwsXG59KTtcbmZ1bmN0aW9uIGJ1aWxkTWlycm9yUGxhY2VtZW50cyhtaXJyb3JTZWdzLCBjb2xQbGFjZW1lbnRzKSB7XG4gICAgaWYgKCFtaXJyb3JTZWdzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHZhciB0b3BzQnlJbnN0YW5jZUlkID0gYnVpbGRBYnNvbHV0ZVRvcEhhc2goY29sUGxhY2VtZW50cyk7IC8vIFRPRE86IGNhY2hlIHRoaXMgYXQgZmlyc3QgcmVuZGVyP1xuICAgIHJldHVybiBtaXJyb3JTZWdzLm1hcChmdW5jdGlvbiAoc2VnKSB7IHJldHVybiAoe1xuICAgICAgICBzZWc6IHNlZyxcbiAgICAgICAgaXNWaXNpYmxlOiB0cnVlLFxuICAgICAgICBpc0Fic29sdXRlOiB0cnVlLFxuICAgICAgICBhYnNvbHV0ZVRvcDogdG9wc0J5SW5zdGFuY2VJZFtzZWcuZXZlbnRSYW5nZS5pbnN0YW5jZS5pbnN0YW5jZUlkXSxcbiAgICAgICAgbWFyZ2luVG9wOiAwLFxuICAgIH0pOyB9KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWJzb2x1dGVUb3BIYXNoKGNvbFBsYWNlbWVudHMpIHtcbiAgICB2YXIgdG9wc0J5SW5zdGFuY2VJZCA9IHt9O1xuICAgIGZvciAodmFyIF9pID0gMCwgY29sUGxhY2VtZW50c18xID0gY29sUGxhY2VtZW50czsgX2kgPCBjb2xQbGFjZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBwbGFjZW1lbnRzID0gY29sUGxhY2VtZW50c18xW19pXTtcbiAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBwbGFjZW1lbnRzXzEgPSBwbGFjZW1lbnRzOyBfYSA8IHBsYWNlbWVudHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgICAgIHZhciBwbGFjZW1lbnQgPSBwbGFjZW1lbnRzXzFbX2FdO1xuICAgICAgICAgICAgdG9wc0J5SW5zdGFuY2VJZFtwbGFjZW1lbnQuc2VnLmV2ZW50UmFuZ2UuaW5zdGFuY2UuaW5zdGFuY2VJZF0gPSBwbGFjZW1lbnQuYWJzb2x1dGVUb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvcHNCeUluc3RhbmNlSWQ7XG59XG5cbnZhciBUYWJsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFibGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0QmdFdmVudFNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RmdFdmVudFNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RGF0ZVNlbGVjdGlvblNlZ3MgPSBjb21tb24ubWVtb2l6ZShzcGxpdFNlZ3NCeVJvdyk7XG4gICAgICAgIF90aGlzLnNwbGl0RXZlbnREcmFnID0gY29tbW9uLm1lbW9pemUoc3BsaXRJbnRlcmFjdGlvbkJ5Um93KTtcbiAgICAgICAgX3RoaXMuc3BsaXRFdmVudFJlc2l6ZSA9IGNvbW1vbi5tZW1vaXplKHNwbGl0SW50ZXJhY3Rpb25CeVJvdyk7XG4gICAgICAgIF90aGlzLnJvd1JlZnMgPSBuZXcgY29tbW9uLlJlZk1hcCgpO1xuICAgICAgICBfdGhpcy5oYW5kbGVSb290RWwgPSBmdW5jdGlvbiAocm9vdEVsKSB7XG4gICAgICAgICAgICBfdGhpcy5yb290RWwgPSByb290RWw7XG4gICAgICAgICAgICBpZiAocm9vdEVsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29udGV4dC5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzLCB7XG4gICAgICAgICAgICAgICAgICAgIGVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIGlzSGl0Q29tYm9BbGxvd2VkOiBfdGhpcy5wcm9wcy5pc0hpdENvbWJvQWxsb3dlZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnRleHQudW5yZWdpc3RlckludGVyYWN0aXZlQ29tcG9uZW50KF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgICB2YXIgZGF0ZVByb2ZpbGUgPSBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5TWF4RXZlbnRSb3dzID0gcHJvcHMuZGF5TWF4RXZlbnRSb3dzLCBkYXlNYXhFdmVudHMgPSBwcm9wcy5kYXlNYXhFdmVudHMsIGV4cGFuZFJvd3MgPSBwcm9wcy5leHBhbmRSb3dzO1xuICAgICAgICB2YXIgcm93Q250ID0gcHJvcHMuY2VsbHMubGVuZ3RoO1xuICAgICAgICB2YXIgYnVzaW5lc3NIb3VyU2Vnc0J5Um93ID0gdGhpcy5zcGxpdEJ1c2luZXNzSG91clNlZ3MocHJvcHMuYnVzaW5lc3NIb3VyU2Vncywgcm93Q250KTtcbiAgICAgICAgdmFyIGJnRXZlbnRTZWdzQnlSb3cgPSB0aGlzLnNwbGl0QmdFdmVudFNlZ3MocHJvcHMuYmdFdmVudFNlZ3MsIHJvd0NudCk7XG4gICAgICAgIHZhciBmZ0V2ZW50U2Vnc0J5Um93ID0gdGhpcy5zcGxpdEZnRXZlbnRTZWdzKHByb3BzLmZnRXZlbnRTZWdzLCByb3dDbnQpO1xuICAgICAgICB2YXIgZGF0ZVNlbGVjdGlvblNlZ3NCeVJvdyA9IHRoaXMuc3BsaXREYXRlU2VsZWN0aW9uU2Vncyhwcm9wcy5kYXRlU2VsZWN0aW9uU2Vncywgcm93Q250KTtcbiAgICAgICAgdmFyIGV2ZW50RHJhZ0J5Um93ID0gdGhpcy5zcGxpdEV2ZW50RHJhZyhwcm9wcy5ldmVudERyYWcsIHJvd0NudCk7XG4gICAgICAgIHZhciBldmVudFJlc2l6ZUJ5Um93ID0gdGhpcy5zcGxpdEV2ZW50UmVzaXplKHByb3BzLmV2ZW50UmVzaXplLCByb3dDbnQpO1xuICAgICAgICB2YXIgbGltaXRWaWFCYWxhbmNlZCA9IGRheU1heEV2ZW50cyA9PT0gdHJ1ZSB8fCBkYXlNYXhFdmVudFJvd3MgPT09IHRydWU7XG4gICAgICAgIC8vIGlmIHJvd3MgY2FuJ3QgZXhwYW5kIHRvIGZpbGwgZml4ZWQgaGVpZ2h0LCBjYW4ndCBkbyBiYWxhbmNlZC1oZWlnaHQgZXZlbnQgbGltaXRcbiAgICAgICAgLy8gVE9ETzogYmVzdCBwbGFjZSB0byBub3JtYWxpemUgdGhlc2Ugb3B0aW9ucz9cbiAgICAgICAgaWYgKGxpbWl0VmlhQmFsYW5jZWQgJiYgIWV4cGFuZFJvd3MpIHtcbiAgICAgICAgICAgIGxpbWl0VmlhQmFsYW5jZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGRheU1heEV2ZW50Um93cyA9IG51bGw7XG4gICAgICAgICAgICBkYXlNYXhFdmVudHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbGFzc05hbWVzID0gW1xuICAgICAgICAgICAgJ2ZjLWRheWdyaWQtYm9keScsXG4gICAgICAgICAgICBsaW1pdFZpYUJhbGFuY2VkID8gJ2ZjLWRheWdyaWQtYm9keS1iYWxhbmNlZCcgOiAnZmMtZGF5Z3JpZC1ib2R5LXVuYmFsYW5jZWQnLFxuICAgICAgICAgICAgZXhwYW5kUm93cyA/ICcnIDogJ2ZjLWRheWdyaWQtYm9keS1uYXR1cmFsJywgLy8gd2lsbCBoZWlnaHQgb2Ygb25lIHJvdyBkZXBlbmQgb24gdGhlIG90aGVycz9cbiAgICAgICAgXTtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5qb2luKCcgJyksIHJlZjogdGhpcy5oYW5kbGVSb290RWwsIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgLy8gdGhlc2UgcHJvcHMgYXJlIGltcG9ydGFudCB0byBnaXZlIHRoaXMgd3JhcHBlciBjb3JyZWN0IGRpbWVuc2lvbnMgZm9yIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IGlmIHdlIHNldCBpdCBoZXJlLCBjYW4gd2UgYXZvaWQgZ2l2aW5nIHRvIGlubmVyIHRhYmxlcz9cbiAgICAgICAgICAgICAgICB3aWR0aDogcHJvcHMuY2xpZW50V2lkdGgsXG4gICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICB9IH0sXG4gICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChjb21tb24uTm93VGltZXIsIHsgdW5pdDogXCJkYXlcIiB9LCBmdW5jdGlvbiAobm93RGF0ZSwgdG9kYXlSYW5nZSkgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KGNvbW1vbi5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICBjb21tb24uY3JlYXRlRWxlbWVudChcInRhYmxlXCIsIHsgcm9sZTogXCJwcmVzZW50YXRpb25cIiwgY2xhc3NOYW1lOiBcImZjLXNjcm9sbGdyaWQtc3luYy10YWJsZVwiLCBzdHlsZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHByb3BzLmNsaWVudFdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHByb3BzLnRhYmxlTWluV2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGV4cGFuZFJvd3MgPyBwcm9wcy5jbGllbnRIZWlnaHQgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgfSB9LFxuICAgICAgICAgICAgICAgICAgICBwcm9wcy5jb2xHcm91cE5vZGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbi5jcmVhdGVFbGVtZW50KFwidGJvZHlcIiwgeyByb2xlOiBcInByZXNlbnRhdGlvblwiIH0sIHByb3BzLmNlbGxzLm1hcChmdW5jdGlvbiAoY2VsbHMsIHJvdykgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KFRhYmxlUm93LCB7IHJlZjogX3RoaXMucm93UmVmcy5jcmVhdGVSZWYocm93KSwga2V5OiBjZWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNlbGxzWzBdLmRhdGUudG9JU09TdHJpbmcoKSAvKiBiZXN0PyBvciBwdXQga2V5IG9uIGNlbGw/IG9yIHVzZSBkaWZmIGZvcm1hdHRlcj8gKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJvdyAvLyBpbiBjYXNlIHRoZXJlIGFyZSBubyBjZWxscyAobGlrZSB3aGVuIHJlc291cmNlIHZpZXcgaXMgbG9hZGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgICwgc2hvd0RheU51bWJlcnM6IHJvd0NudCA+IDEsIHNob3dXZWVrTnVtYmVyczogcHJvcHMuc2hvd1dlZWtOdW1iZXJzLCB0b2RheVJhbmdlOiB0b2RheVJhbmdlLCBkYXRlUHJvZmlsZTogZGF0ZVByb2ZpbGUsIGNlbGxzOiBjZWxscywgcmVuZGVySW50cm86IHByb3BzLnJlbmRlclJvd0ludHJvLCBidXNpbmVzc0hvdXJTZWdzOiBidXNpbmVzc0hvdXJTZWdzQnlSb3dbcm93XSwgZXZlbnRTZWxlY3Rpb246IHByb3BzLmV2ZW50U2VsZWN0aW9uLCBiZ0V2ZW50U2VnczogYmdFdmVudFNlZ3NCeVJvd1tyb3ddLmZpbHRlcihpc1NlZ0FsbERheSkgLyogaGFjayAqLywgZmdFdmVudFNlZ3M6IGZnRXZlbnRTZWdzQnlSb3dbcm93XSwgZGF0ZVNlbGVjdGlvblNlZ3M6IGRhdGVTZWxlY3Rpb25TZWdzQnlSb3dbcm93XSwgZXZlbnREcmFnOiBldmVudERyYWdCeVJvd1tyb3ddLCBldmVudFJlc2l6ZTogZXZlbnRSZXNpemVCeVJvd1tyb3ddLCBkYXlNYXhFdmVudHM6IGRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBkYXlNYXhFdmVudFJvd3MsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7IH0pKSkpKTsgfSkpKTtcbiAgICB9O1xuICAgIC8vIEhpdCBTeXN0ZW1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgVGFibGUucHJvdG90eXBlLnByZXBhcmVIaXRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJvd1Bvc2l0aW9ucyA9IG5ldyBjb21tb24uUG9zaXRpb25DYWNoZSh0aGlzLnJvb3RFbCwgdGhpcy5yb3dSZWZzLmNvbGxlY3QoKS5tYXAoZnVuY3Rpb24gKHJvd09iaikgeyByZXR1cm4gcm93T2JqLmdldENlbGxFbHMoKVswXTsgfSksIC8vIGZpcnN0IGNlbGwgZWwgaW4gZWFjaCByb3cuIFRPRE86IG5vdCBvcHRpbWFsXG4gICAgICAgIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb2xQb3NpdGlvbnMgPSBuZXcgY29tbW9uLlBvc2l0aW9uQ2FjaGUodGhpcy5yb290RWwsIHRoaXMucm93UmVmcy5jdXJyZW50TWFwWzBdLmdldENlbGxFbHMoKSwgLy8gY2VsbCBlbHMgaW4gZmlyc3Qgcm93XG4gICAgICAgIHRydWUsIC8vIGhvcml6b250YWxcbiAgICAgICAgZmFsc2UpO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLnF1ZXJ5SGl0ID0gZnVuY3Rpb24gKHBvc2l0aW9uTGVmdCwgcG9zaXRpb25Ub3ApIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcywgY29sUG9zaXRpb25zID0gX2EuY29sUG9zaXRpb25zLCByb3dQb3NpdGlvbnMgPSBfYS5yb3dQb3NpdGlvbnM7XG4gICAgICAgIHZhciBjb2wgPSBjb2xQb3NpdGlvbnMubGVmdFRvSW5kZXgocG9zaXRpb25MZWZ0KTtcbiAgICAgICAgdmFyIHJvdyA9IHJvd1Bvc2l0aW9ucy50b3BUb0luZGV4KHBvc2l0aW9uVG9wKTtcbiAgICAgICAgaWYgKHJvdyAhPSBudWxsICYmIGNvbCAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2VsbCA9IHRoaXMucHJvcHMuY2VsbHNbcm93XVtjb2xdO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRlUHJvZmlsZTogdGhpcy5wcm9wcy5kYXRlUHJvZmlsZSxcbiAgICAgICAgICAgICAgICBkYXRlU3BhbjogdHNsaWIuX19hc3NpZ24oeyByYW5nZTogdGhpcy5nZXRDZWxsUmFuZ2Uocm93LCBjb2wpLCBhbGxEYXk6IHRydWUgfSwgY2VsbC5leHRyYURhdGVTcGFuKSxcbiAgICAgICAgICAgICAgICBkYXlFbDogdGhpcy5nZXRDZWxsRWwocm93LCBjb2wpLFxuICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdDogY29sUG9zaXRpb25zLmxlZnRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBjb2xQb3NpdGlvbnMucmlnaHRzW2NvbF0sXG4gICAgICAgICAgICAgICAgICAgIHRvcDogcm93UG9zaXRpb25zLnRvcHNbcm93XSxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiByb3dQb3NpdGlvbnMuYm90dG9tc1tyb3ddLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbGF5ZXI6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgVGFibGUucHJvdG90eXBlLmdldENlbGxFbCA9IGZ1bmN0aW9uIChyb3csIGNvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3dSZWZzLmN1cnJlbnRNYXBbcm93XS5nZXRDZWxsRWxzKClbY29sXTsgLy8gVE9ETzogbm90IG9wdGltYWxcbiAgICB9O1xuICAgIFRhYmxlLnByb3RvdHlwZS5nZXRDZWxsUmFuZ2UgPSBmdW5jdGlvbiAocm93LCBjb2wpIHtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5wcm9wcy5jZWxsc1tyb3ddW2NvbF0uZGF0ZTtcbiAgICAgICAgdmFyIGVuZCA9IGNvbW1vbi5hZGREYXlzKHN0YXJ0LCAxKTtcbiAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IHN0YXJ0LCBlbmQ6IGVuZCB9O1xuICAgIH07XG4gICAgcmV0dXJuIFRhYmxlO1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuZnVuY3Rpb24gaXNTZWdBbGxEYXkoc2VnKSB7XG4gICAgcmV0dXJuIHNlZy5ldmVudFJhbmdlLmRlZi5hbGxEYXk7XG59XG5cbnZhciBEYXlUYWJsZVNsaWNlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoRGF5VGFibGVTbGljZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGFibGVTbGljZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5mb3JjZURheUlmTGlzdEl0ZW0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIERheVRhYmxlU2xpY2VyLnByb3RvdHlwZS5zbGljZVJhbmdlID0gZnVuY3Rpb24gKGRhdGVSYW5nZSwgZGF5VGFibGVNb2RlbCkge1xuICAgICAgICByZXR1cm4gZGF5VGFibGVNb2RlbC5zbGljZVJhbmdlKGRhdGVSYW5nZSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF5VGFibGVTbGljZXI7XG59KGNvbW1vbi5TbGljZXIpKTtcblxudmFyIERheVRhYmxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlUYWJsZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEYXlUYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNsaWNlciA9IG5ldyBEYXlUYWJsZVNsaWNlcigpO1xuICAgICAgICBfdGhpcy50YWJsZVJlZiA9IGNvbW1vbi5jcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUYWJsZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSB0aGlzLCBwcm9wcyA9IF9hLnByb3BzLCBjb250ZXh0ID0gX2EuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIChjb21tb24uY3JlYXRlRWxlbWVudChUYWJsZSwgdHNsaWIuX19hc3NpZ24oeyByZWY6IHRoaXMudGFibGVSZWYgfSwgdGhpcy5zbGljZXIuc2xpY2VQcm9wcyhwcm9wcywgcHJvcHMuZGF0ZVByb2ZpbGUsIHByb3BzLm5leHREYXlUaHJlc2hvbGQsIGNvbnRleHQsIHByb3BzLmRheVRhYmxlTW9kZWwpLCB7IGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgY2VsbHM6IHByb3BzLmRheVRhYmxlTW9kZWwuY2VsbHMsIGNvbEdyb3VwTm9kZTogcHJvcHMuY29sR3JvdXBOb2RlLCB0YWJsZU1pbldpZHRoOiBwcm9wcy50YWJsZU1pbldpZHRoLCByZW5kZXJSb3dJbnRybzogcHJvcHMucmVuZGVyUm93SW50cm8sIGRheU1heEV2ZW50czogcHJvcHMuZGF5TWF4RXZlbnRzLCBkYXlNYXhFdmVudFJvd3M6IHByb3BzLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBwcm9wcy5zaG93V2Vla051bWJlcnMsIGV4cGFuZFJvd3M6IHByb3BzLmV4cGFuZFJvd3MsIGhlYWRlckFsaWduRWxSZWY6IHByb3BzLmhlYWRlckFsaWduRWxSZWYsIGNsaWVudFdpZHRoOiBwcm9wcy5jbGllbnRXaWR0aCwgY2xpZW50SGVpZ2h0OiBwcm9wcy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSkpO1xuICAgIH07XG4gICAgcmV0dXJuIERheVRhYmxlO1xufShjb21tb24uRGF0ZUNvbXBvbmVudCkpO1xuXG52YXIgRGF5VGFibGVWaWV3ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliLl9fZXh0ZW5kcyhEYXlUYWJsZVZpZXcsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGF5VGFibGVWaWV3KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYnVpbGREYXlUYWJsZU1vZGVsID0gY29tbW9uLm1lbW9pemUoYnVpbGREYXlUYWJsZU1vZGVsKTtcbiAgICAgICAgX3RoaXMuaGVhZGVyUmVmID0gY29tbW9uLmNyZWF0ZVJlZigpO1xuICAgICAgICBfdGhpcy50YWJsZVJlZiA9IGNvbW1vbi5jcmVhdGVSZWYoKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEYXlUYWJsZVZpZXcucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb250ZXh0LCBvcHRpb25zID0gX2Eub3B0aW9ucywgZGF0ZVByb2ZpbGVHZW5lcmF0b3IgPSBfYS5kYXRlUHJvZmlsZUdlbmVyYXRvcjtcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcbiAgICAgICAgdmFyIGRheVRhYmxlTW9kZWwgPSB0aGlzLmJ1aWxkRGF5VGFibGVNb2RlbChwcm9wcy5kYXRlUHJvZmlsZSwgZGF0ZVByb2ZpbGVHZW5lcmF0b3IpO1xuICAgICAgICB2YXIgaGVhZGVyQ29udGVudCA9IG9wdGlvbnMuZGF5SGVhZGVycyAmJiAoY29tbW9uLmNyZWF0ZUVsZW1lbnQoY29tbW9uLkRheUhlYWRlciwgeyByZWY6IHRoaXMuaGVhZGVyUmVmLCBkYXRlUHJvZmlsZTogcHJvcHMuZGF0ZVByb2ZpbGUsIGRhdGVzOiBkYXlUYWJsZU1vZGVsLmhlYWRlckRhdGVzLCBkYXRlc1JlcERpc3RpbmN0RGF5czogZGF5VGFibGVNb2RlbC5yb3dDbnQgPT09IDEgfSkpO1xuICAgICAgICB2YXIgYm9keUNvbnRlbnQgPSBmdW5jdGlvbiAoY29udGVudEFyZykgeyByZXR1cm4gKGNvbW1vbi5jcmVhdGVFbGVtZW50KERheVRhYmxlLCB7IHJlZjogX3RoaXMudGFibGVSZWYsIGRhdGVQcm9maWxlOiBwcm9wcy5kYXRlUHJvZmlsZSwgZGF5VGFibGVNb2RlbDogZGF5VGFibGVNb2RlbCwgYnVzaW5lc3NIb3VyczogcHJvcHMuYnVzaW5lc3NIb3VycywgZGF0ZVNlbGVjdGlvbjogcHJvcHMuZGF0ZVNlbGVjdGlvbiwgZXZlbnRTdG9yZTogcHJvcHMuZXZlbnRTdG9yZSwgZXZlbnRVaUJhc2VzOiBwcm9wcy5ldmVudFVpQmFzZXMsIGV2ZW50U2VsZWN0aW9uOiBwcm9wcy5ldmVudFNlbGVjdGlvbiwgZXZlbnREcmFnOiBwcm9wcy5ldmVudERyYWcsIGV2ZW50UmVzaXplOiBwcm9wcy5ldmVudFJlc2l6ZSwgbmV4dERheVRocmVzaG9sZDogb3B0aW9ucy5uZXh0RGF5VGhyZXNob2xkLCBjb2xHcm91cE5vZGU6IGNvbnRlbnRBcmcudGFibGVDb2xHcm91cE5vZGUsIHRhYmxlTWluV2lkdGg6IGNvbnRlbnRBcmcudGFibGVNaW5XaWR0aCwgZGF5TWF4RXZlbnRzOiBvcHRpb25zLmRheU1heEV2ZW50cywgZGF5TWF4RXZlbnRSb3dzOiBvcHRpb25zLmRheU1heEV2ZW50Um93cywgc2hvd1dlZWtOdW1iZXJzOiBvcHRpb25zLndlZWtOdW1iZXJzLCBleHBhbmRSb3dzOiAhcHJvcHMuaXNIZWlnaHRBdXRvLCBoZWFkZXJBbGlnbkVsUmVmOiBfdGhpcy5oZWFkZXJFbFJlZiwgY2xpZW50V2lkdGg6IGNvbnRlbnRBcmcuY2xpZW50V2lkdGgsIGNsaWVudEhlaWdodDogY29udGVudEFyZy5jbGllbnRIZWlnaHQsIGZvclByaW50OiBwcm9wcy5mb3JQcmludCB9KSk7IH07XG4gICAgICAgIHJldHVybiBvcHRpb25zLmRheU1pbldpZHRoXG4gICAgICAgICAgICA/IHRoaXMucmVuZGVySFNjcm9sbExheW91dChoZWFkZXJDb250ZW50LCBib2R5Q29udGVudCwgZGF5VGFibGVNb2RlbC5jb2xDbnQsIG9wdGlvbnMuZGF5TWluV2lkdGgpXG4gICAgICAgICAgICA6IHRoaXMucmVuZGVyU2ltcGxlTGF5b3V0KGhlYWRlckNvbnRlbnQsIGJvZHlDb250ZW50KTtcbiAgICB9O1xuICAgIHJldHVybiBEYXlUYWJsZVZpZXc7XG59KFRhYmxlVmlldykpO1xuZnVuY3Rpb24gYnVpbGREYXlUYWJsZU1vZGVsKGRhdGVQcm9maWxlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcikge1xuICAgIHZhciBkYXlTZXJpZXMgPSBuZXcgY29tbW9uLkRheVNlcmllc01vZGVsKGRhdGVQcm9maWxlLnJlbmRlclJhbmdlLCBkYXRlUHJvZmlsZUdlbmVyYXRvcik7XG4gICAgcmV0dXJuIG5ldyBjb21tb24uRGF5VGFibGVNb2RlbChkYXlTZXJpZXMsIC95ZWFyfG1vbnRofHdlZWsvLnRlc3QoZGF0ZVByb2ZpbGUuY3VycmVudFJhbmdlVW5pdCkpO1xufVxuXG52YXIgVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYi5fX2V4dGVuZHMoVGFibGVEYXRlUHJvZmlsZUdlbmVyYXRvciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHRoZSBkYXRlIHJhbmdlIHRoYXQgd2lsbCBiZSByZW5kZXJlZC5cbiAgICBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlID0gZnVuY3Rpb24gKGN1cnJlbnRSYW5nZSwgY3VycmVudFJhbmdlVW5pdCwgaXNSYW5nZUFsbERheSkge1xuICAgICAgICB2YXIgZGF0ZUVudiA9IHRoaXMucHJvcHMuZGF0ZUVudjtcbiAgICAgICAgdmFyIHJlbmRlclJhbmdlID0gX3N1cGVyLnByb3RvdHlwZS5idWlsZFJlbmRlclJhbmdlLmNhbGwodGhpcywgY3VycmVudFJhbmdlLCBjdXJyZW50UmFuZ2VVbml0LCBpc1JhbmdlQWxsRGF5KTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gcmVuZGVyUmFuZ2Uuc3RhcnQ7XG4gICAgICAgIHZhciBlbmQgPSByZW5kZXJSYW5nZS5lbmQ7XG4gICAgICAgIHZhciBlbmRPZldlZWs7XG4gICAgICAgIC8vIHllYXIgYW5kIG1vbnRoIHZpZXdzIHNob3VsZCBiZSBhbGlnbmVkIHdpdGggd2Vla3MuIHRoaXMgaXMgYWxyZWFkeSBkb25lIGZvciB3ZWVrXG4gICAgICAgIGlmICgvXih5ZWFyfG1vbnRoKSQvLnRlc3QoY3VycmVudFJhbmdlVW5pdCkpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gZGF0ZUVudi5zdGFydE9mV2VlayhzdGFydCk7XG4gICAgICAgICAgICAvLyBtYWtlIGVuZC1vZi13ZWVrIGlmIG5vdCBhbHJlYWR5XG4gICAgICAgICAgICBlbmRPZldlZWsgPSBkYXRlRW52LnN0YXJ0T2ZXZWVrKGVuZCk7XG4gICAgICAgICAgICBpZiAoZW5kT2ZXZWVrLnZhbHVlT2YoKSAhPT0gZW5kLnZhbHVlT2YoKSkge1xuICAgICAgICAgICAgICAgIGVuZCA9IGNvbW1vbi5hZGRXZWVrcyhlbmRPZldlZWssIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGVuc3VyZSA2IHdlZWtzXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm1vbnRoTW9kZSAmJlxuICAgICAgICAgICAgdGhpcy5wcm9wcy5maXhlZFdlZWtDb3VudCkge1xuICAgICAgICAgICAgdmFyIHJvd0NudCA9IE1hdGguY2VpbCgvLyBjb3VsZCBiZSBwYXJ0aWFsIHdlZWtzIGR1ZSB0byBoaWRkZW5EYXlzXG4gICAgICAgICAgICBjb21tb24uZGlmZldlZWtzKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgICAgIGVuZCA9IGNvbW1vbi5hZGRXZWVrcyhlbmQsIDYgLSByb3dDbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydCwgZW5kOiBlbmQgfTtcbiAgICB9O1xuICAgIHJldHVybiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yO1xufShjb21tb24uRGF0ZVByb2ZpbGVHZW5lcmF0b3IpKTtcblxudmFyIG1haW4gPSBjb21tb24uY3JlYXRlUGx1Z2luKHtcbiAgICBpbml0aWFsVmlldzogJ2RheUdyaWRNb250aCcsXG4gICAgdmlld3M6IHtcbiAgICAgICAgZGF5R3JpZDoge1xuICAgICAgICAgICAgY29tcG9uZW50OiBEYXlUYWJsZVZpZXcsXG4gICAgICAgICAgICBkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzOiBUYWJsZURhdGVQcm9maWxlR2VuZXJhdG9yLFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkRGF5OiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyBkYXlzOiAxIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRheUdyaWRXZWVrOiB7XG4gICAgICAgICAgICB0eXBlOiAnZGF5R3JpZCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogeyB3ZWVrczogMSB9LFxuICAgICAgICB9LFxuICAgICAgICBkYXlHcmlkTW9udGg6IHtcbiAgICAgICAgICAgIHR5cGU6ICdkYXlHcmlkJyxcbiAgICAgICAgICAgIGR1cmF0aW9uOiB7IG1vbnRoczogMSB9LFxuICAgICAgICAgICAgbW9udGhNb2RlOiB0cnVlLFxuICAgICAgICAgICAgZml4ZWRXZWVrQ291bnQ6IHRydWUsXG4gICAgICAgIH0sXG4gICAgfSxcbn0pO1xuXG5leHBvcnRzLkRheUdyaWRWaWV3ID0gRGF5VGFibGVWaWV3O1xuZXhwb3J0cy5EYXlUYWJsZSA9IERheVRhYmxlO1xuZXhwb3J0cy5EYXlUYWJsZVNsaWNlciA9IERheVRhYmxlU2xpY2VyO1xuZXhwb3J0cy5UYWJsZSA9IFRhYmxlO1xuZXhwb3J0cy5UYWJsZVZpZXcgPSBUYWJsZVZpZXc7XG5leHBvcnRzLmJ1aWxkRGF5VGFibGVNb2RlbCA9IGJ1aWxkRGF5VGFibGVNb2RlbDtcbmV4cG9ydHMuZGVmYXVsdCA9IG1haW47XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJjb21tb24iLCJyZXF1aXJlIiwidHNsaWIiLCJUYWJsZVZpZXciLCJfc3VwZXIiLCJfX2V4dGVuZHMiLCJfdGhpcyIsImFwcGx5IiwiYXJndW1lbnRzIiwiaGVhZGVyRWxSZWYiLCJjcmVhdGVSZWYiLCJwcm90b3R5cGUiLCJyZW5kZXJTaW1wbGVMYXlvdXQiLCJoZWFkZXJSb3dDb250ZW50IiwiYm9keUNvbnRlbnQiLCJfYSIsInByb3BzIiwiY29udGV4dCIsInNlY3Rpb25zIiwic3RpY2t5SGVhZGVyRGF0ZXMiLCJnZXRTdGlja3lIZWFkZXJEYXRlcyIsIm9wdGlvbnMiLCJwdXNoIiwidHlwZSIsImtleSIsImlzU3RpY2t5IiwiY2h1bmsiLCJlbFJlZiIsInRhYmxlQ2xhc3NOYW1lIiwicm93Q29udGVudCIsImxpcXVpZCIsImNvbnRlbnQiLCJjcmVhdGVFbGVtZW50IiwiVmlld1Jvb3QiLCJ2aWV3U3BlYyIsInJvb3RFbFJlZiIsImNsYXNzTmFtZXMiLCJyZWYiLCJjbGFzc05hbWUiLCJjb25jYXQiLCJqb2luIiwiU2ltcGxlU2Nyb2xsR3JpZCIsImlzSGVpZ2h0QXV0byIsImZvclByaW50IiwiY29sbGFwc2libGVXaWR0aCIsImNvbHMiLCJyZW5kZXJIU2Nyb2xsTGF5b3V0IiwiY29sQ250IiwiZGF5TWluV2lkdGgiLCJTY3JvbGxHcmlkIiwicGx1Z2luSG9va3MiLCJzY3JvbGxHcmlkSW1wbCIsIkVycm9yIiwic3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwiZ2V0U3RpY2t5Rm9vdGVyU2Nyb2xsYmFyIiwiY2h1bmtzIiwicmVuZGVyU2Nyb2xsU2hpbSIsImNvbEdyb3VwcyIsInNwYW4iLCJtaW5XaWR0aCIsIkRhdGVDb21wb25lbnQiLCJzcGxpdFNlZ3NCeVJvdyIsInNlZ3MiLCJyb3dDbnQiLCJieVJvdyIsImkiLCJfaSIsInNlZ3NfMSIsImxlbmd0aCIsInNlZyIsInJvdyIsInNwbGl0U2Vnc0J5Rmlyc3RDb2wiLCJieUNvbCIsInNlZ3NfMiIsImZpcnN0Q29sIiwic3BsaXRJbnRlcmFjdGlvbkJ5Um93IiwidWkiLCJhZmZlY3RlZEluc3RhbmNlcyIsImlzRXZlbnQiLCJUYWJsZUNlbGxUb3AiLCJyZW5kZXIiLCJuYXZMaW5rQXR0cnMiLCJidWlsZE5hdkxpbmtBdHRycyIsImRhdGUiLCJEYXlDZWxsQ29udGVudCIsImRhdGVQcm9maWxlIiwidG9kYXlSYW5nZSIsInNob3dEYXlOdW1iZXIiLCJleHRyYUhvb2tQcm9wcyIsImRlZmF1bHRDb250ZW50IiwicmVuZGVyVG9wSW5uZXIiLCJpbm5lckVsUmVmIiwiaW5uZXJDb250ZW50IiwiZm9yY2VEYXlUb3AiLCJfX2Fzc2lnbiIsImlkIiwiZGF5TnVtYmVySWQiLCJGcmFnbWVudCIsIkJhc2VDb21wb25lbnQiLCJkYXlOdW1iZXJUZXh0IiwiREVGQVVMVF9UQUJMRV9FVkVOVF9USU1FX0ZPUk1BVCIsImNyZWF0ZUZvcm1hdHRlciIsImhvdXIiLCJtaW51dGUiLCJvbWl0WmVyb01pbnV0ZSIsIm1lcmlkaWVtIiwiaGFzTGlzdEl0ZW1EaXNwbGF5IiwiZGlzcGxheSIsImV2ZW50UmFuZ2UiLCJkZWYiLCJhbGxEYXkiLCJsYXN0Q29sIiwiaXNTdGFydCIsImlzRW5kIiwiVGFibGVCbG9ja0V2ZW50IiwiU3RhbmRhcmRFdmVudCIsImV4dHJhQ2xhc3NOYW1lcyIsImRlZmF1bHRUaW1lRm9ybWF0IiwiZGVmYXVsdERpc3BsYXlFdmVudEVuZCIsImRpc2FibGVSZXNpemluZyIsIlRhYmxlTGlzdEl0ZW1FdmVudCIsInRpbWVGb3JtYXQiLCJldmVudFRpbWVGb3JtYXQiLCJ0aW1lVGV4dCIsImJ1aWxkU2VnVGltZVRleHQiLCJFdmVudFJvb3QiLCJyZW5kZXJJbm5lckNvbnRlbnQiLCJpc0RyYWdnaW5nIiwiaXNSZXNpemluZyIsImlzRGF0ZVNlbGVjdGluZyIsImlzU2VsZWN0ZWQiLCJpc1Bhc3QiLCJpc0Z1dHVyZSIsImlzVG9kYXkiLCJnZXRTZWdBbmNob3JBdHRycyIsImlubmVyUHJvcHMiLCJzdHlsZSIsImJvcmRlckNvbG9yIiwiYmFja2dyb3VuZENvbG9yIiwiZXZlbnQiLCJ0aXRsZSIsIlRhYmxlQ2VsbE1vcmVMaW5rIiwiY29tcGlsZVNlZ3MiLCJtZW1vaXplIiwic2luZ2xlUGxhY2VtZW50cyIsImFsbFNlZ3MiLCJpbnZpc2libGVTZWdzIiwiTW9yZUxpbmtSb290IiwiYWxsRGF5RGF0ZSIsIm1vcmVDbnQiLCJoaWRkZW5TZWdzIiwiYWxpZ25tZW50RWxSZWYiLCJhbGlnbkdyaWRUb3AiLCJleHRyYURhdGVTcGFuIiwicG9wb3ZlckNvbnRlbnQiLCJpc0ZvcmNlZEludmlzaWJsZSIsImV2ZW50RHJhZyIsImV2ZW50UmVzaXplIiwibWFwIiwiaW5zdGFuY2VJZCIsImluc3RhbmNlIiwidmlzaWJpbGl0eSIsImV2ZW50U2VsZWN0aW9uIiwiZ2V0U2VnTWV0YSIsImhhbmRsZUNsaWNrIiwiaXNFeHBhbmRlZCIsInBvcG92ZXJJZCIsImNyZWF0ZUFyaWFDbGlja0F0dHJzIiwic2luZ2xlUGxhY2VtZW50c18xIiwicGxhY2VtZW50IiwiaXNWaXNpYmxlIiwiREVGQVVMVF9XRUVLX05VTV9GT1JNQVQiLCJ3ZWVrIiwiVGFibGVDZWxsIiwic3RhdGUiLCJnZXRVbmlxdWVEb21JZCIsImhhbmRsZVJvb3RFbCIsImVsIiwic2V0UmVmIiwiRGF5Q2VsbFJvb3QiLCJkYXlFbFJlZiIsImRheUNsYXNzTmFtZXMiLCJyb290RGF0YUF0dHJzIiwiaXNEaXNhYmxlZCIsInJvbGUiLCJleHRyYURhdGFBdHRycyIsInNob3dXZWVrTnVtYmVyIiwiV2Vla051bWJlclJvb3QiLCJkZWZhdWx0Rm9ybWF0Iiwid2Vla0VsUmVmIiwid2Vla0NsYXNzTmFtZXMiLCJmZ0NvbnRlbnRFbFJlZiIsImZnQ29udGVudCIsIm1hcmdpblRvcCIsIm1vcmVNYXJnaW5Ub3AiLCJiZ0NvbnRlbnQiLCJjb21wdXRlRmdTZWdQbGFjZW1lbnQiLCJkYXlNYXhFdmVudHMiLCJkYXlNYXhFdmVudFJvd3MiLCJzdHJpY3RPcmRlciIsImV2ZW50SW5zdGFuY2VIZWlnaHRzIiwibWF4Q29udGVudEhlaWdodCIsImNlbGxzIiwiaGllcmFyY2h5IiwiRGF5R3JpZFNlZ0hpZXJhcmNoeSIsImFsbG93UmVzbGljaW5nIiwibWF4Q29vcmQiLCJoaWRkZW5Db25zdW1lcyIsIm1heFN0YWNrQ250Iiwic2VnSW5wdXRzIiwidW5rbm93bkhlaWdodFNlZ3MiLCJldmVudEhlaWdodCIsImluZGV4IiwidGhpY2tuZXNzIiwic3RhcnQiLCJlbmQiLCJoaWRkZW5FbnRyaWVzIiwiYWRkU2VncyIsInNlZ1JlY3RzIiwidG9SZWN0cyIsInBsYWNlUmVjdHMiLCJzaW5nbGVDb2xQbGFjZW1lbnRzIiwibXVsdGlDb2xQbGFjZW1lbnRzIiwibGVmdG92ZXJNYXJnaW5zIiwibW9yZUNudHMiLCJtb3JlTWFyZ2luVG9wcyIsInVua25vd25IZWlnaHRTZWdzXzEiLCJpc0Fic29sdXRlIiwiYWJzb2x1dGVUb3AiLCJjb2wiLCJyZXNsaWNlU2VnIiwiX2IiLCJoaWRkZW5FbnRyaWVzXzEiLCJoaWRkZW5FbnRyeSIsImhpZGRlblNwYW4iLCJhbGxSZWN0cyIsInJlY3RzQnlFYWNoQ29sIiwiZ3JvdXBSZWN0c0J5RWFjaENvbCIsInJlY3RzIiwiY3VycmVudEhlaWdodCIsImN1cnJlbnRNYXJnaW5Ub3AiLCJyZWN0c18xIiwicmVjdCIsImxldmVsQ29vcmQiLCJtdWx0aVBsYWNlbWVudHMiLCJyZWN0c18yIiwiaXNGaXJzdENvbCIsInJlY3RzXzMiLCJzcGFuU3RhcnQiLCJzcGFuRW5kIiwib3JpZ1JhbmdlIiwicmFuZ2UiLCJzbGljZWRSYW5nZSIsImludGVyc2VjdFJhbmdlcyIsImFkZERheXMiLCJkdXJhdGlvbkVkaXRhYmxlIiwidmFsdWVPZiIsImZvcmNlSGlkZGVuIiwiY2FsbCIsImVudHJpZXNCeUxldmVsIiwiZXhjbHVkZUhpZGRlbiIsImVudHJ5IiwiYnVpbGRFbnRyeUtleSIsImxldmVsIiwiZmlsdGVyIiwiaGFuZGxlSW52YWxpZEluc2VydGlvbiIsImluc2VydGlvbiIsInRvdWNoaW5nRW50cnkiLCJ0b3VjaGluZ0xldmVsIiwidG91Y2hpbmdMYXRlcmFsIiwidG91Y2hpbmdFbnRyeUlkIiwicGxhY2Vob2xkZXJFbnRyeSIsImludGVyc2VjdFNwYW5zIiwicGxhY2Vob2xkZXJFbnRyeUlkIiwic3BsaXRFbnRyeSIsIlNlZ0hpZXJhcmNoeSIsIlRhYmxlUm93IiwiY2VsbEVsUmVmcyIsIlJlZk1hcCIsImZyYW1lRWxSZWZzIiwiZmdFbFJlZnMiLCJzZWdIYXJuZXNzUmVmcyIsImZyYW1lUG9zaXRpb25zIiwiYnVzaW5lc3NIb3Vyc0J5Q29sIiwiYnVzaW5lc3NIb3VyU2VncyIsImJnRXZlbnRTZWdzQnlDb2wiLCJiZ0V2ZW50U2VncyIsImhpZ2hsaWdodFNlZ3NCeUNvbCIsImdldEhpZ2hsaWdodFNlZ3MiLCJtaXJyb3JTZWdzQnlDb2wiLCJnZXRNaXJyb3JTZWdzIiwic29ydEV2ZW50U2VncyIsImZnRXZlbnRTZWdzIiwiZXZlbnRPcmRlciIsImV2ZW50T3JkZXJTdHJpY3QiLCJyZW5kZXJJbnRybyIsImNlbGwiLCJub3JtYWxGZ05vZGVzIiwicmVuZGVyRmdTZWdzIiwibWlycm9yRmdOb2RlcyIsImJ1aWxkTWlycm9yUGxhY2VtZW50cyIsIkJvb2xlYW4iLCJzaG93RGF5TnVtYmVycyIsInNob3dXZWVrTnVtYmVycyIsInJlbmRlckZpbGxTZWdzIiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGRhdGVTaXppbmciLCJjb21wb25lbnREaWRVcGRhdGUiLCJwcmV2UHJvcHMiLCJwcmV2U3RhdGUiLCJjdXJyZW50UHJvcHMiLCJpc1Byb3BzRXF1YWwiLCJkYXRlU2VsZWN0aW9uU2VncyIsInNlZ1BsYWNlbWVudHMiLCJpc01pcnJvciIsIm5vZGVzIiwic2VnUGxhY2VtZW50c18xIiwibGVmdCIsInJpZ2h0IiwiaXNSdGwiLCJsZWZ0cyIsInJpZ2h0cyIsInRvcCIsImZpbGxUeXBlIiwibGVmdFJpZ2h0Q3NzIiwiYnVpbGRFdmVudFJhbmdlS2V5IiwiQmdFdmVudCIsInJlbmRlckZpbGwiLCJfX3NwcmVhZEFycmF5IiwiaXNFeHRlcm5hbFNpemluZ0NoYW5nZSIsImNsaWVudFdpZHRoIiwiZnJhbWVFbHMiLCJjdXJyZW50TWFwIiwib3JpZ2luRWwiLCJjdXJyZW50Iiwic2V0U3RhdGUiLCJQb3NpdGlvbkNhY2hlIiwib2xkSW5zdGFuY2VIZWlnaHRzIiwibmV3SW5zdGFuY2VIZWlnaHRzIiwicXVlcnlFdmVudEluc3RhbmNlSGVpZ2h0cyIsImxpbWl0QnlDb250ZW50SGVpZ2h0Iiwic2FmZVNldFN0YXRlIiwiY29tcHV0ZU1heENvbnRlbnRIZWlnaHQiLCJzZWdFbE1hcCIsImhlaWdodCIsIk1hdGgiLCJyb3VuZCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInNwbGl0IiwibWF4IiwiZmlyc3RLZXkiLCJjZWxsRWwiLCJmY0NvbnRhaW5lckVsIiwiYm90dG9tIiwiZ2V0Q2VsbEVscyIsImVsTWFwIiwiYWRkU3RhdGVFcXVhbGl0eSIsIm1pcnJvclNlZ3MiLCJjb2xQbGFjZW1lbnRzIiwidG9wc0J5SW5zdGFuY2VJZCIsImJ1aWxkQWJzb2x1dGVUb3BIYXNoIiwiY29sUGxhY2VtZW50c18xIiwicGxhY2VtZW50cyIsInBsYWNlbWVudHNfMSIsIlRhYmxlIiwic3BsaXRCdXNpbmVzc0hvdXJTZWdzIiwic3BsaXRCZ0V2ZW50U2VncyIsInNwbGl0RmdFdmVudFNlZ3MiLCJzcGxpdERhdGVTZWxlY3Rpb25TZWdzIiwic3BsaXRFdmVudERyYWciLCJzcGxpdEV2ZW50UmVzaXplIiwicm93UmVmcyIsInJvb3RFbCIsInJlZ2lzdGVySW50ZXJhY3RpdmVDb21wb25lbnQiLCJpc0hpdENvbWJvQWxsb3dlZCIsInVucmVnaXN0ZXJJbnRlcmFjdGl2ZUNvbXBvbmVudCIsImV4cGFuZFJvd3MiLCJidXNpbmVzc0hvdXJTZWdzQnlSb3ciLCJiZ0V2ZW50U2Vnc0J5Um93IiwiZmdFdmVudFNlZ3NCeVJvdyIsImRhdGVTZWxlY3Rpb25TZWdzQnlSb3ciLCJldmVudERyYWdCeVJvdyIsImV2ZW50UmVzaXplQnlSb3ciLCJsaW1pdFZpYUJhbGFuY2VkIiwid2lkdGgiLCJ0YWJsZU1pbldpZHRoIiwiTm93VGltZXIiLCJ1bml0Iiwibm93RGF0ZSIsImNsaWVudEhlaWdodCIsImNvbEdyb3VwTm9kZSIsInRvSVNPU3RyaW5nIiwicmVuZGVyUm93SW50cm8iLCJpc1NlZ0FsbERheSIsInByZXBhcmVIaXRzIiwicm93UG9zaXRpb25zIiwiY29sbGVjdCIsInJvd09iaiIsImNvbFBvc2l0aW9ucyIsInF1ZXJ5SGl0IiwicG9zaXRpb25MZWZ0IiwicG9zaXRpb25Ub3AiLCJsZWZ0VG9JbmRleCIsInRvcFRvSW5kZXgiLCJkYXRlU3BhbiIsImdldENlbGxSYW5nZSIsImRheUVsIiwiZ2V0Q2VsbEVsIiwidG9wcyIsImJvdHRvbXMiLCJsYXllciIsIkRheVRhYmxlU2xpY2VyIiwiZm9yY2VEYXlJZkxpc3RJdGVtIiwic2xpY2VSYW5nZSIsImRhdGVSYW5nZSIsImRheVRhYmxlTW9kZWwiLCJTbGljZXIiLCJEYXlUYWJsZSIsInNsaWNlciIsInRhYmxlUmVmIiwic2xpY2VQcm9wcyIsIm5leHREYXlUaHJlc2hvbGQiLCJoZWFkZXJBbGlnbkVsUmVmIiwiRGF5VGFibGVWaWV3IiwiYnVpbGREYXlUYWJsZU1vZGVsIiwiaGVhZGVyUmVmIiwiZGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJoZWFkZXJDb250ZW50IiwiZGF5SGVhZGVycyIsIkRheUhlYWRlciIsImRhdGVzIiwiaGVhZGVyRGF0ZXMiLCJkYXRlc1JlcERpc3RpbmN0RGF5cyIsImNvbnRlbnRBcmciLCJidXNpbmVzc0hvdXJzIiwiZGF0ZVNlbGVjdGlvbiIsImV2ZW50U3RvcmUiLCJldmVudFVpQmFzZXMiLCJ0YWJsZUNvbEdyb3VwTm9kZSIsIndlZWtOdW1iZXJzIiwiZGF5U2VyaWVzIiwiRGF5U2VyaWVzTW9kZWwiLCJyZW5kZXJSYW5nZSIsIkRheVRhYmxlTW9kZWwiLCJ0ZXN0IiwiY3VycmVudFJhbmdlVW5pdCIsIlRhYmxlRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJidWlsZFJlbmRlclJhbmdlIiwiY3VycmVudFJhbmdlIiwiaXNSYW5nZUFsbERheSIsImRhdGVFbnYiLCJlbmRPZldlZWsiLCJzdGFydE9mV2VlayIsImFkZFdlZWtzIiwibW9udGhNb2RlIiwiZml4ZWRXZWVrQ291bnQiLCJjZWlsIiwiZGlmZldlZWtzIiwiRGF0ZVByb2ZpbGVHZW5lcmF0b3IiLCJtYWluIiwiY3JlYXRlUGx1Z2luIiwiaW5pdGlhbFZpZXciLCJ2aWV3cyIsImRheUdyaWQiLCJjb21wb25lbnQiLCJkYXRlUHJvZmlsZUdlbmVyYXRvckNsYXNzIiwiZGF5R3JpZERheSIsImR1cmF0aW9uIiwiZGF5cyIsImRheUdyaWRXZWVrIiwid2Vla3MiLCJkYXlHcmlkTW9udGgiLCJtb250aHMiLCJEYXlHcmlkVmlldyIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/daygrid/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/main.cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/main.cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar tslib = __webpack_require__(/*! tslib */ \"./node_modules/@fullcalendar/react/node_modules/tslib/tslib.es6.js\");\n__webpack_require__(/*! ./vdom.cjs */ \"./node_modules/@fullcalendar/react/dist/vdom.cjs.js\");\nvar React = __webpack_require__(/*! react */ \"react\");\nvar common = __webpack_require__(/*! @fullcalendar/common */ \"./node_modules/@fullcalendar/common/main.cjs.js\");\nvar FullCalendar = /** @class */ function(_super) {\n    tslib.__extends(FullCalendar, _super);\n    function FullCalendar() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this._calendarApi = new common.CalendarApi();\n        return _this;\n    }\n    FullCalendar.prototype.render = function() {\n        return React.createElement(common.CalendarDataProvider, {\n            optionOverrides: this.props,\n            calendarApi: this._calendarApi\n        }, function(data) {\n            return React.createElement(common.CalendarRoot, {\n                options: data.calendarOptions,\n                theme: data.theme,\n                emitter: data.emitter\n            }, function(classNames, height, isHeightAuto, forPrint) {\n                return React.createElement(\"div\", {\n                    className: classNames.join(\" \"),\n                    style: {\n                        height: height\n                    }\n                }, React.createElement(common.CalendarContent, tslib.__assign({\n                    isHeightAuto: isHeightAuto,\n                    forPrint: forPrint\n                }, data)));\n            });\n        });\n    };\n    FullCalendar.prototype.getApi = function() {\n        return this._calendarApi;\n    };\n    return FullCalendar;\n}(React.Component);\nObject.keys(common).forEach(function(k) {\n    if (k !== \"default\") Object.defineProperty(exports, k, {\n        enumerable: true,\n        get: function() {\n            return common[k];\n        }\n    });\n});\nexports[\"default\"] = FullCalendar;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L21haW4uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPLElBQUk7QUFBQyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEJBLG1CQUFPQSxDQUFDO0FBQ1IsSUFBSUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUUsU0FBU0YsbUJBQU9BLENBQUM7QUFFckIsSUFBSUcsZUFBZSxXQUFXLEdBQUksU0FBVUMsTUFBTSxFQUFFO0lBQ2hETCxNQUFNTSxTQUFTLENBQUNGLGNBQWNDO0lBQzlCLFNBQVNELGVBQWU7UUFDcEIsSUFBSUcsUUFBUUYsV0FBVyxJQUFJLElBQUlBLE9BQU9HLEtBQUssQ0FBQyxJQUFJLEVBQUVDLGNBQWMsSUFBSTtRQUNwRUYsTUFBTUcsWUFBWSxHQUFHLElBQUlQLE9BQU9RLFdBQVc7UUFDM0MsT0FBT0o7SUFDWDtJQUNBSCxhQUFhUSxTQUFTLENBQUNDLE1BQU0sR0FBRyxXQUFZO1FBQ3hDLE9BQVFYLE1BQU1ZLGFBQWEsQ0FBQ1gsT0FBT1ksb0JBQW9CLEVBQUU7WUFBRUMsaUJBQWlCLElBQUksQ0FBQ0MsS0FBSztZQUFFQyxhQUFhLElBQUksQ0FBQ1IsWUFBWTtRQUFDLEdBQUcsU0FBVVMsSUFBSSxFQUFFO1lBQUUsT0FBUWpCLE1BQU1ZLGFBQWEsQ0FBQ1gsT0FBT2lCLFlBQVksRUFBRTtnQkFBRUMsU0FBU0YsS0FBS0csZUFBZTtnQkFBRUMsT0FBT0osS0FBS0ksS0FBSztnQkFBRUMsU0FBU0wsS0FBS0ssT0FBTztZQUFDLEdBQUcsU0FBVUMsVUFBVSxFQUFFQyxNQUFNLEVBQUVDLFlBQVksRUFBRUMsUUFBUSxFQUFFO2dCQUFFLE9BQVExQixNQUFNWSxhQUFhLENBQUMsT0FBTztvQkFBRWUsV0FBV0osV0FBV0ssSUFBSSxDQUFDO29CQUFNQyxPQUFPO3dCQUFFTCxRQUFRQTtvQkFBTztnQkFBRSxHQUM5WnhCLE1BQU1ZLGFBQWEsQ0FBQ1gsT0FBTzZCLGVBQWUsRUFBRWhDLE1BQU1pQyxRQUFRLENBQUM7b0JBQUVOLGNBQWNBO29CQUFjQyxVQUFVQTtnQkFBUyxHQUFHVDtZQUFVO1FBQUs7SUFDdEk7SUFDQWYsYUFBYVEsU0FBUyxDQUFDc0IsTUFBTSxHQUFHLFdBQVk7UUFDeEMsT0FBTyxJQUFJLENBQUN4QixZQUFZO0lBQzVCO0lBQ0EsT0FBT047QUFDWCxFQUFFRixNQUFNaUMsU0FBUztBQUVqQnZDLE9BQU93QyxJQUFJLENBQUNqQyxRQUFRa0MsT0FBTyxDQUFDLFNBQVVDLENBQUMsRUFBRTtJQUNyQyxJQUFJQSxNQUFNLFdBQVcxQyxPQUFPQyxjQUFjLENBQUNDLFNBQVN3QyxHQUFHO1FBQ25EQyxZQUFZLElBQUk7UUFDaEJDLEtBQUssV0FBWTtZQUNiLE9BQU9yQyxNQUFNLENBQUNtQyxFQUFFO1FBQ3BCO0lBQ0o7QUFDSjtBQUNBeEMsa0JBQWUsR0FBR00iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90eXBlc2NyaXB0LXBvcnRmb2xpby8uL25vZGVfbW9kdWxlcy9AZnVsbGNhbGVuZGFyL3JlYWN0L2Rpc3QvbWFpbi5janMuanM/ZWEyNyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciB0c2xpYiA9IHJlcXVpcmUoJ3RzbGliJyk7XG5yZXF1aXJlKCcuL3Zkb20uY2pzJyk7XG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJ0BmdWxsY2FsZW5kYXIvY29tbW9uJyk7XG5cbnZhciBGdWxsQ2FsZW5kYXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWIuX19leHRlbmRzKEZ1bGxDYWxlbmRhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdWxsQ2FsZW5kYXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fY2FsZW5kYXJBcGkgPSBuZXcgY29tbW9uLkNhbGVuZGFyQXBpKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRnVsbENhbGVuZGFyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChjb21tb24uQ2FsZW5kYXJEYXRhUHJvdmlkZXIsIHsgb3B0aW9uT3ZlcnJpZGVzOiB0aGlzLnByb3BzLCBjYWxlbmRhckFwaTogdGhpcy5fY2FsZW5kYXJBcGkgfSwgZnVuY3Rpb24gKGRhdGEpIHsgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KGNvbW1vbi5DYWxlbmRhclJvb3QsIHsgb3B0aW9uczogZGF0YS5jYWxlbmRhck9wdGlvbnMsIHRoZW1lOiBkYXRhLnRoZW1lLCBlbWl0dGVyOiBkYXRhLmVtaXR0ZXIgfSwgZnVuY3Rpb24gKGNsYXNzTmFtZXMsIGhlaWdodCwgaXNIZWlnaHRBdXRvLCBmb3JQcmludCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuam9pbignICcpLCBzdHlsZTogeyBoZWlnaHQ6IGhlaWdodCB9IH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KGNvbW1vbi5DYWxlbmRhckNvbnRlbnQsIHRzbGliLl9fYXNzaWduKHsgaXNIZWlnaHRBdXRvOiBpc0hlaWdodEF1dG8sIGZvclByaW50OiBmb3JQcmludCB9LCBkYXRhKSkpKTsgfSkpOyB9KSk7XG4gICAgfTtcbiAgICBGdWxsQ2FsZW5kYXIucHJvdG90eXBlLmdldEFwaSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhbGVuZGFyQXBpO1xuICAgIH07XG4gICAgcmV0dXJuIEZ1bGxDYWxlbmRhcjtcbn0oUmVhY3QuQ29tcG9uZW50KSk7XG5cbk9iamVjdC5rZXlzKGNvbW1vbikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrLCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbW1vbltrXTtcbiAgICAgICAgfVxuICAgIH0pO1xufSk7XG5leHBvcnRzLmRlZmF1bHQgPSBGdWxsQ2FsZW5kYXI7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ0c2xpYiIsInJlcXVpcmUiLCJSZWFjdCIsImNvbW1vbiIsIkZ1bGxDYWxlbmRhciIsIl9zdXBlciIsIl9fZXh0ZW5kcyIsIl90aGlzIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJfY2FsZW5kYXJBcGkiLCJDYWxlbmRhckFwaSIsInByb3RvdHlwZSIsInJlbmRlciIsImNyZWF0ZUVsZW1lbnQiLCJDYWxlbmRhckRhdGFQcm92aWRlciIsIm9wdGlvbk92ZXJyaWRlcyIsInByb3BzIiwiY2FsZW5kYXJBcGkiLCJkYXRhIiwiQ2FsZW5kYXJSb290Iiwib3B0aW9ucyIsImNhbGVuZGFyT3B0aW9ucyIsInRoZW1lIiwiZW1pdHRlciIsImNsYXNzTmFtZXMiLCJoZWlnaHQiLCJpc0hlaWdodEF1dG8iLCJmb3JQcmludCIsImNsYXNzTmFtZSIsImpvaW4iLCJzdHlsZSIsIkNhbGVuZGFyQ29udGVudCIsIl9fYXNzaWduIiwiZ2V0QXBpIiwiQ29tcG9uZW50Iiwia2V5cyIsImZvckVhY2giLCJrIiwiZW51bWVyYWJsZSIsImdldCIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/main.cjs.js\n");

/***/ }),

/***/ "./node_modules/@fullcalendar/react/dist/vdom.cjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/@fullcalendar/react/dist/vdom.cjs.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar React = __webpack_require__(/*! react */ \"react\");\nvar reactDom = __webpack_require__(/*! react-dom */ \"react-dom\");\n(typeof globalThis !== \"undefined\" ? globalThis : window).FullCalendarVDom = {\n    Component: React.Component,\n    createElement: React.createElement,\n    render: reactDom.render,\n    createRef: React.createRef,\n    Fragment: React.Fragment,\n    createContext: React.createContext,\n    createPortal: reactDom.createPortal,\n    flushSync: flushSync,\n    unmountComponentAtNode: reactDom.unmountComponentAtNode // never called by FullCalendar's React component\n};\nfunction flushSync(callback) {\n    // always sync from top-level\n    callback();\n}\nexports.flushSync = flushSync;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGZ1bGxjYWxlbmRhci9yZWFjdC9kaXN0L3Zkb20uY2pzLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLDhDQUE2QztJQUFFRyxPQUFPLElBQUk7QUFBQyxDQUFDLEVBQUM7QUFFN0QsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUM7QUFDcEIsSUFBSUMsV0FBV0QsbUJBQU9BLENBQUM7QUFFdEIsUUFBT0UsZUFBZSxjQUFjQSxhQUFhQyxNQUFNLEVBQUVDLGdCQUFnQixHQUFHO0lBQ3pFQyxXQUFXTixNQUFNTSxTQUFTO0lBQzFCQyxlQUFlUCxNQUFNTyxhQUFhO0lBQ2xDQyxRQUFRTixTQUFTTSxNQUFNO0lBQ3ZCQyxXQUFXVCxNQUFNUyxTQUFTO0lBQzFCQyxVQUFVVixNQUFNVSxRQUFRO0lBQ3hCQyxlQUFlWCxNQUFNVyxhQUFhO0lBQ2xDQyxjQUFjVixTQUFTVSxZQUFZO0lBQ25DQyxXQUFXQTtJQUNYQyx3QkFBd0JaLFNBQVNZLHNCQUFzQixDQUFDLGlEQUFpRDtBQUM3RztBQUNBLFNBQVNELFVBQVVFLFFBQVEsRUFBRTtJQUN6Qiw2QkFBNkI7SUFDN0JBO0FBQ0o7QUFFQWpCLGlCQUFpQixHQUFHZSIsInNvdXJjZXMiOlsid2VicGFjazovL3R5cGVzY3JpcHQtcG9ydGZvbGlvLy4vbm9kZV9tb2R1bGVzL0BmdWxsY2FsZW5kYXIvcmVhY3QvZGlzdC92ZG9tLmNqcy5qcz81OTc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciByZWFjdERvbSA9IHJlcXVpcmUoJ3JlYWN0LWRvbScpO1xuXG4odHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsVGhpcyA6IHdpbmRvdykuRnVsbENhbGVuZGFyVkRvbSA9IHtcbiAgICBDb21wb25lbnQ6IFJlYWN0LkNvbXBvbmVudCxcbiAgICBjcmVhdGVFbGVtZW50OiBSZWFjdC5jcmVhdGVFbGVtZW50LFxuICAgIHJlbmRlcjogcmVhY3REb20ucmVuZGVyLFxuICAgIGNyZWF0ZVJlZjogUmVhY3QuY3JlYXRlUmVmLFxuICAgIEZyYWdtZW50OiBSZWFjdC5GcmFnbWVudCxcbiAgICBjcmVhdGVDb250ZXh0OiBSZWFjdC5jcmVhdGVDb250ZXh0LFxuICAgIGNyZWF0ZVBvcnRhbDogcmVhY3REb20uY3JlYXRlUG9ydGFsLFxuICAgIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgIHVubW91bnRDb21wb25lbnRBdE5vZGU6IHJlYWN0RG9tLnVubW91bnRDb21wb25lbnRBdE5vZGUgLy8gbmV2ZXIgY2FsbGVkIGJ5IEZ1bGxDYWxlbmRhcidzIFJlYWN0IGNvbXBvbmVudFxufTtcbmZ1bmN0aW9uIGZsdXNoU3luYyhjYWxsYmFjaykge1xuICAgIC8vIGFsd2F5cyBzeW5jIGZyb20gdG9wLWxldmVsXG4gICAgY2FsbGJhY2soKTtcbn1cblxuZXhwb3J0cy5mbHVzaFN5bmMgPSBmbHVzaFN5bmM7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJSZWFjdCIsInJlcXVpcmUiLCJyZWFjdERvbSIsImdsb2JhbFRoaXMiLCJ3aW5kb3ciLCJGdWxsQ2FsZW5kYXJWRG9tIiwiQ29tcG9uZW50IiwiY3JlYXRlRWxlbWVudCIsInJlbmRlciIsImNyZWF0ZVJlZiIsIkZyYWdtZW50IiwiY3JlYXRlQ29udGV4dCIsImNyZWF0ZVBvcnRhbCIsImZsdXNoU3luYyIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJjYWxsYmFjayJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@fullcalendar/react/dist/vdom.cjs.js\n");

/***/ }),

/***/ "@apollo/client":
/*!*********************************!*\
  !*** external "@apollo/client" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@apollo/client");

/***/ }),

/***/ "@fullcalendar/interaction":
/*!********************************************!*\
  !*** external "@fullcalendar/interaction" ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@fullcalendar/interaction");

/***/ }),

/***/ "@mui/icons-material/AccessibilityNew":
/*!*******************************************************!*\
  !*** external "@mui/icons-material/AccessibilityNew" ***!
  \*******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@mui/icons-material/AccessibilityNew");

/***/ }),

/***/ "@mui/icons-material/Menu":
/*!*******************************************!*\
  !*** external "@mui/icons-material/Menu" ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@mui/icons-material/Menu");

/***/ }),

/***/ "@mui/icons-material/RecordVoiceOver":
/*!******************************************************!*\
  !*** external "@mui/icons-material/RecordVoiceOver" ***!
  \******************************************************/
/***/ ((module) => {

"use strict";
module.exports = require("@mui/icons-material/RecordVoiceOver");

/***/ }),

/***/ "@mui/material":
/*!********************************!*\
  !*** external "@mui/material" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("@mui/material");

/***/ }),

/***/ "@mui/system":
/*!******************************!*\
  !*** external "@mui/system" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("@mui/system");

/***/ }),

/***/ "react":
/*!************************!*\
  !*** external "react" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("react");

/***/ }),

/***/ "react-dom":
/*!****************************!*\
  !*** external "react-dom" ***!
  \****************************/
/***/ ((module) => {

"use strict";
module.exports = require("react-dom");

/***/ }),

/***/ "react/jsx-dev-runtime":
/*!****************************************!*\
  !*** external "react/jsx-dev-runtime" ***!
  \****************************************/
/***/ ((module) => {

"use strict";
module.exports = require("react/jsx-dev-runtime");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = (__webpack_exec__("./src/pages/index.tsx"));
module.exports = __webpack_exports__;

})();